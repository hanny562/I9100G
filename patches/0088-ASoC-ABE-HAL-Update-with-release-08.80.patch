From a25bcfe4c9093c44feb965a6f5c17368dcc936f7 Mon Sep 17 00:00:00 2001
From: Sebastien Guiriec <s-guiriec@ti.com>
Date: Tue, 7 Dec 2010 21:04:18 -0600
Subject: ASoC: ABE HAL: Update with release 08.80

Update ABE HAL according to release 08.80. This release is correcting
the noise problem at OPP50 and the new API for ping/pong buffer.

Change-Id: I0b00e0838f8a7b7214f3ff36a68b97c5206acb3e
Signed-off-by: Sebastien Guiriec <s-guiriec@ti.com>
Signed-off-by: Chris Kelly <c-kelly@ti.com>
---
 sound/soc/omap/abe/Makefile        |    1 +
 sound/soc/omap/abe/abe_api.c       |  273 +++++++++++++++------------
 sound/soc/omap/abe/abe_api.h       |   12 +-
 sound/soc/omap/abe/abe_dat.c       |    8 +-
 sound/soc/omap/abe/abe_dbg.h       |    3 +-
 sound/soc/omap/abe/abe_def.h       |    6 +-
 sound/soc/omap/abe/abe_firmware.c  |  370 ++++++++++++++++++------------------
 sound/soc/omap/abe/abe_fw.h        |    2 +-
 sound/soc/omap/abe/abe_ini.c       |   89 ++++++----
 sound/soc/omap/abe/abe_lib.c       |  185 ++----------------
 sound/soc/omap/abe/abe_main.h      |    2 +-
 sound/soc/omap/abe/abe_mem.c       |  140 ++++++++++++++
 sound/soc/omap/abe/abe_ref.h       |   12 +-
 sound/soc/omap/abe/abe_seq.h       |  136 -------------
 sound/soc/omap/abe/abe_sys.h       |   20 --
 sound/soc/omap/abe/c_abe_fw_size.h |    6 -
 sound/soc/omap/omap-abe-dsp.c      |    8 +-
 sound/soc/omap/omap-abe.c          |    6 +-
 18 files changed, 591 insertions(+), 688 deletions(-)
 create mode 100644 sound/soc/omap/abe/abe_mem.c
 delete mode 100644 sound/soc/omap/abe/abe_seq.h
 delete mode 100644 sound/soc/omap/abe/abe_sys.h
 delete mode 100644 sound/soc/omap/abe/c_abe_fw_size.h

Index: Kernel/sound/soc/omap/abe/Makefile
===================================================================
--- Kernel.orig/sound/soc/omap/abe/Makefile	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/Makefile	2011-01-19 00:14:18.512072561 +0530
@@ -5,6 +5,7 @@
 			abe_ini.o \
 			abe_irq.o \
 			abe_lib.o \
+			abe_mem.o \
 			abe_seq.o \
 
 obj-$(CONFIG_SND_OMAP_SOC_ABE_DSP) += snd-soc-abe-hal.o
Index: Kernel/sound/soc/omap/abe/abe_api.c
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_api.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_api.c	2011-01-19 00:14:18.522072429 +0530
@@ -49,7 +49,6 @@
  */
 abehal_status abe_reset_hal(void)
 {
-#if 0
 	u32 i;
 	_log(id_reset_hal, 0, 0, 0);
 	abe_dbg_output = TERMINAL_OUTPUT;
@@ -63,13 +62,14 @@
 	/* default = disable the mixer's adaptive gain control */
 	abe_use_compensated_gain(0);
 	/* reset the default gain values */
-	for (i = 0; i < MAXNBFEATURE; i++)
-		abe_unmuted_desired_gains[i] =
-			abe_unmuted_compensated_gains[i] =
-			abe_muted_gains_indicator[i] = 0;
+	for (i = 0; i < MAXNBFEATURE; i++) {
+		abe_muted_gains_indicator[i] = 0;
+		abe_desired_gains_decibel[i] = (u32) GAIN_MUTE;
+		abe_desired_gains_linear[i] = 0;
+		abe_desired_ramp_delay_ms[i] = 0;
+	}
 	/* set debug mask to "enable all traces" */
 	abe_dbg_mask = (abe_dbg_t) (0);
-#endif
 	abe_hw_configuration();
 	return 0;
 }
@@ -192,9 +192,9 @@
 abehal_status abe_read_hardware_configuration(u32 *u, u32 *o,
 					      abe_hw_config_init_t *hw)
 {
-	_log(id_read_hardware_configuration, (u32);
-	     u, (u32) u >> 8, (u32) u >> 16)
-		abe_read_use_case_opp(u, o);
+	_log(id_read_hardware_configuration, (u32) u,
+		(u32) u >> 8, (u32) u >> 16);
+	abe_read_use_case_opp(u, o);
 	/* 0: 96kHz 1:192kHz */
 	hw->MCPDM_CTRL__DIV_SEL = 0;
 	/* 0: no command in the FIFO, 1: 6 data on each lines (with commands) */
@@ -262,7 +262,7 @@
  * for the delivery of "end of time sequenced tasks" notifications, some are
  * originated from the Ping-Pong protocols, some are generated from
  * the embedded debugger when the firmware stops on programmable break-points,
- * etc
+ * etc ...
  */
 abehal_status abe_irq_processing(void)
 {
@@ -325,7 +325,6 @@
 	return 0;
 }
 EXPORT_SYMBOL(abe_irq_clear);
-
 /**
  * abe_select_main_port - Select stynchronization port for Event generator.
  * @id: audio port name
@@ -426,8 +425,8 @@
 #define OPP_25 1
 #define OPP_50 2
 #define OPP_100 4
-	_log(id_read_use_case_opp, (u32); u, (u32) u >> 8, (u32) u >> 16)
-		opp = i = 0;
+	_log(id_read_use_case_opp, (u32) u, (u32) u >> 8, (u32) u >> 16);
+	opp = i = 0;
 	do {
 		/* check for pointer errors */
 		if (i > MAX_READ_USE_CASE_OPP) {
@@ -499,7 +498,9 @@
  */
 abehal_status abe_set_opp_processing(u32 opp)
 {
-	u32 dOppMode32;
+	u32 dOppMode32, sio_desc_address;
+	ABE_SIODescriptor desc;
+
 	_lock_enter;
 	_log(id_set_opp_processing, opp, 0, 0);
 	switch (opp) {
@@ -522,7 +523,27 @@
 	/* Write Multiframe inside DMEM */
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       D_maxTaskBytesInSlot_ADDR, &dOppMode32, sizeof(u32));
+
+	sio_desc_address = dmem_port_descriptors + (MM_EXT_IN_PORT *
+			   sizeof(ABE_SIODescriptor));
+	abe_block_copy (COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,
+			(u32 *)&desc, sizeof(desc));
+
+	if (dOppMode32 == DOPPMODE32_OPP100) {
+		/* ASRC input buffer, size 40 */
+		desc.smem_addr1 = smem_mm_ext_in_opp100;
+		/* Init MM_EXT_IN ASRC and enable its adaptation */
+		abe_init_asrc_mm_ext_in(250);
+	} else {
+		/* at OPP 50 or without ASRC */
+		desc.smem_addr1 = smem_mm_ext_in_opp50;
+	}
+
+	abe_block_copy (COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,
+			(u32 *)&desc, sizeof(desc));
+
 	return 0;
+
 }
 EXPORT_SYMBOL(abe_set_opp_processing);
 /**
@@ -608,28 +629,6 @@
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_next_ping_pong_buffer);
-abehal_status abe_read_offset_ping_pong_buffer(u32 port, u32 *n)
-{
-	u32 sio_pp_desc_address;
-	ABE_SPingPongDescriptor desc_pp;
-	/* ping_pong is only supported on MM_DL */
-	if (port != MM_DL_PORT) {
-		abe_dbg_param |= ERR_API;
-		abe_dbg_error_log(ABE_PARAMETER_ERROR);
-	}
-	/* read the port SIO descriptor and extract the current pointer
-	   address after reading the counter */
-	sio_pp_desc_address = D_PingPongDesc_ADDR;
-	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_pp_desc_address,
-		       (u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));
-	if ((desc_pp.counter & 0x1) == 0) {
-		*n = 24*1024/4 - desc_pp.workbuff_Samples;
-	} else {
-		*n = 2*24*1024/4 - desc_pp.workbuff_Samples;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(abe_read_offset_ping_pong_buffer);
 /**
  * abe_init_ping_pong_buffer
  * @id: ABE port ID
@@ -663,6 +662,55 @@
 }
 EXPORT_SYMBOL(abe_init_ping_pong_buffer);
 /**
+ * abe_read_offset_from_ping_buffer
+ * @id: ABE port ID
+ * @n:  returned address of the offset from the ping buffer start address expressed in samples
+ *
+ * Computes the current firmware ping pong read pointer location, expressed in samples,
+ * as the offset from the start address of ping buffer.
+ */
+abehal_status abe_read_offset_from_ping_buffer(u32 id, u32 *n)
+{
+	u32 sio_pp_desc_address;
+	ABE_SPingPongDescriptor desc_pp;
+	/* ping_pong is only supported on MM_DL */
+	if (MM_DL_PORT != id) {
+		abe_dbg_param |= ERR_API;
+		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+	} else {
+		/* read the port SIO ping pong descriptor */
+		sio_pp_desc_address = D_PingPongDesc_ADDR;
+		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
+			       sio_pp_desc_address, (u32 *) &desc_pp,
+			       sizeof(ABE_SPingPongDescriptor));
+		/* extract the current ping pong buffer read pointer based on
+		   the value of the counter */
+		if ((desc_pp.counter & 0x1) == 0) {
+			/* the next is buffer0, hence the current is buffer1 */
+			if (abe_port[MM_DL_PORT].format.samp_format &
+			    (MONO_MSB | MONO_RSHIFTED_16 | STEREO_16_16)) {
+				*n = abe_size_pingpong / 4 +
+					desc_pp.nextbuff1_Samples -
+					desc_pp.workbuff_Samples;
+			} else if (abe_port[MM_DL_PORT].format.samp_format &
+				    (STEREO_MSB | STEREO_RSHIFTED_16)) {
+				*n = abe_size_pingpong / 8 +
+					desc_pp.nextbuff1_Samples -
+					desc_pp.workbuff_Samples;
+			} else {
+				abe_dbg_param |= ERR_API;
+				abe_dbg_error_log(ABE_PARAMETER_ERROR);
+			}
+		} else {
+			/* the next is buffer1, hence the current is buffer0 */
+			*n = desc_pp.nextbuff0_Samples -
+				desc_pp.workbuff_Samples;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(abe_read_offset_from_ping_buffer);
+/**
  * abe_plug_subroutine
  * @id: returned sequence index after plugging a new subroutine
  * @f: subroutine address to be inserted
@@ -674,8 +722,8 @@
 abehal_status abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,
 				  u32 *params)
 {
-	_log(id_plug_subroutine, (u32); (*id), (u32) f, n)
-		abe_add_subroutine(id, (abe_subroutine2) f, n, (u32 *) params);
+	_log(id_plug_subroutine, (u32) (*id), (u32) f, n);
+	abe_add_subroutine(id, (abe_subroutine2) f, n, (u32 *) params);
 	return 0;
 }
 EXPORT_SYMBOL(abe_plug_subroutine);
@@ -746,11 +794,11 @@
  */
 abehal_status abe_disable_data_transfer(u32 id)
 {
+	abe_port_protocol_t *protocol;
 	_log(id_disable_data_transfer, id, 0, 0);
 	/* there is only one PDM_DL physical port shared
 	   with DL1/DL2/VIB. Here is a check for the need to stop
 	   PDM_DL if some activity is already on */
-/*
 	if (id == PDM_DL1_PORT) {
 		pdm_dl1_status = 0;
 		if (pdm_dl2_status || pdm_vib_status)
@@ -772,7 +820,12 @@
 		else
 			id = PDM_DL_PORT;
 	}
-*/
+	/* MM_DL managed in ping-pong */
+	if (id == MM_DL_PORT) {
+		protocol = &(abe_port[MM_DL_PORT].protocol);
+		if (protocol->protocol_switch == PINGPONG_PORT_PROT)
+			abe_disable_pp_io_task(MM_DL_PORT);
+	}
 	/* local host variable status= "port is running" */
 	abe_port[id].status = OMAP_ABE_PORT_ACTIVITY_IDLE;
 	/* disable DMA requests */
@@ -781,7 +834,7 @@
 	abe_init_atc(id);
 	abe_clean_temporary_buffers(id);
 	/* select the main port based on the desactivation of this port */
-	abe_decide_main_port(id);
+	abe_decide_main_port();
 	return 0;
 }
 EXPORT_SYMBOL(abe_disable_data_transfer);
@@ -797,12 +850,11 @@
 {
 	abe_port_protocol_t *protocol;
 	abe_data_format_t format;
-	u32 dOppMode32;
+
 	_log(id_enable_data_transfer, id, 0, 0);
 	/* there is only one PDM_DL physical port shared
 	   with DL1/DL2/VIB. Here is a check for the need to enable
 	   PDM_DL when some activity is already on */
-/*
 	if (id == PDM_DL1_PORT) {
 		id = PDM_DL_PORT;
 		if (pdm_dl1_status == 1)
@@ -824,7 +876,6 @@
 		else
 			pdm_vib_status = 1;
 	}
-*/
 	abe_clean_temporary_buffers(id);
 	if (id == PDM_UL_PORT) {
 		/* initializes the ABE ATC descriptors in DMEM - MCPDM_UL */
@@ -840,6 +891,13 @@
 		abe_init_atc(PDM_DL_PORT);
 		abe_init_io_tasks(PDM_DL_PORT, &format, protocol);
 	}
+	/* MM_DL managed in ping-pong */
+	if (id == MM_DL_PORT) {
+		protocol = &(abe_port[MM_DL_PORT].protocol);
+		if (protocol->protocol_switch == PINGPONG_PORT_PROT) {
+			abe_enable_pp_io_task(MM_DL_PORT);
+		}
+	}
 	if (id == DMIC_PORT) {
 		/* one DMIC port enabled = all DMICs enabled,
 		 * since there is a single DMIC path for all DMICs */
@@ -856,20 +914,13 @@
 		/* Init VX_DL ASRC and enable its adaptation */
 		abe_init_asrc_vx_dl(250);
 	}
-	if (id == MM_EXT_IN_PORT) {
-		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       D_maxTaskBytesInSlot_ADDR, &dOppMode32,
-			       sizeof(u32));
-		if (dOppMode32 == DOPPMODE32_OPP100)
-			/* Init MM_EXT_IN ASRC and enable its adaptation */
-			abe_init_asrc_mm_ext_in(250);
-	}
+
 	/* local host variable status= "port is running" */
 	abe_port[id].status = OMAP_ABE_PORT_ACTIVITY_RUNNING;
 	/* enable DMA requests */
 	abe_enable_dma_request(id);
 	/* select the main port based on the activation of this new port */
-	abe_decide_main_port(id);
+	abe_decide_main_port();
 	return 0;
 }
 EXPORT_SYMBOL(abe_enable_data_transfer);
@@ -1350,11 +1401,12 @@
 		drift_sign_addr = D_AsrcVars_UL_VX_ADDR + (1 * sizeof(s32));
 		alpha_params_addr = D_AsrcVars_UL_VX_ADDR + (3 * sizeof(s32));
 		break;
-		/* asynchronous sample-rate-converter for the multimedia player */
 	default:
+		/* asynchronous sample-rate-converter for the multimedia player */
 	case MM_EXT_IN_PORT:
 		drift_sign_addr = D_AsrcVars_MM_EXT_IN_ADDR + (1 * sizeof(s32));
-		alpha_params_addr = D_AsrcVars_MM_EXT_IN_ADDR + (3 * sizeof(s32));
+		alpha_params_addr =
+			D_AsrcVars_MM_EXT_IN_ADDR + (3 * sizeof(s32));
 		break;
 	}
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, drift_sign_addr,
@@ -1404,20 +1456,15 @@
  */
 abehal_status abe_mute_gain(u32 id, u32 p)
 {
-	u32 lin_g, mixer_offset, mixer_target;
+	u32 mixer_offset, f_g, ramp;
+	/* save the input parameters for mute/unmute */
 	abe_gain_offset(id, &mixer_offset);
-	abe_muted_gains_indicator[mixer_offset + p] = 1;
-	/* SMEM word32 address */
-	mixer_target = (S_GTarget1_ADDR << 1);
-	mixer_target += mixer_offset;
-	mixer_target += p;
-	/* translate coef address in Bytes */
-	mixer_target <<= 2;
-	/* new muted gain */
-	lin_g = 0;
-	/* load the S_G_Target SMEM table */
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, mixer_target,
-		       (u32 *) &lin_g, sizeof(lin_g));
+	ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
+	f_g = GAIN_MUTE;
+	abe_muted_gains_decibel[mixer_offset + p] =
+		abe_desired_gains_decibel[mixer_offset + p];
+	/* unmute the gain */
+	abe_write_gain(id, f_g, ramp, p);
 	return 0;
 }
 EXPORT_SYMBOL(abe_mute_gain);
@@ -1430,23 +1477,13 @@
  */
 abehal_status abe_unmute_gain(u32 id, u32 p)
 {
-	u32 mixer_offset, mixer_target, lin_g;
+	u32 mixer_offset, f_g, ramp;
+	/* restore the input parameters for mute/unmute */
 	abe_gain_offset(id, &mixer_offset);
-	/* SMEM word32 address */
-	mixer_target = (S_GTarget1_ADDR << 1);
-	mixer_target += mixer_offset;
-	mixer_target += p;
-	/* translate coef address in Bytes */
-	mixer_target <<= 2;
-	/* unmute gain */
-	if (abe_compensated_mixer_gain)
-		lin_g = abe_unmuted_compensated_gains[mixer_offset + p];
-	else
-		lin_g = abe_unmuted_desired_gains[mixer_offset + p];
-	abe_muted_gains_indicator[mixer_offset + p] = 0;
-	/* load the S_G_Target SMEM table */
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, mixer_target,
-		       (u32 *) &lin_g, sizeof(lin_g));
+	f_g = abe_muted_gains_decibel[mixer_offset + p];
+	ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
+	/* unmute the gain */
+	abe_write_gain(id, f_g, ramp, p);
 	return 0;
 }
 EXPORT_SYMBOL(abe_unmute_gain);
@@ -1464,7 +1501,8 @@
  */
 abehal_status abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p)
 {
-	u32 lin_g, mixer_target, mixer_offset, i, mean_gain, mean_exp;
+	u32 lin_g, sum_g, mixer_target, mixer_offset, i, mean_gain, mean_exp;
+	u32 new_gain_linear[4];
 	s32 gain_index;
 	u32 alpha, beta;
 	u32 ramp_index;
@@ -1474,14 +1512,16 @@
 	gain_index = minimum(gain_index, sizeof_db2lin_table);
 	lin_g = abe_db2lin_table[gain_index];
 	abe_gain_offset(id, &mixer_offset);
+	/* save the input parameters for mute/unmute */
+	abe_desired_gains_linear[mixer_offset + p] = lin_g;
+	abe_desired_gains_decibel[mixer_offset + p] = f_g;
+	abe_desired_ramp_delay_ms[mixer_offset + p] = ramp;
 	/* SMEM word32 address */
 	mixer_target = (S_GTarget1_ADDR << 1);
 	mixer_target += mixer_offset;
 	mixer_target += p;
 	/* translate coef address in Bytes */
 	mixer_target <<= 2;
-	abe_muted_gains_indicator[mixer_offset + p] = 0;
-	abe_unmuted_desired_gains[mixer_offset + p] = lin_g;
 	if (abe_compensated_mixer_gain) {
 		switch (id) {
 		case MIXDL1:
@@ -1489,48 +1529,42 @@
 		case MIXVXREC:
 		case MIXAUDUL:
 			/* compute the sum of the gain of the mixer */
-			for (lin_g = i = 0; i < 4; i++)
-				lin_g += abe_unmuted_desired_gains[mixer_offset
-								   + i];
+			for (sum_g = i = 0; i < 4; i++)
+				sum_g += abe_desired_gains_linear[mixer_offset +
+								  i];
 			/* lets avoid a division by 0 */
-			if (lin_g == 0)
+			if (sum_g == 0)
 				break;
+			/* if the sum is OK with less than 1, then
+			   do not weight the gains */
+			if (sum_g < 0x00040000) {	/* REMOVE HARD CONST */
+				/* recompute all gains from original
+				   desired values */
+				sum_g = 0x00040000;
+			}
 			/* translate it in Q16 format for the later division */
-			abe_int_2_float16(lin_g, &mean_gain, &mean_exp);
+			abe_int_2_float16(sum_g, &mean_gain, &mean_exp);
 			mean_exp = 10 - mean_exp;
 			for (i = 0; i < 4; i++) {
 				/* new gain = desired gain divided by sum of gains */
-				abe_unmuted_compensated_gains[mixer_offset +
-							      i] =
-					(abe_unmuted_desired_gains
+				new_gain_linear[i] =
+					(abe_desired_gains_linear
 					 [mixer_offset + i]
 					 << 8) / mean_gain;
-				abe_unmuted_compensated_gains[mixer_offset +
-							      i] =
-					(mean_exp >
-					 0) ?
-					abe_unmuted_compensated_gains
-					[mixer_offset + i]
-					<< mean_exp :
-					abe_unmuted_compensated_gains
-					[mixer_offset + i]
-					>> mean_exp;
+				new_gain_linear[i] = (mean_exp > 0) ?
+					new_gain_linear[i] << mean_exp :
+					new_gain_linear[i] >> mean_exp;
 			}
 			/* load the whole adpated S_G_Target SMEM MIXER table */
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,
 				       mixer_target - (p << 2),
-				       abe_unmuted_compensated_gains,
-				       (4 * sizeof(lin_g)));
+				       new_gain_linear, (4 * sizeof(lin_g)));
 			break;
 		default:
-		case GAINS_DMIC1:
-		case GAINS_DMIC2:
-		case GAINS_DMIC3:
-		case GAINS_AMIC:
-		case GAINS_DL1:
-		case GAINS_DL2:
-		case MIXECHO:
-		case MIXSDT:
+			/* load the S_G_Target SMEM table */
+			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,
+				       mixer_target,
+				       (u32 *) &lin_g, sizeof(lin_g));
 			break;
 		}
 	} else {
@@ -1597,9 +1631,8 @@
  */
 abehal_status abe_read_gain(u32 id, u32 *f_g, u32 p)
 {
-	u32 mixer_target, mixer_offset;
-	u32 i;
-	_log(id_read_gain, id, (u32); f_g, p)
+	u32 mixer_target, mixer_offset, i;
+	_log(id_read_gain, id, (u32) f_g, p);
 		abe_gain_offset(id, &mixer_offset);
 	/* SMEM word32 address */
 	mixer_target = (S_GTarget1_ADDR << 1);
@@ -1665,8 +1698,8 @@
  */
 abehal_status abe_set_router_configuration(u32 id, u32 k, u32 *param)
 {
-	_log(id_set_router_configuration, id, (u32); param, (u32) param >> 8)
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
+	_log(id_set_router_configuration, id, (u32) param, (u32) param >> 8);
+	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       D_aUplinkRouting_ADDR,
 			       param, D_aUplinkRouting_sizeof);
 	return 0;
Index: Kernel/sound/soc/omap/abe/abe_api.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_api.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_api.h	2011-01-19 00:14:18.522072429 +0530
@@ -168,7 +168,6 @@
  * Tell the next base address of the next ping_pong Buffer and its size
  */
 abehal_status abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n);
-abehal_status abe_read_offset_ping_pong_buffer(u32 port, u32 *n);
 /**
  * abe_init_ping_pong_buffer
  * @id: ABE port ID
@@ -182,6 +181,15 @@
 abehal_status abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,
 					u32 *p);
 /**
+ * abe_read_offset_from_ping_buffer
+ * @id: ABE port ID
+ * @n:  returned address of the offset from the ping buffer start address expressed in samples
+ *
+ * Computes the current firmware ping pong read pointer location, expressed in samples,
+ * as the offset from the start address of ping buffer.
+ */
+abehal_status abe_read_offset_from_ping_buffer(u32 id, u32 *n);
+/**
  * abe_plug_subroutine
  * @id: returned sequence index after plugging a new subroutine
  * @f: subroutine address to be inserted
@@ -234,8 +242,6 @@
  * enable the IO task (@f <> 0)
  */
 abehal_status abe_enable_data_transfer(u32 id);
-void abe_enable_irq_transfer(u32 id);
-void abe_disable_irq_transfer(u32 id);
 /**
  * abe_set_dmic_filter
  * @d: DMIC decimation ratio : 16/25/32/40
Index: Kernel/sound/soc/omap/abe/abe_dat.c
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_dat.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_dat.c	2011-01-19 00:14:18.522072429 +0530
@@ -30,8 +30,10 @@
  */
 u32 abe_compensated_mixer_gain;
 u8 abe_muted_gains_indicator[MAX_NBGAIN_CMEM];
-u32 abe_unmuted_desired_gains[MAX_NBGAIN_CMEM];
-u32 abe_unmuted_compensated_gains[MAX_NBGAIN_CMEM];
+u32 abe_desired_gains_decibel[MAX_NBGAIN_CMEM];
+u32 abe_muted_gains_decibel[MAX_NBGAIN_CMEM];
+u32 abe_desired_gains_linear[MAX_NBGAIN_CMEM];
+u32 abe_desired_ramp_delay_ms[MAX_NBGAIN_CMEM];
 /*
  * HAL/FW ports status / format / sampling / protocol(call_back) / features
  *	/ gain / name
@@ -528,7 +530,7 @@
  typedef double (*PtrFun) (double);
 PtrFun pFun;
 pFun = sin;
-       y = (* pFun) (x);
+   y = (* pFun) (x);
 *//* mask, { time id param tag1} */
 const abe_sequence_t seq_null = {
 	NOMASK, {CL_M1, 0, {0, 0, 0, 0}, 0}, {CL_M1, 0, {0, 0, 0, 0}, 0}
Index: Kernel/sound/soc/omap/abe/abe_dbg.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_dbg.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_dbg.h	2011-01-19 00:14:18.522072429 +0530
@@ -146,4 +146,5 @@
 /*
  * MACROS
  */
-#define _log(x,y,z,t) {}
+#define _log(x, y, z, t) {if (x & abe_dbg_mask) abe_dbg_log(x, y, z, t); }
+
Index: Kernel/sound/soc/omap/abe/abe_def.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_def.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_def.h	2011-01-19 00:14:18.522072429 +0530
@@ -184,7 +184,7 @@
  */
 #define min_mdb (-12000)
 #define max_mdb ( 3000)
-#define sizeof_db2lin_table (1+ ((max_mdb - min_mdb)/100))
+#define sizeof_db2lin_table (1 + ((max_mdb - min_mdb)/100))
 #define sizeof_alpha_iir_table 61
 #define sizeof_beta_iir_table 61
 #define GAIN_MAXIMUM 3000L
@@ -237,7 +237,7 @@
 #define NOPARAMETER 0
 /* number of ATC access upon AMIC DMArequests, all the FIFOs are enabled */
 #define MCPDM_UL_ITER 4
-/* All the McPDM FIFOs are enabled simultaneously */
+/* All the McPDM FIFOs are enabled simultaneously MCPDMDL_IP THR = 4 */
 #define MCPDM_DL_ITER 24
 /* All the DMIC FIFOs are enabled simultaneously */
 #define DMIC_ITER 12
@@ -263,7 +263,7 @@
 #define c_feat_read_eq3 6
 #define c_write_eq3 7
 /* ATC FIFOs pointer margin before the scheduler is resynchronized */
-#define JITTER_MARGIN 3
+#define JITTER_MARGIN 4
 /* max number of gain to be controlled by HAL */
 #define MAX_NBGAIN_CMEM 34
 /*
Index: Kernel/sound/soc/omap/abe/abe_firmware.c
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_firmware.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_firmware.c	2011-01-19 00:14:18.522072429 +0530
@@ -1,4 +1,4 @@
-0x0000850A,  /* VERSION NUMBER */
+0x00008800,  /* VERSION NUMBER */
 0x00002000,  /* PMEM LENGTH IN BYTES */
 0x000014F8,  /* CMEM LENGTH IN BYTES */
 0x00010000,  /* DMEM LENGTH IN BYTES */
@@ -27,31 +27,31 @@
 0x014000ef,
 0x144000e4,
 0x9e000000,
-0x0a202e50,
+0x0a202ed0,
 0x9e000040,
-0x0a202e50,
+0x0a202ed0,
 0x9e000080,
-0x0a202e50,
+0x0a202ed0,
 0x9e0000c0,
-0x0a202e50,
+0x0a202ed0,
 0x9e080000,
-0x0a202e50,
+0x0a202ed0,
 0x9e080100,
-0x0a202e50,
+0x0a202ed0,
 0x9e080200,
-0x0a202e50,
+0x0a202ed0,
 0x9e080300,
-0x0a202e50,
+0x0a202ed0,
 0x9e080400,
-0x0a202e50,
+0x0a202ed0,
 0x9e080500,
-0x0a202e50,
+0x0a202ed0,
 0x9e080600,
-0x0a202e50,
+0x0a202ed0,
 0x9e080700,
-0x0a202e50,
+0x0a202ed0,
 0x9c050800,
-0x0a202e50,
+0x0a202ed0,
 0x16000010,
 0x16000001,
 0x17000102,
@@ -106,9 +106,13 @@
 0x9d01b260,
 0x9d02bc70,
 0x08200000,
+0x1602c7c6,
+0x00000068,
+0x16003fc5,
+0x01000058,
 0x1602c88a,
 0x000000a9,
-0x1602c7c6,
+0x16003fc6,
 0x00000068,
 0x0400089b,
 0x4000009c,
@@ -116,7 +120,7 @@
 0x410000ec,
 0x0600000c,
 0x1600274d,
-0x0a800830,
+0x0a800870,
 0x1602ea03,
 0x00000030,
 0x00000231,
@@ -137,7 +141,7 @@
 0x04800299,
 0x410000a9,
 0x05c00b90,
-0x4ac006c0,
+0x4ac00700,
 0x04a01085,
 0x1602c8c4,
 0x40000047,
@@ -150,7 +154,7 @@
 0x04a00111,
 0x410000e1,
 0x06000001,
-0x4aa009d0,
+0x4aa00a50,
 0x1602c90d,
 0x400000d6,
 0x16022e89,
@@ -160,6 +164,10 @@
 0x04900077,
 0x010000d6,
 0x010002d7,
+0x1602c7c6,
+0x00000068,
+0x16003fc5,
+0x01000058,
 0x1600c005,
 0x1602d241,
 0x16000002,
@@ -173,8 +181,8 @@
 0x08400000,
 0x01000004,
 0x9d140550,
-0x0a800670,
-0x0a0009d0,
+0x0a8006b0,
+0x0a000a50,
 0x048006ff,
 0x013ffafb,
 0x013ffcfc,
@@ -183,9 +191,9 @@
 0x004002bc,
 0x0600000c,
 0x1600274d,
-0x0a800b70,
+0x0a800bf0,
 0x0a200480,
-0x0a000b10,
+0x0a000b90,
 0x003ffefe,
 0x003ffcfc,
 0x003ffafb,
@@ -195,7 +203,7 @@
 0x07800000,
 0x07800000,
 0x9d088118,
-0x98800bc0,
+0x98800c40,
 0x08200000,
 0x9f158048,
 0x9f040040,
@@ -205,14 +213,14 @@
 0x07800000,
 0x07800000,
 0x9d188148,
-0x98800c20,
+0x98800ca0,
 0x08200000,
 0x9f158048,
 0x07800000,
 0x07800000,
 0x9d188148,
 0x9d188108,
-0x98800cc0,
+0x98800d40,
 0x08200000,
 0x9f158048,
 0x07800000,
@@ -222,7 +230,7 @@
 0x07800000,
 0x9d1e8148,
 0x9d1e8108,
-0x98800d30,
+0x98800db0,
 0x08200000,
 0x9f158018,
 0x9f040010,
@@ -235,21 +243,21 @@
 0x07800000,
 0x07800000,
 0x9d1e8108,
-0x98800dd0,
+0x98800e50,
 0x08200000,
 0x9c080048,
 0x9f1d0010,
 0x07800000,
 0x07800000,
 0x9d0c8118,
-0x98800ea0,
+0x98800f20,
 0x08200000,
 0x9c180028,
 0x9f1d0010,
 0x07800000,
 0x07800000,
 0x9d0c8108,
-0x98800f10,
+0x98800f90,
 0x08200000,
 0x9c180068,
 0x9c180028,
@@ -257,7 +265,7 @@
 0x07800000,
 0x07800000,
 0x9d0c8148,
-0x98800f80,
+0x98801000,
 0x08200000,
 0x9c1e0048,
 0x9c1e0008,
@@ -265,14 +273,14 @@
 0x07800000,
 0x07800000,
 0x9d0c8148,
-0x98801000,
+0x98801080,
 0x08200000,
 0x9c1e0008,
 0x9f1d0010,
 0x07800000,
 0x07800000,
 0x9d0c8108,
-0x98801080,
+0x98801100,
 0x08200000,
 0x160004d4,
 0x160004e5,
@@ -296,7 +304,7 @@
 0x07800000,
 0x07800000,
 0x9d0c8518,
-0x98801160,
+0x988011e0,
 0x9d032340,
 0x9d032c50,
 0x9d033560,
@@ -319,7 +327,7 @@
 0x9d1881c8,
 0x9d188108,
 0x9d188148,
-0x98801310,
+0x98801390,
 0x9d032440,
 0x9d032d50,
 0x9d033660,
@@ -333,7 +341,7 @@
 0x9d188108,
 0x9f158038,
 0x07800000,
-0x98801470,
+0x988014f0,
 0x9d188108,
 0x08200000,
 0x9e088100,
@@ -355,7 +363,7 @@
 0x07800000,
 0x07800000,
 0x9d0c8118,
-0x988015f0,
+0x98801670,
 0x08200000,
 0x08200000,
 0x08200000,
@@ -389,7 +397,7 @@
 0x9c0c0468,
 0x9f130462,
 0x9d0c8530,
-0x98801770,
+0x988017f0,
 0x9f1380ea,
 0x9f13056a,
 0x9c0c0428,
@@ -490,23 +498,23 @@
 0x9f0020b0,
 0x9f0400d0,
 0x05800560,
-0x0a801ea0,
+0x0a801f20,
 0x9c0c0510,
-0x0a001eb0,
+0x0a001f30,
 0x9c0c0618,
 0x16000014,
 0x9d0c81e8,
 0x9d0c8148,
-0x0a801f20,
+0x0a801fa0,
 0x9c0c05b0,
 0x9c0c0510,
-0x0a001f40,
+0x0a001fc0,
 0x9c0c06b8,
 0x9c0c0618,
 0x07800000,
 0x9d0c81e8,
 0x9d0c8148,
-0x98801d20,
+0x98801da0,
 0x9d180750,
 0x08200000,
 0x9d019220,
@@ -515,13 +523,13 @@
 0x413ffefe,
 0x16000040,
 0x9c010910,
-0x0a203490,
+0x0a203510,
 0x14400040,
 0x9c030810,
 0x16000171,
 0x9c009f30,
 0x9c019220,
-0x0a202f90,
+0x0a203010,
 0x9c009830,
 0x003ffefe,
 0x048ffeff,
@@ -534,7 +542,7 @@
 0x04000400,
 0x9e0f0150,
 0x01000025,
-0x0a202250,
+0x0a2022d0,
 0x403ffefe,
 0x16000007,
 0x9e0f0170,
@@ -544,7 +552,7 @@
 0x413ffefe,
 0x16000005,
 0x01000025,
-0x0a202250,
+0x0a2022d0,
 0x40000024,
 0x16000005,
 0x403ffefe,
@@ -569,25 +577,25 @@
 0x9c180674,
 0x9c180650,
 0x058001a0,
-0x0aa02750,
+0x0aa027d0,
 0x04800144,
 0x04400044,
 0x05800040,
-0x0aa02490,
+0x0aa02510,
 0x05800160,
-0x0ac02430,
+0x0ac024b0,
 0x9e090000,
 0x07800000,
 0x07800000,
 0x9e0d0500,
 0x9d040508,
-0x0a002620,
+0x0a0026a0,
 0x9d040008,
 0x9e090000,
 0x07800000,
 0x9d040008,
 0x9e0d0500,
-0x0a002620,
+0x0a0026a0,
 0x9d040008,
 0x9e090000,
 0x07800000,
@@ -596,18 +604,18 @@
 0x1280010a,
 0x048001a9,
 0x05800940,
-0x0aa02620,
+0x0aa026a0,
 0x05800160,
 0x40000628,
 0x160ffff9,
-0x0ac025b0,
+0x0ac02630,
 0x05800180,
-0x0ae02620,
+0x0ae026a0,
 0x160ffff6,
 0x160ffff7,
-0x0a0025f0,
+0x0a002670,
 0x05800810,
-0x0ae02620,
+0x0ae026a0,
 0x16000016,
 0x16000007,
 0x9d044690,
@@ -615,10 +623,10 @@
 0x9d180674,
 0x05800160,
 0x9d180654,
-0x0ac02690,
+0x0ac02710,
 0x0420040a,
 0x04a001ab,
-0x4a0026c0,
+0x4a002740,
 0x044000bb,
 0x0480014b,
 0x044000bb,
@@ -630,24 +638,24 @@
 0x12000288,
 0x12000299,
 0x9e0e8280,
-0xca002860,
+0xca0028e0,
 0x1e0e8390,
 0xdd040604,
 0x05800160,
-0x0ac02800,
+0x0ac02880,
 0x9d040008,
 0x9e090000,
 0x07800000,
 0x05800040,
 0x9e0d0500,
-0x0aa02860,
+0x0aa028e0,
 0x9d040508,
-0x0a002860,
+0x0a0028e0,
 0x9e090000,
 0x05800040,
 0x9d040008,
 0x9e0d0500,
-0x0a802860,
+0x0a8028e0,
 0x9d040508,
 0x9c1d06c4,
 0xdc1d0644,
@@ -660,7 +668,7 @@
 0x9d108700,
 0x00000cc9,
 0x06000008,
-0x0aa02a60,
+0x0aa02ae0,
 0xdc1d0684,
 0x14400005,
 0xdc1d0604,
@@ -671,16 +679,16 @@
 0xdd108700,
 0x160ffff8,
 0x05800540,
-0x0aa02a20,
+0x0aa02aa0,
 0x05800160,
-0x0ac02a10,
+0x0ac02a90,
 0x01000027,
-0x0a002a20,
+0x0a002aa0,
 0x01000028,
 0x9e088000,
 0xa0054dba,
 0xa005c81a,
-0x0a002af0,
+0x0a002b70,
 0x9e088000,
 0xa0054dba,
 0xa005c81a,
@@ -693,7 +701,7 @@
 0x9d0446a0,
 0x9e0f0070,
 0x9d0c8118,
-0x988022f0,
+0x98802370,
 0x003ffefb,
 0x003ffcfa,
 0x003ffaf9,
@@ -712,7 +720,7 @@
 0x9d0c82b8,
 0x07800000,
 0x9d0c8318,
-0x98802bf0,
+0x98802c70,
 0x07800000,
 0xa00602ba,
 0x9c0c0118,
@@ -726,10 +734,10 @@
 0x9c1d0548,
 0x9f093860,
 0x06000006,
-0x0aa02d70,
+0x0aa02df0,
 0x06000017,
-0x0aa02d70,
-0x01800025,
+0x0aa02df0,
+0x07800000,
 0x9c0c0118,
 0x9c0c01b0,
 0x9f082010,
@@ -739,10 +747,10 @@
 0x9c1d0548,
 0x9f083860,
 0x06000006,
-0x0aa02e40,
+0x0aa02ec0,
 0x06000017,
-0x0aa02e40,
-0x01800125,
+0x0aa02ec0,
+0x07800000,
 0x08200000,
 0x07800000,
 0x01400040,
@@ -775,7 +783,7 @@
 0x9d0c8318,
 0x9d0c81b8,
 0x9d0c02b8,
-0x98802fe0,
+0x98803060,
 0x07800000,
 0xa00602ba,
 0x07800000,
@@ -800,7 +808,7 @@
 0x07800000,
 0x9d0c8318,
 0x9d0c02b8,
-0x98803110,
+0x98803190,
 0x9c0c0018,
 0xa00602ba,
 0x07800000,
@@ -825,7 +833,7 @@
 0x9d0c8298,
 0x9d0c8338,
 0x9d0c8198,
-0x988032f0,
+0x98803370,
 0x07800000,
 0xa00602ba,
 0xa006821a,
@@ -840,9 +848,9 @@
 0xdd040008,
 0x06000001,
 0x04a00111,
-0x0aa03410,
+0x0aa03490,
 0x9d0c8118,
-0x988033f0,
+0x98803470,
 0x08200000,
 0x9c0c02b0,
 0x9c0c0018,
@@ -852,8 +860,8 @@
 0xdd0c81b8,
 0x06000005,
 0x04a00155,
-0x0aa034e0,
-0x988034a0,
+0x0aa03560,
+0x98803520,
 0x08200000,
 0x9c0c0018,
 0x9e0e0620,
@@ -873,7 +881,7 @@
 0x9d0c8318,
 0x9d0c81b8,
 0x9d0c02b8,
-0x98803590,
+0x98803610,
 0x9c0c0610,
 0xa00602ba,
 0x07800000,
@@ -895,7 +903,7 @@
 0x07800000,
 0x9f160028,
 0x9f168298,
-0x98803780,
+0x98803800,
 0x9d0c8128,
 0x08200000,
 0x9f160020,
@@ -903,14 +911,14 @@
 0x07800000,
 0x9d0c8108,
 0x9d0c8258,
-0x988037f0,
+0x98803870,
 0x08200000,
 0x9f160010,
 0x9f168068,
 0x07800000,
 0x07800000,
 0x9d0c8128,
-0x98803860,
+0x988038e0,
 0x08200000,
 0x9d008810,
 0x1280020d,
@@ -934,7 +942,7 @@
 0x9d0c87b8,
 0x9d1082c8,
 0x9d108288,
-0x98803930,
+0x988039b0,
 0x08200000,
 0x00000003,
 0x00000205,
@@ -947,7 +955,7 @@
 0x07800000,
 0x07800000,
 0x9d0c8128,
-0x98803ab0,
+0x98803b30,
 0x08200000,
 0x010002fe,
 0x00801605,
@@ -978,7 +986,7 @@
 0xdc180404,
 0x06000003,
 0x9c180480,
-0x0aa04020,
+0x0aa040a0,
 0x9c052b20,
 0x9c042820,
 0x9c023970,
@@ -990,27 +998,27 @@
 0x00800e04,
 0x00800503,
 0x05800420,
-0x0ae03f10,
+0x0ae03f90,
 0x160fffe6,
 0x04000344,
 0x05800420,
-0x0ae04000,
+0x0ae04080,
 0x160ffff6,
 0x04000344,
 0x05800420,
-0x0ae04000,
+0x0ae04080,
 0x16000006,
 0x04000344,
 0x05800420,
-0x0ae04000,
+0x0ae04080,
 0x16000016,
 0x04000344,
 0x05800420,
-0x0ae04000,
+0x0ae04080,
 0x16000026,
 0x04000344,
 0x05800420,
-0x0ae04000,
+0x0ae04080,
 0x16000036,
 0x010000f6,
 0x12000132,
@@ -1028,7 +1036,7 @@
 0x9e0f0070,
 0x000000f6,
 0x01000606,
-0x0a004420,
+0x0a0044a0,
 0x9c042b20,
 0x9c052920,
 0x9c023870,
@@ -1040,43 +1048,43 @@
 0x160fffb6,
 0x00800503,
 0x05800420,
-0x0ae04330,
+0x0ae043b0,
 0x160fffc6,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x160fffd6,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x160fffe6,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x160ffff6,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000006,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000016,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000026,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000036,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000046,
 0x04000344,
 0x05800420,
-0x0ae04410,
+0x0ae04490,
 0x16000056,
 0x010000f6,
 0x12000232,
@@ -1116,7 +1124,7 @@
 0x06000005,
 0x40800f02,
 0x04c07f77,
-0x4a804650,
+0x4a8046d0,
 0x04500273,
 0x00800a02,
 0x9e088100,
@@ -1167,8 +1175,8 @@
 0x9d0c810c,
 0x9d0c815c,
 0x9d0c81ac,
-0x98804860,
-0x0aa047e0,
+0x988048e0,
+0x0aa04860,
 0x9e0f0120,
 0x08200000,
 0x4080070d,
@@ -1180,35 +1188,36 @@
 0x413ffefe,
 0x06000004,
 0x9c03a950,
-0x4aa049f0,
+0x4aa04a80,
 0x144000d2,
-0x0a204cb0,
-0x00000e04,
+0x0a204d40,
+0x40000e04,
+0x1440002d,
 0x06000004,
-0x0a804b30,
+0x0a804bc0,
 0x05800d40,
-0x0ae04a30,
-0x0a204b60,
-0x0a004ae0,
+0x0ae04ac0,
+0x0a204bf0,
+0x0a004b70,
 0x042004d2,
 0x1440004d,
-0x0a204b60,
-0x0a204cb0,
+0x0a204bf0,
+0x0a204d40,
 0x06000002,
-0x0a804ae0,
+0x0a804b70,
 0x1440002d,
 0x00000e04,
 0x05800d40,
-0x0ac04b30,
-0x0a204b60,
+0x0ac04bc0,
+0x0a204bf0,
 0x003ffefe,
 0x40800905,
 0x048ffeff,
 0x9d03a950,
 0x08200000,
 0x04a0012d,
-0x0a2014d0,
-0x0a004ae0,
+0x0a201550,
+0x0a004b70,
 0x16014e46,
 0x40800605,
 0x048002ff,
@@ -1235,19 +1244,19 @@
 0x40000403,
 0x04c001d7,
 0x06000007,
-0x4a804da0,
+0x4a804e30,
 0x16000017,
 0x00001604,
 0x06000004,
-0x0a804ec0,
+0x0a804f50,
 0x40001405,
 0x048001dd,
 0x01000e04,
 0x01000c05,
-0x0a004e10,
+0x0a004ea0,
 0x00001204,
 0x06000004,
-0x0a804ec0,
+0x0a804f50,
 0x40001005,
 0x048001dd,
 0x01000e04,
@@ -1257,11 +1266,11 @@
 0x16000005,
 0x40800a04,
 0x05c00630,
-0x0a804eb0,
+0x0a804f40,
 0x12000233,
 0x9e0e0530,
 0x9d140550,
-0x0a004ec0,
+0x0a004f50,
 0x01800017,
 0x08200000,
 0x048008ff,
@@ -1287,13 +1296,13 @@
 0x01c00127,
 0x01c0012b,
 0x9c018201,
-0x98804fc0,
+0x98805050,
 0x04800633,
 0x1440001d,
 0x00000034,
 0x04802833,
 0x01c00124,
-0x98805070,
+0x98805100,
 0x1602e9ca,
 0x16002102,
 0x408000a4,
@@ -1351,11 +1360,11 @@
 0x16000005,
 0x16000006,
 0x06000008,
-0x0aa05470,
+0x0aa05500,
 0x16000015,
 0x000002a8,
 0x06000009,
-0x0aa054b0,
+0x0aa05540,
 0x16000016,
 0x000002b9,
 0x1602d0c2,
@@ -1367,12 +1376,12 @@
 0x1602c90d,
 0x41800027,
 0x06000004,
-0x0aa055a0,
+0x0aa05630,
 0x06000005,
-0x0aa05620,
-0x06000001,
 0x0aa056b0,
-0x0a0057a0,
+0x06000001,
+0x0aa05740,
+0x0a005830,
 0x160000a8,
 0x400000d6,
 0x12000c88,
@@ -1380,7 +1389,7 @@
 0x07800000,
 0x06000005,
 0x9d180078,
-0x0a805690,
+0x0a805720,
 0x160000c8,
 0x400000d6,
 0x12000c88,
@@ -1389,7 +1398,7 @@
 0x07800000,
 0x9d180078,
 0x06000001,
-0x0a805720,
+0x0a8057b0,
 0x160000d8,
 0x400000d6,
 0x12000c88,
@@ -1413,7 +1422,7 @@
 0x06000000,
 0x00000049,
 0x16000005,
-0x0a805840,
+0x0a8058d0,
 0x04200959,
 0x160ffff6,
 0x05800590,
@@ -1423,7 +1432,7 @@
 0x04800233,
 0x01000023,
 0x1601fe02,
-0x01001623,
+0x01004a23,
 0x003ffefb,
 0x003ffcfa,
 0x003ffaf9,
@@ -1566,20 +1575,20 @@
 0x07800000,
 0x06000033,
 0x9e0e8220,
-0x0aa06210,
+0x0aa062a0,
 0x9c1d0004,
 0x9c1d0044,
 0x07800000,
 0x9d0c0210,
-0x0a0062c0,
+0x0a006350,
 0x06000023,
-0x0aa06270,
+0x0aa06300,
 0x9c1d0004,
 0x9d040004,
 0x9d100200,
-0x0a0062c0,
+0x0a006350,
 0x06000043,
-0x0aa062c0,
+0x0aa06350,
 0x9c180024,
 0x9d040004,
 0x9d180200,
@@ -1587,16 +1596,7 @@
 0x05c00740,
 0x17800644,
 0x01000004,
-0x0a006130,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
+0x0a0061c0,
 0x00000000,
 0x00000000,
 0x00000000,
@@ -3434,6 +3434,7 @@
 0x00000000,
 0x00000000,
 0x00000000,
+
 0x00000000,
 0x00000000,
 0x00000000,
@@ -3549,32 +3550,32 @@
 0x00000000,
 0x00000000,
 0x00000000,
-0x00008500,
-0x037402F9,
-0x033F037F,
-0x00430349,
-0x0386003A,
-0x038D03A5,
-0x01AC032A,
-0x03B20490,
-0x02EB04ED,
-0x01FA01CE,
-0x030C02B9,
-0x019C00AC,
-0x02190165,
-0x060F020B,
-0x03540599,
-0x00BC0002,
-0x00CC00C2,
-0x00DD00D3,
-0x00F100EA,
-0x01000108,
-0x010F00F8,
-0x0141012A,
-0x01620003,
-0x01640163,
-0x03C5046F,
-0x0000014D,
+0x00008800,
+0x037C0301,
+0x03470387,
+0x00430351,
+0x038E003A,
+0x039503AD,
+0x01B40332,
+0x03BA0498,
+0x02F304F6,
+0x020201D6,
+0x031402C1,
+0x01A400B4,
+0x0221016D,
+0x06180213,
+0x035C05A2,
+0x00C40002,
+0x00D400CA,
+0x00E500DB,
+0x00F900F2,
+0x01080110,
+0x01170100,
+0x01490132,
+0x016A0003,
+0x016C016B,
+0x03CD0477,
+0x00000155,
 0x00000000,
 0x00000000,
 0x00000000,
@@ -11626,6 +11627,7 @@
 0x00000000,
 0x00000000,
 0x00000000,
+
 0x00000000,
 0x00000000,
 0x00000000,
@@ -19818,6 +19820,7 @@
 0x0001570E,
 0x0001570E,
 0x0001570E,
+
 0x0001570E,
 0x0001570E,
 0x0001570E,
@@ -24241,3 +24244,4 @@
 0x00000000,
 0x00010000,
 0x00010000,
+
Index: Kernel/sound/soc/omap/abe/abe_fw.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_fw.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_fw.h	2011-01-19 00:14:18.522072429 +0530
@@ -220,7 +220,7 @@
 #define smem_vx_dl	IO_VX_DL_ASRC_labelID	/* Voice_16k_DL_labelID */
 #define dmem_vx_ul D_VX_UL_FIFO_ADDR
 #define dmem_vx_ul_size (D_VX_UL_FIFO_sizeof/4)
-#define smem_vx_ul Voice_16k_UL_labelID
+#define smem_vx_ul Voice_8k_UL_labelID
 #define dmem_tones_dl D_TONES_DL_FIFO_ADDR
 #define dmem_tones_dl_size (D_TONES_DL_FIFO_sizeof/4)
 #define smem_tones_dl Tones_labelID
Index: Kernel/sound/soc/omap/abe/abe_ini.c
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_ini.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_ini.c	2011-01-19 00:14:18.522072429 +0530
@@ -20,6 +20,9 @@
  */
 #include "abe_main.h"
 #include "abe_dm_addr.h"
+
+short MultiFrame[PROCESSING_SLOTS][TASKS_IN_SLOT];
+
 /*
  * initialize the default values for call-backs to subroutines
  * - FIFO IRQ call-backs for sequenced tasks
@@ -28,7 +31,6 @@
  * - Error monitoring
  * - Activity Tracing
  */
-static short MultiFrame[PROCESSING_SLOTS][TASKS_IN_SLOT];
 /**
  * abe_hw_configuration
  *
@@ -71,10 +73,10 @@
 	/* MultiFrame[1][1] = 0; */
 #define TASK_ASRC_VX_DL_SLT 1
 #define TASK_ASRC_VX_DL_IDX 2
-	MultiFrame[1][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_DL_16);
+	MultiFrame[1][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_DL_8);
 #define TASK_VX_DL_SLT 1
 #define TASK_VX_DL_IDX 3
-	MultiFrame[1][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_16_48);
+	MultiFrame[1][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_8_48);
 	/* MultiFrame[1][4] = 0; */
 	/* MultiFrame[1][5] = 0; */
 	MultiFrame[1][6] = ABE_TASK_ID(C_ABE_FW_TASK_DL2Mixer);
@@ -166,7 +168,7 @@
 	MultiFrame[12][4] = ABE_TASK_ID(C_ABE_FW_TASK_ULMixer);
 #define TASK_VX_UL_SLT 12
 #define TASK_VX_UL_IDX 5
-	MultiFrame[12][5] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_16);
+	MultiFrame[12][5] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_8);
 	/* MultiFrame[12][6] = 0; */
 	/* MultiFrame[12][7] = 0; */
 	/* MultiFrame[13][0] = 0; */
@@ -199,7 +201,7 @@
 	/* MultiFrame[16][1] = 0; */
 #define TASK_ASRC_VX_UL_SLT 16
 #define TASK_ASRC_VX_UL_IDX 2
-	MultiFrame[16][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_UL_16);
+	MultiFrame[16][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_UL_8);
 	MultiFrame[16][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VX_UL);
 	/* MultiFrame[16][4] = 0; */
 	/* MultiFrame[16][5] = 0; */
@@ -317,11 +319,11 @@
 	/* IN from AESS point of view */
 	if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN)
 		if (iter + 2 * datasize > 126)
-			desc.wrpt = (iter >> 1) + (JITTER_MARGIN * datasize);
+			desc.wrpt = (iter >> 1) + ((JITTER_MARGIN - 1) * datasize);
 		else
-			desc.wrpt = iter + (JITTER_MARGIN * datasize);
+			desc.wrpt = iter + ((JITTER_MARGIN - 1) * datasize);
 	else
-		desc.wrpt = 0 + (JITTER_MARGIN * datasize);
+		desc.wrpt = 0 + ((JITTER_MARGIN + 1) * datasize);
 	switch ((abe_port[id]).protocol.protocol_switch) {
 	case SLIMBUS_PORT_PROT:
 		desc.cbdir = (abe_port[id]).protocol.direction;
@@ -580,20 +582,10 @@
 	u32 sio_desc_address, datasize, iter, nsamp, datasize2, dOppMode32;
 	u32 atc_ptr_saved, atc_ptr_saved2, copy_func_index1;
 	u32 copy_func_index2, atc_desc_address1, atc_desc_address2;
+
 	if (prot->protocol_switch == PINGPONG_PORT_PROT) {
-		/* MM_DL managed in ping-pong */
-		if (MM_DL_PORT == id) {
-#if 0
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR,
-				       (u32 *) MultiFrame, sizeof(MultiFrame));
-			MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
-				ABE_TASK_ID(C_ABE_FW_TASK_IO_PING_PONG);
-			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
-#endif
-		} else {
+		/* ping_pong is only supported on MM_DL */
+		if (MM_DL_PORT != id) {
 			abe_dbg_param |= ERR_API;
 			abe_dbg_error_log(ABE_PARAMETER_ERROR);
 		}
@@ -622,17 +614,22 @@
 		desc_pp.workbuff_BaseAddr =
 			(u16) (abe_base_address_pingpong[1]);
 		/* size comunicated in XIO sample */
-		desc_pp.workbuff_Samples = (u16) iter_samples;
+		desc_pp.workbuff_Samples = 0;
 		desc_pp.nextbuff0_BaseAddr =
 			(u16) (abe_base_address_pingpong[0]);
-		desc_pp.nextbuff0_Samples =
-			(u16) ((abe_size_pingpong >> 2) / datasize);
 		desc_pp.nextbuff1_BaseAddr =
 			(u16) (abe_base_address_pingpong[1]);
-		desc_pp.nextbuff1_Samples =
-			(u16) ((abe_size_pingpong >> 2) / datasize);
+		if (dmareq_addr == ABE_DMASTATUS_RAW) {
+			desc_pp.nextbuff0_Samples =
+				(u16) ((abe_size_pingpong >> 2) / datasize);
+			desc_pp.nextbuff1_Samples =
+				(u16) ((abe_size_pingpong >> 2) / datasize);
+		} else {
+			desc_pp.nextbuff0_Samples = 0;
+			desc_pp.nextbuff1_Samples = 0;
+		}
 		/* next buffer to send is B1, first IRQ fills B0 */
-		desc_pp.counter = 1;
+		desc_pp.counter = 0;
 		/* send a DMA req to fill B0 with N samples
 		   abe_block_copy (COPY_FROM_HOST_TO_ABE, ABE_ATC, ABE_DMASTATUS_RAW,
 		   &(abe_port[id].protocol.p.prot_pingpong.irq_data), 4); */
@@ -879,33 +876,55 @@
 			       sio_desc_address, (u32 *) &desc, sizeof(desc));
 	}
 }
-void abe_enable_irq_transfer(u32 id)
+/**
+ * abe_enable_pp_io_task
+ * @id: port_id
+ *
+ *
+ */
+void abe_enable_pp_io_task(u32 id)
 {
+
 	/* MM_DL managed in ping-pong */
 	if (MM_DL_PORT == id) {
 		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       D_multiFrame_ADDR,
-			       (u32 *) MultiFrame, sizeof(MultiFrame));
+			       D_multiFrame_ADDR, (u32 *) MultiFrame,
+			       sizeof(MultiFrame));
 		MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
 			ABE_TASK_ID(C_ABE_FW_TASK_IO_PING_PONG);
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+			       sizeof(MultiFrame));
+	}
+	/* ping_pong is only supported on MM_DL */
+	else {
+		abe_dbg_param |= ERR_API;
+		abe_dbg_error_log(ABE_PARAMETER_ERROR);
 	}
 }
-
-void abe_disable_irq_transfer(u32 id)
+/**
+ * abe_disable_pp_io_task
+ * @id: port_id
+ *
+ *
+ */
+void abe_disable_pp_io_task(u32 id)
 {
 	/* MM_DL managed in ping-pong */
 	if (MM_DL_PORT == id) {
 		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       D_multiFrame_ADDR,
-			       (u32 *) MultiFrame, sizeof(MultiFrame));
+			       D_multiFrame_ADDR, (u32 *) MultiFrame,
+			       sizeof(MultiFrame));
 		MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] = 0;
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       D_multiFrame_ADDR, (u32 *) MultiFrame,
 			       sizeof(MultiFrame));
 	}
+	/* ping_pong is only supported on MM_DL */
+	else {
+		abe_dbg_param |= ERR_API;
+		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+	}
 }
 /**
  * abe_init_dmic
Index: Kernel/sound/soc/omap/abe/abe_lib.c
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_lib.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_lib.c	2011-01-19 00:14:18.532072173 +0530
@@ -22,34 +22,6 @@
 #if PC_SIMULATION
 #include <stdlib.h>
 #endif
-#define ABE_PMEM_BASE_OFFSET_MPU	0xe0000
-#define ABE_CMEM_BASE_OFFSET_MPU	0xa0000
-#define ABE_SMEM_BASE_OFFSET_MPU	0xc0000
-#define ABE_DMEM_BASE_OFFSET_MPU	0x80000
-#define ABE_ATC_BASE_OFFSET_MPU		0xf1000
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <linux/pm_runtime.h>
-void __iomem *io_base;
-/**
- * abe_init_mem - Allocate Kernel space memory map for ABE
- *
- * Memory map of ABE memory space for PMEM/DMEM/SMEM/DMEM
- */
-void abe_init_mem(void __iomem *_io_base)
-{
-	io_base = _io_base;
-}
 /**
 * abe_fprintf
 * @line: character line to be printed
@@ -132,108 +104,6 @@
 	}
 }
 /**
- * abe_block_copy
- * @direction: direction of the data move (Read/Write)
- * @memory_bamk:memory bank among PMEM, DMEM, CMEM, SMEM, ATC/IO
- * @address: address of the memory copy (byte addressing)
- * @data: pointer to the data to transfer
- * @nb_bytes: number of data to move
- *
- * Memory transfer to/from ABE to MPU
- */
-void abe_block_copy(u32 direction, u32 memory_bank, u32 address,
-		    u32 *data, u32 nb_bytes)
-{
-	u32 i;
-	u32 base_address = 0, *src_ptr, *dst_ptr, n;
-	switch (memory_bank) {
-	case ABE_PMEM:
-		base_address = (u32) io_base + ABE_PMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_CMEM:
-		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_SMEM:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_DMEM:
-		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_ATC:
-		base_address = (u32) io_base + ABE_ATC_BASE_OFFSET_MPU;
-		break;
-	default:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
-		abe_dbg_param |= ERR_LIB;
-		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
-		break;
-	}
-	if (direction == COPY_FROM_HOST_TO_ABE) {
-		dst_ptr = (u32 *) (base_address + address);
-		src_ptr = (u32 *) data;
-	} else {
-		dst_ptr = (u32 *) data;
-		src_ptr = (u32 *) (base_address + address);
-	}
-	n = (nb_bytes / 4);
-	for (i = 0; i < n; i++)
-		*dst_ptr++ = *src_ptr++;
-}
-#if 0
-/*
- * ABE_SINGLE_COPY
- *
- * Parameter :
- * address of the memory copy (byte addressing)
- * long pointer to the data
- * number of data to move
- *
- * Operations :
- * 32bits data move
- *
- * Return value :
- * none
- */
-void abe_write_dmem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_read_dmem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_write_cmem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_read_cmem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_write_smem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_read_smem(u32 address, u32 *data, u32 nb_bytes)
-     void abe_write_atc(u32 address, u32 *data, u32 nb_bytes)
-     void abe_read_atc(u32 address, u32 *data, u32 nb_bytes)
-#endif
-/**
- * abe_reset_mem
- *
- * @memory_bank: memory bank among DMEM, SMEM
- * @address: address of the memory copy (byte addressing)
- * @nb_bytes: number of data to move
- *
- * Reset ABE memory
- */
-     void abe_reset_mem(u32 memory_bank, u32 address, u32 nb_bytes)
-{
-	u32 i;
-	u32 *dst_ptr, n;
-	u32 base_address = 0;
-	switch (memory_bank) {
-	case ABE_SMEM:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_DMEM:
-		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
-		break;
-	case ABE_CMEM:
-		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
-		break;
-	}
-	dst_ptr = (u32 *) (base_address + address);
-	n = (nb_bytes / 4);
-	for (i = 0; i < n; i++)
-		*dst_ptr++ = 0;
-}
-/**
  * abe_monitoring
  *
  * checks the internal status of ABE and HAL
@@ -500,49 +370,28 @@
  */
 u32 abe_valid_port_for_synchro(u32 id)
 {
-	if ((abe_port[id].protocol.protocol_switch == DMAREQ_PORT_PROT) ||
-		(abe_port[id].protocol.protocol_switch == PINGPONG_PORT_PROT))
+	if ((abe_port[id].protocol.protocol_switch ==
+	     DMAREQ_PORT_PROT) ||
+	    (abe_port[id].protocol.protocol_switch ==
+	     PINGPONG_PORT_PROT) ||
+	    (abe_port[id].status != OMAP_ABE_PORT_ACTIVITY_RUNNING))
 		return 0;
 	else
 		return 1;
 }
-void abe_decide_main_port(u32 id)
-{
-	u32 i;
-
-	if (abe_valid_port_for_synchro(id)) {
-		for (i = 0; i < (LAST_PORT_ID - 1); i++) {
-			if (abe_port[abe_port_priority[i]].status ==
-					OMAP_ABE_PORT_ACTIVITY_RUNNING)
-				break;
-		}
-
-		if (i < (LAST_PORT_ID - 1))
-			id = abe_port_priority[i];
-		abe_select_main_port(id);
-	}
-}
-/**
- * abe_check_activity - Check if some ABE activity.
- *
- * Check if any ABE ports are running.
- * return 1: still activity on ABE
- * return 0: no more activity on ABE. Event generator can be stopped
- *
- */
-u32 abe_check_activity(void)
+void abe_decide_main_port(void)
 {
-	u32 i;
-	u32 ret;
-
-	ret = 0;
-	for (i = 0; i < (LAST_PORT_ID - 1); i++) {
-		if (abe_port[abe_port_priority[i]].status ==
-				OMAP_ABE_PORT_ACTIVITY_RUNNING)
+	u32 id, id_not_found;
+	id_not_found = 1;
+	for (id = 0; id < LAST_PORT_ID - 1; id++) {
+		if (abe_valid_port_for_synchro(abe_port_priority[id])) {
+			id_not_found = 0;
 			break;
+		}
 	}
-	if (i < (LAST_PORT_ID - 1))
-		ret = 1;
-
-	return ret;
+	/* if no port is currently activated, the default one is PDM_DL */
+	if (id_not_found)
+		abe_select_main_port(PDM_DL_PORT);
+	else
+		abe_select_main_port(abe_port_priority[id]);
 }
Index: Kernel/sound/soc/omap/abe/abe_main.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_main.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_main.h	2011-01-19 00:14:18.532072173 +0530
@@ -44,4 +44,4 @@
 #define ABE_DEBUG_LL_LOG                0
 #define ABE_DEBUG (ABE_DEBUG_CHECKERS | ABE_DEBUG_HWFILE | ABE_DEBUG_LL_LOG)
 extern void abe_init_mem(void __iomem *_io_base);
-#endif/* _ABE_MAIN_H_ */
+#endif /* _ABE_MAIN_H_ */
Index: Kernel/sound/soc/omap/abe/abe_mem.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/sound/soc/omap/abe/abe_mem.c	2011-01-19 00:14:18.532072173 +0530
@@ -0,0 +1,140 @@
+/*
+ * ALSA SoC OMAP ABE driver
+ *
+ * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
+ * 	Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include "abe_main.h"
+
+#define ABE_PMEM_BASE_OFFSET_MPU	0xe0000
+#define ABE_CMEM_BASE_OFFSET_MPU	0xa0000
+#define ABE_SMEM_BASE_OFFSET_MPU	0xc0000
+#define ABE_DMEM_BASE_OFFSET_MPU	0x80000
+#define ABE_ATC_BASE_OFFSET_MPU		0xf1000
+
+void __iomem *io_base;
+/**
+ * abe_init_mem - Allocate Kernel space memory map for ABE
+ *
+ * Memory map of ABE memory space for PMEM/DMEM/SMEM/DMEM
+ */
+void abe_init_mem(void __iomem *_io_base)
+{
+	io_base = _io_base;
+}
+/**
+ * abe_block_copy
+ * @direction: direction of the data move (Read/Write)
+ * @memory_bamk:memory bank among PMEM, DMEM, CMEM, SMEM, ATC/IO
+ * @address: address of the memory copy (byte addressing)
+ * @data: pointer to the data to transfer
+ * @nb_bytes: number of data to move
+ *
+ * Memory transfer to/from ABE to MPU
+ */
+void abe_block_copy(u32 direction, u32 memory_bank, u32 address,
+		    u32 *data, u32 nb_bytes)
+{
+	u32 i;
+	u32 base_address = 0, *src_ptr, *dst_ptr, n;
+	switch (memory_bank) {
+	case ABE_PMEM:
+		base_address = (u32) io_base + ABE_PMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_CMEM:
+		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_SMEM:
+		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_DMEM:
+		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_ATC:
+		base_address = (u32) io_base + ABE_ATC_BASE_OFFSET_MPU;
+		break;
+	default:
+		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		abe_dbg_param |= ERR_LIB;
+		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
+		break;
+	}
+	if (direction == COPY_FROM_HOST_TO_ABE) {
+		dst_ptr = (u32 *) (base_address + address);
+		src_ptr = (u32 *) data;
+	} else {
+		dst_ptr = (u32 *) data;
+		src_ptr = (u32 *) (base_address + address);
+	}
+	n = (nb_bytes / 4);
+	for (i = 0; i < n; i++)
+		*dst_ptr++ = *src_ptr++;
+}
+/**
+ * abe_reset_mem
+ *
+ * @memory_bank: memory bank among DMEM, SMEM
+ * @address: address of the memory copy (byte addressing)
+ * @nb_bytes: number of data to move
+ *
+ * Reset ABE memory
+ */
+     void abe_reset_mem(u32 memory_bank, u32 address, u32 nb_bytes)
+{
+	u32 i;
+	u32 *dst_ptr, n;
+	u32 base_address = 0;
+	switch (memory_bank) {
+	case ABE_SMEM:
+		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_DMEM:
+		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
+		break;
+	case ABE_CMEM:
+		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
+		break;
+	}
+	dst_ptr = (u32 *) (base_address + address);
+	n = (nb_bytes / 4);
+	for (i = 0; i < n; i++)
+		*dst_ptr++ = 0;
+}
+/**
+ * abe_check_activity - Check if some ABE activity.
+ *
+ * Check if any ABE ports are running.
+ * return 1: still activity on ABE
+ * return 0: no more activity on ABE. Event generator can be stopped
+ *
+ */
+u32 abe_check_activity(void)
+{
+	u32 i;
+	u32 ret;
+
+	ret = 0;
+	for (i = 0; i < (LAST_PORT_ID - 1); i++) {
+		if (abe_port[abe_port_priority[i]].status ==
+				OMAP_ABE_PORT_ACTIVITY_RUNNING)
+			break;
+	}
+	if (i < (LAST_PORT_ID - 1))
+		ret = 1;
+
+	return ret;
+}
Index: Kernel/sound/soc/omap/abe/abe_ref.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_ref.h	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/abe/abe_ref.h	2011-01-19 00:14:18.532072173 +0530
@@ -29,7 +29,7 @@
 /*
  * HAL INTERNAL AP
  */
-void abe_decide_main_port(u32 id);
+void abe_decide_main_port(void);
 void abe_gain_offset(u32 id, u32 *mixer_offset);
 void abe_int_2_float16(u32 data, u32 *mantissa, u32 *exp);
 void abe_reset_gain_mixer(u32 id, u32 p);
@@ -49,6 +49,8 @@
 void abe_init_atc(u32 id);
 void abe_init_io_tasks(u32 id, abe_data_format_t *format,
 		       abe_port_protocol_t *prot);
+void abe_enable_pp_io_task(u32 id);
+void abe_disable_pp_io_task(u32 id);
 void abe_init_dma_t(u32 id, abe_port_protocol_t *prot);
 u32 abe_dma_port_iter_factor(abe_data_format_t *f);
 u32 abe_dma_port_copy_subroutine_id(u32 i);
@@ -63,6 +65,8 @@
 void abe_irq_check_for_sequences(u32 seq_info);
 void abe_default_irq_pingpong_player(void);
 void abe_default_irq_pingpong_player_32bits(void);
+void abe_rshifted16_irq_pingpong_player_32bits(void);
+void abe_1616_irq_pingpong_player_1616bits(void);
 void abe_default_irq_aps_adaptation(void);
 void abe_irq_aps(u32 aps_info);
 void abe_clean_temporary_buffers(u32 id);
@@ -80,8 +84,10 @@
 extern const u32 abe_port_priority[LAST_PORT_ID - 1];
 extern u32 abe_compensated_mixer_gain;
 extern u8 abe_muted_gains_indicator[MAX_NBGAIN_CMEM];
-extern u32 abe_unmuted_desired_gains[MAX_NBGAIN_CMEM];
-extern u32 abe_unmuted_compensated_gains[MAX_NBGAIN_CMEM];
+extern u32 abe_desired_gains_decibel[MAX_NBGAIN_CMEM];
+extern u32 abe_muted_gains_decibel[MAX_NBGAIN_CMEM];
+extern u32 abe_desired_gains_linear[MAX_NBGAIN_CMEM];
+extern u32 abe_desired_ramp_delay_ms[MAX_NBGAIN_CMEM];
 extern u32 pdm_dl1_status;
 extern u32 pdm_dl2_status;
 extern u32 pdm_vib_status;
Index: Kernel/sound/soc/omap/abe/abe_seq.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_seq.h	2011-01-19 00:14:09.033321891 +0530
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,136 +0,0 @@
-/*
- * ALSA SoC OMAP ABE driver
- *
- * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-void abe_init_subroutine_table(void);
-/*
- * Register Programming Examples
- *
- * 1. Power on sequence
- *
- * The modules HSLDO, NCP, LSLDO, LPPLL are enabled/disabled automatically by
- * the TWL6040 power state machine after pin AUDPWRON transitions from 0 ' 1.
- * No register writes are necessary.
- *
- * For the purposes of test it is possible to bypass the power state machine
- * and manually enable these modules in the same order as described in Fig 2-XX.
- * This can be done after VIO comes up and I2C register writes are possible.
- *
- * The manual sequence could be as follows
- * LDOCTL = 0x04 (Enable HSLDO)
- * NCPCTL = 0x03 (Enable NCP in auto mode)
- * LDOCTL = 0x05 (Enable LSLDO)
- * LPPLLCTL = 0x09 (Enable LPPLL with output frequency = 19.2MHz)
- *
- * Please see Fig 2-64 for details on details to be maintained between successive
- * I2C register writes.
- *
- * Further if the system MCLK is active the HPPLL could be enabled instead of the
- * LPPLL.
- * (a) For a square wave where slicer is not required
- * HPPLLCTL = 0x11 (Select HPPLL output, Enable HPPLL)
- * (a) For a sine wave where slicer is required
- * HPPLLCTL = 0x19 (Select HPPLL output, Enable Slicer, Enable HPPLL)
- *
- */
-/*
- * 2. Setting up a stereo UPLINK path through MICAMPL, MICAMPR input amplifiers
- * AMICBCTL = 0x10
- * MICGAIN = 0x0F (Gain to 24 dB for L and R)
- * HPPLLCTL = 0x19 (Select HPPLL output, Enable Slicer, Enable HPPLL)
- * MICLCTL = 0x0D (Select MMIC input, Enable ADC)
- * MICRCTL = 0x0D (Select SMIC input, Enable ADC)
- *
- */
-/*
- * 3. Setting up a stereo headset MP3 playback DNLINK path
- * Please see section 2.3.1.1 for details
- *
- * (b) HP
- * HSGAIN = 0x22 (-4 dB gain on L and R amplifiers)
- * HSLCTL = 0x01 (Enable HSDAC L, HP mode)
- * HSRCTL = 0x01 (Enable HSDAC R, HP mode)
- * Wait 80us
- * HSLCTL = 0x05 (Enable HSLDRV, HP mode)
- * HSRCTL = 0x05 (Enable HSRDRV, HP mode)
- * Wait 2ms
- * HSLCTL = 0x25 (Close HSDACL switch)
- * HSRCTL = 0x25 (Close HSDACR switch)
- *
- */
-/*
- * (a) LP
- * HSGAIN = 0x22 (-4 dB gain on L and R amplifiers)
- * HSLCTL = 0x03 (Enable HSDAC L, LP mode)
- * HSRCTL = 0x03 (Enable HSDAC R, LP mode)
- * Wait 80us
- * HSLCTL = 0x0F (Enable HSLDRV, LP mode)
- * HSRCTL = 0x0F (Enable HSRDRV, LP mode)
- * Wait 2ms
- * HSLCTL = 0x2F (Close HSDACL switch)
- * HSRCTL = 0x2F (Close HSDACR switch)
- *
- */
-/*
- * 4. Setting up a stereo FM playback path on headset
- * (a) HP
- * LINEGAIN = 0x1B (0dB gain on L and R inputs)
- * MICLCTL = 0x02 (Enable Left LINEAMP)
- * MICRCTL = 0x02 (Enable Right LINEAMP)
- * HSGAIN = 0x22 (-4 dB gain on L and R amplifiers)
- * HSLCTL = 0x04 (Enable HSLDRV in HP mode)
- * HSRCTL = 0x04 (Enable HSRDRV in HP mode)
- * Wait 2ms
- * HSLCTL = 0x44 (Close FMLOOP switch)
- * HSRCTL = 0x44 (Close FMLOOP switch)
- *
- *
- */
-/*
- * (b) LP
- * LINEGAIN = 0x1B (0dB gain on L and R inputs)
- * MICLCTL = 0x02 (Enable Left LINEAMP)
- * MICRCTL = 0x02 (Enable Right LINEAMP)
- * HSGAIN = 0x22 (-4 dB gain on L and R amplifiers)
- * HSLCTL = 0x0C (Enable HSLDRV in LP mode)
- * HSRCTL = 0x0C (Enable HSRDRV in LP mode)
- * Wait 2ms
- * HSLCTL = 0x4C (Close FMLOOP switch)
- * HSRCTL = 0x4C (Close FMLOOP switch)
- *
- */
-/*
- * 5. Setting up a handset call
- *
- * UPLINK
- *
- * AMICBCTL = 0x10
- * MICGAIN = 0x0F (Gain to 24 dB for L and R)
- * HPPLLCTL = 0x19 (Select HPPLL output, Enable Slicer, Enable HPPLL)
- * MICLCTL = 0x0D (Select MMIC input, Enable ADC)
- * MICRCTL = 0x0D (Select SMIC input, Enable ADC)
- *
- * DNLINK
- *
- * HSLCTL = 0x01 (Enable HSDACL, HP mode)
- * Wait 80us
- * EARCTL = 0x03 (Enable EAR, Gain = min, by default enabling EAR connects
- * HSDACL output to EAR)
- *
- */
Index: Kernel/sound/soc/omap/abe/abe_sys.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/abe_sys.h	2011-01-19 00:14:09.033321891 +0530
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-/*
- * ALSA SoC OMAP ABE driver
- *
- * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
Index: Kernel/sound/soc/omap/abe/c_abe_fw_size.h
===================================================================
--- Kernel.orig/sound/soc/omap/abe/c_abe_fw_size.h	2011-01-19 00:14:09.033321891 +0530
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-/*
-        FW 05.10  MEMORY SIZES
-*/
-#define ABE_DMEM_SIZE_OPTIMIZED 16384
-#define ABE_SMEM_SIZE_OPTIMIZED 15360
-#define ABE_CMEM_SIZE_OPTIMIZED 6552
Index: Kernel/sound/soc/omap/omap-abe-dsp.c
===================================================================
--- Kernel.orig/sound/soc/omap/omap-abe-dsp.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/omap-abe-dsp.c	2011-01-19 00:14:18.532072173 +0530
@@ -1706,7 +1706,8 @@
 	format.f = params_rate(params);
 	format.samp_format = STEREO_16_16;
 
-	abe_write_event_generator(EVENT_44100);
+	if (format.f == 44100)
+		abe_write_event_generator(EVENT_44100);
 
 	/*Adding ping pong buffer subroutine*/
 	abe_add_subroutine(&abe_irq_pingpong_player_id,
@@ -1725,6 +1726,9 @@
 	runtime->dma_addr  = 0;
 	runtime->dma_bytes = N_SAMPLES_BYTES * 2;
 
+	/* Need to set the first buffer in order to get interrupt */
+	abe_set_ping_pong_buffer(MM_DL_PORT, N_SAMPLES_BYTES);
+
 	return 0;
 }
 
@@ -1817,7 +1821,7 @@
 	snd_pcm_uframes_t offset;
 	u32 pingpong;
 
-	abe_read_offset_ping_pong_buffer(MM_DL_PORT, &pingpong);
+	abe_read_offset_from_ping_buffer(MM_DL_PORT, &pingpong);
 	offset = (snd_pcm_uframes_t)pingpong;
 /*
 	if (offset >= runtime->buffer_size)
Index: Kernel/sound/soc/omap/omap-abe.c
===================================================================
--- Kernel.orig/sound/soc/omap/omap-abe.c	2011-01-19 00:14:09.033321891 +0530
+++ Kernel/sound/soc/omap/omap-abe.c	2011-01-19 00:14:18.532072173 +0530
@@ -1150,7 +1150,7 @@
 			abe_enable_data_transfer(MM_UL_PORT);
 		break;
 	case ABE_FRONTEND_DAI_LP_MEDIA:
-		abe_enable_irq_transfer(MM_DL_PORT);
+		abe_enable_data_transfer(MM_DL_PORT);
 		break;
 	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:
 		if (stream == SNDRV_PCM_STREAM_CAPTURE)
@@ -1283,7 +1283,7 @@
 			abe_disable_data_transfer(MM_UL_PORT);
 		break;
 	case ABE_FRONTEND_DAI_LP_MEDIA:
-		abe_disable_irq_transfer(MM_DL_PORT);
+		abe_disable_data_transfer(MM_DL_PORT);
 		break;
 	case ABE_FRONTEND_DAI_MEDIA_CAPTURE:
 		if (stream == SNDRV_PCM_STREAM_CAPTURE)
@@ -1651,7 +1651,7 @@
 			.stream_name = "MultiMedia1 LP Playback",
 			.channels_min = 2,
 			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_44100,
+			.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
 			.formats = OMAP_ABE_FORMATS | SNDRV_PCM_FMTBIT_S16_LE,
 		},
 		.ops = &omap_abe_dai_ops,
