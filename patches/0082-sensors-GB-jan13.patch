Index: Kernel-org/arch/arm/configs/android_omap4tab_rev05_defconfig
===================================================================
--- Kernel-org.orig/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-01-24 14:38:37.680273724 +0530
+++ Kernel-org/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-01-24 14:54:58.007775405 +0530
@@ -803,7 +803,9 @@
 CONFIG_OPTICAL_GP2A=y
 CONFIG_ACCEL=y
 CONFIG_ACCEL_KXSD9=y
-# CONFIG_COMPASS is not set
+CONFIG_COMPASS=y
+# CONFIG_COMPASS_AK8973B is not set
+CONFIG_COMPASS_YAS530=y
 CONFIG_GYRO=y
 CONFIG_GYRO_MPU3050=y
 CONFIG_MISC_DEVICES=y
Index: Kernel-org/drivers/sensors/accel/kxsd9.c
===================================================================
--- Kernel-org.orig/drivers/sensors/accel/kxsd9.c	2011-01-24 14:38:37.680273724 +0530
+++ Kernel-org/drivers/sensors/accel/kxsd9.c	2011-01-24 14:39:30.170275460 +0530
@@ -42,6 +42,22 @@
 #define KXSD9_DUMP   0
 
 
+struct kxsd9 *kxsd9;
+static struct input_dev *kxsd9_input_dev;
+
+// Used globally in current driver.
+static int kxsd9_timeout = -1;
+
+// Used in suspend/resume in current driver.
+static int timeout_at_suspend = -1;
+static int shutdown_at_suspend = 0;
+
+// Workqueue related definitions
+static struct workqueue_struct *kxsd9_work_q;
+static struct delayed_work kxsd9_delayed_work_q;
+
+#if 0
+
 struct kxsd9_seq {
 	int len;
 	unsigned char *data;
@@ -59,14 +75,19 @@
 static ktime_t kxsd9_poll_time = {.tv.nsec =  100 * NSEC_PER_MSEC };
 static ktime_t kxsd9_seq_time = {.tv.nsec =  5 * NSEC_PER_MSEC };
 
-struct kxsd9 *kxsd9;
+static enum hrtimer_restart kxsd9_poll_timer(struct hrtimer *timer)
+{
+	struct kxsd9 *kxsd9;
 
-static struct input_dev *kxsd9_input_dev;
+	kxsd9 = container_of(timer, struct kxsd9, timer);
 
-int kxsd9_timeout = -1;
+#ifdef CONFIG_ANDROID_POWER
+	android_lock_suspend(&kxsd9->suspend_lock);
+#endif
 
-static struct workqueue_struct *kxsd9_work_q;
-static struct delayed_work kxsd9_delayed_work_q;
+	schedule_work(&kxsd9->work.work);
+	return HRTIMER_NORESTART;
+}
 
 int kxsd9_enable(struct kxsd9 *kxsd9,int on)
 {
@@ -86,8 +107,10 @@
 	return 0;
 }
 
-static int kxsd9_i2c_read(struct i2c_client *client, unsigned id,
-						char *buf, int len)
+#endif
+
+
+static int kxsd9_i2c_read(struct i2c_client *client, unsigned id, char *buf, int len)
 {
 	int r;
 	char outbuffer[2] = { 0, 0 };
@@ -112,18 +135,26 @@
 	return 0;
 }
 
-static enum hrtimer_restart kxsd9_poll_timer(struct hrtimer *timer)
+static int kxsd9_i2c_write(struct i2c_client *client, unsigned id, char *buf)
 {
-	struct kxsd9 *kxsd9;
+	int r;
+	char outbuffer[2] = { 0, 0 };
 
-	kxsd9 = container_of(timer, struct kxsd9, timer);
+	outbuffer[0] = id ;
+	outbuffer[1] = *buf ;
 
-#ifdef CONFIG_ANDROID_POWER
-	android_lock_suspend(&kxsd9->suspend_lock);
-#endif
+	printk("writing data=%02x at address %02x\n", outbuffer[1], outbuffer[0] );
 
-	schedule_work(&kxsd9->work.work);
-	return HRTIMER_NORESTART;
+
+	r = i2c_master_send(client, outbuffer, 2);
+	if (r < 0) {
+		printk(KERN_WARNING "%s: error writing gsensor data at "
+			"address %02x,%02x: %d\n",
+			__func__, client->addr, id, r);
+		return r;
+	}
+
+	return 0;
 }
 
 int kxsd9_read_accel_xyz(struct kxsd9 *kxsd9, kxsd9acc_t * acc)
@@ -152,68 +183,23 @@
 	acc->x = y;
 	acc->y = x;
 	acc->z = z;
+
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
+	acc->x = y;
+	acc->y = -x;
+	acc->z = z;
 #endif
 
 #if KXSD9_DEBUG
 	printk("X:%d, Y:%d, Z:%d\n", acc->x, acc->y, acc->z);
 #endif
 
-	//input_report_abs(kxsd9_input_dev, ABS_X, acc->x );
-	//input_report_abs(kxsd9_input_dev, ABS_Y, acc->y );
-	//input_report_abs(kxsd9_input_dev, ABS_Z, acc->z );
-
-	//input_sync(kxsd9_input_dev);
-
 	return err;
 }
 
 struct class *acc_class;
 
 
-static int kxsd9_remove(struct i2c_client * client)
-{
-	struct kxsd9 *kxsd9 = i2c_get_clientdata(client);
-	unregister_early_suspend(&kxsd9->kxsd9_early_suspend);
-	input_unregister_device(kxsd9->inputdev);
-	input_free_device(kxsd9->inputdev);
-
-#ifdef CONFIG_ANDROID_POWER
-	android_uninit_suspend_lock(&kxsd9->suspend_lock);	
-#endif
-	
-	kfree(kxsd9);
-	return 0;
-}
-
-#if CONFIG_PM
-static int kxsd9_suspend(struct i2c_client * client, pm_message_t mesg)
-{
-#if KXSD9_DEBUG
-	printk(KERN_INFO MODULE_NAME ": suspending device...\n");
-#endif
-	kxsd9_timeout =-1;
-	flush_workqueue(kxsd9_work_q);
-        cancel_delayed_work(&kxsd9_delayed_work_q);
-	return 0;
-}
-
-static int kxsd9_resume(struct i2c_client * client)
-{
-#if KXSD9_DEBUG
-	printk(KERN_INFO MODULE_NAME ": resuming device...\n");
-#endif
-	if(kxsd9_timeout < 0){
-			kxsd9_timeout=msecs_to_jiffies(200);
-			}
-	queue_delayed_work(kxsd9_work_q, &kxsd9_delayed_work_q, kxsd9_timeout);
-	return 0;
-}
-#else
-#define kxsd9_suspend NULL
-#define kxsd9_resume NULL
-#endif
-
-
 int kxsd9_open (struct inode *inode, struct file *filp)
 {
 	return 0;
@@ -237,12 +223,23 @@
 void kxsd9_set_operation_mode(u8 mode)
 {
 
+	int ret;
+	char tmp_buf;
+
 	switch(mode)
 	{
 		//POWER_UP
 		case 1 : 
 		{	
 			printk("KXSD9 Power-up\n");
+
+			// Put KXSD9 in ON-mode
+			tmp_buf = 0x40;
+			ret = kxsd9_i2c_write(kxsd9->client, KXSD9_CTRL_REGB , &tmp_buf);
+			if(ret<0) {
+				printk("KXSD9 : POWER ON FAILED!!!! ret = %d\n", ret);
+			}
+
 			if(kxsd9_timeout < 0)
 			{
 				kxsd9_timeout=msecs_to_jiffies(200);
@@ -256,8 +253,14 @@
 		case 0 :
 		{
 			printk("KXSD( Power-down\n");
-			kxsd9_timeout=-1;
+			kxsd9_timeout =-1;
 			flush_workqueue(kxsd9_work_q);
+		        cancel_delayed_work(&kxsd9_delayed_work_q);
+
+			// Put KXSD9 in standby-mode
+			tmp_buf = 0x00;
+			ret = kxsd9_i2c_write(kxsd9->client, KXSD9_CTRL_REGB , &tmp_buf);
+
 			break;
 		}
 
@@ -267,7 +270,6 @@
 
 static int kxsd9_work(void)
 {
-	u8 lux_value;
 	int ret =0;
 
 	kxsd9acc_t data;
@@ -305,7 +307,7 @@
 
 static ssize_t poll_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	int64_t delay_to_report;
+	long int delay_to_report;
 	
 	if (kxsd9_timeout<0)
 	{
@@ -313,35 +315,37 @@
 	}
 	else
 	{
-		delay_to_report = (int64_t)jiffies_to_msecs(kxsd9_timeout);
+		// millisecs to nanosecs
+		delay_to_report = jiffies_to_msecs(kxsd9_timeout*1000000);
 	}
 
 #if KXSD9_DEBUG
-	printk("delay_to_report=%lld\n", delay_to_report );
+	printk("delay_to_report=%ld\n", delay_to_report );
 #endif
-	return snprintf(buf, PAGE_SIZE, "%lld\n", delay_to_report);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", delay_to_report);
 }
 
 
 static ssize_t poll_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
 	int err;
-	int64_t new_delay;
+	long int new_delay;
 
 #if KXSD9_DEBUG
 	printk("buf=%s\n", buf);
 	printk("size=%u\n", size);
 #endif
 
-	err = strict_strtoll(buf, 10, &new_delay);
+	err = strict_strtol(buf, 10, &new_delay);
 	if ( err < 0 )
 		return err;
 
-	kxsd9_timeout = msecs_to_jiffies(200);
+	// nanosecs to millisecs
+	kxsd9_timeout = msecs_to_jiffies(new_delay/1000000);
 
 
 #ifdef KXSD9_DEBUG
-	printk("poll_delay_store called. new_delay=%lld\n", new_delay);
+	printk("poll_delay_store called. new_delay=%ld\n", new_delay);
 	printk("poll_delay_store called. kxsd9_timeout=%d\n", kxsd9_timeout);
 #endif
 	return size;
@@ -382,7 +386,7 @@
 		kxsd9_set_operation_mode(0);
 	}
 
-	(ret < 0) ? NULL : (ret = size) ;
+	(ret < 0) ? (int)NULL : (ret = (int)size) ;
 
 	return ret;
 }
@@ -412,6 +416,57 @@
 /*****************************************************************/
 
 
+#if CONFIG_PM
+
+static int kxsd9_suspend(struct i2c_client * client, pm_message_t mesg)
+{
+
+	if (kxsd9_timeout > -1) {
+
+		#if KXSD9_DEBUG
+		printk(KERN_INFO MODULE_NAME ": suspending device...\n");
+		#endif
+
+		// Preserve the current kxsd9_timeout value
+		// This is needed to re-initialise the workqueue
+		// at the same poll_delay rate after resuming.
+		timeout_at_suspend = kxsd9_timeout;
+
+		kxsd9_set_operation_mode(0);
+		shutdown_at_suspend = 1;
+	}
+	else {
+			shutdown_at_suspend = 0;
+	}
+
+	return 0;
+}
+
+static int kxsd9_resume(struct i2c_client * client)
+{
+
+	if (shutdown_at_suspend) {
+
+		#if KXSD9_DEBUG
+		printk(KERN_INFO MODULE_NAME ": resuming device...\n");
+		#endif
+
+		shutdown_at_suspend = 0;
+
+		kxsd9_timeout = timeout_at_suspend;
+		kxsd9_set_operation_mode(1);
+	}
+	return 0;
+}
+
+#else
+
+#define kxsd9_suspend NULL
+#define kxsd9_resume NULL
+
+#endif
+
+
 int kxsd9_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,  unsigned long arg)
 {
 	int err = 0;
@@ -508,8 +563,6 @@
 
 	struct device *dev_t;
 
-	kxsd9acc_t accels;
-
 #if KXSD9_DEBUG
 	printk("Initializing Kionix KXSD9 driver "
 		"at addr: 0x%02x\n", client->addr);
@@ -582,7 +635,6 @@
 	//Workqueue Initialisation
 	kxsd9_work_q = create_singlethread_workqueue("accel_sensor_kxsd9_work_queue");
 	INIT_DELAYED_WORK( (struct delayed_work *)&kxsd9_delayed_work_q, kxsd9_work);
-        //kxsd9_read_accel_xyz(kxsd9, &accels );
 
 	return 0;
 
@@ -591,6 +643,22 @@
 	return result;
 }
 
+
+static int kxsd9_remove(struct i2c_client * client)
+{
+	struct kxsd9 *kxsd9 = i2c_get_clientdata(client);
+	unregister_early_suspend(&kxsd9->kxsd9_early_suspend);
+	input_unregister_device(kxsd9->inputdev);
+	input_free_device(kxsd9->inputdev);
+
+#ifdef CONFIG_ANDROID_POWER
+	android_uninit_suspend_lock(&kxsd9->suspend_lock);	
+#endif
+	
+	kfree(kxsd9);
+	return 0;
+}
+
 static const struct i2c_device_id kxsd9_ids[] = {
         { MODULE_NAME, 0 },
         { },
@@ -606,8 +674,8 @@
 	.probe = kxsd9_probe,
 	.remove = kxsd9_remove,
 #if CONFIG_PM
-	.suspend = kxsd9_suspend,
-	.resume = kxsd9_resume,
+//	.suspend = kxsd9_suspend,
+//	.resume = kxsd9_resume,
 #endif
 };
 
Index: Kernel-org/drivers/sensors/gyro-mpu3050/mpu3050.c
===================================================================
--- Kernel-org.orig/drivers/sensors/gyro-mpu3050/mpu3050.c	2011-01-24 14:38:37.680273724 +0530
+++ Kernel-org/drivers/sensors/gyro-mpu3050/mpu3050.c	2011-01-24 14:39:30.170275460 +0530
@@ -22,8 +22,13 @@
 static struct workqueue_struct *mpu3050_work_q;
 static struct delayed_work mpu3050_delayed_work_q;
 
-int mpu3050_timeout = -1;
-static atomic_t is_true_suspend =ATOMIC_INIT(0);
+// Used globally in current driver.
+static int mpu3050_timeout = -1;
+
+// Used in suspend/resume in current driver.
+static int timeout_at_suspend = -1;
+static int shutdown_at_suspend = 0;
+
 int mpu3050_i2c_read( u8 reg, u8 *rdata , int length) //Read from register "reg", in buffer "rdata","length" number of bytes
 {
 	int count =0;
@@ -115,6 +120,10 @@
 			ret = -EFAULT;
 			printk("Error in mpu3050_set_operation_mode: MPU3050_PWR_MGMNT\n");
 		}
+
+		mpu3050_timeout =-1;
+		flush_workqueue(mpu3050_work_q);
+	        cancel_delayed_work(&mpu3050_delayed_work_q);
 	}
 
 	//Power-ON
@@ -139,6 +148,17 @@
 			ret = -EFAULT;
 			printk("Error in mpu3050_set_operation_mode: MPU3050_DLPF_FS_SYNC\n");
 		}
+
+
+		// If poll_delay not set,
+		// initialise it to default value 200ms
+		if (mpu3050_timeout == -1) {
+			mpu3050_timeout = msecs_to_jiffies(200);
+		}
+
+		//start the polling workqueue
+		queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
+
 	}
 
 	return ret;
@@ -172,6 +192,7 @@
 	return ret;
 }
 
+#if 0
 static int mpu3050_set_interrupt_config(u8 interrupt_mode)
 {
 	u8 interrupt = 0;
@@ -193,7 +214,7 @@
 
 	return (ret);
 }
-
+#endif
 
 static int mpu3050_work(void)
 {
@@ -228,8 +249,6 @@
 	int ret =0;
 	void __user *argp = (void __user*)arg;
 	
-	u16 gyro_xyz[3];
-	
 	if(_IOC_TYPE(ioctl_cmd) != MPU3050_GYRO_IOC_MAGIC)
 	{
 		printk("mpu3050 cmd magic type error\n");
@@ -265,28 +284,15 @@
 				printk(KERN_ERR"Copy_from_user failed\n");
 				return (-EFAULT);
 			}
-			printk("\n\nmpu3050 mode==%x\n\n",mode);
-		
-			// Power-OFF mode
-			if( mode == GYRO_POWER_OFF)
-			{
-				printk("Gyro[mpu3050] Power-OFF\n");
-				mpu3050_timeout = -1;
-				flush_workqueue(mpu3050_work_q);
-				ret = mpu3050_set_operation_mode(mode);
-			}
-			// Power-ON mode;
-			// delay need to be set and work need to be done
-			else if ( mode == GYRO_POWER_ON)
-			{
-				ret = mpu3050_set_operation_mode(mode);
-				printk("Gyro[mpu3050] Power-ON\n");
-				mpu3050_timeout = msecs_to_jiffies(200);
-				queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
-			}
 
-			if( ret < 0 )
-			{
+			#if MPU3050_DEBUG
+				printk("\n\nmpu3050 mode==%x\n\n",mode);
+			#endif		
+
+			// mode is either GYRO_POWER_OFF or GYRO_POWER_ON
+			ret = mpu3050_set_operation_mode(mode);
+
+			if( ret < 0 ) {
 				printk("mpu3050: set_operation_mode Failed\n");
 				return (-EFAULT);			
 			}
@@ -307,7 +313,7 @@
 
 			else
 			{
-				mpu3050_timeout = msecs_to_jiffies(50+delay);
+				mpu3050_timeout = msecs_to_jiffies(delay);
 				printk("mpu3050 polling delay=%d\n", mpu3050_timeout);
 			}
 
@@ -326,7 +332,7 @@
 /***********************Sysfs Interface *********************************/
 static ssize_t poll_delay_show( struct device *dev, struct device_attribute *attr, char *buf)
 {
-        int delay_to_report;
+        long int delay_to_report;
 
         if (mpu3050_timeout<0)
         {
@@ -334,40 +340,46 @@
         }
         else
         {
-                delay_to_report = jiffies_to_msecs(mpu3050_timeout);
+                delay_to_report = jiffies_to_msecs(mpu3050_timeout*1000000);
         }
 
-        printk("delay_to_report=%d\n", delay_to_report );
+#ifdef MPU3050_DEBUG
+        printk("delay_to_report=%ld\n", delay_to_report );
+#endif
 
-        return snprintf(buf, PAGE_SIZE, "%d\n", delay_to_report);
+        return snprintf(buf, PAGE_SIZE, "%ld\n", delay_to_report);
 }
 
 
 static ssize_t poll_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
         int err;
-        int new_delay;
-
+        long int new_delay;
 
+#ifdef MPU3050_DEBUG
         printk("buf=%s\n", buf);
         printk("size=%u\n", size);
+#endif
 
         err = strict_strtol(buf, 10, &new_delay);
         if ( err < 0 )
                 return err;
 
-	//mpu3050_timeout = msecs_to_jiffies(new_delay);
-	mpu3050_timeout = msecs_to_jiffies(200);
-
+	mpu3050_timeout = msecs_to_jiffies(new_delay/1000000);
+	
 #ifdef MPU3050_DEBUG
-        printk("poll_delay_store called. new_delay=%d\n", new_delay);
+        printk("poll_delay_store called. new_delay=%ld\n", new_delay);
         printk("poll_delay_store called. mpu3050_timeout=%d\n", mpu3050_timeout);
 #endif
         return size;
 }
 static ssize_t gyro_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
+
+#ifdef MPU3050_DEBUG
         printk("enabled=%d\n", ((mpu3050_timeout < 0) ? 0 : 1) );
+#endif
+
         return snprintf(buf, PAGE_SIZE, "%d\n", ((mpu3050_timeout < 0) ? 0 : 1) );
 }
 
@@ -386,7 +398,9 @@
                 return -EINVAL;
         }
 
+#ifdef MPU3050_DEBUG
         printk("new_value = %d, old state = %d\n", new_value, ((mpu3050_timeout < 0) ? 0 : 1) );
+#endif
         if (new_value && (mpu3050_timeout < 0) ) {
 
                 ret = mpu3050_set_operation_mode(GYRO_POWER_ON);
@@ -395,28 +409,16 @@
                         ret = -EINVAL;
                 }
 
-		// If poll_delay not set,
-		// initialise it to default value 200ms
-		if (mpu3050_timeout == -1) {
-			mpu3050_timeout = msecs_to_jiffies(200);
-		}
-
-		//start the polling workqueue
-		queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
-
         } else if (!new_value && (mpu3050_timeout > -1) ) {
+
                 ret = mpu3050_set_operation_mode(GYRO_POWER_OFF);
                 if (ret < 0) {
                         printk("GYRO POWER_DOWN failed!!\n");
                         ret = -EINVAL;
                 }
-
-		//stop the polling workqueue
-		mpu3050_timeout = -1;
-		flush_workqueue(mpu3050_work_q);
         }
 
-        (ret < 0) ? NULL : (ret = size) ;
+        (ret < 0) ? (int)NULL : (ret = size) ;
 
         return ret;
 }
@@ -454,42 +456,52 @@
 #if CONFIG_PM
 static int mpu3050_suspend(struct i2c_client * client, pm_message_t mesg)
 {
+	int ret = 0;
+
         #ifdef MPU3050_DEBUG
         printk(KERN_INFO MODULE_NAME ": suspending device...\n");
         #endif
-	  int ret =-1;
-	mpu3050_timeout =-1;
-        atomic_set(&is_true_suspend,1);
-        printk(KERN_ERR MODULE_NAME ": suspending device...\n");
-        flush_workqueue(mpu3050_work_q);
-        cancel_delayed_work(&mpu3050_delayed_work_q);
-	 if((ret = mpu3050_i2c_write( MPU3050_PWR_MGMNT, GYRO_MODE_STANDBY )) < 0){
-                        ret = -EFAULT;
-                        printk("Error in Suspending Gyro Device:GYRO_MODE_STANDBY\n");
+
+	if(mpu3050_timeout > -1) {
+
+		shutdown_at_suspend = 1;
+		timeout_at_suspend = mpu3050_timeout;
+
+                ret = mpu3050_set_operation_mode(GYRO_POWER_OFF);
+                if (ret < 0) {
+                        printk("GYRO POWER_OFF failed!!\n");
+                        ret = -EINVAL;
                 }
 
-        return 0;
+	}
+	else {
+		shutdown_at_suspend = 0;
+	}
 
+        return 0;
 }
 
 static int mpu3050_resume(struct i2c_client * client)
 {
-	int ret=-1;
-        #ifdef MPU3050_DEBUG
-        printk(KERN_INFO MODULE_NAME ": resuming device...\n");
-        #endif
-	 if(atomic_read(&is_true_suspend)){
-                printk(KERN_INFO MODULE_NAME ": resuming device...\n");
-                if((ret = mpu3050_set_operation_mode(GYRO_POWER_ON))<0){
-                                ret = -EFAULT;
-                                printk("MPU3050:resuming :Error in Resuming Gyro Device\n");
-                        }
-                if(mpu3050_timeout < 0){
-                                mpu3050_timeout=msecs_to_jiffies(200);
-                        }
-                queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
-        }
-        return 0;
+	int ret = 0;
+
+	if (shutdown_at_suspend) {
+
+		#if MPU3050_DEBUG
+		printk(KERN_INFO MODULE_NAME ": resuming device...\n");
+		#endif
+
+		shutdown_at_suspend = 0;
+
+		mpu3050_timeout = timeout_at_suspend;
+                ret = mpu3050_set_operation_mode(GYRO_POWER_ON);
+                if (ret < 0) {
+                        printk("GYRO POWER_ON failed!!\n");
+                        ret = -EINVAL;
+                }
+	}
+
+	return ret;
 }
 #else
 
@@ -503,7 +515,6 @@
 {
 	int ret = 0;
 	int result_gyro=-1;
-	u16 gyro_xyz[3];
 
 	struct device *dev_gyro;
 	mpu3050_client = client;
@@ -592,18 +603,6 @@
         mpu3050_dev->mpu3050_early_suspend.resume = mpu3050_resume;
         register_early_suspend(&mpu3050_dev->mpu3050_early_suspend);
 
-	#ifdef MPU3050_DEBUG
-	// Initializing the device;
-	// MPU-3050 is being used as gyrosensor only (i.e. in pass-thru mode)
-	if((ret = mpu3050_set_operation_mode(GYRO_POWER_ON))<0)
-	{
-		printk("mpu3050_set_operation_mode failed");
-		ret = -EFAULT;
-	}
-		msleep(1000);
-		mpu3050_read_gyro_xyz(gyro_xyz);
-		printk("mpu3050\n x=%hi y=%hi z=%hi\n", gyro_xyz[0], gyro_xyz[1], gyro_xyz[2]);
-	#endif
 
 release_input_dev:
 	input_free_device(gyro_input);
Index: Kernel-org/drivers/sensors/optical/gp2a.c
===================================================================
--- Kernel-org.orig/drivers/sensors/optical/gp2a.c	2011-01-24 14:38:37.680273724 +0530
+++ Kernel-org/drivers/sensors/optical/gp2a.c	2011-01-24 14:55:25.677780599 +0530
@@ -1,440 +1,292 @@
-#include<asm/uaccess.h>
-#include<asm/mach-types.h>
-#include<asm/atomic.h>
-#include<linux/module.h>
-#include<linux/init.h>
-#include<linux/input.h>
-#include<linux/i2c.h>
-#include<linux/hrtimer.h>
-#include<linux/delay.h>
-#include<linux/workqueue.h>
+/* linux/driver/input/misc/gp2a.c
+ * Copyright (C) 2010 Samsung Electronics. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/wakelock.h>
 #include <linux/slab.h>
-#include<linux/gpio.h>
-#include <linux/i2c/twl6030-gpadc.h>
-#include<linux/earlysuspend.h>
-#define MODULE_NAME "gp2a"
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/uaccess.h>
+#include <linux/gp2a.h>
+
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4 )
+#define OMAP4TAB_GP2A_PS_ON				35
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5 )
+#define OMAP4TAB_GP2A_PS_ON				37
+#endif
+
+/* Note about power vs enable/disable:
+ *  The chip has two functions, proximity and ambient light sensing.
+ *  There is no separate power enablement to the two functions (unlike
+ *  the Capella CM3602/3623).
+ *  This module implements two drivers: /dev/proximity and /dev/light.
+ *  When either driver is enabled (via sysfs attributes), we give power
+ *  to the chip.  When both are disabled, we remove power from the chip.
+ *  In suspend, we remove power if light is disabled but not if proximity is
+ *  enabled (proximity is allowed to wakeup from suspend).
+ *
+ *  There are no ioctls for either driver interfaces.  Output is via
+ *  input device framework and control via sysfs attributes.
+ */
 
 #if 0
-#define GP2A_DEBUG
+#define gp2a_dbgmsg(str, args...) pr_debug("%s: " str, __func__, ##args)
+#else
+#define gp2a_dbgmsg(str, args...) printk("%s: " str, __func__, ##args)
 #endif
 
-//Register-Addresses.
-#define REG_PROX	0x00
-#define REG_GAIN	0x01
-#define	REG_HYS		0x02
-#define REG_CYCLE	0x03
-#define REG_OPMOD	0x04
-#define REG_CON		0x06
-
-#define LIGHT_DEV_NAME "lightsensor"
-
-//Different Modes
-#define POWER_UP 			0
-#define POWER_DOWN 			1
-#define NORMAL_MODE 			2
-#define INTERRUPT_MODE 			3
-
-#define GP2A_LIGHT_IOC_MAGIC 				221
-#define GP2A_LIGHT_IOC_MAGIC_NR_MAX 			4
-
-#define GP2A_LIGHT_IOC_SET_OPERATION_MODE         		_IOW(GP2A_LIGHT_IOC_MAGIC, 0,u8)
-#define GP2A_LIGHT_IOC_GET_OPERATION_MODE         		_IOR(GP2A_LIGHT_IOC_MAGIC, 1,u8)
-#define GP2A_LIGHT_IOC_GET_LUX_VALUE				_IOR(GP2A_LIGHT_IOC_MAGIC,2,u8)
-#define GP2A_LIGHT_IOC_SET_POLL_DELAY				_IOW(GP2A_LIGHT_IOC_MAGIC,3,u16)
-
-
-#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
-#define OMAP4TAB_PS_ON_GPIO                            35
-#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
-#define OMAP4TAB_PS_ON_GPIO                            37
-#endif
+#define ADC_BUFFER_NUM	6
 
-static unsigned gp2a_ps_on_gpio;
-struct gp2a_dev
-{
-struct i2c_client *client;
-struct input_dev *inputdev;
-struct mutex lock;
-struct early_suspend gp2a_early_suspend;
+/* ADDSEL is LOW */
+#define REGS_PROX		0x0 /* Read  Only */
+#define REGS_GAIN		0x1 /* Write Only */
+#define REGS_HYS		0x2 /* Write Only */
+#define REGS_CYCLE		0x3 /* Write Only */
+#define REGS_OPMOD		0x4 /* Write Only */
+
+/* sensor type */
+#define LIGHT           0
+#define PROXIMITY	1
+#define ALL		2
+
+static u8 reg_defaults[5] = {
+	0x00, /* PROX: read only register */
+	0x08, /* GAIN: large LED drive level */
+	0xC2, /* HYS: receiver sensitivity */
+	0x04, /* CYCLE: */
+	0x01, /* OPMOD: normal operating mode */
 };
 
-static struct twl6030_gpadc_request conv_request = {
-        .channels = (0x1 << 3),
-        .do_avg = 0,
-	.method = TWL6030_GPADC_SW2,
-	.type = 0,
-	.active = 0,
-	.result_pending = 0,
-	.func_cb = NULL,
+struct gp2a_data;
 
+enum {
+	LIGHT_ENABLED = BIT(0),
+	PROXIMITY_ENABLED = BIT(1),
 };
 
-static struct i2c_client* gp2a_client;
-struct gp2a_dev *gp2a_dev;
-struct class *light_class;
-
-struct input_dev *light_input;
-struct input_dev *proximity_input;
-
-static struct workqueue_struct *gp2a_work_q;
-static struct delayed_work gp2a_delayed_work_q;
-
-int gp2a_timeout = -1;
-static int gp2a_initialize_register(u8 mode);
-static atomic_t is_true_suspend =ATOMIC_INIT(0);
-// GP2A has different i2c_read.
-// The register address and the buffer (in which data is to be read)
-// must go in one single "i2c_transfer"
-int gp2a_i2c_read( u8 reg, u8 *rdata) //Read from register "reg", in buffer "rdata"
+/* driver data */
+struct gp2a_data {
+	struct input_dev *proximity_input_dev;
+	struct input_dev *light_input_dev;
+	struct gp2a_platform_data *pdata;
+	struct i2c_client *i2c_client;
+	int irq;
+	struct work_struct work_light;
+	struct hrtimer timer;
+	ktime_t light_poll_delay;
+	int adc_value_buf[ADC_BUFFER_NUM];
+	int adc_index_count;
+	bool adc_buf_initialized;
+	bool on;
+	u8 power_state;
+	struct mutex power_lock;
+	struct wake_lock prx_wake_lock;
+	struct workqueue_struct *wq;
+};
+
+int gp2a_i2c_write(struct gp2a_data *gp2a, u8 reg, u8 *val)
 {
-	int count =0;
-	int ret =0;
+	int err = 0;
 	struct i2c_msg msg[1];
-	u8 data[2]={0,0};
-	data[0]=reg;
-	
-	msg[0].addr = gp2a_client->addr;
-	msg[0].flags=I2C_M_RD;
-	msg[0].len=2;
-	msg[0].buf=data;
-	
-	count = i2c_transfer(gp2a_client->adapter, msg, 1);
-	*rdata=data[1];
-	#ifdef GP2A_DEBUG
-	printk("Count in gp2a_i2c_read:%d\n",count);
-	#endif
+	unsigned char data[2];
+	int retry = 10;
+	struct i2c_client *client = gp2a->i2c_client;
 
-	if(count !=1)
-		ret= -1;
-	return ret;
-}
+	if ((client == NULL) || (!client->adapter))
+		return -ENODEV;
 
+	while (retry--) {
+		data[0] = reg;
+		data[1] = *val;
 
-int gp2a_i2c_write(u8 reg, u8 value)
-{
-	u8 data[2];
-	int ret =0, count=0;
-	struct i2c_msg msg[1];
+		msg->addr = client->addr;
+		msg->flags = 0; /* write */
+		msg->len = 2;
+		msg->buf = data;
 
-	data[0]=reg;
-	data[1]=value;
+		err = i2c_transfer(client->adapter, msg, 1);
 
-	msg[0].addr = gp2a_client->addr;
-	msg[0].flags=0;
-	msg[0].len=2;
-	msg[0].buf=data;
-
-	count = i2c_transfer(gp2a_client->adapter, msg, 1);
-	if(count !=1){
-		ret = -1;
+		if (err >= 0)
+			return 0;
 	}
-	return ret;
+	return err;
 }
 
-
-
-
-
-static int gp2a_get_lux_value(u8 *lux_value)
+static void gp2a_light_enable(struct gp2a_data *gp2a)
 {
-#ifdef GP2A_DEBUG
-	printk("gp2a_read_lux_value called\n");
-#endif
-
-	int ret=-1;
-	unsigned int als_out;
-	
-	ret = gp2a_i2c_read(REG_PROX,lux_value);
-	if(ret <0){
-		printk("gp2a_i2c_read failed !!\n");
-	}
-
-	// Proximity bit is LSB of the data-byte.
-	// Discard remaining 7 bits
-	// NOTE: Proximity = 0 in "near" state, 1 in "far" state.
-	*lux_value = !((*lux_value )& 0x01);
-
-	// Ambient Light sensing
-        twl6030_gpadc_conversion(&conv_request);
-	als_out = conv_request.rbuf[3];
-
-
-#ifdef GP2A_DEBUG
-	printk("gp2a: ALS_OUT=%u\n\n", als_out);
-	printk("gp2a: proximity_bit=%hi\n",*lux_value);
-#endif
-
-	return ret;
+	gp2a_dbgmsg("starting poll timer, delay %lldns\n",
+		    ktime_to_ns(gp2a->light_poll_delay));
+	hrtimer_start(&gp2a->timer, gp2a->light_poll_delay, HRTIMER_MODE_REL);
 }
 
-
-static int gp2a_set_operation_mode(u8 mode)
+static void gp2a_light_disable(struct gp2a_data *gp2a)
 {
-	int ret = 0;
-
-	switch(mode)
-	{
-		case POWER_UP:
-		{
-			//Power up the GPIO-35 too.
-			gpio_direction_output(gp2a_ps_on_gpio, 1);	
-			printk("Light[GP2A] Power-up\n");
-
-			msleep(1000);
-
-			#if 0
-			if((ret = gp2a_i2c_write(REG_OPMOD,0x01))<0)   //Software-Shutdown Disabed.
-			{
-				ret = -EFAULT;
-				printk("Error in gp2a_set_operation_mode: REG_OPMOD \n");
-			}
-			#endif
-			if(gp2a_dev<0){
-				printk(KERN_ERR "Error in GP2A device");
-				}
-			if((ret = gp2a_initialize_register(NORMAL_MODE))<0){
-				ret = -EFAULT;
-				printk("Error in gp2a_register_initialization\n");
-			}
-			if(gp2a_timeout < 0){
-				gp2a_timeout=msecs_to_jiffies(200);
-			}
-		
-			queue_delayed_work(gp2a_work_q, &gp2a_delayed_work_q, gp2a_timeout);
-			break;
-		}
-
-		case POWER_DOWN:
-		{
-			printk("Light[GP2A] Power-down\n");
-			gp2a_timeout=-1;
-			flush_workqueue(gp2a_work_q);
-		        cancel_delayed_work(&gp2a_delayed_work_q);
-			if((ret = gp2a_i2c_write(REG_OPMOD,0x00))<0) //Software-Shutdown Enabled.
-
-			{
-			ret=-EFAULT;
-			printk("Error in gp2a_set_operation_mode: REG_OPMOD \n");
-			}
-
-			// WARNING: rev0.4 board When PS_ON_GPIO --> GND, i2c_read fails.
-			// After that sensors do not come up properly next time.
-			// So Avoid PS_ON_GPIO --> GND on rev0.4 board
-#if (CONFIG_SAMSUNG_OMAP4_TAB_REV != 4)
-			//Shut down the GPIO-35 as the device has been shut down.
-			gpio_direction_output(gp2a_ps_on_gpio, 0);
-#endif
-			break;
-		}
-
-	}
-
-	return ret;
+	gp2a_dbgmsg("cancelling poll timer\n");
+	hrtimer_cancel(&gp2a->timer);
+	cancel_work_sync(&gp2a->work_light);
 }
 
-
-static int gp2a_initialize_register(u8 mode)
+static ssize_t poll_delay_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
 {
-	int ret = 0;
-	u8 return_reg_value=0;
-
-
-	switch(mode)
-	{
-		case NORMAL_MODE:
-		{
-			printk("Light[GP2A] Initializing Registers in Normal-Mode\n");
-			if((ret = gp2a_i2c_write(REG_GAIN,0x08))<0){
-				printk("Error in gp2a_initialize_register: REG_GAIN \n");
-				return ret;
-			}
-			#ifdef GP2A_DEBUG
-			msleep(10);
-			if((ret=gp2a_i2c_read(REG_GAIN,&return_reg_value))<0) {
-				printk("Error in gp2a_initiaize_register:gp2a_i2c_read:REG_GAIN\n");
-				return ret;
-			}
-			printk("After Writing Gain; Read Value:%d\n",return_reg_value);
-			#endif
-			if((ret = gp2a_i2c_write(REG_HYS,0xc2))<0)
-			{
-				printk("Error in gp2a_initialize_register: REG_HYS \n");
-				return ret;
-			}
-			#ifdef GP2A_DEBUG
-			msleep(10);
-			if((ret=gp2a_i2c_read(REG_HYS,&return_reg_value))<0)
-			{
-				printk("Error in gp2a_i2c_read:REG_HYS\n");
-				return ret;
-			}
-			printk("After writing HYS; value read back is:%d",return_reg_value);
-			#endif
-			if((ret = gp2a_i2c_write(REG_CYCLE,0x04))<0)
-			{
-				printk("Error in gp2a_initialize_register: REG_CYCLE \n");
-				return ret;
-			}
-			if((ret = gp2a_i2c_write(REG_OPMOD,0x01))<0)
-			{
-				printk("Error in gp2a_initialize_register: REG_OPMOD \n");
-				return ret;
-			}
-			break;
-		}
-
-		case INTERRUPT_MODE:
-		{
-			printk("Light[GP2A] Initializing Registers in Interrupt-Mode\n");
-			return 0;
-		}
-	}
-
-	return ret;
-}
-
-
-/**************************sysfs-interface**************************/
-
-static ssize_t poll_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	long int delay_to_report;
-	
-	if (gp2a_timeout<0)
-	{
-		delay_to_report = -1 ;
-	}
-	else
-	{
-		delay_to_report = jiffies_to_msecs(gp2a_timeout);
-	}
-
-	printk("delay_to_report=%lld\n", delay_to_report );
-
-	return snprintf(buf, PAGE_SIZE, "%ld\n", delay_to_report);
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%lld\n", ktime_to_ns(gp2a->light_poll_delay));
 }
 
 
-static ssize_t poll_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t poll_delay_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
 {
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	int64_t new_delay;
 	int err;
-	long int new_delay;
-
-
-	printk("buf=%s\n", buf);
-	printk("size=%u\n", size);
 
-	err = strict_strtol(buf, 10, &new_delay);
-	if ( err < 0 )
+	err = strict_strtoll(buf, 10, &new_delay);
+	if (err < 0)
 		return err;
 
-	//gp2a_timeout = msecs_to_jiffies(new_delay);
-	gp2a_timeout = msecs_to_jiffies(200);
+	gp2a_dbgmsg("new delay = %lldns, old delay = %lldns\n",
+		    new_delay, ktime_to_ns(gp2a->light_poll_delay));
+	mutex_lock(&gp2a->power_lock);
+	if (new_delay != ktime_to_ns(gp2a->light_poll_delay)) {
+		gp2a->light_poll_delay = ns_to_ktime(new_delay);
+		if (gp2a->power_state & LIGHT_ENABLED) {
+			gp2a_light_disable(gp2a);
+			gp2a_light_enable(gp2a);
+		}
+	}
+	mutex_unlock(&gp2a->power_lock);
 
-#ifdef GP2A_DEBUG
-	printk("poll_delay_store called. new_delay=%lld\n", new_delay);
-	printk("poll_delay_store called. gp2a_timeout=%d\n", gp2a_timeout);
-#endif
 	return size;
 }
 
-
-static ssize_t light_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t light_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
 {
-	printk("enabled=%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
-	return snprintf(buf, PAGE_SIZE, "%ld\n", (long int)((gp2a_timeout < 0) ? 0 : 1) );
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n",
+		       (gp2a->power_state & LIGHT_ENABLED) ? 1 : 0);
 }
 
+static ssize_t proximity_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n",
+		       (gp2a->power_state & PROXIMITY_ENABLED) ? 1 : 0);
+}
 
-static ssize_t light_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t light_enable_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
 {
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
 	bool new_value;
-	int ret = 0;
 
 	if (sysfs_streq(buf, "1"))
 		new_value = true;
 	else if (sysfs_streq(buf, "0"))
 		new_value = false;
 	else {
-		printk("%s: invalid value %d\n", __func__, *buf);
+		pr_err("%s: invalid value %d\n", __func__, *buf);
 		return -EINVAL;
 	}
 
-	printk("new_value = %d, old state = %d\n", new_value, ((gp2a_timeout < 0) ? 0 : 1) );
-	if (new_value && (gp2a_timeout < 0) ) {
-
-		ret = gp2a_set_operation_mode(POWER_UP);
-		if (ret < 0) {
-			printk("POWER_UP failed!!\n");
-			ret = -EINVAL;
-		}
-
-	} else if (!new_value && (gp2a_timeout > -1) ) {
-		ret = gp2a_set_operation_mode(POWER_DOWN);
-		if (ret < 0) {
-			printk("POWER_DOWN failed!!\n");
-			ret = -EINVAL;
-		}
+	mutex_lock(&gp2a->power_lock);
+	gp2a_dbgmsg("new_value = %d, old state = %d\n",
+		    new_value, (gp2a->power_state & LIGHT_ENABLED) ? 1 : 0);
+	if (new_value && !(gp2a->power_state & LIGHT_ENABLED)) {
+		if (!gp2a->power_state)
+			gp2a->pdata->power(true);
+		gp2a->power_state |= LIGHT_ENABLED;
+		gp2a_light_enable(gp2a);
+	} else if (!new_value && (gp2a->power_state & LIGHT_ENABLED)) {
+		gp2a_light_disable(gp2a);
+		gp2a->power_state &= ~LIGHT_ENABLED;
+		if (!gp2a->power_state)
+			gp2a->pdata->power(false);
 	}
-
-	(ret < 0) ? NULL : (ret = size) ;
-
-	return ret;
-}
-
-
-static ssize_t proximity_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	printk("enabled=%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
-	return snprintf(buf, PAGE_SIZE, "%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
+	mutex_unlock(&gp2a->power_lock);
+	return size;
 }
 
-
-static ssize_t proximity_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t proximity_enable_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
 {
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
 	bool new_value;
-	int ret = 0;
 
 	if (sysfs_streq(buf, "1"))
 		new_value = true;
 	else if (sysfs_streq(buf, "0"))
 		new_value = false;
 	else {
-		printk("%s: invalid value %d\n", __func__, *buf);
+		pr_err("%s: invalid value %d\n", __func__, *buf);
 		return -EINVAL;
 	}
 
-	printk("new_value = %d, old state = %d\n", new_value, ((gp2a_timeout < 0) ? 0 : 1) );
-	if (new_value && (gp2a_timeout < 0) ) {
-
-		ret = gp2a_set_operation_mode(POWER_UP);
-		if (ret < 0) {
-			printk("POWER_UP failed!!\n");
-			ret = -EINVAL;
-		}
-
-	} else if (!new_value && (gp2a_timeout > -1) ) {
-		ret = gp2a_set_operation_mode(POWER_DOWN);
-		if (ret < 0) {
-			printk("POWER_DOWN failed!!\n");
-			ret = -EINVAL;
-		}
+	mutex_lock(&gp2a->power_lock);
+	gp2a_dbgmsg("new_value = %d, old state = %d\n",
+		    new_value, (gp2a->power_state & PROXIMITY_ENABLED) ? 1 : 0);
+	if (new_value && !(gp2a->power_state & PROXIMITY_ENABLED)) {
+		if (!gp2a->power_state)
+			gp2a->pdata->power(true);
+		gp2a->power_state |= PROXIMITY_ENABLED;
+		enable_irq(gp2a->irq);
+		enable_irq_wake(gp2a->irq);
+		gp2a_i2c_write(gp2a, REGS_GAIN, &reg_defaults[1]);
+		gp2a_i2c_write(gp2a, REGS_HYS, &reg_defaults[2]);
+		gp2a_i2c_write(gp2a, REGS_CYCLE, &reg_defaults[3]);
+		gp2a_i2c_write(gp2a, REGS_OPMOD, &reg_defaults[4]);
+	} else if (!new_value && (gp2a->power_state & PROXIMITY_ENABLED)) {
+		disable_irq_wake(gp2a->irq);
+		disable_irq(gp2a->irq);
+		gp2a_i2c_write(gp2a, REGS_OPMOD, &reg_defaults[0]);
+		gp2a->power_state &= ~PROXIMITY_ENABLED;
+		if (!gp2a->power_state)
+			gp2a->pdata->power(false);
 	}
-
-	(ret < 0) ? NULL : (ret = size) ;
-
-	return ret;
+	mutex_unlock(&gp2a->power_lock);
+	return size;
 }
 
-
-static struct device_attribute dev_attr_poll_delay =
-	__ATTR(poll_delay, S_IRUGO | S_IWUGO | S_IXUGO,
-	       poll_delay_show, poll_delay_store);
+static DEVICE_ATTR(poll_delay, S_IRUGO | S_IWUGO,
+		   poll_delay_show, poll_delay_store);
 
 static struct device_attribute dev_attr_light_enable =
-	__ATTR(enable, S_IRUGO | S_IWUGO | S_IXUGO,
+	__ATTR(enable, S_IRUGO | S_IWUGO,
 	       light_enable_show, light_enable_store);
 
+static struct device_attribute dev_attr_proximity_enable =
+	__ATTR(enable, S_IRUGO | S_IWUGO,
+	       proximity_enable_show, proximity_enable_store);
 
 static struct attribute *light_sysfs_attrs[] = {
 	&dev_attr_light_enable.attr,
@@ -446,15 +298,6 @@
 	.attrs = light_sysfs_attrs,
 };
 
-
-
-
-
-static struct device_attribute dev_attr_proximity_enable =
-	__ATTR(enable, S_IRUGO | S_IWUGO | S_IXUGO,
-	       proximity_enable_show, proximity_enable_store);
-
-
 static struct attribute *proximity_sysfs_attrs[] = {
 	&dev_attr_proximity_enable.attr,
 	NULL
@@ -463,383 +306,387 @@
 static struct attribute_group proximity_attribute_group = {
 	.attrs = proximity_sysfs_attrs,
 };
-/*****************************************************************/
-
 
-static int gp2a_ioctl(struct inode *inode, struct file *filp, unsigned int ioctl_cmd, unsigned long arg )
+static int lightsensor_get_adcvalue(struct gp2a_data *gp2a)
 {
-	int ret =0;
-	void __user *argp = (void __user*)arg;
-	u8 lux_value;
 
+#if 0
+	int i = 0;
+	int j = 0;
+	unsigned int adc_total = 0;
+	int adc_avr_value;
+	unsigned int adc_index = 0;
+	unsigned int adc_max = 0;
+	unsigned int adc_min = 0;
+#endif
 
-	if(_IOC_TYPE(ioctl_cmd) != GP2A_LIGHT_IOC_MAGIC)
-	{
-		printk("GP2A cmd magic type error\n");
-		return -ENOTTY;
-	}
+	int value = 0;
 
-	if(_IOC_NR(ioctl_cmd)>GP2A_LIGHT_IOC_MAGIC_NR_MAX)
-	{
-		printk("gp2a cmd number error\n");
-		return -ENOTTY;
-	}
+	/* get ADC */
+	value = gp2a->pdata->light_adc_value();
 
-	switch(ioctl_cmd)
-	{
+#if 0
+	adc_index = (gp2a->adc_index_count++) % ADC_BUFFER_NUM;
 
-		case GP2A_LIGHT_IOC_SET_OPERATION_MODE:
-		{
-			u8 mode =0;
+	/*ADC buffer initialize (light sensor off ---> light sensor on) */
+	if (!gp2a->adc_buf_initialized) {
+		gp2a->adc_buf_initialized = true;
+		for (j = 0; j < ADC_BUFFER_NUM; j++)
+			gp2a->adc_value_buf[j] = value;
+	} else
+		gp2a->adc_value_buf[adc_index] = value;
 
-			if(copy_from_user(&mode,argp,sizeof(mode)))
-			{
-				printk(KERN_ERR"copy_from_user failed\n");
-				return -EFAULT;
-			}
+	adc_max = gp2a->adc_value_buf[0];
+	adc_min = gp2a->adc_value_buf[0];
 
-			printk("\n\ngp2a mode==%x\n\n",mode);
-			ret = gp2a_set_operation_mode(mode);
-		}
+	for (i = 0; i < ADC_BUFFER_NUM; i++) {
+		adc_total += gp2a->adc_value_buf[i];
 
+		if (adc_max < gp2a->adc_value_buf[i])
+			adc_max = gp2a->adc_value_buf[i];
 
-		case GP2A_LIGHT_IOC_SET_POLL_DELAY:
-		{
-			u16 delay;
-			if(copy_from_user(&delay,argp,sizeof(delay)))
-			{
-				printk("gp2a: copy_from_user failed\n");
-				return -EFAULT;
-			}
-			else
-			{
-				gp2a_timeout=msecs_to_jiffies(delay);
-				printk("gp2a polling delay=%d\n",gp2a_timeout);
-			}
+		if (adc_min > gp2a->adc_value_buf[i])
+			adc_min = gp2a->adc_value_buf[i];
+	}
+	adc_avr_value = (adc_total-(adc_max+adc_min))/(ADC_BUFFER_NUM-2);
 
-			return 0;
-		}
+	if (gp2a->adc_index_count == ADC_BUFFER_NUM-1)
+		gp2a->adc_index_count = 0;
+#endif
+	return value;
+}
 
+static void gp2a_work_func_light(struct work_struct *work)
+{
+	struct gp2a_data *gp2a = container_of(work, struct gp2a_data,
+					      work_light);
+	int adc = lightsensor_get_adcvalue(gp2a);
+	input_report_abs(gp2a->light_input_dev, ABS_MISC, adc);
+	input_sync(gp2a->light_input_dev);
+}
 
-		case GP2A_LIGHT_IOC_GET_OPERATION_MODE:
-		{
-			
-			return 0;
-			//TODO
-		}
+/* This function is for light sensor.  It operates every a few seconds.
+ * It asks for work to be done on a thread because i2c needs a thread
+ * context (slow and blocking) and then reschedules the timer to run again.
+ */
+static enum hrtimer_restart gp2a_timer_func(struct hrtimer *timer)
+{
+	struct gp2a_data *gp2a = container_of(timer, struct gp2a_data, timer);
+	queue_work(gp2a->wq, &gp2a->work_light);
+	hrtimer_forward_now(&gp2a->timer, gp2a->light_poll_delay);
+	return HRTIMER_RESTART;
+}
 
+/* interrupt happened due to transition/change of near/far proximity state */
+irqreturn_t gp2a_irq_handler(int irq, void *data)
+{
+	struct gp2a_data *ip = data;
+	int val = gpio_get_value(ip->pdata->p_out);
+	if (val < 0) {
+		pr_err("%s: gpio_get_value error %d\n", __func__, val);
+		return IRQ_HANDLED;
+	}
 
-		case GP2A_LIGHT_IOC_GET_LUX_VALUE:
-		{
-			return 0;
-			//TODO
-		}
+	gp2a_dbgmsg("gp2a: proximity val=%d\n", val);
 
+	/* 0 is close, 1 is far */
+	input_report_abs(ip->proximity_input_dev, ABS_DISTANCE, val);
+	input_sync(ip->proximity_input_dev);
+	wake_lock_timeout(&ip->prx_wake_lock, 3*HZ);
 
-		default:
-		{
-			printk(KERN_ERR"GP2A: UNKNOWN IOCTL\n");
-			return (-ENOTTY);
-		}
-	}
+	return IRQ_HANDLED;
 }
 
-static int gp2a_work(void)
+static int gp2a_setup_irq(struct gp2a_data *gp2a)
 {
-	//printk("gp2a_work called\n");
-	u8 lux_value;
-	int ret =0;
+	int rc = -EIO;
+	struct gp2a_platform_data *pdata = gp2a->pdata;
+	int irq;
 
-	ret = gp2a_get_lux_value(&lux_value);
+	gp2a_dbgmsg("start\n");
 
-	if(ret < 0)
-	{
-		printk("gp2a_read_lux_value FAILED\n");
-		return (-1);
+	rc = gpio_request(pdata->p_out, "gpio_proximity_out");
+	if (rc < 0) {
+		pr_err("%s: gpio %d request failed (%d)\n",
+			__func__, pdata->p_out, rc);
+		return rc;
 	}
 
-	input_report_abs(light_input, ABS_DISTANCE, (lux_value & 0x01) );	// Proximity
-	input_report_abs(light_input, ABS_MISC, conv_request.rbuf[3] );		// Ambient light
-	input_sync(light_input);
+	rc = gpio_direction_input(pdata->p_out);
+	if (rc < 0) {
+		pr_err("%s: failed to set gpio %d as input (%d)\n",
+			__func__, pdata->p_out, rc);
+		goto err_gpio_direction_input;
+	}
 
-	if(gp2a_timeout > -1)
-	{
-		queue_delayed_work(gp2a_work_q, &gp2a_delayed_work_q, gp2a_timeout);
+	irq = gpio_to_irq(pdata->p_out);
+	rc = request_irq(irq,
+			 gp2a_irq_handler,
+			 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			 "proximity_int",
+			 gp2a);
+	if (rc < 0) {
+		pr_err("%s: request_irq(%d) failed for gpio %d (%d)\n",
+			__func__, irq,
+			pdata->p_out, rc);
+		goto err_request_irq;
 	}
 
-	return 0;
-}
+	/* start with interrupts disabled */
+	disable_irq(irq);
+	gp2a->irq = irq;
 
+	gp2a_dbgmsg("success\n");
 
-struct file_operations gp2a_fops =
-{
-	.owner   = THIS_MODULE,
+	goto done;
 
-	//.read    = gp2a_read, 
-	//.write   = gp2a_write,
-	//.open    = gp2a_open,
-	.ioctl   = gp2a_ioctl,
-	//.release = gp2a_release,
-};
-
-#ifdef CONFIG_PM
-static int gp2a_suspend(struct i2c_client * client, pm_message_t mesg)
-{
-        int ret =-1;
-	 gp2a_timeout=-1;
-	atomic_set(&is_true_suspend ,1);
-        printk(KERN_ERR MODULE_NAME ": suspending device...\n");
-        flush_workqueue(gp2a_work_q);
-        cancel_delayed_work(&gp2a_delayed_work_q);
-        if((ret = gp2a_i2c_write(REG_OPMOD,0x00))<0) //Software-Shutdown Enabled.
-
-                        {
-                        ret=-EFAULT;
-                        printk("Error in gp2a_set_operation_mode: REG_OPMOD \n");
-                        }
-
-        return 0;
-}
-
-static int gp2a_resume(struct i2c_client * client)
-{
-        int ret =-1;
-        #ifdef GP2A_DEBUG
-        #endif
-	if(atomic_read(&is_true_suspend)){
-	        printk(KERN_INFO MODULE_NAME ": resuming device...\n");
-        	if((ret = gp2a_initialize_register(NORMAL_MODE))<0){
-                                ret = -EFAULT;
-                                printk("Error in gp2a_register_initialization\n");
-                        }
-       		if(gp2a_timeout < 0){
-                                gp2a_timeout=msecs_to_jiffies(200);
-                        }
-       		queue_delayed_work(gp2a_work_q, &gp2a_delayed_work_q, gp2a_timeout);
-	}
-	
-        return 0;
+err_request_irq:
+err_gpio_direction_input:
+	gpio_free(pdata->p_out);
+done:
+	return rc;
 }
-#else
-#define gp2a_suspend NULL
-#define gp2a_resume NULL
 
-#endif
-
-
-static int gp2a_probe(struct i2c_client *client,const struct i2c_device_id *id )
+static int gp2a_i2c_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
 {
-	int ret = 0;
-	int result_light=-1;
+	int ret = -ENODEV;
+	struct input_dev *input_dev;
+	struct gp2a_data *gp2a;
+	struct gp2a_platform_data *pdata = client->dev.platform_data;
 
-	#ifdef GP2A_DEBUG
-	u8 lux_value= 0;  // Proximitiy values =0 or 1.
-	#endif
-
-	struct device *dev_light;
-	gp2a_client = client;
-	
-	//Allocate light-device
-	gp2a_dev = kzalloc(sizeof *gp2a_dev, GFP_KERNEL);
-	if(gp2a_dev < 0)
-	{
-		printk("[GP2A_LIGHT]:Not enough memory while allocating Device\n");
-		return -ENOMEM;
+	if (!pdata) {
+		pr_err("%s: missing pdata!\n", __func__);
+		return ret;
 	}
 
-	//Initialize lock;
-	mutex_init(&gp2a_dev->lock);
-	gp2a_dev->client = client;
-	i2c_set_clientdata(client, gp2a_dev);
-	gp2a_client = client;
-	
-	printk(KERN_INFO MODULE_NAME"Registering [GP2A_LIGHT] Light-Driver at address:%d",gp2a_client->addr);
-	printk("--------%s %d\n",__func__,__LINE__);
-	
-	
-	//Register char-driver
-	result_light = register_chrdev ( (int)NULL, LIGHT_DEV_NAME, &gp2a_fops);
-
-	if(result_light <0)
-	{
-		printk(KERN_ERR "GP2A: Error while registering[GP2A_LIGHT] the char-device\n");
-		return result_light;
+	ret = gpio_request(OMAP4TAB_GP2A_PS_ON, "gpio_ps_on");
+	if (ret < 0) {
+		pr_err("%s: gpio %d request failed (%d)\n",
+			__func__, OMAP4TAB_GP2A_PS_ON, ret);
+		return ret;
 	}
 
+	ret = gpio_direction_input(OMAP4TAB_GP2A_PS_ON);
+	if (ret < 0) {
+		pr_err("%s: failed to set gpio %d as input (%d)\n",
+			__func__, OMAP4TAB_GP2A_PS_ON, ret);
+		return ret;
+	}
 
-	light_class = class_create(THIS_MODULE,LIGHT_DEV_NAME);
-	if(IS_ERR(light_class))
-		{
-			printk(KERN_ERR"Error while[GP2A_LIGHT] Creating the light_class\n");
-			unregister_chrdev(result_light,LIGHT_DEV_NAME);
-			return PTR_ERR(light_class);
-		}
-
-	dev_light = device_create(light_class, NULL, MKDEV(result_light ,0),"%s",LIGHT_DEV_NAME);
-
-	if(IS_ERR(dev_light))
-	{
-		printk(KERN_ERR "Error while[GP2A_LIGHT] Creating the dev_light\n");
-		return PTR_ERR(dev_light);
-	}
-	
-
-	//Ambient-light input device
-	light_input = input_allocate_device();
-
-	if(NULL == light_input)
-	{
-		printk(KERN_ERR"\n[gp2a-lightSENSOR] Error while allocating light input device");
-		return -EIO;
-	}
-
-	gp2a_dev->inputdev=light_input;
-	set_bit(EV_ABS, light_input->evbit);
-	set_bit(ABS_MISC, light_input->absbit);
-	
-	light_input->name="gp2a_light";
-	light_input->dev.parent = &gp2a_client->dev;
-	
-	input_set_abs_params(light_input,ABS_MISC,0,30000,0,0);
-	
-	ret = input_register_device(light_input);
-	if(ret)
-	{
-		printk("gp2a light Sensor couldn't be registered:%d\n",ret);
-		goto release_input_dev;
-	}	
-
-	ret = sysfs_create_group(&light_input->dev.kobj, &light_attribute_group);
-	if (ret) {
-		printk("%s: could not create light sysfs group\n", __func__);
-		goto release_input_dev;
+	if (!pdata->power || !pdata->light_adc_value) {
+		pr_err("%s: incomplete pdata!\n", __func__);
+		return ret;
 	}
 
 
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: i2c functionality check failed!\n", __func__);
+		return ret;
+	}
+	gp2a = kzalloc(sizeof(struct gp2a_data), GFP_KERNEL);
+	if (!gp2a) {
+		pr_err("%s: failed to alloc memory for module data\n",
+		       __func__);
+		return -ENOMEM;
+	}
 
-	// Proximity input-device
-	proximity_input = input_allocate_device();
+	gp2a->pdata = pdata;
+	gp2a->i2c_client = client;
+	i2c_set_clientdata(client, gp2a);
+
+	/* wake lock init */
+	wake_lock_init(&gp2a->prx_wake_lock, WAKE_LOCK_SUSPEND,
+		       "prx_wake_lock");
+	mutex_init(&gp2a->power_lock);
 
-	if(NULL == proximity_input)
-	{
-		printk(KERN_ERR"\n[gp2a-ProximitySENSOR] Error while allocating proximity input device");
-		return -EIO;
-	}
-
-	//gp2a_dev->inputdev=proximity_input;
-	set_bit(EV_ABS, proximity_input->evbit);
-	set_bit(ABS_DISTANCE, proximity_input->absbit);
-	
-	light_input->name="gp2a_proximity";
-	light_input->dev.parent = &gp2a_client->dev;
-	
-	input_set_abs_params(light_input,ABS_DISTANCE,0,1,0,0);
-	
-	ret = input_register_device(proximity_input);
-	if(ret)
-	{
-		printk("gp2a proximity Sensor couldn't be registered:%d\n",ret);
-		goto release_input_dev;
-	}	
+        ret = gp2a_setup_irq(gp2a);
+        if (ret) {
+                pr_err("%s: could not setup irq\n", __func__);
+                goto err_setup_irq;
+        }
 
-	ret = sysfs_create_group(&proximity_input->dev.kobj, &proximity_attribute_group);
+	/* allocate proximity input_device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("%s: could not allocate input device\n", __func__);
+		goto err_input_allocate_device_proximity;
+	}
+	gp2a->proximity_input_dev = input_dev;
+	input_set_drvdata(input_dev, gp2a);
+	input_dev->name = "proximity";
+	input_set_capability(input_dev, EV_ABS, ABS_DISTANCE);
+	input_set_abs_params(input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+
+	gp2a_dbgmsg("registering proximity input device\n");
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		pr_err("%s: could not register input device\n", __func__);
+		input_free_device(input_dev);
+		goto err_input_register_device_proximity;
+	}
+	ret = sysfs_create_group(&input_dev->dev.kobj,
+				 &proximity_attribute_group);
 	if (ret) {
-		printk("%s: could not create proximity sysfs group\n", __func__);
-		goto release_input_dev;
+		pr_err("%s: could not create sysfs group\n", __func__);
+		goto err_sysfs_create_group_proximity;
 	}
 
+	/* hrtimer settings.  we poll for light values using a timer. */
+	hrtimer_init(&gp2a->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	gp2a->light_poll_delay = ns_to_ktime(200 * NSEC_PER_MSEC);
+	gp2a->timer.function = gp2a_timer_func;
+
+	/* the timer just fires off a work queue request.  we need a thread
+	   to read the i2c (can be slow and blocking). */
+	gp2a->wq = create_singlethread_workqueue("gp2a_wq");
+	if (!gp2a->wq) {
+		ret = -ENOMEM;
+		pr_err("%s: could not create workqueue\n", __func__);
+		goto err_create_workqueue;
+	}
+	/* this is the thread function we run on the work queue */
+	INIT_WORK(&gp2a->work_light, gp2a_work_func_light);
+
+	/* allocate lightsensor-level input_device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("%s: could not allocate input device\n", __func__);
+		ret = -ENOMEM;
+		goto err_input_allocate_device_light;
+	}
+	input_set_drvdata(input_dev, gp2a);
+	input_dev->name = "lightsensor-level";
+	input_set_capability(input_dev, EV_ABS, ABS_MISC);
+	input_set_abs_params(input_dev, ABS_MISC, 0, 1, 0, 0);
+
+	gp2a_dbgmsg("registering lightsensor-level input device\n");
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		pr_err("%s: could not register input device\n", __func__);
+		input_free_device(input_dev);
+		goto err_input_register_device_light;
+	}
+	gp2a->light_input_dev = input_dev;
+	ret = sysfs_create_group(&input_dev->dev.kobj,
+				 &light_attribute_group);
+	if (ret) {
+		pr_err("%s: could not create sysfs group\n", __func__);
+		goto err_sysfs_create_group_light;
+	}
+	goto done;
 
+	/* error, unwind it all */
+err_sysfs_create_group_light:
+	input_unregister_device(gp2a->light_input_dev);
+err_input_register_device_light:
+err_input_allocate_device_light:
+	destroy_workqueue(gp2a->wq);
+err_create_workqueue:
+	sysfs_remove_group(&gp2a->proximity_input_dev->dev.kobj,
+			   &proximity_attribute_group);
+err_sysfs_create_group_proximity:
+	input_unregister_device(gp2a->proximity_input_dev);
+err_input_register_device_proximity:
+err_input_allocate_device_proximity:
+	free_irq(gp2a->irq, 0);
+	gpio_free(gp2a->pdata->p_out);
+err_setup_irq:
+	mutex_destroy(&gp2a->power_lock);
+	wake_lock_destroy(&gp2a->prx_wake_lock);
+	kfree(gp2a);
+done:
+	return ret;
+}
 
-	//Workqueue Initialisation
-	gp2a_work_q = create_singlethread_workqueue("light_sensor_gp2a_work_queue");
-	INIT_DELAYED_WORK( (struct delayed_work *)&gp2a_delayed_work_q, gp2a_work);
-
-	//Initializing the GPIO for GP2A
-	gp2a_ps_on_gpio = OMAP4TAB_PS_ON_GPIO;
-        ret = gpio_request(gp2a_ps_on_gpio, "GP2A Power On GPIO");
-        if (ret) {
-                printk(KERN_ERR "failed to get GP2A Power on GPIO\n");
-                return -EFAULT;
-        }
-	
-	gp2a_dev->gp2a_early_suspend.suspend = gp2a_suspend;
-        gp2a_dev->gp2a_early_suspend.resume = gp2a_resume;
-        register_early_suspend(&gp2a_dev->gp2a_early_suspend);
-
-
-	#ifdef GP2A_DEBUG
-	// Initializing the device;
-	// GP2A_LIGHT is being used as lightsensor
-	if((ret = gp2a_set_operation_mode(POWER_UP))<0)
-	{
-		printk("gp2a_set_operation_mode failed");
-		ret = -EFAULT;
-	}
-		msleep(1000);
-		gp2a_get_lux_value(&lux_value);
-		printk("gp2a: proximity_register value=%hi \n", lux_value);
-		lux_value = lux_value & 0x01;
-		printk("gp2a: proximity_bit=%hi\n",lux_value);
-	#endif
-
+static int gp2a_suspend(struct device *dev)
+{
+	/* We disable power only if proximity is disabled.  If proximity
+	   is enabled, we leave power on because proximity is allowed
+	   to wake up device.  We remove power without changing
+	   gp2a->power_state because we use that state in resume.
+	*/
+	struct i2c_client *client = to_i2c_client(dev);
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	if (gp2a->power_state & LIGHT_ENABLED)
+		gp2a_light_disable(gp2a);
+	if (gp2a->power_state == LIGHT_ENABLED)
+		gp2a->pdata->power(false);
 	return 0;
+}
 
-release_input_dev:
-	input_free_device(light_input);
-	return ret;
+static int gp2a_resume(struct device *dev)
+{
+	/* Turn power back on if we were before suspend. */
+	struct i2c_client *client = to_i2c_client(dev);
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	if (gp2a->power_state == LIGHT_ENABLED)
+		gp2a->pdata->power(true);
+	if (gp2a->power_state & LIGHT_ENABLED)
+		gp2a_light_enable(gp2a);
+	return 0;
 }
 
-static int  gp2a_remove(struct i2c_client *client)
+static int gp2a_i2c_remove(struct i2c_client *client)
 {
-	struct gp2a_dev *gp2a = i2c_get_clientdata(client);
-	unregister_early_suspend(&gp2a_dev->gp2a_early_suspend);
-	sysfs_remove_group(&gp2a->inputdev->dev.kobj, &light_attribute_group);
-	input_unregister_device(gp2a->inputdev);
-	input_free_device(gp2a->inputdev);
+	struct gp2a_data *gp2a = i2c_get_clientdata(client);
+	sysfs_remove_group(&gp2a->light_input_dev->dev.kobj,
+			   &light_attribute_group);
+	input_unregister_device(gp2a->light_input_dev);
+	sysfs_remove_group(&gp2a->proximity_input_dev->dev.kobj,
+			   &proximity_attribute_group);
+	input_unregister_device(gp2a->proximity_input_dev);
+	free_irq(gp2a->irq, NULL);
+	gpio_free(gp2a->pdata->p_out);
+	if (gp2a->power_state) {
+		gp2a->power_state = 0;
+		if (gp2a->power_state & LIGHT_ENABLED)
+			gp2a_light_disable(gp2a);
+		gp2a->pdata->power(false);
+	}
+	destroy_workqueue(gp2a->wq);
+	mutex_destroy(&gp2a->power_lock);
+	wake_lock_destroy(&gp2a->prx_wake_lock);
 	kfree(gp2a);
-
 	return 0;
 }
 
-static const struct i2c_device_id gp2a_ids[] = {	
-        { MODULE_NAME, 0 },
-	{ }
+static const struct i2c_device_id gp2a_device_id[] = {
+	{"gp2a", 0},
+	{}
 };
+MODULE_DEVICE_TABLE(i2c, gp2a_device_id);
 
-MODULE_DEVICE_TABLE(i2c, gp2a_ids);
+static const struct dev_pm_ops gp2a_pm_ops = {
+	.suspend = gp2a_suspend,
+	.resume = gp2a_resume
+};
 
-static struct i2c_driver gp2a_driver = {
+static struct i2c_driver gp2a_i2c_driver = {
 	.driver = {
-		.name	= MODULE_NAME,
-		.owner	= THIS_MODULE,
+		.name = "gp2a",
+		.owner = THIS_MODULE,
+		.pm = &gp2a_pm_ops
 	},
-	.id_table = gp2a_ids,
-	.probe = gp2a_probe,
-	.remove = gp2a_remove,
-
+	.probe		= gp2a_i2c_probe,
+	.remove		= gp2a_i2c_remove,
+	.id_table	= gp2a_device_id,
 };
 
 
 static int __init gp2a_init(void)
 {
-	#ifdef GP2A_DEBUG
-	printk(KERN_INFO MODULE_NAME ": Registering GP2A driver\n");
-	#endif
-	return i2c_add_driver(&gp2a_driver);
+	return i2c_add_driver(&gp2a_i2c_driver);
 }
 
 static void __exit gp2a_exit(void)
 {
-	#ifdef GP2A_DEBUG
-	printk(KERN_INFO MODULE_NAME ": Unregistered GP2A driver\n");
-	#endif
-	i2c_del_driver(&gp2a_driver);
+	i2c_del_driver(&gp2a_i2c_driver);
 }
 
-
 module_init(gp2a_init);
 module_exit(gp2a_exit);
 
-MODULE_AUTHOR("Dharam Kumar");
-MODULE_DESCRIPTION("GP2A Driver");
+MODULE_AUTHOR("mjchen@sta.samsung.com");
+MODULE_DESCRIPTION("Optical Sensor driver for gp2ap002a00f");
 MODULE_LICENSE("GPL");
Index: Kernel-org/include/linux/gp2a.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel-org/include/linux/gp2a.h	2011-01-24 14:39:30.170275460 +0530
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2010 Samsung Electronics. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef __LINUX_GP2A_H
+#define __LINUX_GP2A_H
+
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+#define GP2A_OPT "gp2a-opt"
+struct gp2a_platform_data {
+	int p_out;  /* proximity-sensor-output gpio */
+	int (*power)(bool); /* power to the chip */
+	int (*light_adc_value)(void); /* get light level from adc */
+};
+#endif /* __KERNEL__ */
+
+#endif
Index: Kernel-org/arch/arm/mach-omap2/board-omap4tab10-1.c
===================================================================
--- Kernel-org.orig/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-24 14:38:37.680273724 +0530
+++ Kernel-org/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-24 14:54:59.340273955 +0530
@@ -63,6 +63,9 @@
 #include <linux/haptic.h>
 #include <plat/opp_twl_tps.h>
 #include <linux/fsa9480.h>
+#include <linux/gp2a.h>
+
+#include <linux/i2c/twl6030-gpadc.h>
 
 #ifdef CONFIG_PN544_NFC
 #include<linux/pn544.h>
@@ -113,10 +116,16 @@
 #define OMAP4TAB_KXSD9_INT_GPIO				94
 #define OMAP4TAB_AKM_INT_GPIO				157
 #define OMAP4TAB_MPU3050_INT_GPIO			45
-#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4 || CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
+#define OMAP4TAB_KXSD9_INT_GPIO				122
+#define OMAP4TAB_AKM_INT_GPIO				157
+#define OMAP4TAB_MPU3050_INT_GPIO			45
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
 #define OMAP4TAB_KXSD9_INT_GPIO				122
 #define OMAP4TAB_AKM_INT_GPIO				157
 #define OMAP4TAB_MPU3050_INT_GPIO			45
+#define OMAP4TAB_GP2A_PS_ON				37
+#define OMAP4TAB_GP2A_PS_VOUT				33
 #endif
 
 #define CONTROL_CORE_PAD0_I2C3_SDA_PAD1_I2C4_SCL	0x4A10012C
@@ -247,6 +256,42 @@
        .reset_cb       = omap4_fsa9480_reset_cb,
 };
 
+/* For gp2a light/proximity sensor */
+
+static int gp2a_power(bool on)
+{
+	/* this controls the power supply rail to the gp2a IC */
+	gpio_direction_output(OMAP4TAB_GP2A_PS_ON, on);
+	return 0;
+}
+
+static struct twl6030_gpadc_request conv_request = {
+        .channels = (0x1 << 3),
+        .do_avg = 0,
+	.method = TWL6030_GPADC_SW2,
+	.type = 0,
+	.active = 0,
+	.result_pending = 0,
+	.func_cb = NULL,
+
+};
+
+static int gp2a_light_adc_value(void)
+{
+	// Ambient Light sensing
+        twl6030_gpadc_conversion(&conv_request);
+	return (conv_request.rbuf[3]);
+
+}
+
+static struct gp2a_platform_data gp2a_pdata = {
+	.power = gp2a_power,
+	.p_out = OMAP4TAB_GP2A_PS_VOUT,
+	.light_adc_value = gp2a_light_adc_value
+};
+
+
+
 static void omap4_usb_cb(u8 attached)
 {
        /* TODO: need to implement this once uUSB charging available in HW */
@@ -1512,6 +1557,7 @@
 	},
 	{
 		I2C_BOARD_INFO("gp2a",0x44),
+		.platform_data = &gp2a_pdata,
 		
 	},
 	{
