Index: android-2.6.35/drivers/sensors/Kconfig
===================================================================
--- android-2.6.35.orig/drivers/sensors/Kconfig	2010-12-22 14:36:03.681988196 +0530
+++ android-2.6.35/drivers/sensors/Kconfig	2010-12-22 14:36:55.673862278 +0530
@@ -5,3 +5,7 @@
 	  Say Y to enable Sensors support.  This allows control of supported
 	  Sensors.
 
+if NEW_SENSORS
+source "drivers/sensors/optical/Kconfig"
+endif # NEW_SENSORS
+
Index: android-2.6.35/drivers/sensors/optical/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/Kconfig	2010-12-22 14:36:40.291988780 +0530
@@ -0,0 +1,17 @@
+#
+# Optical Sensor Configuration
+#
+
+config OPTICAL
+	bool "Optical Sensor"
+	default n
+	help
+	  This option enables proximity & light sensors
+
+config OPTICAL_ISL29023
+	depends on OPTICAL
+	tristate "Ambient Light Sensor driver"
+	default y
+	help
+	  This option enables light sensors using isl29023.
+
Index: android-2.6.35/drivers/sensors/optical/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/Makefile	2010-12-22 14:36:40.261987968 +0530
@@ -0,0 +1,11 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# AUTHOR	: Throughc
+# ##############################################################################
+# VERSION&DATE	: Version 1.00  2007/12/25 (Throughc)
+# #############################################################################
+
+obj-$(CONFIG_OPTICAL_ISL29023) += isl29023_func.o \
+				  isl29023_i2c.o \
+				  isl29023.o
+
Index: android-2.6.35/drivers/sensors/optical/isl29023.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023.c	2010-12-22 14:36:40.271988431 +0530
@@ -0,0 +1,492 @@
+/*****************************************************************************
+ *
+ * COPYRIGHT(C) : Samsung Electronics Co.Ltd, 2006-2015 ALL RIGHTS RESERVED
+ *
+ *****************************************************************************/
+/*Linux Kernel Driver for ISL29023 Ambient Light Sensor Driver*/ 
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+
+#include <plat/irqs.h>
+#include <mach/gpio.h>
+#include "isl29023.h"
+#include "isl29023_func.h"
+#include "isl29023_i2c.h"
+
+static int isl29023_open (struct inode *, struct file *);
+static int isl29023_release (struct inode *, struct file *);
+static ssize_t isl29023_read(struct file *, char __user *, size_t, loff_t *);
+static int isl29023_isr( int , void * );
+#ifdef USE_ISL29023_IOCTLS 
+static int isl29023_ioctl(struct inode *, struct file *, unsigned int ,unsigned long);
+#endif
+
+struct class *lightsensor_class;
+struct device *switch_cmd_dev;
+static bool light_enable = OFF;
+
+static struct input_dev *isl29023_input_dev;
+
+static struct file_operations isl29023_fops =
+{
+    .owner = THIS_MODULE,
+    .open = isl29023_open,
+	.read = isl29023_read,
+#ifdef USE_ISL29023_IOCTLS 
+    .ioctl = isl29023_ioctl,
+#endif
+    .release = isl29023_release,
+};
+
+static struct miscdevice isl29023_misc_device = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "light",
+    .fops = &isl29023_fops,
+};
+
+static int isl29023_open (struct inode *inode, struct file *filp)
+{
+    int ret=0;
+	debug("%s called",__func__);
+	if((ret=isl29023_set_operation_mode(ALS_CONTINUOUS))<0)
+		ret=-1;
+	return ret;
+}
+
+static int isl29023_release (struct inode *inode, struct file *filp)
+{
+	int ret=0;
+	debug("%s called",__func__);
+	if((ret=isl29023_set_operation_mode(POWER_DOWN))<0)
+		ret=-1;
+	return ret;
+}
+
+static ssize_t isl29023_read(struct file *filp, char __user *buf, size_t count , loff_t *f_pos )
+{
+	u32 lux_value;	
+	debug("%s called",__func__);	
+	isl29023_get_lux_value(&lux_value);
+	debug("lux_value =%d",lux_value);
+	put_user(lux_value,buf);
+	return 1;
+}
+
+static int isl29023_isr( int irq, void *unused )
+{
+	//TBD
+	debug("%s called",__func__);
+	return 0;
+}
+
+#ifdef USE_ISL29023_IOCTLS 
+static int isl29023_ioctl(struct inode *inode, struct file *filp, 
+	                        unsigned int ioctl_cmd,  unsigned long arg)
+{	int ret = 0;
+	void __user *argp = (void __user *)arg;   
+	
+	if( _IOC_TYPE(ioctl_cmd) != ISL29023_LIGHT_IOC_MAGIC )
+    {
+        debug("Wrong _IOC_TYPE 0x%x",ioctl_cmd);
+        return -ENOTTY;
+    }
+    if( _IOC_NR(ioctl_cmd) > ISL29023_LIGHT_IOC_NR_MAX )
+    {
+        debug("Wrong _IOC_NR 0x%x",ioctl_cmd);	
+        return -ENOTTY;
+    }
+	switch (ioctl_cmd)
+    {
+        case ISL29023_LIGHT_IOC_SET_OPERATION_MODE:
+			{
+				u8 mode;
+				debug("ISL29023_LIGHT_IOC_SET_OPERATION_MODE called");	
+				
+				if(copy_from_user((void*) &mode, argp, sizeof(u8)))        	   	 
+        	   	       ret = -EFAULT;        	   	   
+                else if( (ret = isl29023_set_operation_mode(mode)) < 0 )        		
+					debug("ISL29023_LIGHT_IOC_SET_OPERATION_MODE failed"); 			
+				break;
+			}
+        case ISL29023_LIGHT_IOC_SET_LUX_RANGE:			
+			{
+				u32 range;
+				debug("ISL29023_LIGHT_IOC_SET_LUX_RANGE called");	
+				
+				if(copy_from_user((void*) &range, argp, sizeof(u32)))        	   	 
+        	   	       ret = -EFAULT;        	   	   
+                else if( (ret = isl29023_set_lux_range(range)) < 0 )       			
+					debug("ISL29023_LIGHT_IOC_SET_LUX_RANGE failed"); 			
+				break;
+			}
+		case ISL29023_LIGHT_IOC_SET_ADC_RESOLUTION:
+			{
+				u8 resol;				debug("ISL29023_LIGHT_IOC_SET_ADC_RESOLUTION called");	
+				
+				if(copy_from_user((void*) &resol, argp, sizeof(u8)))        	   	 
+        	   	       ret = -EFAULT;        	   	   
+                else if( (ret = isl29023_set_adc_resolution(resol)) < 0 )        
+					debug("ISL29023_LIGHT_IOC_SET_ADC_RESOLUTION failed"); 			
+				break;
+			}
+		case ISL29023_LIGHT_IOC_SET_INTERRUPT_PERSIST:
+			{
+				u8 persist;
+				debug("ISL29023_LIGHT_IOC_SET_INTERRUPT_PERSIST called");	
+			
+				if(copy_from_user((void*) &persist, argp, sizeof(u8)))        	   	 
+        	   	       ret = -EFAULT;        	   	   
+                else if( (ret = isl29023_set_interrupt_persist(persist)) < 0 )        	
+					debug("ISL29023_LIGHT_IOC_SET_INTERRUPT_PERSIST failed"); 			
+				break;
+			}		
+		case ISL29023_LIGHT_IOC_GET_OPERATION_MODE:
+			{
+				u8 mode;
+				debug("ISL29023_LIGHT_IOC_GET_OPERATION_MODE called");	
+		
+                if( (ret = isl29023_get_operation_mode(&mode)) < 0 )        
+					debug("ISL29023_LIGHT_IOC_GET_OPERATION_MODE failed");
+				else if(copy_to_user(argp, (void*) &mode, sizeof(u8)))    	   	 
+        	   	       ret = -EFAULT; 
+				break;
+			}
+		case ISL29023_LIGHT_IOC_GET_LUX_RANGE:
+			{
+				u32 range;
+				debug("ISL29023_LIGHT_IOC_GET_LUX_RANGE called");	
+			
+                if( (ret = isl29023_get_lux_range(&range)) < 0 )        
+					debug("ISL29023_LIGHT_IOC_GET_LUX_RANGE failed");
+				else if(copy_to_user(argp, (void*) &range, sizeof(u32)))    	   	 
+        	   	       ret = -EFAULT; 
+				break;
+			}
+		case ISL29023_LIGHT_IOC_GET_ADC_RESOLUTION:
+			{
+				u8 resol;
+				debug("ISL29023_LIGHT_IOC_GET_ADC_RESOLUTION called");	
+			
+                if( (ret = isl29023_get_adc_resolution(&resol)) < 0 )        
+					debug("ISL29023_LIGHT_IOC_GET_ADC_RESOLUTION failed");
+				else if(copy_to_user(argp, (void*) &resol, sizeof(u8)))    	   	 
+        	   	       ret = -EFAULT; 
+				break;
+			}
+		case ISL29023_LIGHT_IOC_GET_INTERRUPT_PERSIST:
+			{
+				u8 persist;
+				debug("ISL29023_LIGHT_IOC_GET_INTERRUPT_PERSIST called");	
+			
+                if( (ret = isl29023_get_interrupt_persist(&persist)) < 0 )        
+					debug("ISL29023_LIGHT_IOC_GET_INTERRUPT_PERSIST failed");
+				else if(copy_to_user(argp, (void*) &persist, sizeof(u8)))    	   	 
+        	   	       ret = -EFAULT; 
+				break;
+			}
+		case ISL29023_LIGHT_IOC_GET_LUX_VALUE:
+			{
+				u32 lux_value;
+				debug("ISL29023_LIGHT_IOC_GET_LUX_VALUE called");	
+				
+               			if( (ret = isl29023_get_lux_value(&lux_value)) < 0 )        
+				{
+					debug("ISL29023_LIGHT_IOC_GET_LUX_VALUE failed");
+				}
+				else
+				{
+					input_report_abs(isl29023_input_dev, ABS_MISC, lux_value );
+					input_report_abs(isl29023_input_dev, ABS_DISTANCE, lux_value );
+
+					input_sync(isl29023_input_dev);
+				}
+				break;
+			}
+		default:
+			debug("Unknown IOCTL command");
+            ret = -ENOTTY;
+            break;
+	}
+	return ret;
+}
+#endif
+
+/*sysfs -operation_mode*/
+static ssize_t isl29023_show_operation_mode(struct device *dev,struct device_attribute *attr, char *buf)
+{      
+		u8 mode;
+		isl29023_get_operation_mode(&mode);
+        return sprintf(buf, "%d\n", mode);
+}
+static ssize_t isl29023_store_operation_mode(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{      
+		int mode,ret;
+		ret=0;
+		sscanf(buf,"%d",&mode);
+		if(mode>=POWER_DOWN && mode <=IR_CONTINUOUS)
+		{
+			if((ret=isl29023_set_operation_mode((u8)mode))<0)
+				return ret;
+		}
+		else
+			return -EINVAL;
+		return count;
+}
+static DEVICE_ATTR(operation_mode, S_IRUGO | S_IWUGO, isl29023_show_operation_mode, isl29023_store_operation_mode);
+
+/*sysfs -lux_range*/
+static ssize_t isl29003_show_lux_range(struct device *dev,struct device_attribute *attr, char *buf)
+{      
+		u32 lux_range;
+		isl29023_get_lux_range(&lux_range);
+        return sprintf(buf, "%d\n", lux_range);
+}
+static ssize_t isl29003_store_lux_range(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{      
+		int lux_range,ret;
+		ret=0;
+		sscanf(buf,"%d",&lux_range);
+		if(lux_range>=LUX_RANGE_1 && lux_range<=LUX_RANGE_4)
+		{
+			if((ret=isl29023_set_lux_range((u32)lux_range))<0)
+				return ret;
+		}
+		else
+			return -EINVAL;
+		return count;
+}
+static DEVICE_ATTR(lux_range, S_IRUGO | S_IWUGO, isl29003_show_lux_range, isl29003_store_lux_range);
+
+/*sysfs -adc_resolution*/
+static ssize_t isl29003_show_adc_resolution(struct device *dev,struct device_attribute *attr, char *buf)
+{      
+		u8 adc_resol;
+		isl29023_get_adc_resolution(&adc_resol);
+        return sprintf(buf, "%d\n", adc_resol);
+}
+static ssize_t isl29003_store_adc_resolution(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{      
+		int adc_resol,ret;
+		ret=0;
+		sscanf(buf,"%d",&adc_resol);
+		if(adc_resol>=ADC_RESOLUTION_4 && adc_resol<=ADC_RESOLUTION_16)
+		{
+			if((ret=isl29023_set_adc_resolution((u8)adc_resol))<0)
+				return ret;
+		}
+		else
+			return -EINVAL;			
+		return count;
+}
+static DEVICE_ATTR(adc_resolution, S_IRUGO | S_IWUGO, isl29003_show_adc_resolution, isl29003_store_adc_resolution);
+
+/*sysfs -interrupt_persist*/
+static ssize_t isl29023_show_interrupt_persist(struct device *dev,struct device_attribute *attr, char *buf)
+{      
+		u8 persist;
+		isl29023_get_interrupt_persist(&persist);
+        return sprintf(buf, "%d\n", persist);
+}
+static ssize_t isl29023_store_interrupt_persist(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{      
+		int persist,ret;
+		ret=0;
+		sscanf(buf,"%d",&persist);
+		if(persist>=INTERRUPT_PERSIST_1 && persist<=INTERRUPT_PERSIST_16)
+		{
+			if((ret=isl29023_set_interrupt_persist((u8)persist))<0)
+				return ret;
+		}
+		else
+			return -EINVAL;
+		return count;
+}
+static DEVICE_ATTR(interrupt_persist, S_IRUGO | S_IWUGO, isl29023_show_interrupt_persist, isl29023_store_interrupt_persist);
+
+/*sysfs -lux_value*/
+static ssize_t isl29023_show_lux_value(struct device *dev,struct device_attribute *attr, char *buf)
+{   	
+		u32 lux_value;
+		isl29023_get_lux_value(&lux_value);		
+        return sprintf(buf, "%d\n", lux_value);	
+}
+static DEVICE_ATTR(lux_value, S_IRUGO, isl29023_show_lux_value,NULL);
+
+static struct attribute *isl29003_attributes[] = {
+        &dev_attr_operation_mode.attr,
+        &dev_attr_lux_range.attr,
+		&dev_attr_adc_resolution.attr,
+        &dev_attr_interrupt_persist.attr,
+        &dev_attr_lux_value.attr,
+        NULL
+};
+
+static const struct attribute_group isl29003_attr_group = {
+         .attrs = isl29003_attributes,
+ };
+
+/*For Factory Test Mode*/
+static ssize_t lightsensor_file_state_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+		u32 lux_value;
+		isl29023_get_lux_value(&lux_value);		
+        return sprintf(buf, "%d\n", lux_value);	
+}
+static DEVICE_ATTR(lightsensor_file_state, S_IRUGO, lightsensor_file_state_show,NULL);
+
+/* for light sensor on/off control from platform */
+static ssize_t lightsensor_file_cmd_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u8 mode;
+	isl29023_get_operation_mode(&mode);
+	if(mode==POWER_DOWN)
+		light_enable = OFF;
+	else if(mode==ALS_CONTINUOUS)
+		light_enable = ON;
+	return sprintf(buf, "%d\n", light_enable);
+}
+static ssize_t lightsensor_file_cmd_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int mode,ret;
+	ret=0;
+	sscanf(buf,"%d",&mode);
+	if(mode>=POWER_DOWN && mode <=IR_CONTINUOUS)
+	{
+		switch(mode)
+		{
+			case 0:
+				ret=isl29023_set_operation_mode(POWER_DOWN);					
+				break;
+			case 1:
+				ret=isl29023_set_operation_mode(ALS_CONTINUOUS);					
+				break;
+			default:
+				break;
+		}
+		if(ret<0)
+			return ret;
+	}
+	else
+		return -EINVAL;
+	return count;		
+}
+static DEVICE_ATTR(lightsensor_file_cmd, S_IRUGO | S_IWUGO, lightsensor_file_cmd_show, lightsensor_file_cmd_store);
+
+
+int __init isl29023_drv_init(void)
+{
+	int ret =0;
+	debug("%s called",__func__);
+	/*misc device registration*/
+    if( (ret = misc_register(&isl29023_misc_device)) < 0 )
+    {
+        error("isl29023_drv_init misc_register failed");
+        return ret; 	  	
+    }
+	
+	/*mutex initialisation*/
+	isl29023_dev_mutex_init();	
+
+	/* set sysfs for light sensor test mode*/
+	lightsensor_class = class_create(THIS_MODULE, "lightsensor");
+	if (IS_ERR(lightsensor_class))
+	{
+		debug("Failed to create class(lightsensor)!\n");
+		goto FREE_IRQ;
+	}
+	switch_cmd_dev = device_create(lightsensor_class, NULL, 0, NULL, "switch_cmd");
+	if (IS_ERR(switch_cmd_dev))
+	{
+		debug("Failed to create device(switch_cmd_dev)!\n");
+		goto DESTROY_CLASS;
+	}
+	if (device_create_file(switch_cmd_dev, &dev_attr_lightsensor_file_cmd) < 0)
+	{
+		debug("Failed to create device file(%s)!\n", dev_attr_lightsensor_file_cmd.attr.name);
+		goto DESTROY_DEVICE;
+	}
+	if (device_create_file(switch_cmd_dev, &dev_attr_lightsensor_file_state) < 0)
+	{
+		debug("Failed to create device file(%s)!\n", dev_attr_lightsensor_file_state.attr.name);
+		device_remove_file(switch_cmd_dev, &dev_attr_lightsensor_file_cmd);
+		goto DESTROY_DEVICE;
+	}
+	
+
+	//input-device initialisation
+	isl29023_input_dev = input_allocate_device();
+	set_bit(EV_ABS, isl29023_input_dev->evbit);
+	set_bit(ABS_MISC, isl29023_input_dev->absbit);
+	set_bit(ABS_DISTANCE, isl29023_input_dev->absbit);
+
+	isl29023_input_dev->name = "isl29023_light";
+
+	input_set_abs_params(isl29023_input_dev, ABS_MISC, 0, 30000, 0, 0);
+	input_set_abs_params(isl29023_input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+	
+	ret = input_register_device(isl29023_input_dev);
+  	if (ret)
+	{
+    		printk("Light/Proximity Sensor couldn't be registered as input device: %d\n", ret);
+    		goto release_input_dev;
+  	}
+
+
+	/*create sysfs attributes*/
+	ret = sysfs_create_group(&isl29023_misc_device.this_device->kobj, &isl29003_attr_group);
+    if (ret)
+    {
+		printk("Failed to create sysfs attributes");
+		goto REMOVE_DEVICE_FILE;
+	}
+	
+	if ( (ret = isl29023_i2c_init() < 0) ) 
+    {
+		goto REMOVE_SYSFS_ATTRS;
+    }
+	return ret;
+	
+REMOVE_SYSFS_ATTRS:
+	sysfs_remove_group(&isl29023_misc_device.this_device->kobj, &isl29003_attr_group);
+release_input_dev:
+	input_free_device(isl29023_input_dev);
+REMOVE_DEVICE_FILE:
+	device_remove_file(switch_cmd_dev, &dev_attr_lightsensor_file_state);
+	device_remove_file(switch_cmd_dev, &dev_attr_lightsensor_file_cmd);
+DESTROY_DEVICE:
+	device_destroy(lightsensor_class,0);
+DESTROY_CLASS:
+	class_destroy(lightsensor_class);
+FREE_IRQ:
+	// free_irq(LIGHTSENSOR_IRQ,NULL);
+MISC_DREG:
+	misc_deregister(&isl29023_misc_device);
+	return ret;
+}
+
+void __init isl29023_drv_exit(void)
+{	debug("%s called",__func__);	
+	isl29023_i2c_exit();
+	sysfs_remove_group(&isl29023_misc_device.this_device->kobj, &isl29003_attr_group);
+	device_remove_file(switch_cmd_dev, &dev_attr_lightsensor_file_state);
+	device_remove_file(switch_cmd_dev, &dev_attr_lightsensor_file_cmd);
+	device_destroy(lightsensor_class,0);
+	class_destroy(lightsensor_class);
+	// free_irq(LIGHTSENSOR_IRQ,NULL);
+	misc_deregister(&isl29023_misc_device);
+}
+module_init(isl29023_drv_init);
+module_exit(isl29023_drv_exit);			
+
+MODULE_AUTHOR("V.N.V.Srikanth, SAMSUNG ELECTRONICS, vnv.srikanth@samsung.com");
+MODULE_DESCRIPTION("Ambient Light Sensor driver for ISL29023");
+MODULE_LICENSE("GPL"); 
Index: android-2.6.35/drivers/sensors/optical/isl29023.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023.h	2010-12-22 14:36:40.281987881 +0530
@@ -0,0 +1,42 @@
+#ifndef __ISL29023_H__
+#define __ISL29023_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#define LIGHTSENSOR_IRQ 		IRQ_EINT2
+//#define ISL29023_DEBUG
+
+#define USE_ISL29023_IOCTLS
+
+#define error(fmt,arg...) printk(fmt "\n",## arg)
+
+#ifdef ISL29023_DEBUG
+#define debug(fmt,arg...) printk("--------" fmt "\n",## arg)
+#else
+#define debug(fmt,arg...)
+#endif
+
+/* Light Sensor Power Control */
+#define ON              1
+#define OFF				0
+
+#ifdef USE_ISL29023_IOCTLS
+/*IOCTLS*/
+/*magic no*/
+#define ISL29023_LIGHT_IOC_MAGIC  		0xEE
+/*max seq no*/
+#define ISL29023_LIGHT_IOC_NR_MAX 		9
+
+#define ISL29023_LIGHT_IOC_SET_OPERATION_MODE         		_IOW(ISL29023_LIGHT_IOC_MAGIC, 0,u8)
+#define ISL29023_LIGHT_IOC_SET_LUX_RANGE         		_IOW(ISL29023_LIGHT_IOC_MAGIC, 1,u32)
+#define ISL29023_LIGHT_IOC_SET_ADC_RESOLUTION       		_IOW(ISL29023_LIGHT_IOC_MAGIC, 2,u8)
+#define ISL29023_LIGHT_IOC_SET_INTERRUPT_PERSIST      		_IOW(ISL29023_LIGHT_IOC_MAGIC, 3,u8)
+#define ISL29023_LIGHT_IOC_GET_OPERATION_MODE         		_IOR(ISL29023_LIGHT_IOC_MAGIC, 4,u8)
+#define ISL29023_LIGHT_IOC_GET_LUX_RANGE         		_IOR(ISL29023_LIGHT_IOC_MAGIC, 5,u32)
+#define ISL29023_LIGHT_IOC_GET_ADC_RESOLUTION       		_IOR(ISL29023_LIGHT_IOC_MAGIC, 6,u8)
+#define ISL29023_LIGHT_IOC_GET_INTERRUPT_PERSIST      		_IOR(ISL29023_LIGHT_IOC_MAGIC, 7,u8)
+#define ISL29023_LIGHT_IOC_GET_LUX_VALUE			_IOR(ISL29023_LIGHT_IOC_MAGIC, 8,u32)
+#endif
+
+#endif
Index: android-2.6.35/drivers/sensors/optical/isl29023_func.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023_func.c	2010-12-22 14:36:03.913238838 +0530
@@ -0,0 +1,494 @@
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include <plat/irqs.h>
+#include <mach/gpio.h>
+#include "isl29023.h"
+#include "isl29023_i2c.h"
+#include "isl29023_func.h"
+
+
+int isl29023_set_operation_mode(u8);
+int isl29023_set_lux_range(u32);
+int isl29023_set_adc_resolution(u8);
+int isl29023_set_interrupt_persist(u8);
+int isl29023_clear_irq_status(void);
+int isl29023_get_operation_mode(u8*);
+int isl29023_get_lux_range(u32*);
+int isl29023_get_adc_resolution(u8*);
+int isl29023_get_interrupt_persist(u8*);
+int isl29023_get_lux_value(u32*);
+
+static isl29023_dev  dev;
+
+
+int isl29023_dev_init(struct i2c_client *client)
+{
+	int reg;
+	int ret = 0;
+
+	debug("%s called", __func__);
+
+	dev.client = client;
+
+	/* Resetting the registers array */
+	for(reg = 0; reg < 8; reg++)
+		dev.registers[reg] = 0;
+
+	/* Device intialisations */
+	if((ret = isl29023_set_operation_mode(ALS_CONTINUOUS)) < 0) {
+		debug("isl29023_set_operation_mode failed");
+		goto EXIT;
+	}
+
+	if((ret = isl29023_set_lux_range(LUX_RANGE_4)) < 0) {
+		debug("isl29023_set_lux_range failed");
+		goto EXIT;
+	}
+
+	if((ret = isl29023_set_adc_resolution(ADC_RESOLUTION_16))<0) {
+		debug("isl29023_set_adc_resolution failed");
+		goto EXIT;
+	}
+
+	if((ret = isl29023_set_interrupt_persist(INTERRUPT_PERSIST_4)) < 0) {
+		debug("isl29023_set_interrupt_persist failed");
+		goto EXIT;
+	}
+
+EXIT:
+	return ret;
+}
+
+void isl29023_dev_exit(void)
+{
+	dev.client = NULL;
+}
+
+void isl29023_dev_mutex_init(void)
+{
+	mutex_init(&(dev.mutex_lock));
+}
+
+int isl29023_set_operation_mode(u8 mode)
+{
+	int ret = 0;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	switch(mode) {
+	case POWER_DOWN:
+		debug("POWER_DOWN");
+		COMMAND1_SET_POWER_DOWN(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.op_mode=POWER_DOWN;
+		break;
+
+	case ALS_ONCE:
+		debug("ALS_ONCE");
+		COMMAND1_SET_ALS_ONCE(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.op_mode=ALS_ONCE;
+		break;
+
+	case IR_ONCE:
+		debug("IR_ONCE");
+		COMMAND1_SET_IR_ONCE(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.op_mode=IR_ONCE;
+		break;
+
+	case ALS_CONTINUOUS:
+		debug("ALS_CONTINUOUS");
+		COMMAND1_SET_ALS_CONTINUOUS(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.op_mode=ALS_CONTINUOUS;
+		break;
+
+	case IR_CONTINUOUS:
+		debug("IR_CONTINUOUS");
+		COMMAND1_SET_IR_CONTINUOUS(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.op_mode=IR_CONTINUOUS;
+		break;
+
+	default:
+		debug("Wrong Operation mode called");
+		ret = -EINVAL;
+		goto EXIT;
+	}
+
+	if ((ret = isl29023_i2c_write(dev.client, ISL_REG_COMMAND1, dev.registers[ISL_REG_COMMAND1])) < 0)
+		debug("isl29023_i2c_write failed %s",__func__);
+
+EXIT:
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_set_lux_range(u32 range)
+{
+	int ret = 0;
+
+	debug("%s called", __func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	switch(range) {
+	case LUX_RANGE_1:
+		debug("LUX_RANGE_1");
+		COMMAND2_SET_LUX_RANGE_1(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.lux_range=LUX_RANGE_1;
+		break;
+
+	case LUX_RANGE_2:
+		debug("LUX_RANGE_2");
+		COMMAND2_SET_LUX_RANGE_2(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.lux_range=LUX_RANGE_2;
+		break;
+
+	case LUX_RANGE_3:
+		debug("LUX_RANGE_3");
+		COMMAND2_SET_LUX_RANGE_3(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.lux_range=LUX_RANGE_3;
+		break;
+
+	case LUX_RANGE_4:
+		debug("LUX_RANGE_4");
+		COMMAND2_SET_LUX_RANGE_4(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.lux_range=LUX_RANGE_4;
+		break;
+
+	default:
+		debug("Wrong Lux Range value");
+		ret = -EINVAL;
+		goto EXIT;
+	}
+
+	if ((ret = isl29023_i2c_write(dev.client, ISL_REG_COMMAND2, dev.registers[ISL_REG_COMMAND2])) < 0)
+		debug("isl29023_i2c_write failed %s",__func__);
+
+EXIT:
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_set_adc_resolution(u8 resol)
+{
+	int ret = 0;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	switch(resol) {
+	case ADC_RESOLUTION_4:
+		debug("ADC_RESOLUTION_4");
+		COMMAND2_SET_ADC_RESOLUTION_4(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.adc_resol=ADC_RESOLUTION_4;
+		break;
+
+	case ADC_RESOLUTION_8:
+		debug("ADC_RESOLUTION_8");
+		COMMAND2_SET_ADC_RESOLUTION_8(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.adc_resol=ADC_RESOLUTION_8;
+		break;
+
+	case ADC_RESOLUTION_12:
+		debug("ADC_RESOLUTION_12");
+		COMMAND2_SET_ADC_RESOLUTION_12(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.adc_resol=ADC_RESOLUTION_12;
+		break;
+
+	case ADC_RESOLUTION_16:
+		debug("ADC_RESOLUTION_16");
+		COMMAND2_SET_ADC_RESOLUTION_16(&(dev.registers[ISL_REG_COMMAND2]));
+		dev.state.adc_resol=ADC_RESOLUTION_16;
+		break;
+
+	default:
+		debug("Wrong ADC Resolution value");
+		ret= -EINVAL;
+		goto EXIT;
+	}
+
+	if ((ret = isl29023_i2c_write(dev.client, ISL_REG_COMMAND2, dev.registers[ISL_REG_COMMAND2])) < 0)
+		debug("isl29023_i2c_write failed %s",__func__);
+
+EXIT:
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_set_interrupt_persist(u8 persist)
+{
+	int ret = 0;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	switch(persist) {
+	case INTERRUPT_PERSIST_1:
+		debug("INTERRUPT_PERSIST_1");
+		COMMAND1_SET_INTERRUPT_PERSIST_1(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.interrupt_persist=INTERRUPT_PERSIST_1;
+		break;
+
+	case INTERRUPT_PERSIST_4:
+		debug("INTERRUPT_PERSIST_4");
+		COMMAND1_SET_INTERRUPT_PERSIST_4(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.interrupt_persist=INTERRUPT_PERSIST_4;
+		break;
+
+	case INTERRUPT_PERSIST_8:
+		debug("INTERRUPT_PERSIST_8");
+		COMMAND1_SET_INTERRUPT_PERSIST_8(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.interrupt_persist=INTERRUPT_PERSIST_8;
+		break;
+
+	case INTERRUPT_PERSIST_16:
+		debug("INTERRUPT_PERSIST_16");
+		COMMAND1_SET_INTERRUPT_PERSIST_16(&(dev.registers[ISL_REG_COMMAND1]));
+		dev.state.interrupt_persist=INTERRUPT_PERSIST_16;
+		break;
+
+	default:
+		debug("Wrong Interrupt Persist value");
+		ret = -EINVAL;
+		goto EXIT;
+	}
+
+	if ((ret = isl29023_i2c_write(dev.client, ISL_REG_COMMAND1, dev.registers[ISL_REG_COMMAND1])) < 0)
+		debug("isl29023_i2c_write failed %s",__func__);
+
+EXIT:
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_clear_irq_status(void)
+{
+	int ret = 0;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	COMMAND1_CLEAR_INTERRUPT_STATUS(&dev.registers[ISL_REG_COMMAND1]);
+	if ((ret = isl29023_i2c_write(dev.client, ISL_REG_COMMAND1, (dev.registers[ISL_REG_COMMAND1]))) < 0)
+		debug("isl29023_i2c_write failed %s",__func__);
+
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_get_lux_value(u32* lux_value)
+{
+	int ret = 0;
+	u8 adc_lsb;
+	u8 adc_msb;
+	u16 adc_data;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	msleep(100); /*Time for ADC Conversion*/
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_DATA_LSB, &adc_lsb)) < 0)
+		debug("isl29023_i2c_read 1 failed %s",__func__);
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_DATA_MSB, &adc_msb)) < 0)
+		debug("isl29023_i2c_read 2 failed %s",__func__);
+
+	debug("msb=%x,lsb=%x", adc_msb, adc_lsb);
+	adc_data = adc_msb<<8|adc_lsb;
+	debug("adc_data=%x,adc_resol=%d,lux_range=%d", adc_msb<<8|adc_lsb,
+			dev.state.adc_resol, dev.state.lux_range);
+	*lux_value = (adc_data*dev.state.lux_range)>>dev.state.adc_resol;
+
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+
+int isl29023_get_operation_mode(u8* mode)
+{
+	int ret = 0;
+	u8 temp;
+
+	debug("%s called",__func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_COMMAND1, &temp)) < 0)
+		debug("isl29023_i2c_read  failed %s",__func__);
+
+	temp = (REG0_OPM_MASK&temp)>>REG0_OPM_SHIFT;
+	//temp = (REG0_OPM_MASK&dev.registers[ISL_REG_COMMAND1])>>REG0_OPM_SHIFT;
+	switch(temp) {
+	case 0:
+		debug("Device is in POWER_DOWN mode");
+		*mode = POWER_DOWN;
+		break;
+
+	case 1:
+		debug("Device is in ALS_ONCE mode");
+		*mode = ALS_ONCE;
+		break;
+
+	case 2:
+		debug("Device is in IR_ONCE mode");
+		*mode = IR_ONCE;
+		break;
+
+	case 5:
+		debug("Device is in ALS_CONTINUOUS mode");
+		*mode = ALS_CONTINUOUS;
+		break;
+
+	case 6:
+		debug("Device is in IR_CONTINUOUS mode");
+		*mode = IR_CONTINUOUS;
+		break;
+
+	default:
+		debug("Unknown Operation Mode");
+		*mode = 0xFF;
+		break;
+	}
+
+	debug("mode=%d",*mode);
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_get_lux_range(u32* range)
+{
+	int ret = 0;
+	u8 temp;
+
+	debug("%s called", __func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_COMMAND2, &temp)) < 0)
+		debug("isl29023_i2c_read  failed %s",__func__);
+
+	temp = (REG1_RANGE_MASK&temp) >> REG1_RANGE_SHIFT;
+	//temp = (REG1_RANGE_MASK&dev.registers[ISL_REG_COMMAND2])>>REG1_RANGE_SHIFT;
+	switch(temp) {
+	case 0 :
+		debug("Lux Range is 1000");
+		*range = LUX_RANGE_1;
+		break;
+
+	case 1:
+		debug("Lux Range is 4000");
+		*range = LUX_RANGE_2;
+		break;
+
+	case 2:
+		debug("Lux Range is 16000");
+		*range = LUX_RANGE_3;
+		break;
+
+	case 3:
+		debug("Lux Range is 64000");
+		*range = LUX_RANGE_4;
+		break;
+
+	default:
+		debug("Unknown Lux Range");
+		*range = 0xFFFF;
+		break;
+	}
+
+	debug("range=%d", *range);
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_get_adc_resolution(u8* resol)
+{
+	int ret = 0;
+	u8 temp;
+
+	debug("%s called", __func__);
+	mutex_lock(&(dev.mutex_lock));
+
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_COMMAND2, &temp)) < 0)
+		debug("isl29023_i2c_read  failed %s", __func__);
+
+	temp = (REG1_ADC_MASK&temp) >> REG1_ADC_SHIFT;
+	//temp = (REG1_ADC_MASK&dev.registers[ISL_REG_COMMAND2])>>REG1_ADC_SHIFT;
+	switch(temp) {
+	case 0 :
+		debug("ADC Resolution is 16");
+		*resol = ADC_RESOLUTION_16;
+		break;
+
+	case 1:
+		debug("ADC Resolution is 12");
+		*resol = ADC_RESOLUTION_12;
+		break;
+
+	case 2:
+		debug("ADC Resolution is 8");
+		*resol = ADC_RESOLUTION_8;
+		break;
+
+	case 3:
+		debug("ADC Resolution is 4");
+		*resol = ADC_RESOLUTION_4;
+		break;
+
+	default:
+		debug("Unknown ADC Resolution");
+		*resol = 0xFF;
+		break;
+	}
+
+	debug("resol=%d", *resol);
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
+int isl29023_get_interrupt_persist(u8* persist)
+{
+	int ret = 0;
+	u8 temp;
+
+	debug("%s called", __func__);
+	mutex_lock(&(dev.mutex_lock));
+	if ((ret = isl29023_i2c_read(dev.client, ISL_REG_COMMAND1, &temp)) < 0)
+		debug("isl29023_i2c_read  failed %s",__func__);
+
+	temp = (REG0_INT_PERSIST_MASK&temp)>>REG0_INT_PERSIST_SHIFT;
+	//temp = (REG0_INT_PERSIST_MASK&dev.registers[ISL_REG_COMMAND1])>>REG0_INT_PERSIST_SHIFT;
+	switch(temp) {
+	case 0 :
+		debug("Interrupt Persist is 1 integration cycle");
+		*persist = INTERRUPT_PERSIST_1;
+		break;
+
+	case 1:
+		debug("Interrupt Persist is 4 integration cycle");
+		*persist = INTERRUPT_PERSIST_4;
+		break;
+
+	case 2:
+		debug("Interrupt Persist is 8 integration cycle");
+		*persist = INTERRUPT_PERSIST_8;
+		break;
+
+	case 3:
+		debug("Interrupt Persist is 16 integration cycle");
+		*persist = INTERRUPT_PERSIST_16;
+		break;
+
+	default:
+		debug("Unknown Interrupt Persist value");
+		*persist = 0xFF;
+		break;
+	}
+
+	debug("persist=%d", *persist);
+	mutex_unlock(&(dev.mutex_lock));
+	return ret;
+}
+
Index: android-2.6.35/drivers/sensors/optical/isl29023_func.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023_func.h	2010-12-22 14:36:03.913238838 +0530
@@ -0,0 +1,160 @@
+#ifndef __ISL29023_DEV_H
+#define __ISL29023_DEV_H
+
+#include "isl29023_regs.h"
+
+/*Operation Modes*/
+#define POWER_DOWN		0
+#define ALS_ONCE		1
+#define IR_ONCE			2
+#define ALS_CONTINUOUS		3
+#define IR_CONTINUOUS		4
+
+/*Interrupt Persist modes*/
+#define INTERRUPT_PERSIST_1	1
+#define INTERRUPT_PERSIST_4	4
+#define INTERRUPT_PERSIST_8	8
+#define INTERRUPT_PERSIST_16	16
+
+/* LUX Range/FSR */
+#define LUX_RANGE_1		1000
+#define LUX_RANGE_2		4000
+#define LUX_RANGE_3		16000
+#define LUX_RANGE_4		64000
+
+
+/* ADC Resolution/Width */
+#define ADC_RESOLUTION_4	4
+#define ADC_RESOLUTION_8	8
+#define ADC_RESOLUTION_12	12
+#define ADC_RESOLUTION_16	16
+
+typedef struct
+{
+	u8 op_mode;
+	u16 lux_range;
+	u16 adc_resol;
+	u8 interrupt_persist;
+} isl29023_dev_state;
+
+typedef struct
+{
+	struct i2c_client *client;
+	struct mutex mutex_lock;
+	isl29023_dev_state state;
+	u8 registers[8];		/*NUM_OF_REGS=8*/
+} isl29023_dev;
+
+extern int isl29023_dev_init(struct i2c_client *client);
+extern void isl29023_dev_exit(void);
+extern void isl29023_dev_mutex_init(void);
+
+extern int isl29023_set_operation_mode(u8);
+extern int isl29023_set_lux_range(u32);
+extern int isl29023_set_adc_resolution(u8);
+extern int isl29023_set_interrupt_persist(u8);
+extern int isl29023_clear_irq_status(void);
+
+extern int isl29023_get_operation_mode(u8*);
+extern int isl29023_get_lux_range(u32*);
+extern int isl29023_get_adc_resolution(u8*);
+extern int isl29023_get_interrupt_persist(u8*);
+
+extern int isl29023_get_lux_value(u32*);
+
+static inline void COMMAND1_SET_POWER_DOWN(u8 *reg)
+{
+	*reg &= ~REG0_OPM_MASK;
+	*reg |= REG0_OPM_POWERDOWN;
+}
+static inline void COMMAND1_SET_ALS_ONCE(u8 *reg)
+{
+	*reg &= ~REG0_OPM_MASK;
+	*reg |= REG0_OPM_ALSONCE;
+}
+static inline void COMMAND1_SET_IR_ONCE(u8 *reg)
+{
+	*reg &= ~REG0_OPM_MASK;
+	*reg |= REG0_OPM_IRONCE;
+}
+static inline void COMMAND1_SET_ALS_CONTINUOUS(u8* reg)
+{
+	*reg &= ~REG0_OPM_MASK;
+	*reg |= REG0_OPM_ALSCONTINUOUS;
+}
+static inline void COMMAND1_SET_IR_CONTINUOUS(u8* reg)
+{
+	*reg &= ~REG0_OPM_MASK;
+	*reg |= REG0_OPM_IRCONTINUOUS;
+}
+
+static inline void COMMAND1_SET_INTERRUPT_PERSIST_1(u8 *reg)
+{
+	*reg &= ~REG0_INT_PERSIST_MASK;
+	*reg |= REG0_INT_PERSIST_1;
+}
+static inline void COMMAND1_SET_INTERRUPT_PERSIST_4(u8 *reg)
+{
+	*reg &= ~REG0_INT_PERSIST_MASK;
+	*reg |= REG0_INT_PERSIST_4;
+}
+static inline void COMMAND1_SET_INTERRUPT_PERSIST_8(u8 *reg)
+{
+	*reg &= ~REG0_INT_PERSIST_MASK;
+	*reg |= REG0_INT_PERSIST_8;
+}
+static inline void COMMAND1_SET_INTERRUPT_PERSIST_16(u8 *reg)
+{
+	*reg &= ~REG0_INT_PERSIST_MASK;
+	*reg |= REG0_INT_PERSIST_16;
+}
+
+static inline void COMMAND1_CLEAR_INTERRUPT_STATUS(u8 *reg)
+{
+	*reg &= ~REG0_FLAG_MASK;
+	*reg |= REG0_FLAG_CLEARED;
+}
+
+static inline void COMMAND2_SET_LUX_RANGE_1(u8* reg)
+{
+	*reg &= ~REG1_RANGE_MASK;
+	*reg |= REG1_RANGE_1;
+}
+static inline void COMMAND2_SET_LUX_RANGE_2(u8* reg)
+{
+	*reg &= ~REG1_RANGE_MASK;
+	*reg |= REG1_RANGE_2;
+}
+static inline void COMMAND2_SET_LUX_RANGE_3(u8* reg)
+{
+	*reg &= ~REG1_RANGE_MASK;
+	*reg |= REG1_RANGE_3;
+}
+static inline void COMMAND2_SET_LUX_RANGE_4(u8* reg)
+{
+	*reg &= ~REG1_RANGE_MASK;
+	*reg |= REG1_RANGE_4;
+}
+
+static inline void COMMAND2_SET_ADC_RESOLUTION_4(u8* reg)
+{
+	*reg &= ~REG1_ADC_MASK;
+	*reg |= REG1_ADC_4;
+}
+static inline void COMMAND2_SET_ADC_RESOLUTION_8(u8* reg)
+{
+	*reg &= ~REG1_ADC_MASK;
+	*reg |= REG1_ADC_8;
+}
+static inline void COMMAND2_SET_ADC_RESOLUTION_12(u8* reg)
+{
+	*reg &= ~REG1_ADC_MASK;
+	*reg |= REG1_ADC_12;
+}
+static inline void COMMAND2_SET_ADC_RESOLUTION_16(u8* reg)
+{
+	*reg &= ~REG1_ADC_MASK;
+	*reg |= REG1_ADC_16;
+}
+
+#endif
Index: android-2.6.35/drivers/sensors/optical/isl29023_i2c.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023_i2c.c	2010-12-22 14:36:03.913238838 +0530
@@ -0,0 +1,150 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+
+#include "isl29023.h"
+#include "isl29023_func.h"
+
+#define LIGHTSENSOR_I2C_ADDR	0x88
+
+int isl29023_i2c_read(struct i2c_client *, u8 , u8 *);
+int isl29023_i2c_write(struct i2c_client *, u8 , u8);
+
+static int isl29023_probe(struct i2c_client *,const struct i2c_device_id *);
+static int __devexit isl29023_remove(struct i2c_client *);
+static int isl29023_suspend(struct i2c_client *, pm_message_t);
+static int isl29023_resume(struct i2c_client *);
+
+static struct i2c_client* isl29023_i2c_client;
+static struct i2c_driver isl29023_i2c_driver;
+
+static const struct i2c_device_id isl29023_ids[] = {
+	{ "isl29023", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, isl29023_ids);
+
+static struct i2c_driver isl29023_i2c_driver =
+{
+	.driver	= {
+		.name	= "isl29023_driver",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= isl29023_probe,
+	.remove		= __devexit_p(isl29023_remove),
+	.suspend	= &isl29023_suspend,
+	.resume		= &isl29023_resume,
+	.id_table	= isl29023_ids,
+};
+
+
+static int isl29023_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	int ret = 0;
+	printk("----- %s %d\n", __func__, __LINE__);
+
+	isl29023_i2c_client = client;
+	/*Device Initialisation*/
+	ret = isl29023_dev_init(isl29023_i2c_client);
+	return ret;
+}
+
+static int __devexit isl29023_remove(struct i2c_client *client)
+{
+	isl29023_set_operation_mode(POWER_DOWN);
+	isl29023_i2c_client = NULL;
+	isl29023_dev_exit();
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int isl29023_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret = 0;
+
+	debug("%s called", __func__);
+	if ((ret = isl29023_set_operation_mode(POWER_DOWN)) < 0)
+		ret = -1;
+	return ret;
+}
+
+static int isl29023_resume(struct i2c_client *client)
+{
+	int ret = 0;
+
+	debug("%s called", __func__);
+	if ((ret = isl29023_set_operation_mode(ALS_CONTINUOUS)) < 0)
+		ret = -1;
+
+	return ret;
+}
+#else
+#define isl29023_suspend	NULL
+#define	isl29023_resume		NULL
+#endif
+
+int isl29023_i2c_init(void)
+{
+	int ret = 0;
+	debug("%s called", __func__);
+	if ( (ret = i2c_add_driver(&isl29023_i2c_driver) < 0) ) {
+		error("isl29023_i2c_init failed");
+	}
+
+	return ret;
+}
+
+void isl29023_i2c_exit(void)
+{
+	debug("%s called", __func__);
+	i2c_del_driver(&isl29023_i2c_driver);
+}
+
+int isl29023_i2c_read(struct i2c_client *client, u8 reg, u8 *value)
+{
+	struct i2c_msg msg[2];
+	int count =0;
+	int ret = 0;
+
+	msg[0].addr	= client->addr;
+	msg[0].flags	= 0;
+	msg[0].len	= 1;
+	msg[0].buf	= &reg;
+	count = i2c_transfer(client->adapter,msg,1);
+
+	if(count==1) {
+		msg[0].addr	= client->addr;
+		msg[0].flags	= I2C_M_RD;
+		msg[0].len	= 1;
+		msg[0].buf	= value;
+		count = i2c_transfer(client->adapter, msg, 1);
+		if(count !=1)
+			ret =-1;
+	} else
+		ret =-1;
+
+	return ret;
+}
+
+int isl29023_i2c_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	struct i2c_msg msg[1];
+	u8 data[2];
+	int count = 0;
+	int ret = 0;
+
+	data[0] = reg;
+	data[1] = value;
+
+	msg[0].addr	= client->addr;
+	msg[0].flags	= 0;
+	msg[0].len	= 2;
+	msg[0].buf	= data;
+
+	count = i2c_transfer(client->adapter, msg, 1);
+	if(count !=1)
+		ret =-1;
+
+	return ret;
+}
+
Index: android-2.6.35/drivers/sensors/optical/isl29023_i2c.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023_i2c.h	2010-12-22 14:36:03.913238838 +0530
@@ -0,0 +1,9 @@
+#ifndef __ISL29023_I2C_H
+#define __ISL29023_I2C_H
+
+extern int isl29023_i2c_read(struct i2c_client*, u8 , u8*);
+extern int isl29023_i2c_write(struct i2c_client*, u8 , u8);
+extern int isl29023_i2c_init(void);
+extern void isl29023_i2c_exit(void);
+
+#endif
Index: android-2.6.35/drivers/sensors/optical/isl29023_regs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/isl29023_regs.h	2010-12-22 14:36:03.913238838 +0530
@@ -0,0 +1,63 @@
+#ifndef __ISL29023_REGS_H__
+#define __ISL29023_REGS_H__
+
+/*ISL29023 Register Addresses*/
+#define ISL_REG_COMMAND1	0x00
+#define ISL_REG_COMMAND2	0x01
+#define ISL_REG_DATA_LSB	0x02
+#define ISL_REG_DATA_MSB	0x03
+#define ISL_REG_INT_LT_LSB	0x04
+#define ISL_REG_INT_LT_MSB	0x05
+#define ISL_REG_INT_HT_LSB	0x06
+#define ISL_REG_INT_HT_MSB	0x07
+
+/*=======================================================
+	Register 00h - Command1 Register
+=========================================================*/
+/*Bits 7:5,these 3 bits determine the operation mode of the device*/
+#define REG0_OPM_MASK		0xE0
+#define REG0_OPM_SHIFT		5
+#define REG0_OPM_POWERDOWN	(0x0 << REG0_OPM_SHIFT)
+#define REG0_OPM_ALSONCE	(0x1 << REG0_OPM_SHIFT)
+#define REG0_OPM_IRONCE		(0x2 << REG0_OPM_SHIFT)
+#define REG0_OPM_RESERVED	(0x4 << REG0_OPM_SHIFT)
+#define REG0_OPM_ALSCONTINUOUS	(0x5 << REG0_OPM_SHIFT)
+#define REG0_OPM_IRCONTINUOUS	(0x6 << REG0_OPM_SHIFT)
+
+/*	Bit 2, interrupt status bit
+ * 	0 Interrupt is cleared or not triggered
+ *	1 Interrupt is triggered
+ */
+#define REG0_FLAG_MASK		0x04
+#define REG0_FLAG_SHIFT		2
+#define REG0_FLAG_CLEARED	(0x0 << REG0_FLAG_SHIFT)
+#define REG0_FLAG_TRIGGERED	(0x1 << REG0_FLAG_SHIFT)
+
+/*Bits 1:0, Interrupt Persist */
+#define REG0_INT_PERSIST_MASK	0x03
+#define REG0_INT_PERSIST_SHIFT	0
+#define REG0_INT_PERSIST_1	(0x0)
+#define REG0_INT_PERSIST_4	(0x1)
+#define REG0_INT_PERSIST_8	(0x2)
+#define REG0_INT_PERSIST_16	(0x3)
+
+/*=======================================================
+	Register 01h - Command2 Register
+=========================================================*/
+/*Bits 3:2, ADC Resolution/width */
+#define REG1_ADC_MASK		0x0C
+#define REG1_ADC_SHIFT		2
+#define REG1_ADC_16		(0x0 << REG1_ADC_SHIFT)
+#define REG1_ADC_12		(0x1 << REG1_ADC_SHIFT)
+#define REG1_ADC_8		(0x2 << REG1_ADC_SHIFT)
+#define REG1_ADC_4		(0x3 << REG1_ADC_SHIFT)
+
+/*Bits 1:0, Lux Range/FSR  */
+#define REG1_RANGE_MASK		0x03
+#define REG1_RANGE_SHIFT	0
+#define REG1_RANGE_1		(0x0)
+#define REG1_RANGE_2		(0x1)
+#define REG1_RANGE_3		(0x2)
+#define REG1_RANGE_4		(0x3)
+
+#endif
Index: android-2.6.35/drivers/Makefile
===================================================================
--- android-2.6.35.orig/drivers/Makefile	2010-12-10 15:11:20.000000000 +0530
+++ android-2.6.35/drivers/Makefile	2010-12-22 14:36:43.013862773 +0530
@@ -123,3 +123,4 @@
 obj-$(CONFIG_OMAP_DEVICE_HANDLER)	+= dsp/syslink/devh/44xx/
 obj-$(CONFIG_DMM_OMAP)		+= media/
 obj-$(CONFIG_TILER_OMAP)		+= media/
+obj-$(CONFIG_NEW_SENSORS)	+= sensors/
Index: android-2.6.35/arch/arm/configs/android_4430_samsung_defconfig
===================================================================
--- android-2.6.35.orig/arch/arm/configs/android_4430_samsung_defconfig	2010-12-22 14:36:03.383239835 +0530
+++ android-2.6.35/arch/arm/configs/android_4430_samsung_defconfig	2010-12-22 14:36:55.643862966 +0530
@@ -767,6 +767,9 @@
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
+CONFIG_NEW_SENSORS=y
+CONFIG_OPTICAL=y
+CONFIG_OPTICAL_ISL29023=y
 CONFIG_MISC_DEVICES=y
 # CONFIG_AD525X_DPOT is not set
 CONFIG_ANDROID_PMEM=y
