Index: Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c
===================================================================
--- Kernel.orig/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-05 15:08:16.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-05 19:23:23.000000000 +0530
@@ -1434,7 +1434,30 @@
                 I2C_BOARD_INFO("cmc623_i2c_driver", 0x38),
         },
 
-#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4 || CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4 )
+        {
+                I2C_BOARD_INFO("kxsd9", 0x18),
+                .irq    = OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
+        },
+        {
+                I2C_BOARD_INFO("mpu3050", 0x68),
+                .irq    = OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
+        },
+        {
+                I2C_BOARD_INFO("akm8975", 0x0C),
+                .irq    = OMAP_GPIO_IRQ(OMAP4TAB_AKM_INT_GPIO),
+        },
+        {
+                I2C_BOARD_INFO("gp2a",0x44),
+
+        },
+        {
+               I2C_BOARD_INFO("fsa9480", (0x4A >> 1)),
+               .platform_data = &omap4_fsa9480_pdata,
+               .irq = OMAP_GPIO_IRQ(OMAP4430_GPIO_JACK_NINT),
+        },
+
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5 )
 	{
 		I2C_BOARD_INFO("kxsd9", 0x18),
 		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
@@ -1444,11 +1467,11 @@
 		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
 	},
 	{
-		I2C_BOARD_INFO("akm8975", 0x0C),
-		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_AKM_INT_GPIO),
+		I2C_BOARD_INFO("gp2a",0x44),
+		
 	},
 	{
-		I2C_BOARD_INFO("gp2a",0x44),
+		I2C_BOARD_INFO("yas530",0x2E),
 		
 	},
         {
Index: Kernel/drivers/sensors/gyro-mpu3050/mpu3050.c
===================================================================
--- Kernel.orig/drivers/sensors/gyro-mpu3050/mpu3050.c	2010-12-31 12:04:58.000000000 +0530
+++ Kernel/drivers/sensors/gyro-mpu3050/mpu3050.c	2011-01-05 19:25:17.000000000 +0530
@@ -326,7 +326,7 @@
 /***********************Sysfs Interface *********************************/
 static ssize_t poll_delay_show( struct device *dev, struct device_attribute *attr, char *buf)
 {
-        int64_t delay_to_report;
+        int delay_to_report;
 
         if (mpu3050_timeout<0)
         {
@@ -334,32 +334,34 @@
         }
         else
         {
-                delay_to_report = (int64_t)jiffies_to_msecs(mpu3050_timeout);
+                delay_to_report = jiffies_to_msecs(mpu3050_timeout);
         }
 
-        printk("delay_to_report=%lld\n", delay_to_report );
+        printk("delay_to_report=%d\n", delay_to_report );
 
-        return snprintf(buf, PAGE_SIZE, "%lld\n", delay_to_report);
+        return snprintf(buf, PAGE_SIZE, "%d\n", delay_to_report);
 }
 
 
 static ssize_t poll_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
         int err;
-        int64_t new_delay;
+        int new_delay;
 
 
         printk("buf=%s\n", buf);
         printk("size=%u\n", size);
 
-        err = strict_strtoll(buf, 10, &new_delay);
+        err = strict_strtol(buf, 10, &new_delay);
         if ( err < 0 )
                 return err;
 
+	//mpu3050_timeout = msecs_to_jiffies(new_delay);
+	mpu3050_timeout = msecs_to_jiffies(200);
 
-#ifdef GP2A_DEBUG
-        printk("poll_delay_store called. new_delay=%lld\n", new_delay);
-        printk("poll_delay_store called.mpu3050_timeout=%d\n", mpu3050_timeout);
+#ifdef MPU3050_DEBUG
+        printk("poll_delay_store called. new_delay=%d\n", new_delay);
+        printk("poll_delay_store called. mpu3050_timeout=%d\n", mpu3050_timeout);
 #endif
         return size;
 }
@@ -393,12 +395,25 @@
                         ret = -EINVAL;
                 }
 
+		// If poll_delay not set,
+		// initialise it to default value 200ms
+		if (mpu3050_timeout == -1) {
+			mpu3050_timeout = msecs_to_jiffies(200);
+		}
+
+		//start the polling workqueue
+		queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
+
         } else if (!new_value && (mpu3050_timeout > -1) ) {
                 ret = mpu3050_set_operation_mode(GYRO_POWER_OFF);
                 if (ret < 0) {
                         printk("GYRO POWER_DOWN failed!!\n");
                         ret = -EINVAL;
                 }
+
+		//stop the polling workqueue
+		mpu3050_timeout = -1;
+		flush_workqueue(mpu3050_work_q);
         }
 
         (ret < 0) ? NULL : (ret = size) ;
Index: Kernel/drivers/sensors/optical/gp2a.c
===================================================================
--- Kernel.orig/drivers/sensors/optical/gp2a.c	2010-12-31 12:04:58.000000000 +0530
+++ Kernel/drivers/sensors/optical/gp2a.c	2011-01-05 19:29:21.000000000 +0530
@@ -74,6 +74,7 @@
 struct class *light_class;
 
 struct input_dev *light_input;
+struct input_dev *proximity_input;
 
 static struct workqueue_struct *gp2a_work_q;
 static struct delayed_work gp2a_delayed_work_q;
@@ -178,6 +179,9 @@
 			//Power up the GPIO-35 too.
 			gpio_direction_output(gp2a_ps_on_gpio, 1);	
 			printk("Light[GP2A] Power-up\n");
+
+			msleep(1000);
+
 			#if 0
 			if((ret = gp2a_i2c_write(REG_OPMOD,0x01))<0)   //Software-Shutdown Disabed.
 			{
@@ -205,6 +209,7 @@
 			printk("Light[GP2A] Power-down\n");
 			gp2a_timeout=-1;
 			flush_workqueue(gp2a_work_q);
+		        cancel_delayed_work(&gp2a_delayed_work_q);
 			if((ret = gp2a_i2c_write(REG_OPMOD,0x00))<0) //Software-Shutdown Enabled.
 
 			{
@@ -293,7 +298,7 @@
 
 static ssize_t poll_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	int64_t delay_to_report;
+	long int delay_to_report;
 	
 	if (gp2a_timeout<0)
 	{
@@ -301,30 +306,30 @@
 	}
 	else
 	{
-		delay_to_report = (int64_t)jiffies_to_msecs(gp2a_timeout);
+		delay_to_report = jiffies_to_msecs(gp2a_timeout);
 	}
 
 	printk("delay_to_report=%lld\n", delay_to_report );
 
-	return snprintf(buf, PAGE_SIZE, "%lld\n", delay_to_report);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", delay_to_report);
 }
 
 
 static ssize_t poll_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
 	int err;
-	int64_t new_delay;
+	long int new_delay;
 
 
 	printk("buf=%s\n", buf);
 	printk("size=%u\n", size);
 
-	err = strict_strtoll(buf, 10, &new_delay);
+	err = strict_strtol(buf, 10, &new_delay);
 	if ( err < 0 )
 		return err;
 
-	gp2a_timeout = msecs_to_jiffies(new_delay);
-
+	//gp2a_timeout = msecs_to_jiffies(new_delay);
+	gp2a_timeout = msecs_to_jiffies(200);
 
 #ifdef GP2A_DEBUG
 	printk("poll_delay_store called. new_delay=%lld\n", new_delay);
@@ -337,7 +342,7 @@
 static ssize_t light_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	printk("enabled=%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
-	return snprintf(buf, PAGE_SIZE, "%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
+	return snprintf(buf, PAGE_SIZE, "%ld\n", (long int)((gp2a_timeout < 0) ? 0 : 1) );
 }
 
 
@@ -351,7 +356,51 @@
 	else if (sysfs_streq(buf, "0"))
 		new_value = false;
 	else {
-		pr_err("%s: invalid value %d\n", __func__, *buf);
+		printk("%s: invalid value %d\n", __func__, *buf);
+		return -EINVAL;
+	}
+
+	printk("new_value = %d, old state = %d\n", new_value, ((gp2a_timeout < 0) ? 0 : 1) );
+	if (new_value && (gp2a_timeout < 0) ) {
+
+		ret = gp2a_set_operation_mode(POWER_UP);
+		if (ret < 0) {
+			printk("POWER_UP failed!!\n");
+			ret = -EINVAL;
+		}
+
+	} else if (!new_value && (gp2a_timeout > -1) ) {
+		ret = gp2a_set_operation_mode(POWER_DOWN);
+		if (ret < 0) {
+			printk("POWER_DOWN failed!!\n");
+			ret = -EINVAL;
+		}
+	}
+
+	(ret < 0) ? NULL : (ret = size) ;
+
+	return ret;
+}
+
+
+static ssize_t proximity_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	printk("enabled=%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
+	return snprintf(buf, PAGE_SIZE, "%d\n", ((gp2a_timeout < 0) ? 0 : 1) );
+}
+
+
+static ssize_t proximity_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	bool new_value;
+	int ret = 0;
+
+	if (sysfs_streq(buf, "1"))
+		new_value = true;
+	else if (sysfs_streq(buf, "0"))
+		new_value = false;
+	else {
+		printk("%s: invalid value %d\n", __func__, *buf);
 		return -EINVAL;
 	}
 
@@ -398,6 +447,22 @@
 };
 
 
+
+
+
+static struct device_attribute dev_attr_proximity_enable =
+	__ATTR(enable, S_IRUGO | S_IWUGO | S_IXUGO,
+	       proximity_enable_show, proximity_enable_store);
+
+
+static struct attribute *proximity_sysfs_attrs[] = {
+	&dev_attr_proximity_enable.attr,
+	NULL
+};
+
+static struct attribute_group proximity_attribute_group = {
+	.attrs = proximity_sysfs_attrs,
+};
 /*****************************************************************/
 
 
@@ -566,7 +631,10 @@
 {
 	int ret = 0;
 	int result_light=-1;
+
+	#ifdef GP2A_DEBUG
 	u8 lux_value= 0;  // Proximitiy values =0 or 1.
+	#endif
 
 	struct device *dev_light;
 	gp2a_client = client;
@@ -616,26 +684,23 @@
 	}
 	
 
-	//Register input device
+	//Ambient-light input device
 	light_input = input_allocate_device();
 
 	if(NULL == light_input)
 	{
-		printk(KERN_ERR"\n[gp2a-lightSENSOR] Error while allocating input device");
+		printk(KERN_ERR"\n[gp2a-lightSENSOR] Error while allocating light input device");
 		return -EIO;
 	}
 
 	gp2a_dev->inputdev=light_input;
 	set_bit(EV_ABS, light_input->evbit);
 	set_bit(ABS_MISC, light_input->absbit);
-	set_bit(ABS_DISTANCE, light_input->absbit);
-	
 	
 	light_input->name="gp2a_light";
 	light_input->dev.parent = &gp2a_client->dev;
 	
-	//input_set_abs_params(light_input,ABS_MISC,0,30000,0,0);
-	input_set_abs_params(light_input,ABS_DISTANCE,0,1,0,0);
+	input_set_abs_params(light_input,ABS_MISC,0,30000,0,0);
 	
 	ret = input_register_device(light_input);
 	if(ret)
@@ -646,10 +711,45 @@
 
 	ret = sysfs_create_group(&light_input->dev.kobj, &light_attribute_group);
 	if (ret) {
-		pr_err("%s: could not create sysfs group\n", __func__);
+		printk("%s: could not create light sysfs group\n", __func__);
 		goto release_input_dev;
 	}
 
+
+
+	// Proximity input-device
+	proximity_input = input_allocate_device();
+
+	if(NULL == proximity_input)
+	{
+		printk(KERN_ERR"\n[gp2a-ProximitySENSOR] Error while allocating proximity input device");
+		return -EIO;
+	}
+
+	//gp2a_dev->inputdev=proximity_input;
+	set_bit(EV_ABS, proximity_input->evbit);
+	set_bit(ABS_DISTANCE, proximity_input->absbit);
+	
+	light_input->name="gp2a_proximity";
+	light_input->dev.parent = &gp2a_client->dev;
+	
+	input_set_abs_params(light_input,ABS_DISTANCE,0,1,0,0);
+	
+	ret = input_register_device(proximity_input);
+	if(ret)
+	{
+		printk("gp2a proximity Sensor couldn't be registered:%d\n",ret);
+		goto release_input_dev;
+	}	
+
+	ret = sysfs_create_group(&proximity_input->dev.kobj, &proximity_attribute_group);
+	if (ret) {
+		printk("%s: could not create proximity sysfs group\n", __func__);
+		goto release_input_dev;
+	}
+
+
+
 	//Workqueue Initialisation
 	gp2a_work_q = create_singlethread_workqueue("light_sensor_gp2a_work_queue");
 	INIT_DELAYED_WORK( (struct delayed_work *)&gp2a_delayed_work_q, gp2a_work);
Index: Kernel/drivers/sensors/compass/yas530.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/compass/yas530.c	2011-01-05 19:32:42.839732758 +0530
@@ -0,0 +1,3623 @@
+/*
+ * Copyright (c) 2010 Yamaha Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+#define CONFIG_COMPASS_YAS530_POSITION 0
+
+#include<asm/uaccess.h>
+#include<asm/mach-types.h>
+#include<asm/atomic.h>
+#include<linux/module.h>
+#include<linux/init.h>
+#include<linux/input.h>
+#include<linux/i2c.h>
+#include<linux/hrtimer.h>
+#include<linux/delay.h>
+#include<linux/workqueue.h>
+#include <linux/slab.h>
+#include<linux/gpio.h>
+#include <linux/i2c/twl6030-gpadc.h>
+#include<linux/earlysuspend.h>
+#include "yas530.h"
+
+/*#include "yas.h"*/
+/*#include "utimer.h"*/
+
+static void (*current_time)(int *sec, int *msec) = {0};
+
+STATIC int
+utimeval_init(struct utimeval *val)
+{
+    if (val == NULL) {
+        return -1;
+    }
+    val->tv_sec = val->tv_msec = 0;
+    return 0;
+}
+
+STATIC int
+utimeval_is_initial(struct utimeval *val)
+{
+    if (val == NULL) {
+        return 0;
+    }
+    return val->tv_sec == 0 && val->tv_msec == 0;
+}
+
+STATIC int
+utimeval_is_overflow(struct utimeval *val)
+{
+    int32_t max;
+
+    if (val == NULL) {
+        return 0;
+    }
+
+    max = (int32_t) ((uint32_t) 0xffffffff / (uint32_t) 1000);
+    if (val->tv_sec > max) {
+        return 1; /* overflow */
+    }
+    else if (val->tv_sec == max) {
+        if (val->tv_msec > (int32_t)((uint32_t)0xffffffff % (uint32_t)1000)) {
+            return 1; /* overflow */
+        }
+    }
+
+    return 0;
+}
+
+STATIC struct utimeval
+utimeval_plus(struct utimeval *first, struct utimeval *second)
+{
+    struct utimeval result = {0, 0};
+    int32_t tmp;
+
+    if (first == NULL || second == NULL) {
+        return result;
+    }
+
+    tmp = first->tv_sec + second->tv_sec;
+    if (first->tv_sec >= 0 && second->tv_sec >= 0 && tmp < 0) {
+        goto overflow;
+    }
+    if (first->tv_sec < 0 && second->tv_sec < 0 && tmp >= 0) {
+        goto underflow;
+    }
+
+    result.tv_sec = tmp;
+    result.tv_msec = first->tv_msec + second->tv_msec;
+    if (1000 <= result.tv_msec) {
+        tmp = result.tv_sec + result.tv_msec / 1000;
+        if (result.tv_sec >= 0 && result.tv_msec >= 0 && tmp < 0) {
+            goto overflow;
+        }
+        result.tv_sec = tmp;
+        result.tv_msec = result.tv_msec % 1000;
+    }
+    if (result.tv_msec < 0) {
+        tmp = result.tv_sec + result.tv_msec / 1000 - 1;
+        if (result.tv_sec < 0 && result.tv_msec < 0 && tmp >= 0) {
+            goto underflow;
+        }
+        result.tv_sec = tmp;
+        result.tv_msec = result.tv_msec % 1000 + 1000;
+    }
+
+    return result;
+
+overflow:
+    result.tv_sec = 0x7fffffff;
+    result.tv_msec = 999;
+    return result;
+
+underflow:
+    result.tv_sec = 0x80000000;
+    result.tv_msec = 0;
+    return result;
+}
+
+STATIC struct utimeval
+utimeval_minus(struct utimeval *first, struct utimeval *second)
+{
+    struct utimeval result = {0, 0}, tmp;
+
+    if (first == NULL || second == NULL || second->tv_sec == (int)0x80000000) {
+        return result;
+    }
+
+    tmp.tv_sec = -second->tv_sec;
+    tmp.tv_msec = -second->tv_msec;
+    return utimeval_plus(first, &tmp);
+}
+
+static int
+utimeval_less_than(struct utimeval *first, struct utimeval *second)
+{
+    if (first == NULL || second == NULL) {
+        return 0;
+    }
+
+    if (first->tv_sec > second->tv_sec) {
+        return 1;
+    }
+    else if (first->tv_sec < second->tv_sec) {
+        return 0;
+    }
+    else {
+        if (first->tv_msec > second->tv_msec) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
+    }
+}
+
+STATIC int
+utimeval_greater_than(struct utimeval *first, struct utimeval *second)
+{
+    if (first == NULL || second == NULL) {
+        return 0;
+    }
+
+    if (first->tv_sec < second->tv_sec) {
+        return 1;
+    }
+    else if (first->tv_sec > second->tv_sec) {
+        return 0;
+    }
+    else {
+        if (first->tv_msec < second->tv_msec) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
+    }
+}
+
+STATIC int
+utimeval_greater_or_equal(struct utimeval *first,
+                         struct utimeval *second)
+{
+    return !utimeval_less_than(first, second);
+}
+
+STATIC int
+utimeval_greater_than_zero(struct utimeval *val)
+{
+    struct utimeval zero = {0, 0};
+    return utimeval_greater_than(&zero, val);
+}
+
+STATIC int
+utimeval_less_than_zero(struct utimeval *val)
+{
+    struct utimeval zero = {0, 0};
+    return utimeval_less_than(&zero, val);
+}
+
+STATIC struct utimeval *
+msec_to_utimeval(struct utimeval *result, uint32_t msec)
+{
+    if (result == NULL) {
+        return result;
+    }
+    result->tv_sec = msec / 1000;
+    result->tv_msec = msec % 1000;
+
+    return result;
+}
+
+STATIC uint32_t
+utimeval_to_msec(struct utimeval *val)
+{
+    if (val == NULL) {
+        return 0;
+    }
+    if (utimeval_less_than_zero(val)) {
+        return 0;
+    }
+    if (utimeval_is_overflow(val)) {
+        return 0xffffffff;
+    }
+
+    return val->tv_sec * 1000 + val->tv_msec;
+}
+
+STATIC struct utimeval
+utimer_calc_next_time(struct utimer *ut, struct utimeval *cur)
+{
+    struct utimeval result = {0, 0}, delay;
+
+    if (ut == NULL || cur == NULL) {
+        return result;
+    }
+
+    utimer_update_with_curtime(ut, cur);
+    if (utimer_is_timeout(ut)) {
+        result = *cur;
+    }
+    else {
+        delay = utimeval_minus(&ut->delay_ms, &ut->total_time);
+        result = utimeval_plus(cur, &delay);
+    }
+
+    return result;
+}
+
+STATIC struct utimeval
+utimer_current_time(void)
+{
+    struct utimeval tv;
+    int sec, msec;
+
+    if (current_time != NULL) {
+        current_time(&sec, &msec);
+    }
+    else {
+        sec = 0, msec = 0;
+    }
+    tv.tv_sec = sec;
+    tv.tv_msec = msec;
+
+    return tv;
+}
+
+STATIC int
+utimer_clear(struct utimer *ut)
+{
+    if (ut == NULL) {
+        return -1;
+    }
+    utimeval_init(&ut->prev_time);
+    utimeval_init(&ut->total_time);
+
+    return 0;
+}
+
+STATIC int
+utimer_update_with_curtime(struct utimer *ut, struct utimeval *cur)
+{
+    struct utimeval tmp;
+
+    if (ut == NULL || cur == NULL) {
+        return -1;
+    }
+    if (utimeval_is_initial(&ut->prev_time)) {
+        ut->prev_time = *cur;
+    }
+    if (utimeval_greater_than_zero(&ut->delay_ms)) {
+        tmp = utimeval_minus(cur, &ut->prev_time);
+        ut->total_time = utimeval_plus(&tmp, &ut->total_time);
+        ut->prev_time = *cur;
+    }
+
+    return 0;
+}
+
+STATIC int
+utimer_update(struct utimer *ut)
+{
+    struct utimeval cur;
+
+    if (ut == NULL) {
+        return -1;
+    }
+    cur = utimer_current_time();
+    utimer_update_with_curtime(ut, &cur);
+    return 0;
+}
+
+STATIC int
+utimer_is_timeout(struct utimer *ut)
+{
+    if (ut == NULL) {
+        return 0;
+    }
+    if (utimeval_greater_than_zero(&ut->delay_ms)) {
+        return utimeval_greater_or_equal(&ut->delay_ms, &ut->total_time);
+    }
+    else {
+        return 1;
+    }
+}
+
+STATIC int
+utimer_clear_timeout(struct utimer *ut)
+{
+    uint32_t delay, total;
+
+    if (ut == NULL) {
+        return -1;
+    }
+
+    delay = utimeval_to_msec(&ut->delay_ms);
+    if (delay == 0 || utimeval_is_overflow(&ut->total_time)) {
+        total = 0;
+    }
+    else {
+        total = utimeval_to_msec(&ut->total_time);
+        if (delay * 2 <= total) {
+            total = delay;
+        }
+        else {
+            total = total % delay;
+        }
+    }
+    msec_to_utimeval(&ut->total_time, total);
+
+    return 0;
+}
+
+STATIC uint32_t
+utimer_sleep_time_with_curtime(struct utimer *ut, struct utimeval *cur)
+{
+    struct utimeval tv;
+
+    if (ut == NULL || cur == NULL) {
+        return 0;
+    }
+    tv = utimer_calc_next_time(ut, cur);
+    tv = utimeval_minus(&tv, cur);
+    if (utimeval_less_than_zero(&tv)) {
+        return 0;
+    }
+
+    return utimeval_to_msec(&tv);
+}
+
+STATIC uint32_t
+utimer_sleep_time(struct utimer *ut)
+{
+    struct utimeval cur;
+
+    if (ut == NULL) {
+        return 0;
+    }
+
+    cur = utimer_current_time();
+    return utimer_sleep_time_with_curtime(ut, &cur);
+}
+
+STATIC int
+utimer_init(struct utimer *ut, uint32_t delay_ms)
+{
+    if (ut == NULL) {
+        return -1;
+    }
+    utimer_clear(ut);
+    msec_to_utimeval(&ut->delay_ms, delay_ms);
+
+    return 0;
+}
+
+STATIC uint32_t
+utimer_get_total_time(struct utimer *ut)
+{
+    return utimeval_to_msec(&ut->total_time);
+}
+
+STATIC uint32_t
+utimer_get_delay(struct utimer *ut)
+{
+    if (ut == NULL) {
+        return -1;
+    }
+    return utimeval_to_msec(&ut->delay_ms);
+}
+
+STATIC int
+utimer_set_delay(struct utimer *ut, uint32_t delay_ms)
+{
+    return utimer_init(ut, delay_ms);
+}
+
+STATIC void
+utimer_lib_init(void (*func)(int *sec, int *msec))
+{
+    current_time = func;
+}
+
+
+/*#include "yas_mag_cdriver.h"*/
+
+struct yas_cal_data {
+    uint8_t dx, dy1, dy2;
+    uint8_t d2, d3, d4, d5, d6, d7, d8, d9, d0;
+    uint8_t dck;
+};
+struct yas_correction_data {
+    int32_t Cx, Cy1, Cy2;
+    int32_t a2, a3, a4, a5, a6, a7, a8, a9, k;
+};
+struct yas_cdriver {
+    struct yas_cal_data cal;
+    struct yas_correction_data correct;
+    struct yas_machdep_func func;
+    int8_t transform[9];
+    int16_t temperature;
+};
+static struct yas_cdriver cdriver;
+
+static int
+i2c_open(void)
+{
+    if (cdriver.func.i2c_open == NULL) {
+        return -1;
+    }
+    return cdriver.func.i2c_open();
+}
+
+static int
+i2c_close(void)
+{
+    if (cdriver.func.i2c_close == NULL) {
+        return -1;
+    }
+    return cdriver.func.i2c_close();
+}
+
+static int
+i2c_write(uint8_t addr, const uint8_t *buf, int len)
+{
+    if (cdriver.func.i2c_write == NULL) {
+        return -1;
+    }
+    return cdriver.func.i2c_write(YAS_SLAVE_ADDRESS, addr, buf, len);
+}
+
+static int
+i2c_read(uint8_t addr, uint8_t *buf, int len)
+{
+    if (cdriver.func.i2c_read == NULL) {
+        return -1;
+    }
+    return cdriver.func.i2c_read(YAS_SLAVE_ADDRESS, addr, buf, len);
+}
+
+static void
+sleep(int millisec)
+{
+    if (cdriver.func.msleep == NULL) {
+        return;
+    }
+    cdriver.func.msleep(millisec);
+}
+
+static int
+init_test_register(void)
+{
+    uint8_t data;
+
+    data = 0x00;
+    if (i2c_write(YAS_REGADDR_TEST1, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    data = 0x00;
+    if (i2c_write(YAS_REGADDR_TEST2, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+get_device_id(uint8_t *id)
+{
+    uint8_t data = 0;
+
+    if (i2c_read(YAS_REGADDR_DEVICE_ID, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    *id = data;
+
+    return YAS_NO_ERROR;
+}
+
+static int
+get_cal_data(struct yas_cal_data *cal)
+{
+    uint8_t data[16];
+
+    if (i2c_read(YAS_REGADDR_CAL, data, 16) < 0) { /* dummy read */
+        return YAS_ERROR_I2C;
+    }
+    if (i2c_read(YAS_REGADDR_CAL, data, 16) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    cal->dx = data[0];
+    cal->dy1 = data[1];
+    cal->dy2 = data[2];
+    cal->d2 = (data[3]>>2) & 0x03f;
+    cal->d3 = ((data[3]<<2) & 0x0c) | ((data[4]>>6) & 0x03);
+    cal->d4 = data[4] & 0x3f;
+    cal->d5 = (data[5]>>2) & 0x3f;
+    cal->d6 = ((data[5]<<4) & 0x30) | ((data[6]>>4) & 0x0c);
+    cal->d7 = ((data[6]<<3) & 0x78) | ((data[7]>>5) & 0x07);
+    cal->d8 = ((data[7]<<1) & 0x3e) | ((data[8]>>7) & 0x01);
+    cal->d9 = ((data[8]<<1) & 0xfe) | ((data[9]>>7) & 0x01);
+    cal->d0 = (data[9]>>2) & 0x1f;
+    cal->dck = ((data[9]<<1) & 0x06) | ((data[10]>>7) & 0x01);
+
+    return YAS_NO_ERROR;
+}
+
+static void
+get_correction_value(struct yas_cal_data *cal,
+        struct yas_correction_data *correct)
+{
+    correct->Cx = cal->dx * 6 - 768;
+    correct->Cy1 = cal->dy1 * 6 - 768;
+    correct->Cy2 = cal->dy2 * 6 - 768;
+    correct->a2 = cal->d2 - 32;
+    correct->a3 = cal->d3 - 8;
+    correct->a4 = cal->d4 - 32;
+    correct->a5 = cal->d5 + 38;
+    correct->a6 = cal->d6 - 32;
+    correct->a7 = cal->d7 - 64;
+    correct->a8 = cal->d8 - 32;
+    correct->a9 = cal->d9;
+    correct->k = cal->d0 + 10;
+}
+
+static int
+set_configuration(int inton, int inthact, int cck)
+{
+    uint8_t data = 0;
+
+    data |= (!!inton) & 0x01;
+    data |= ((!!inthact)<<1) & 0x02;
+    data |= (cck<<2) & 0x1c;
+
+    if (i2c_write(YAS_REGADDR_CONFIG, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+get_measure_interval(int32_t *msec)
+{
+    uint8_t data;
+
+    if (i2c_read(YAS_REGADDR_MEASURE_INTERVAL, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    *msec = data * 5;
+
+    return YAS_NO_ERROR;
+}
+
+static int
+set_measure_interval(int32_t msec)
+{
+    uint8_t data = 0;
+
+    if (msec > 5*0xff) {
+        data = 0xff;
+    }
+    else {
+        data = (msec % 5) == 0 ? msec / 5 : (msec / 5) + 1;
+    }
+    if (i2c_write(YAS_REGADDR_MEASURE_INTERVAL, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+set_measure_command(int ldtc, int fors, int dlymes)
+{
+    uint8_t data = 0;
+
+    data |= 0x01; /* bit 0 must be 1 */
+    data |= ((!!ldtc)<<1) & 0x02;
+    data |= ((!!fors)<<2) & 0x04;
+    data |= ((!!dlymes)<<4) & 0x10;
+
+    if (i2c_write(YAS_REGADDR_MEASURE_COMMAND, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+measure_normal(int *busy, int16_t *t, int16_t *x, int16_t *y1, int16_t *y2)
+{
+    uint8_t data[8];
+
+    if (set_measure_command(0, 0, 0) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    sleep(2);
+
+    if (i2c_read(YAS_REGADDR_MEASURE_DATA, data, 8) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    *busy = (data[0]>>7) & 0x01;
+    *t = ((data[0]<<2) & 0x1fc) | ((data[1]>>6) & 0x03);
+    *x = ((data[2]<<5) & 0xfe0) | ((data[3]>>3) & 0x1f);
+    *y1 = ((data[4]<<5) & 0xfe0) | ((data[5]>>3) & 0x1f);
+    *y2 = ((data[6]<<5) & 0xfe0) | ((data[7]>>3) & 0x1f);
+    /*YLOGD(("f[%d] t[%d] x[%d] y1[%d] y2[%d]\n", *busy, *t, *x, *y1, *y2));*/
+
+    return YAS_NO_ERROR;
+}
+
+static int
+coordinate_conversion(int16_t x, int16_t y1, int16_t y2, int16_t t,
+        int32_t *xo, int32_t *yo, int32_t *zo,
+        struct yas_correction_data *c)
+{
+    int32_t sx, sy1, sy2, sy, sz;
+    int32_t hx, hy, hz;
+
+    sx  = x  - (c->Cx  * t) / 100;
+    sy1 = y1 - (c->Cy1 * t) / 100;
+    sy2 = y2 - (c->Cy2 * t) / 100;
+
+    sy = sy1 - sy2;
+    sz = -sy1 - sy2;
+
+    hx = c->k * ((100   * sx + c->a2 * sy + c->a3 * sz) / 10);
+    hy = c->k * ((c->a4 * sx + c->a5 * sy + c->a6 * sz) / 10);
+    hz = c->k * ((c->a7 * sx + c->a8 * sy + c->a9 * sz) / 10);
+
+    *xo = cdriver.transform[0] * hx
+            + cdriver.transform[1] * hy
+            + cdriver.transform[2] * hz;
+    *yo = cdriver.transform[3] * hx
+            + cdriver.transform[4] * hy
+            + cdriver.transform[5] * hz;
+    *zo = cdriver.transform[6] * hx
+            + cdriver.transform[7] * hy
+            + cdriver.transform[8] * hz;
+
+    return YAS_NO_ERROR;
+}
+
+static int
+set_hardware_offset(int8_t offset_x, int8_t offset_y1, int8_t offset_y2)
+{
+    uint8_t data;
+
+    data = offset_x & 0x3f;
+    if (i2c_write(YAS_REGADDR_OFFSET_X, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    data = offset_y1 & 0x3f;
+    if (i2c_write(YAS_REGADDR_OFFSET_Y1, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    data = offset_y2 & 0x3f;
+    if (i2c_write(YAS_REGADDR_OFFSET_Y2, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_actuate_initcoil(void)
+{
+    uint8_t data = 0;
+
+    if (i2c_write(YAS_REGADDR_ACTUATE_INIT_COIL, &data, 1) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+check_offset(int8_t offset_x, int8_t offset_y1, int8_t offset_y2,
+        int *flag_x, int *flag_y1, int *flag_y2)
+{
+    int busy;
+    int16_t t, x, y1, y2;
+
+    if (set_hardware_offset(offset_x, offset_y1, offset_y2) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (measure_normal(&busy, &t, &x, &y1, &y2) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    *flag_x = *flag_y1 = *flag_y2 = 0;
+    if (x  > 2048)  *flag_x  =  1;
+    if (y1 > 2048)  *flag_y1 =  1;
+    if (y2 > 2048)  *flag_y2 =  1;
+    if (x  < 2048)  *flag_x  = -1;
+    if (y1 < 2048)  *flag_y1 = -1;
+    if (y2 < 2048)  *flag_y2 = -1;
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_measure_and_set_offset(int8_t *offset)
+{
+    int i;
+    int8_t offset_x = 0, offset_y1 = 0, offset_y2 = 0;
+    int flag_x = 0, flag_y1 = 0, flag_y2 = 0;
+    static const int correct[5] = {16, 8, 4, 2, 1};
+
+    for (i = 0; i < 5; i++) {
+        if (check_offset(offset_x, offset_y1, offset_y2,
+                    &flag_x, &flag_y1, &flag_y2) < 0) {
+            return YAS_ERROR_I2C;
+        }
+        YLOGD(("offset[%d][%d][%d] flag[%d][%d][%d]\n",
+                offset_x, offset_y1, offset_y2,
+                flag_x, flag_y1, flag_y2));
+        if (flag_x)  {
+            offset_x  += flag_x  * correct[i];
+        }
+        if (flag_y1) {
+            offset_y1 += flag_y1 * correct[i];
+        }
+        if (flag_y2) {
+            offset_y2 += flag_y2 * correct[i];
+        }
+    }
+    if (set_hardware_offset(offset_x, offset_y1, offset_y2) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    offset[0] = offset_x;
+    offset[1] = offset_y1;
+    offset[2] = offset_y2;
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_set_offset(const int8_t *offset)
+{
+    if (set_hardware_offset(offset[0], offset[1], offset[2]) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_measure(int32_t *data, int16_t *raw, int16_t *temperature)
+{
+    int busy;
+    int16_t x, y1, y2, t;
+    int result = 0;
+
+    if (measure_normal(&busy, &t, &x, &y1, &y2) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (coordinate_conversion(x, y1, y2, t, &data[0], &data[1],
+                &data[2], &cdriver.correct) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    cdriver.temperature = t;
+
+    if (raw != NULL) {
+        raw[0] = x, raw[1] = y1, raw[2] = y2;
+    }
+    if (temperature != NULL) {
+        *temperature = t;
+    }
+    if (x == 0) result |= 0x01;
+    if (x == 4095) result |= 0x02;
+    if (y1 == 0) result |= 0x04;
+    if (y1 == 4095) result |= 0x08;
+    if (y2 == 0) result |= 0x10;
+    if (y2 == 4095) result |= 0x20;
+
+    return result;
+}
+
+STATIC int
+yas_cdrv_recalc_calib_offset(int32_t *prev_calib_offset,
+                              int32_t *new_calib_offset,
+                              int8_t *prev_offset,
+                              int8_t *new_offset)
+{
+    int32_t tmp[3], resolution[9], base[3];
+    int16_t raw[3];
+    int32_t diff, i;
+
+    if (prev_calib_offset == NULL || new_calib_offset == NULL
+            || prev_offset == NULL || new_offset == NULL) {
+        return YAS_ERROR_ARG;;
+    }
+
+    raw[0] = raw[1] = raw[2] = 0;
+    if (coordinate_conversion(raw[0], raw[1], raw[2], cdriver.temperature,
+                &base[0], &base[1], &base[2], &cdriver.correct) < 0) {
+        return YAS_ERROR_ERROR;
+    }
+    for (i = 0; i < 3; i++) {
+        raw[0] = raw[1] = raw[2] = 0;
+        raw[i] = 380;
+        if (coordinate_conversion(raw[0], raw[1], raw[2],
+                    cdriver.temperature,
+                    &resolution[i*3 + 0],
+                    &resolution[i*3 + 1],
+                    &resolution[i*3 + 2],
+                    &cdriver.correct) < 0) {
+            return YAS_ERROR_ERROR;
+        }
+        resolution[i*3 + 0] -= base[0];
+        resolution[i*3 + 1] -= base[1];
+        resolution[i*3 + 2] -= base[2];
+    }
+
+    for (i = 0; i < 3; i++) {
+        tmp[i] = prev_calib_offset[i];
+    }
+    for (i = 0; i < 3; i++) {
+        diff = (int32_t)new_offset[i] - (int32_t)prev_offset[i];
+        while (diff > 0) {
+            tmp[0] -= resolution[i*3 + 0];
+            tmp[1] -= resolution[i*3 + 1];
+            tmp[2] -= resolution[i*3 + 2];
+            diff--;
+        }
+        while (diff < 0) {
+            tmp[0] += resolution[i*3 + 0];
+            tmp[1] += resolution[i*3 + 1];
+            tmp[2] += resolution[i*3 + 2];
+            diff++;
+        }
+    }
+    for (i = 0; i < 3; i++) {
+        new_calib_offset[i] = tmp[i];
+    }
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_set_transformatiom_matrix(const int8_t *transform)
+{
+    int i;
+
+    if (transform == NULL) {
+        return YAS_ERROR_ARG;
+    }
+    for (i = 0; i < 9; i++) {
+        cdriver.transform[i] = transform[i];
+    }
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_init(const int8_t *transform, struct yas_machdep_func *func)
+{
+    int interval, i;
+    uint8_t id;
+
+    if (transform == NULL || func == NULL) {
+        return YAS_ERROR_ARG;
+    }
+
+    for (i = 0; i < 9; i++) {
+        cdriver.transform[i] = transform[i];
+    }
+    cdriver.func = *func;
+
+    if (i2c_open() < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (init_test_register() < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (get_device_id(&id) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (id != 0x01) {
+        return YAS_ERROR_I2C;
+    }
+    YLOGD(("device id:%02x\n", id));
+
+    if (get_cal_data(&cdriver.cal) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    YLOGD(("dx[%d] dy1[%d] dy2[%d] d2[%d] d3[%d] d4[%d] d5[%d] d6[%d] d7[%d] d8[%d] d9[%d] d0[%d] dck[%d]\n",
+            cdriver.cal.dx, cdriver.cal.dy1, cdriver.cal.dy2, cdriver.cal.d2, cdriver.cal.d3,
+            cdriver.cal.d4, cdriver.cal.d5, cdriver.cal.d6, cdriver.cal.d7, cdriver.cal.d8,
+            cdriver.cal.d9, cdriver.cal.d0, cdriver.cal.dck));
+    get_correction_value(&cdriver.cal, &cdriver.correct);
+    YLOGD(("Cx[%4d] Cy1[%4d] Cy2[%4d] a2[%4d] a3[%4d] a4[%4d] a5[%4d] a6[%4d] a7[%4d] a8[%4d] a9[%4d] k[%4d]\n",
+            cdriver.correct.Cx, cdriver.correct.Cy1, cdriver.correct.Cy2,
+            cdriver.correct.a2, cdriver.correct.a3, cdriver.correct.a4,
+            cdriver.correct.a5, cdriver.correct.a6, cdriver.correct.a7,
+            cdriver.correct.a8, cdriver.correct.a9, cdriver.correct.k));
+    if (set_configuration(0, 0, cdriver.cal.dck) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (set_measure_interval(0) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    if (get_measure_interval(&interval) < 0) {
+        return YAS_ERROR_I2C;
+    }
+    YLOGD(("interval[%d]\n", interval));
+
+    return YAS_NO_ERROR;
+}
+
+STATIC int
+yas_cdrv_term(void)
+{
+    i2c_close();
+    return YAS_NO_ERROR;
+}
+
+
+/*#include "yas.h"*/
+/*#include "yas_mag_cdriver.h"*/
+/*#include "utimer.h"*/
+
+#define YAS_DEFAULT_CALIB_INTERVAL     (50)    /* 50 msecs */
+#define YAS_DEFAULT_DATA_INTERVAL      (200)   /* 200 msecs */
+#define YAS_INITCOIL_INTERVAL          (3000)  /* 3 seconds */
+#define YAS_INITCOIL_GIVEUP_INTERVAL   (180000) /* 180 seconds */
+#define YAS_INTENSITY_THRESH0          (120)   /* 120 uT */
+#define YAS_INTENSITY_THRESH1          (90)    /* 90 uT */
+#define YAS_DETECT_OVERFLOW_INTERVAL   (0)     /* 0 second */
+#define YAS_MAX_FILTER_LEN             (20)
+#define YAS_DEFAULT_FILTER_LEN         (8)
+#define YAS_DEFAULT_FILTER_THRESH      (0)
+
+#define YAS_MAG_ERROR_DELAY            (100)
+#define YAS_MAG_STATE_NORMAL           (0)
+#define YAS_MAG_STATE_INIT_COIL        (1)
+#define YAS_MAG_STATE_MEASURE_OFFSET   (2)
+
+static const int8_t YAS_TRANSFORMATION[][9] = {
+    { 0, 1, 0,-1, 0, 0, 0, 0, 1 },
+    {-1, 0, 0, 0,-1, 0, 0, 0, 1 },
+    { 0,-1, 0, 1, 0, 0, 0, 0, 1 },
+    { 1, 0, 0, 0, 1, 0, 0, 0, 1 },
+    { 0,-1, 0,-1, 0, 0, 0, 0,-1 },
+    { 1, 0, 0, 0,-1, 0, 0, 0,-1 },
+    { 0, 1, 0, 1, 0, 0, 0, 0,-1 },
+    {-1, 0, 0, 0, 1, 0, 0, 0,-1 },
+};
+
+static const int supported_data_interval[] = {10, 20, 50, 60, 100, 200, 1000};
+static const int supported_calib_interval[] = {60, 60, 50, 60, 50, 50, 50};
+static const int32_t INVALID_CALIB_OFFSET[] = {0x7fffffff, 0x7fffffff, 0x7fffffff};
+static const int8_t INVALID_OFFSET[] = {0x7f, 0x7f, 0x7f};
+
+struct yas_fir_filter {
+    int num;
+    int filter_len;
+    int index;
+    int32_t sequence[YAS_MAX_FILTER_LEN];
+};
+
+struct yas_thresh_filter {
+    int32_t threshold;
+    int32_t last;
+};
+
+struct yas_driver {
+    struct yas_mag_driver_callback callback;
+
+    struct utimer data_timer;
+    struct utimer initcoil_timer;
+    struct utimer initcoil_giveup_timer;
+    struct utimer detect_overflow_timer;
+
+    int32_t prev_mag[3];
+    int32_t prev_xy1y2[3];
+    int32_t prev_mag_w_offset[3];
+    int measure_state;
+    int active;
+    int overflow;
+    int initcoil_gaveup;
+    int position;
+    int delay_timer_use_data;
+    int delay_timer_interval;
+    int delay_timer_counter;
+    int filter_enable;
+    int filter_len;
+    int filter_thresh;
+    struct yas_fir_filter fir_filter[3];
+    struct yas_thresh_filter thresh_filter[3];
+    struct yas_mag_offset offset;
+};
+
+
+static struct yas_driver this_driver = {
+    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
+    {{0,0}, {0,0}, {0,0}},  /* data_timer */
+    {{0,0}, {0,0}, {0,0}},  /* initcoil_timer */
+    {{0,0}, {0,0}, {0,0}},  /* initcoil_giveup_timer */
+    {{0,0}, {0,0}, {0,0}},  /* detect_overflow_timer */
+    {0, 0, 0},              /* prev_mag */
+    {0, 0, 0},              /* prev_xy1y2 */
+    {0, 0, 0},              /* prev_mag_w_offset */
+    YAS_MAG_STATE_NORMAL,  /* measure_state */
+    0,                      /* active */
+    0,                      /* overflow */
+    0,                      /* initcoil_gaveup */
+    0,                      /* position */
+    0,                      /* delay_timer_use_data */
+    (YAS_DEFAULT_DATA_INTERVAL
+     / YAS_DEFAULT_CALIB_INTERVAL), /* delay_timer_interval */
+    (YAS_DEFAULT_DATA_INTERVAL
+     / YAS_DEFAULT_CALIB_INTERVAL), /* delay_timer_counter */
+    0,                      /* filter_enable */
+    YAS_DEFAULT_FILTER_LEN,/* filter_len */
+    YAS_DEFAULT_FILTER_THRESH,/* filter_thresh */
+    {{0,0,0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},
+     {0,0,0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},
+     {0,0,0, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, /* filter */
+    {{0, 0}, {0, 0}, {0, 0}},
+    {{0,0,0}, {{0,0,0}}}, /* offset */
+};
+
+static int
+lock(void)
+{
+    if (this_driver.callback.lock != NULL) {
+        if (this_driver.callback.lock() < 0) {
+            return YAS_ERROR_RESTARTSYS;
+        }
+    }
+    return 0;
+}
+
+static int
+unlock(void)
+{
+    if (this_driver.callback.unlock != NULL) {
+        if (this_driver.callback.unlock() < 0) {
+            return YAS_ERROR_RESTARTSYS;
+        }
+    }
+    return 0;
+}
+
+static void
+fir_filter_init(struct yas_fir_filter *fir_filter, int len)
+{
+    int i;
+
+    fir_filter->num = 0;
+    fir_filter->index = 0;
+    fir_filter->filter_len = len;
+
+    for (i = 0; i < fir_filter->filter_len; ++i) {
+        fir_filter->sequence[i] = 0;
+    }
+}
+
+static int32_t
+fir_filter_filter(struct yas_fir_filter *fir_filter, int32_t in)
+{
+    int32_t out = 0;
+    int i;
+
+    if (fir_filter->filter_len == 0) {
+        return in;
+    }
+    if (fir_filter->num < fir_filter->filter_len) {
+        fir_filter->sequence[fir_filter->index++] = in;
+        fir_filter->num++;
+        return in;
+    }
+    else {
+        if (fir_filter->filter_len <= fir_filter->index) {
+            fir_filter->index = 0;
+        }
+        fir_filter->sequence[fir_filter->index++] = in;
+
+        for (i = 0; i < fir_filter->filter_len; i++) {
+            out += fir_filter->sequence[i];
+        }
+        return out / fir_filter->filter_len;
+    }
+}
+
+static void
+thresh_filter_init(struct yas_thresh_filter *thresh_filter, int threshold)
+{
+    thresh_filter->threshold = threshold;
+    thresh_filter->last = 0;
+}
+
+static int32_t
+thresh_filter_filter(struct yas_thresh_filter *thresh_filter, int32_t in)
+{
+    if (in < thresh_filter->last - thresh_filter->threshold
+            || thresh_filter->last + thresh_filter->threshold < in) {
+        thresh_filter->last = in;
+        return in;
+    }
+    else {
+        return thresh_filter->last;
+    }
+}
+
+static void
+filter_init(struct yas_driver *d)
+{
+    int i;
+
+    for (i = 0; i < 3; i++) {
+        fir_filter_init(&d->fir_filter[i], d->filter_len);
+        thresh_filter_init(&d->thresh_filter[i], d->filter_thresh);
+    }
+}
+
+static void
+filter_filter(struct yas_driver *d, int32_t *orig, int32_t *filtered)
+{
+    int i;
+
+    for (i = 0; i < 3; i++) {
+        filtered[i] = fir_filter_filter(&d->fir_filter[i], orig[i]);
+        filtered[i] = thresh_filter_filter(&d->thresh_filter[i], filtered[i]);
+    }
+}
+
+static int
+is_valid_offset(const int8_t *p)
+{
+    return (p != NULL
+            && (p[0] <= 31) && (p[1] <= 31) && (p[2] <= 31)
+            && (-31 <= p[0]) && (-31 <= p[1]) && (-31 <= p[2]));
+}
+
+static int
+is_valid_calib_offset(const int32_t *p)
+{
+    int i;
+    for (i = 0; i < 3; i++) {
+        if (p[i] != INVALID_CALIB_OFFSET[i]) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static int
+is_offset_differ(const int8_t *p0, const int8_t *p1)
+{
+    return (p0[0] != p1[0] || p0[1] != p1[1] || p0[2] != p1[2]);
+}
+
+static int
+is_calib_offset_differ(const int32_t *p0, const int32_t *p1)
+{
+    return (p0[0] != p1[0] || p0[1] != p1[1] || p0[2] != p1[2]);
+}
+
+static int
+get_overflow(struct yas_driver *d)
+{
+    return d->overflow;
+}
+
+static void
+set_overflow(struct yas_driver *d, const int overflow)
+{
+    if (d->overflow != overflow) {
+        d->overflow = overflow;
+    }
+}
+
+static int
+get_initcoil_gaveup(struct yas_driver *d)
+{
+    return d->initcoil_gaveup;
+}
+
+static void
+set_initcoil_gaveup(struct yas_driver *d, const int initcoil_gaveup)
+{
+    d->initcoil_gaveup = initcoil_gaveup;
+}
+
+static int32_t *
+get_calib_offset(struct yas_driver *d)
+{
+    return d->offset.calib_offset.v;
+}
+
+static void
+set_calib_offset(struct yas_driver *d, const int32_t *offset)
+{
+    int i;
+
+    if (is_calib_offset_differ(d->offset.calib_offset.v, offset)) {
+        for (i = 0; i < 3; i++) {
+            d->offset.calib_offset.v[i] = offset[i];
+        }
+    }
+}
+
+static int8_t *
+get_offset(struct yas_driver *d)
+{
+    return d->offset.hard_offset;
+}
+
+static void
+set_offset(struct yas_driver *d, const int8_t *offset)
+{
+    int i;
+
+    if (is_offset_differ(d->offset.hard_offset, offset)) {
+        for (i = 0; i < 3; i++) {
+            d->offset.hard_offset[i] = offset[i];
+        }
+    }
+}
+
+static int
+get_active(struct yas_driver *d)
+{
+    return d->active;
+}
+
+static void
+set_active(struct yas_driver *d, const int active)
+{
+    d->active = active;
+}
+
+static int
+get_position(struct yas_driver *d)
+{
+    return d->position;
+}
+
+static void
+set_position(struct yas_driver *d, const int position)
+{
+    d->position = position;
+}
+
+static int
+get_measure_state(struct yas_driver *d)
+{
+    return d->measure_state;
+}
+
+static void
+set_measure_state(struct yas_driver *d, const int state)
+{
+    YLOGI(("state(%d)\n", state));
+    d->measure_state = state;
+}
+
+static struct utimer *
+get_data_timer(struct yas_driver *d)
+{
+    return &d->data_timer;
+}
+
+static struct utimer *
+get_initcoil_timer(struct yas_driver *d)
+{
+    return &d->initcoil_timer;
+}
+
+static struct utimer *
+get_initcoil_giveup_timer(struct yas_driver *d)
+{
+    return &d->initcoil_giveup_timer;
+}
+
+static struct utimer *
+get_detect_overflow_timer(struct yas_driver *d)
+{
+    return &d->detect_overflow_timer;
+}
+
+static int
+get_delay_timer_use_data(struct yas_driver *d)
+{
+    return d->delay_timer_use_data;
+}
+
+static void
+set_delay_timer_use_data(struct yas_driver *d, int flag)
+{
+    d->delay_timer_use_data = !!flag;
+}
+
+static int
+get_delay_timer_interval(struct yas_driver *d)
+{
+    return d->delay_timer_interval;
+}
+
+static void
+set_delay_timer_interval(struct yas_driver *d, int interval)
+{
+    d->delay_timer_interval = interval;
+}
+
+static int
+get_delay_timer_counter(struct yas_driver *d)
+{
+    return d->delay_timer_counter;
+}
+
+static void
+set_delay_timer_counter(struct yas_driver *d, int counter)
+{
+    d->delay_timer_counter = counter;
+}
+
+static int
+get_filter_enable(struct yas_driver *d)
+{
+    return d->filter_enable;
+}
+
+static void
+set_filter_enable(struct yas_driver *d, int enable)
+{
+    if (enable) {
+        filter_init(d);
+    }
+    d->filter_enable = enable;
+}
+
+static int
+get_filter_len(struct yas_driver *d)
+{
+    return d->filter_len;
+}
+
+static void
+set_filter_len(struct yas_driver *d, int len)
+{
+    if (d->filter_len < 0) {
+        d->filter_len = 0;
+    }
+    if (d->filter_len > YAS_MAX_FILTER_LEN) {
+        d->filter_len = YAS_MAX_FILTER_LEN;
+    }
+    d->filter_len = len;
+    filter_init(d);
+}
+
+static int
+get_filter_thresh(struct yas_driver *d)
+{
+    return d->filter_thresh;
+}
+
+static void
+set_filter_thresh(struct yas_driver *d, int threshold)
+{
+    if (d->filter_thresh < 0) {
+        d->filter_thresh = 0;
+    }
+    d->filter_thresh = threshold;
+    filter_init(d);
+}
+
+static int32_t*
+get_previous_mag(struct yas_driver *d)
+{
+    return d->prev_mag;
+}
+
+static void
+set_previous_mag(struct yas_driver *d, int32_t *data)
+{
+    int i;
+    for (i = 0; i < 3; i++) {
+        d->prev_mag[i] = data[i];
+    }
+}
+
+static int32_t*
+get_previous_xy1y2(struct yas_driver *d)
+{
+    return d->prev_xy1y2;
+}
+
+static void
+set_previous_xy1y2(struct yas_driver *d, int32_t *data)
+{
+    int i;
+    for (i = 0; i < 3; i++) {
+        d->prev_xy1y2[i] = data[i];
+    }
+}
+
+static int32_t*
+get_previous_mag_w_offset(struct yas_driver *d)
+{
+    return d->prev_mag_w_offset;
+}
+
+static void
+set_previous_mag_w_offset(struct yas_driver *d, int32_t *data)
+{
+    int i;
+    for (i = 0; i < 3; i++) {
+        d->prev_mag_w_offset[i] = data[i];
+    }
+}
+
+static int
+init_coil(struct yas_driver *d)
+{
+    int rt;
+
+    YLOGD(("init_coil IN\n"));
+
+    utimer_update(get_initcoil_timer(d));
+    if (!get_initcoil_gaveup(d)) {
+        utimer_update(get_initcoil_giveup_timer(d));
+        if (utimer_is_timeout(get_initcoil_giveup_timer(d))) {
+            utimer_clear_timeout(get_initcoil_giveup_timer(d));
+            set_initcoil_gaveup(d, TRUE);
+        }
+    }
+    if (utimer_is_timeout(get_initcoil_timer(d)) && !get_initcoil_gaveup(d)) {
+        utimer_clear_timeout(get_initcoil_timer(d));
+        YLOGI(("init_coil!\n"));
+        if ((rt = yas_cdrv_actuate_initcoil()) < 0) {
+            YLOGE(("yas_cdrv_actuate_initcoil failed[%d]\n", rt));
+            return rt;
+        }
+        if (get_overflow(d) || !is_valid_offset(get_offset(d))) {
+            set_measure_state(d, YAS_MAG_STATE_MEASURE_OFFSET);
+        }
+        else {
+            set_measure_state(d, YAS_MAG_STATE_NORMAL);
+        }
+    }
+
+    YLOGD(("init_coil OUT\n"));
+
+    return 0;
+}
+
+static int
+measure_offset(struct yas_driver *d)
+{
+    int8_t offset[3];
+    int32_t moffset[3];
+    int rt, result = 0, i;
+
+    YLOGI(("measure_offset IN\n"));
+
+    if ((rt = yas_cdrv_measure_and_set_offset(offset)) < 0) {
+        YLOGE(("yas_cdrv_measure_offset failed[%d]\n", rt));
+        return rt;
+    }
+
+    YLOGI(("offset[%d][%d][%d]\n", offset[0], offset[1], offset[2]));
+
+    for (i = 0; i < 3; i++) {
+        moffset[i] = get_calib_offset(d)[i];
+    }
+    if (is_offset_differ(get_offset(d), offset)) {
+        if (is_valid_offset(get_offset(d))
+                && is_valid_calib_offset(get_calib_offset(d))) {
+            yas_cdrv_recalc_calib_offset(get_calib_offset(d),
+                    moffset,
+                    get_offset(d),
+                    offset);
+            result |= YAS_REPORT_CALIB_OFFSET_CHANGED;
+        }
+    }
+
+    result |= YAS_REPORT_HARD_OFFSET_CHANGED;
+    set_offset(d, offset);
+    if (is_valid_calib_offset(moffset)) {
+        set_calib_offset(d, moffset);
+    }
+    set_measure_state(d, YAS_MAG_STATE_NORMAL);
+
+    YLOGI(("measure_offset OUT\n"));
+
+    return result;
+}
+
+static int
+measure_msensor_normal(struct yas_driver *d, int32_t *magnetic,
+        int32_t *mag_w_offset, int32_t *xy1y2, int16_t *temperature)
+{
+    int rt = 0, result, i;
+    int32_t filtered[3];
+    int16_t tmp[3];
+
+    YLOGD(("measure_msensor_normal IN\n"));
+
+    result = 0;
+    if ((rt = yas_cdrv_measure(mag_w_offset, tmp, temperature)) < 0) {
+        YLOGE(("yas_cdrv_measure failed[%d]\n", rt));
+        return rt;
+    }
+    for (i = 0; i < 3; i++) {
+        xy1y2[i] = tmp[i];
+    }
+    if (rt > 0) {
+        YLOGW(("yas_cdrv_measure under/overflow x[%c%c] y[%c%c] z[%c%c]\n",
+                (rt&0x01) ? 'u' : ' ',
+                (rt&0x02) ? 'o' : ' ',
+                (rt&0x04) ? 'u' : ' ',
+                (rt&0x08) ? 'o' : ' ',
+                (rt&0x10) ? 'u' : ' ',
+                (rt&0x20) ? 'o' : ' '));
+        utimer_update(get_detect_overflow_timer(d));
+        set_overflow(d, TRUE);
+        if (utimer_is_timeout(get_detect_overflow_timer(d))) {
+            utimer_clear_timeout(get_detect_overflow_timer(d));
+            result |= YAS_REPORT_OVERFLOW_OCCURED;
+        }
+        if (get_measure_state(d) == YAS_MAG_STATE_NORMAL) {
+            set_measure_state(d, YAS_MAG_STATE_INIT_COIL);
+        }
+    }
+    else {
+        utimer_clear(get_detect_overflow_timer(d));
+        set_overflow(d, FALSE);
+        if (get_measure_state(d) == YAS_MAG_STATE_NORMAL) {
+            utimer_clear(get_initcoil_timer(d));
+            utimer_clear(get_initcoil_giveup_timer(d));
+        }
+    }
+    if (get_filter_enable(d)) {
+        filter_filter(d, mag_w_offset, filtered);
+    }
+
+    if (is_valid_calib_offset(get_calib_offset(d))) {
+        for (i = 0; i < 3; i++) {
+            magnetic[i] = get_filter_enable(d)
+                ? filtered[i] - get_calib_offset(d)[i]
+                : mag_w_offset[i] - get_calib_offset(d)[i];
+        }
+    }
+    else {
+        for (i = 0; i < 3; i++) {
+            magnetic[i] = get_filter_enable(d) ? filtered[i] : mag_w_offset[i];
+        }
+    }
+
+    YLOGD(("measure_msensor_normal OUT\n"));
+
+    return result;
+}
+
+static int
+measure_msensor(struct yas_driver *d, int32_t *magnetic, int32_t *mag_w_offset,
+        int32_t *xy1y2, int16_t *temperature)
+{
+    int result, i;
+
+    YLOGD(("measure_msensor IN\n"));
+
+    for (i = 0; i < 3; i++) {
+        magnetic[i] = get_previous_mag(d)[i];
+        mag_w_offset[i] = get_previous_mag_w_offset(d)[i];
+        xy1y2[i] = get_previous_xy1y2(d)[i];
+    }
+
+    result = 0;
+    switch (get_measure_state(d)) {
+    case YAS_MAG_STATE_INIT_COIL:
+        result = init_coil(d);
+        break;
+    case YAS_MAG_STATE_MEASURE_OFFSET:
+        result = measure_offset(d);
+        break;
+    case YAS_MAG_STATE_NORMAL:
+        result = 0;
+        break;
+    default:
+        result = -1;
+        break;
+    }
+
+    if (result < 0) {
+        return result;
+    }
+
+    if (!(result & YAS_REPORT_OVERFLOW_OCCURED)) {
+        result |= measure_msensor_normal(d, magnetic, mag_w_offset, xy1y2, temperature);
+    }
+    set_previous_mag(d, magnetic);
+    set_previous_xy1y2(d, xy1y2);
+    set_previous_mag_w_offset(d, mag_w_offset);
+
+    YLOGD(("measure_msensor OUT\n"));
+
+    return result;
+}
+
+static int
+measure(struct yas_driver *d, int32_t *magnetic, int32_t *mag_w_offset,
+        int32_t *xy1y2, int16_t *temperature, uint32_t *time_delay)
+{
+    int result;
+    int counter;
+    uint32_t total = 0;
+
+    YLOGD(("measure IN\n"));
+
+    utimer_update(get_data_timer(d));
+
+    if ((result = measure_msensor(d, magnetic, mag_w_offset, xy1y2, temperature)) < 0) {
+        return result;
+    }
+
+    counter = get_delay_timer_counter(d);
+    total = utimer_get_total_time(get_data_timer(d));
+    if (utimer_get_delay(get_data_timer(d)) > 0) {
+        counter -= total / utimer_get_delay(get_data_timer(d));
+    }
+    else {
+        counter = 0;
+    }
+
+    if (utimer_is_timeout(get_data_timer(d))) {
+        utimer_clear_timeout(get_data_timer(d));
+
+        if (get_delay_timer_use_data(d)) {
+            result |= YAS_REPORT_DATA;
+            if (counter <= 0) {
+                result |= YAS_REPORT_CALIB;
+            }
+        }
+        else {
+            result |= YAS_REPORT_CALIB;
+            if (counter <= 0) {
+                result |= YAS_REPORT_DATA;
+            }
+        }
+    }
+
+    if (counter <= 0) {
+        set_delay_timer_counter(d, get_delay_timer_interval(d));
+    }
+    else {
+        set_delay_timer_counter(d, counter);
+    }
+
+    *time_delay = utimer_sleep_time(get_data_timer(d));
+
+    YLOGD(("measure OUT [%d]\n", result));
+
+    return result;
+}
+
+static void
+activate(struct yas_driver *d)
+{
+    YLOGI(("activate IN\n"));
+
+    filter_init(d);
+
+    YLOGI(("activate OUT\n"));
+}
+
+static void
+deactivate(struct yas_driver *d)
+{
+    YLOGI(("deactivate IN\n"));
+
+    /* restart initialization coil give up timer */
+    utimer_clear(get_initcoil_giveup_timer(d));
+    set_initcoil_gaveup(d, FALSE);
+
+    YLOGI(("deactivate OUT\n"));
+}
+
+static int
+check_interval(int ms)
+{
+    int index;
+
+    if (ms == 0) {
+        ms = supported_data_interval[0];
+    }
+    for (index = 0; index < NELEMS(supported_data_interval); index++) {
+        if (ms == supported_data_interval[index]) {
+            return index;
+        }
+    }
+    return -1;
+}
+
+static int
+yas_init_nolock(struct yas_driver *d)
+{
+    struct yas_machdep_func func;
+    int rt;
+
+    YLOGI(("yas_init_nolock IN\n"));
+
+    func.i2c_open = d->callback.i2c_open;
+    func.i2c_close = d->callback.i2c_close;
+    func.i2c_write = d->callback.i2c_write;
+    func.i2c_read = d->callback.i2c_read;
+    func.msleep = d->callback.msleep;
+
+    if ((rt = yas_cdrv_init(YAS_TRANSFORMATION[get_position(d)], &func)) < 0) {
+        YLOGE(("yas_cdrv_init failed[%d]\n", rt));
+        return rt;
+    }
+
+    utimer_lib_init(this_driver.callback.current_time);
+    utimer_init(get_data_timer(d), 50);
+    utimer_init(get_initcoil_timer(d), YAS_INITCOIL_INTERVAL);
+    utimer_init(get_initcoil_giveup_timer(d), YAS_INITCOIL_GIVEUP_INTERVAL);
+    utimer_init(get_detect_overflow_timer(d), YAS_DETECT_OVERFLOW_INTERVAL);
+    set_initcoil_gaveup(d, FALSE);
+
+    set_calib_offset(d, INVALID_CALIB_OFFSET);
+    set_offset(d, INVALID_OFFSET);
+
+    if ((rt = yas_cdrv_actuate_initcoil()) < 0) {
+        YLOGE(("yas_cdrv_actuate_initcoil failed[%d]\n", rt));
+        set_measure_state(d, YAS_MAG_STATE_INIT_COIL);
+    }
+    else {
+        set_measure_state(d, YAS_MAG_STATE_MEASURE_OFFSET);
+    }
+
+    YLOGI(("yas_init_nolock OUT\n"));
+
+    return 0;
+}
+
+static void
+yas_term_nolock(struct yas_driver *d)
+{
+    YLOGI(("yas_term_nolock\n"));
+
+    (void) d;
+    yas_cdrv_term();
+
+    YLOGI(("yas_term_nolock out\n"));
+}
+
+static int
+yas_get_delay_nolock(struct yas_driver *d, int *ms)
+{
+    if (get_delay_timer_use_data(d)) {
+        *ms = utimer_get_delay(get_data_timer(d));
+    }
+    else {
+        *ms = utimer_get_delay(get_data_timer(d)) * get_delay_timer_interval(d);
+    }
+    return 0;
+}
+
+static int
+yas_set_delay_nolock(struct yas_driver *d, int ms)
+{
+    int index;
+    uint32_t delay_data, delay_calib;
+
+    if ((index = check_interval(ms)) < 0) {
+        return -1;
+    }
+    delay_data = supported_data_interval[index];
+    delay_calib = supported_calib_interval[index];
+    set_delay_timer_use_data(d, delay_data < delay_calib);
+    if (delay_data < delay_calib) {
+        set_delay_timer_interval(d, delay_calib / delay_data);
+        set_delay_timer_counter(d, delay_calib / delay_data);
+        utimer_set_delay(get_data_timer(d), supported_data_interval[index]);
+    }
+    else {
+        set_delay_timer_interval(d, delay_data / delay_calib);
+        set_delay_timer_counter(d, delay_data / delay_calib);
+        utimer_set_delay(get_data_timer(d), supported_calib_interval[index]);
+    }
+
+    return 0;
+}
+
+static int
+yas_get_offset_nolock(struct yas_driver *d, struct yas_mag_offset *offset)
+{
+    *offset = d->offset;
+    return 0;
+}
+
+static int
+yas_set_offset_nolock(struct yas_driver *d, struct yas_mag_offset *offset)
+{
+    d->offset = *offset;
+    if (is_valid_offset(d->offset.hard_offset)) {
+        yas_cdrv_set_offset(d->offset.hard_offset);
+    }
+    else {
+        set_measure_state(d, YAS_MAG_STATE_MEASURE_OFFSET);
+    }
+    return 0;
+}
+
+static int
+yas_get_enable_nolock(struct yas_driver *d)
+{
+    return get_active(d);
+}
+
+static int
+yas_set_enable_nolock(struct yas_driver *d, int active)
+{
+    if (active) {
+        if (!get_active(d)) {
+            activate(d);
+            set_active(d, TRUE);
+            return 0;
+        }
+    }
+    else {
+        if (get_active(d)) {
+            deactivate(d);
+            set_active(d, FALSE);
+            return 0;
+        }
+    }
+    return 0;
+}
+
+static int
+yas_get_filter_nolock(struct yas_driver *d, struct yas_mag_filter *filter)
+{
+    filter->len = get_filter_len(d);
+    filter->threshold = get_filter_thresh(d);
+    return 0;
+}
+
+static int
+yas_set_filter_nolock(struct yas_driver *d, struct yas_mag_filter *filter)
+{
+    set_filter_len(d, filter->len);
+    set_filter_thresh(d, filter->threshold);
+    return 0;
+}
+
+static int
+yas_get_filter_enable_nolock(struct yas_driver *d)
+{
+    return get_filter_enable(d);
+}
+
+static int
+yas_set_filter_enable_nolock(struct yas_driver *d, int enable)
+{
+    set_filter_enable(d, enable);
+    return 0;
+}
+
+static int
+yas_get_position_nolock(struct yas_driver *d, int *position)
+{
+    *position = get_position(d);
+    return 0;
+}
+
+static int
+yas_set_position_nolock(struct yas_driver *d, int position)
+{
+    set_position(d, position);
+    yas_cdrv_set_transformatiom_matrix(YAS_TRANSFORMATION[position]);
+    filter_init(d);
+    return 0;
+}
+
+static int
+yas_init(void)
+{
+    int rt;
+
+    YLOGI(("yas_init\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_init_nolock(&this_driver);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    return rt;
+}
+
+static int
+yas_term(void)
+{
+    YLOGI(("yas_term\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    yas_term_nolock(&this_driver);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    return 0;
+}
+
+static int
+yas_get_delay(void)
+{
+    int ms;
+
+    YLOGI(("yas_get_delay\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    yas_get_delay_nolock(&this_driver, &ms);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_delay[%d] OUT\n", ms));
+
+    return ms;
+}
+
+static int
+yas_set_delay(int delay)
+{
+    int rt;
+
+    YLOGI(("yas_set_delay\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_delay_nolock(&this_driver, delay);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_delay OUT\n"));
+
+    return rt;
+}
+
+static int
+yas_get_offset(struct yas_mag_offset *offset)
+{
+    int rt;
+
+    YLOGI(("yas_get_offset\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_get_offset_nolock(&this_driver, offset);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_offset[%d] OUT\n", rt));
+
+    return rt;
+}
+
+static int
+yas_set_offset(struct yas_mag_offset *offset)
+{
+    int rt;
+
+    YLOGI(("yas_set_offset IN\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_offset_nolock(&this_driver, offset);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_offset OUT\n"));
+
+    return rt;
+}
+
+static int
+yas_get_enable(void)
+{
+    int rt;
+
+    YLOGI(("yas_get_enable\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_get_enable_nolock(&this_driver);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_enable OUT[%d]\n", rt));
+
+    return rt;
+}
+
+static int
+yas_set_enable(int enable)
+{
+    int rt;
+
+    YLOGI(("yas_set_enable IN\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_enable_nolock(&this_driver, enable);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_enable OUT\n"));
+
+    return rt;
+}
+
+static int
+yas_get_filter(struct yas_mag_filter *filter)
+{
+    int rt;
+
+    YLOGI(("yas_get_filter\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_get_filter_nolock(&this_driver, filter);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_filter[%d] OUT\n", rt));
+
+    return rt;
+}
+
+static int
+yas_set_filter(struct yas_mag_filter *filter)
+{
+    int rt;
+
+    YLOGI(("yas_set_filter IN\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_filter_nolock(&this_driver, filter);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_filter OUT\n"));
+
+    return rt;
+}
+
+static int
+yas_get_filter_enable(void)
+{
+    int rt;
+
+    YLOGI(("yas_get_filter_enable\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_get_filter_enable_nolock(&this_driver);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_filter_enable OUT[%d]\n", rt));
+
+    return rt;
+}
+
+static int
+yas_set_filter_enable(int enable)
+{
+    int rt;
+
+    YLOGI(("yas_set_filter_enable IN\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_filter_enable_nolock(&this_driver, enable);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_filter_enable OUT\n"));
+
+    return rt;
+}
+
+static int
+yas_get_position(void)
+{
+    int position = 0;
+
+    YLOGI(("yas_get_position\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    yas_get_position_nolock(&this_driver, &position);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_get_position[%d] OUT\n", position));
+
+    return position;
+}
+
+static int
+yas_set_position(int position)
+{
+    int rt;
+
+    if (position < 0 || 7 < position) {
+        return YAS_ERROR_ARG;
+    }
+
+    YLOGI(("yas_set_position\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_set_position_nolock(&this_driver, position);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_set_position[%d] OUT\n", position));
+
+    return rt;
+}
+
+static int
+yas_read_reg_nolock(struct yas_driver *d, uint8_t addr, uint8_t *buf, int len)
+{
+    if (d->callback.i2c_read(YAS_SLAVE_ADDRESS, addr, buf, len) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+yas_write_reg_nolock(struct yas_driver *d, uint8_t addr, const uint8_t *buf, int len)
+{
+    if (d->callback.i2c_write(YAS_SLAVE_ADDRESS, addr, buf, len) < 0) {
+        return YAS_ERROR_I2C;
+    }
+
+    return YAS_NO_ERROR;
+}
+
+static int
+yas_read_reg(uint8_t addr, uint8_t *buf, int len)
+{
+    int rt;
+
+    YLOGI(("yas_read_reg\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_read_reg_nolock(&this_driver, addr, buf, len);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_read_reg[%d] OUT\n", rt));
+
+    return rt;
+}
+
+static int
+yas_write_reg(uint8_t addr, const uint8_t *buf, int len)
+{
+    int rt;
+
+    YLOGI(("yas_write_reg\n"));
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    rt = yas_write_reg_nolock(&this_driver, addr, buf, len);
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGI(("yas_write_reg[%d] OUT\n", rt));
+
+    return rt;
+}
+
+static int
+yas_measure(struct yas_mag_data *data, int *time_delay_ms)
+{
+    uint32_t time_delay = YAS_MAG_ERROR_DELAY;
+    int rt;
+
+    YLOGD(("yas_measure IN\n"));
+
+    if (data == NULL || time_delay_ms == NULL) {
+        return YAS_ERROR_ARG;
+    }
+
+    if (lock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    *time_delay_ms = YAS_MAG_ERROR_DELAY;
+    rt = 0;
+
+    if (get_active(&this_driver)) {
+        rt = measure(&this_driver, data->xyz.v, data->raw.v, data->xy1y2.v, &data->temperature, &time_delay);
+        if (rt >= 0) {
+            *time_delay_ms = time_delay;
+            if (*time_delay_ms > 0) {
+                *time_delay_ms += 1; /* for the system that the time is in usec
+                                        unit */
+            }
+        }
+    }
+    else {
+        rt = YAS_ERROR_NOT_ACTIVE;
+    }
+
+    if (unlock() < 0) {
+        return YAS_ERROR_RESTARTSYS;
+    }
+
+    YLOGD(("yas_measure OUT[%d]\n", rt));
+
+    return rt;
+}
+
+STATIC int
+yas_mag_driver_init(struct yas_mag_driver *f)
+{
+    if (f == NULL) {
+        return YAS_ERROR_ARG;
+    }
+
+    f->init = yas_init;
+    f->term = yas_term;
+    f->get_delay = yas_get_delay;
+    f->set_delay = yas_set_delay;
+    f->get_offset = yas_get_offset;
+    f->set_offset = yas_set_offset;
+    f->get_enable = yas_get_enable;
+    f->set_enable = yas_set_enable;
+    f->get_filter = yas_get_filter;
+    f->set_filter = yas_set_filter;
+    f->get_filter_enable = yas_get_filter_enable;
+    f->set_filter_enable = yas_set_filter_enable;
+    f->get_position = yas_get_position;
+    f->set_position = yas_set_position;
+    f->read_reg = yas_read_reg;
+    f->write_reg = yas_write_reg;
+    f->measure = yas_measure;
+
+    this_driver.callback.lock = f->callback.lock;
+    this_driver.callback.unlock = f->callback.unlock;
+    this_driver.callback.i2c_open = f->callback.i2c_open;
+    this_driver.callback.i2c_close = f->callback.i2c_close;
+    this_driver.callback.i2c_write = f->callback.i2c_write;
+    this_driver.callback.i2c_read = f->callback.i2c_read;
+    this_driver.callback.msleep = f->callback.msleep;
+    this_driver.callback.current_time = f->callback.current_time;
+
+    return YAS_NO_ERROR;
+}
+
+
+/*
+ * Copyright (c) 2010 Yamaha Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+
+/*#include "yas.h"*/
+
+#define YAS_DEFAULT_THRESHOLD               (1)
+#define YAS_DEFAULT_DISTORTION              (15)
+#define YAS_DEFAULT_SHAPE                   (0)
+
+#define GEOMAGNETIC_I2C_DEVICE_NAME         "yas530"
+#define GEOMAGNETIC_INPUT_NAME              "geomagnetic"
+#define GEOMAGNETIC_INPUT_RAW_NAME          "geomagnetic_raw"
+
+#define ABS_STATUS                          (ABS_BRAKE)
+#define ABS_WAKE                            (ABS_MISC)
+
+#define ABS_RAW_DISTORTION                  (ABS_THROTTLE)
+#define ABS_RAW_THRESHOLD                   (ABS_RUDDER)
+#define ABS_RAW_SHAPE                       (ABS_WHEEL)
+#define ABS_RAW_REPORT                      (ABS_GAS)
+
+static int geomagnetic_lock(void);
+static int geomagnetic_unlock(void);
+static int geomagnetic_i2c_open(void);
+static int geomagnetic_i2c_close(void);
+static int geomagnetic_i2c_read(uint8_t slave, uint8_t addr, uint8_t *buf, int len);
+static int geomagnetic_i2c_write(uint8_t slave, uint8_t addr, const uint8_t *buf, int len);
+static void geomagnetic_msleep(int ms);
+static void geomagnetic_current_time(int32_t *sec, int32_t *msec);
+
+struct geomagnetic_data {
+    struct input_dev *input_data;
+    struct input_dev *input_raw;
+    struct delayed_work work;
+    struct semaphore driver_lock;
+    struct semaphore multi_lock;
+    atomic_t last_data[3];
+    atomic_t last_status;
+    atomic_t enable;
+    atomic_t filter_enable;
+    atomic_t filter_len;
+    atomic_t filter_threshold;
+    atomic_t delay;
+    int32_t threshold;
+    int32_t distortion[3];
+    int32_t shape;
+    struct yas_mag_offset driver_offset;
+#if DEBUG
+    int suspend;
+#endif
+};
+
+static struct yas_mag_driver hwdep_driver = {
+    .callback = {
+        .lock           = geomagnetic_lock,
+        .unlock         = geomagnetic_unlock,
+        .i2c_open       = geomagnetic_i2c_open,
+        .i2c_close      = geomagnetic_i2c_close,
+        .i2c_read       = geomagnetic_i2c_read,
+        .i2c_write      = geomagnetic_i2c_write,
+        .msleep         = geomagnetic_msleep,
+        .current_time   = geomagnetic_current_time,
+    },
+};
+
+static struct i2c_client *this_client = NULL;
+
+static int
+geomagnetic_multi_lock(void)
+{
+    struct geomagnetic_data *data = NULL;
+    int rt;
+
+    if (this_client == NULL) {
+        return -1;
+    }
+
+    data = i2c_get_clientdata(this_client);
+    rt = down_interruptible(&data->multi_lock);
+    if (rt < 0) {
+        up(&data->multi_lock);
+    }
+    return rt;
+}
+
+static int
+geomagnetic_multi_unlock(void)
+{
+    struct geomagnetic_data *data = NULL;
+
+    if (this_client == NULL) {
+        return -1;
+    }
+
+    data = i2c_get_clientdata(this_client);
+    up(&data->multi_lock);
+    return 0;
+}
+
+static int
+geomagnetic_enable(struct geomagnetic_data *data)
+{
+    if (!atomic_cmpxchg(&data->enable, 0, 1)) {
+        schedule_delayed_work(&data->work, 0);
+    }
+
+    return 0;
+}
+
+static int
+geomagnetic_disable(struct geomagnetic_data *data)
+{
+    if (atomic_cmpxchg(&data->enable, 1, 0)) {
+        cancel_delayed_work_sync(&data->work);
+    }
+
+    return 0;
+}
+
+/* Sysfs interface */
+static ssize_t
+geomagnetic_delay_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+
+    return sprintf(buf, "%d\n", atomic_read(&data->delay));
+}
+
+static ssize_t
+geomagnetic_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    int value = simple_strtoul(buf, NULL, 10);
+
+    if (hwdep_driver.set_delay == NULL) {
+        return -ENOTTY;
+    }
+
+    value = simple_strtoul(buf, NULL, 10);
+    if (hwdep_driver.set_delay(value) == 0) {
+        atomic_set(&data->delay, value);
+    }
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_enable_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+
+    return sprintf(buf, "%d\n", atomic_read(&data->enable));
+}
+
+static ssize_t
+geomagnetic_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    int value;
+
+    value = simple_strtoul(buf, NULL, 10);
+    if (value != 0 && value != 1) {
+        return count;
+    }
+    if (hwdep_driver.set_enable == NULL) {
+        return -ENOTTY;
+    }
+
+    if (geomagnetic_multi_lock() < 0) {
+        return count;
+    }
+
+    if (value) {
+        hwdep_driver.set_enable(value);
+        geomagnetic_enable(data);
+    }
+    else {
+        geomagnetic_disable(data);
+        hwdep_driver.set_enable(value);
+    }
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_filter_enable_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+
+    return sprintf(buf, "%d\n", atomic_read(&data->filter_enable));
+}
+
+static ssize_t
+geomagnetic_filter_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    int value;
+
+    if (hwdep_driver.set_filter_enable == NULL) {
+        return -ENOTTY;
+    }
+
+    value = simple_strtoul(buf, NULL, 10);
+    if (value != 0 && value != 1) {
+        return count;
+    }
+    if (geomagnetic_multi_lock() < 0) {
+        return count;
+    }
+
+    if (value) {
+        hwdep_driver.set_filter_enable(value);
+    }
+    else {
+        hwdep_driver.set_filter_enable(value);
+    }
+    atomic_set(&data->filter_enable, value);
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_filter_len_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+
+    return sprintf(buf, "%d\n", atomic_read(&data->filter_len));
+}
+
+static ssize_t
+geomagnetic_filter_len_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    struct yas_mag_filter filter;
+    int value;
+
+
+    if (hwdep_driver.get_filter == NULL || hwdep_driver.set_filter == NULL) {
+        return -ENOTTY;
+    }
+
+    value = simple_strtoul(buf, NULL, 10);
+
+    if (geomagnetic_multi_lock() < 0) {
+        return count;
+    }
+
+    hwdep_driver.get_filter(&filter);
+    filter.len = value;
+    hwdep_driver.set_filter(&filter);
+    atomic_set(&data->filter_len, value);
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_filter_threshold_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+
+    return sprintf(buf, "%d\n", atomic_read(&data->filter_threshold));
+}
+
+static ssize_t
+geomagnetic_filter_threshold_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    struct yas_mag_filter filter;
+    int value;
+
+
+    if (hwdep_driver.get_filter == NULL || hwdep_driver.set_filter == NULL) {
+        return -ENOTTY;
+    }
+
+    value = simple_strtoul(buf, NULL, 10);
+
+    if (geomagnetic_multi_lock() < 0) {
+        return count;
+    }
+
+    hwdep_driver.get_filter(&filter);
+    filter.threshold = value;
+    hwdep_driver.set_filter(&filter);
+    atomic_set(&data->filter_threshold, value);
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_position_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    if (hwdep_driver.get_position == NULL) {
+        return -ENOTTY;
+    }
+    return sprintf(buf, "%d\n", hwdep_driver.get_position());
+}
+
+static ssize_t
+geomagnetic_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    int value = simple_strtoul(buf, NULL, 10);
+
+    if (hwdep_driver.set_position == NULL) {
+        return -ENOTTY;
+    }
+    hwdep_driver.set_position(value);
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_data_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    int rt;
+
+    rt = sprintf(buf, "%d %d %d\n",
+            atomic_read(&data->last_data[0]),
+            atomic_read(&data->last_data[1]),
+            atomic_read(&data->last_data[2]));
+
+    return rt;
+}
+
+static ssize_t
+geomagnetic_status_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    int rt;
+
+    rt = sprintf(buf, "%d\n", atomic_read(&data->last_status));
+
+    return rt;
+}
+
+static ssize_t
+geomagnetic_wake_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_data = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_data);
+    static int16_t cnt = 1;
+
+    input_report_abs(data->input_data, ABS_WAKE, cnt++);
+
+    return count;
+}
+
+#if DEBUG
+
+static int geomagnetic_suspend(struct i2c_client *client, pm_message_t mesg);
+static int geomagnetic_resume(struct i2c_client *client);
+
+static ssize_t
+geomagnetic_debug_suspend_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input);
+
+    return sprintf(buf, "%d\n", data->suspend);
+}
+
+static ssize_t
+geomagnetic_debug_suspend_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long suspend = simple_strtoul(buf, NULL, 10);
+
+    if (suspend) {
+        pm_message_t msg;
+        memset(&msg, 0, sizeof(msg));
+        geomagnetic_suspend(this_client, msg);
+    } else {
+        geomagnetic_resume(this_client);
+    }
+
+    return count;
+}
+
+#endif /* DEBUG */
+
+static DEVICE_ATTR(poll_delay, S_IRUGO|S_IWUSR|S_IWGRP,
+        geomagnetic_delay_show, geomagnetic_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        geomagnetic_enable_show, geomagnetic_enable_store);
+static DEVICE_ATTR(filter_enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        geomagnetic_filter_enable_show, geomagnetic_filter_enable_store);
+static DEVICE_ATTR(filter_len, S_IRUGO|S_IWUSR|S_IWGRP,
+        geomagnetic_filter_len_show, geomagnetic_filter_len_store);
+static DEVICE_ATTR(filter_threshold, S_IRUGO|S_IWUSR|S_IWGRP,
+        geomagnetic_filter_threshold_show, geomagnetic_filter_threshold_store);
+static DEVICE_ATTR(data, S_IRUGO, geomagnetic_data_show, NULL);
+static DEVICE_ATTR(status, S_IRUGO, geomagnetic_status_show, NULL);
+static DEVICE_ATTR(wake, S_IWUSR|S_IWGRP, NULL, geomagnetic_wake_store);
+static DEVICE_ATTR(position, S_IRUGO|S_IWUSR,
+        geomagnetic_position_show, geomagnetic_position_store);
+#if DEBUG
+static DEVICE_ATTR(debug_suspend, S_IRUGO|S_IWUSR,
+        geomagnetic_debug_suspend_show, geomagnetic_debug_suspend_store);
+#endif /* DEBUG */
+
+static struct attribute *geomagnetic_attributes[] = {
+    &dev_attr_poll_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_filter_enable.attr,
+    &dev_attr_filter_len.attr,
+    &dev_attr_filter_threshold.attr,
+    &dev_attr_data.attr,
+    &dev_attr_status.attr,
+    &dev_attr_wake.attr,
+    &dev_attr_position.attr,
+#if DEBUG
+    &dev_attr_debug_suspend.attr,
+#endif /* DEBUG */
+    NULL
+};
+
+static struct attribute_group geomagnetic_attribute_group = {
+    .attrs = geomagnetic_attributes
+};
+
+static ssize_t
+geomagnetic_threshold_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int threshold;
+
+    geomagnetic_multi_lock();
+
+    threshold = data->threshold;
+
+    geomagnetic_multi_unlock();
+
+    return sprintf(buf, "%d\n", threshold);
+}
+
+static ssize_t
+geomagnetic_threshold_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int value = simple_strtoul(buf, NULL, 10);
+
+    geomagnetic_multi_lock();
+
+    if (0 <= value && value <= 2) {
+        data->threshold = value;
+        input_report_abs(data->input_raw, ABS_RAW_THRESHOLD, value);
+    }
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_distortion_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int rt;
+
+    geomagnetic_multi_lock();
+
+    rt = sprintf(buf, "%d %d %d\n",
+            data->distortion[0],
+            data->distortion[1],
+            data->distortion[2]);
+
+    geomagnetic_multi_unlock();
+
+    return rt;
+}
+
+static ssize_t
+geomagnetic_distortion_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int32_t distortion[3];
+    static int32_t val = 1;
+    int i;
+
+    geomagnetic_multi_lock();
+
+    sscanf(buf, "%d %d %d",
+            &distortion[0],
+            &distortion[1],
+            &distortion[2]);
+    if (distortion[0] > 0 && distortion[1] > 0 && distortion[2] > 0) {
+        for (i = 0; i < 3; i++) {
+            data->distortion[i] = distortion[i];
+        }
+        input_report_abs(data->input_raw, ABS_RAW_DISTORTION, val++);
+    }
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_shape_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int shape;
+
+    geomagnetic_multi_lock();
+
+    shape = data->shape;
+
+    geomagnetic_multi_unlock();
+
+    return sprintf(buf, "%d\n", shape);
+}
+
+static ssize_t
+geomagnetic_shape_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    int value = simple_strtoul(buf, NULL, 10);
+
+    geomagnetic_multi_lock();
+
+    if (0 <= value && value <= 1) {
+        data->shape = value;
+        input_report_abs(data->input_raw, ABS_RAW_SHAPE, value);
+    }
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static ssize_t
+geomagnetic_offsets_show(struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    struct yas_mag_offset offset;
+    int accuracy;
+
+    geomagnetic_multi_lock();
+
+    offset = data->driver_offset;
+    accuracy = atomic_read(&data->last_status);
+
+    geomagnetic_multi_unlock();
+
+    return sprintf(buf, "%d %d %d %d %d %d %d\n",
+            offset.hard_offset[0],
+            offset.hard_offset[1],
+            offset.hard_offset[2],
+            offset.calib_offset.v[0],
+            offset.calib_offset.v[1],
+            offset.calib_offset.v[2],
+            accuracy);
+}
+
+static ssize_t
+geomagnetic_offsets_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+    struct input_dev *input_raw = to_input_dev(dev);
+    struct geomagnetic_data *data = input_get_drvdata(input_raw);
+    struct yas_mag_offset offset;
+    int32_t hard_offset[3];
+    int i, accuracy;
+
+    geomagnetic_multi_lock();
+
+    sscanf(buf, "%d %d %d %d %d %d %d",
+            &hard_offset[0],
+            &hard_offset[1],
+            &hard_offset[2],
+            &offset.calib_offset.v[0],
+            &offset.calib_offset.v[1],
+            &offset.calib_offset.v[2],
+            &accuracy);
+    for (i = 0; i < 3; i++) {
+        offset.hard_offset[i] = (int8_t)hard_offset[i];
+    }
+    hwdep_driver.set_offset(&offset);
+    atomic_set(&data->last_status, accuracy);
+    data->driver_offset = offset;
+
+    geomagnetic_multi_unlock();
+
+    return count;
+}
+
+static DEVICE_ATTR(threshold, S_IRUGO|S_IWUSR,
+        geomagnetic_threshold_show, geomagnetic_threshold_store);
+static DEVICE_ATTR(distortion, S_IRUGO|S_IWUSR,
+        geomagnetic_distortion_show, geomagnetic_distortion_store);
+static DEVICE_ATTR(shape, S_IRUGO|S_IWUSR,
+        geomagnetic_shape_show, geomagnetic_shape_store);
+static DEVICE_ATTR(offsets, S_IRUGO|S_IWUSR,
+        geomagnetic_offsets_show, geomagnetic_offsets_store);
+
+static struct attribute *geomagnetic_raw_attributes[] = {
+    &dev_attr_threshold.attr,
+    &dev_attr_distortion.attr,
+    &dev_attr_shape.attr,
+    &dev_attr_offsets.attr,
+    NULL
+};
+
+static struct attribute_group geomagnetic_raw_attribute_group = {
+    .attrs = geomagnetic_raw_attributes
+};
+
+/* Interface Functions for Lower Layer */
+
+static void
+geomagnetic_input_work_func(struct work_struct *work)
+{
+    struct geomagnetic_data *data = container_of((struct delayed_work *)work,
+            struct geomagnetic_data, work);
+    uint32_t time_delay_ms = 100;
+    struct yas_mag_offset offset;
+    struct yas_mag_data magdata;
+    int rt, i, accuracy;
+
+    if (hwdep_driver.measure == NULL || hwdep_driver.get_offset == NULL) {
+        return;
+    }
+
+    rt = hwdep_driver.measure(&magdata, &time_delay_ms);
+    if (rt < 0) {
+        YLOGE(("measure failed[%d]\n", rt));
+    }
+    YLOGD(("xy1y2 [%d][%d][%d] raw[%d][%d][%d]\n",
+            magdata.xy1y2.v[0], magdata.xy1y2.v[1], magdata.xy1y2.v[2],
+            magdata.xyz.v[0], magdata.xyz.v[1], magdata.xyz.v[2]));
+
+    if (rt >= 0) {
+        accuracy = atomic_read(&data->last_status);
+
+        if ((rt & YAS_REPORT_OVERFLOW_OCCURED)
+                || (rt & YAS_REPORT_HARD_OFFSET_CHANGED)
+                || (rt & YAS_REPORT_CALIB_OFFSET_CHANGED)) {
+            static uint16_t count = 1;
+            int code = 0;
+            int value = 0;
+
+            hwdep_driver.get_offset(&offset);
+
+            geomagnetic_multi_lock();
+            data->driver_offset = offset;
+            if (rt & YAS_REPORT_OVERFLOW_OCCURED) {
+                /* FIXME: intensity threshold */
+                atomic_set(&data->last_status, 0);
+                accuracy = 0;
+            }
+            geomagnetic_multi_unlock();
+
+            /* report event */
+            code |= (rt & YAS_REPORT_OVERFLOW_OCCURED);
+            code |= (rt & YAS_REPORT_HARD_OFFSET_CHANGED);
+            code |= (rt & YAS_REPORT_CALIB_OFFSET_CHANGED);
+            value = (count++ << 16) | (code);
+            input_report_abs(data->input_raw, ABS_RAW_REPORT, value);
+        }
+
+        if (rt & YAS_REPORT_DATA) {
+            for (i = 0; i < 3; i++) {
+                atomic_set(&data->last_data[i], magdata.xyz.v[i]);
+            }
+
+            /* report magnetic data in [nT] */
+            input_report_abs(data->input_data, ABS_RX, magdata.xyz.v[0]);
+            input_report_abs(data->input_data, ABS_RY, magdata.xyz.v[1]);
+            input_report_abs(data->input_data, ABS_RZ, magdata.xyz.v[2]);
+            input_report_abs(data->input_data, ABS_STATUS, accuracy);
+            input_sync(data->input_data);
+        }
+
+        if (rt & YAS_REPORT_CALIB) {
+            /* report raw magnetic data */
+            input_report_abs(data->input_raw, ABS_RX, magdata.raw.v[0]);
+            input_report_abs(data->input_raw, ABS_RY, magdata.raw.v[1]);
+            input_report_abs(data->input_raw, ABS_RZ, magdata.raw.v[2]);
+            input_sync(data->input_raw);
+        }
+    }
+    else {
+        time_delay_ms = 100;
+    }
+
+    if (time_delay_ms > 0) {
+        schedule_delayed_work(&data->work, msecs_to_jiffies(time_delay_ms) + 1);
+    }
+    else {
+        schedule_delayed_work(&data->work, 0);
+    }
+}
+
+static int
+geomagnetic_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+    struct geomagnetic_data *data = i2c_get_clientdata(client);
+
+    if (atomic_read(&data->enable)) {
+        cancel_delayed_work_sync(&data->work);
+    }
+#if DEBUG
+    data->suspend = 1;
+#endif
+
+    return 0;
+}
+
+static int
+geomagnetic_resume(struct i2c_client *client)
+{
+    struct geomagnetic_data *data = i2c_get_clientdata(client);
+
+    if (atomic_read(&data->enable)) {
+        schedule_delayed_work(&data->work, 0);
+    }
+
+#if DEBUG
+    data->suspend = 0;
+#endif
+
+    return 0;
+}
+
+static int
+geomagnetic_i2c_write(uint8_t slave, uint8_t addr, const uint8_t *buf, int len)
+{
+#if 0
+    struct i2c_msg msg[2];
+    int status;
+
+    msg[0].addr = slave;
+    msg[0].flags = 0;
+    msg[0].buf = &addr;
+    msg[0].len = 1;
+
+    msg[1].addr = slave;
+    msg[1].flags = 0;
+    msg[1].buf = buf;
+    msg[1].len = len;
+
+    status = i2c_transfer(this_client->adapter, msg, 2);
+    if (status != 2) {
+        return -EIO;
+    }
+#else
+    struct i2c_msg msg[1];
+    uint8_t data[2];
+    int status;
+
+    if (len != 1) {
+        return -1;
+    }
+
+    data[0] = addr;
+    data[1] = buf[0];
+
+    msg[0].addr = slave;
+    msg[0].flags = 0;
+    msg[0].buf = data;
+    msg[0].len = 2;
+
+    status = i2c_transfer(this_client->adapter, msg, 1);
+    if (status != 1) {
+        return -EIO;
+    }
+#endif
+#if DEBUG
+    YLOGD(("[W] addr[%02x] [%02x]\n", addr, buf[0]));
+#endif
+
+    return 0;
+}
+
+static int
+geomagnetic_i2c_read(uint8_t slave, uint8_t addr, uint8_t *buf, int len)
+{
+    struct i2c_msg msg[2];
+    int status;
+
+    msg[0].addr = slave;
+    msg[0].flags = 0;
+    msg[0].buf = &addr;
+    msg[0].len = 1;
+
+    msg[1].addr = slave;
+    msg[1].flags = I2C_M_RD;
+    msg[1].buf = buf;
+    msg[1].len = len;
+
+    status = i2c_transfer(this_client->adapter, msg, 2);
+    if (status != 2) {
+        return -EIO;
+    }
+#if DEBUG
+    if (len == 1) {
+        YLOGD(("[R] addr[%02x] [%02x]\n", addr, buf[0]));
+    }
+    else if (len == 8) {
+        YLOGD(("[R] addr[%02x] "
+        "[%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+        addr, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]));
+    }
+    else {
+        YLOGD(("[R] addr[%02x] "
+        "[%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x]\n",
+        addr,
+        buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
+        buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]));
+    }
+#endif
+
+    return 0;
+}
+
+static int
+geomagnetic_i2c_open(void)
+{
+    return 0;
+}
+
+static int
+geomagnetic_i2c_close(void)
+{
+    return 0;
+}
+
+static int
+geomagnetic_lock(void)
+{
+    struct geomagnetic_data *data = NULL;
+    int rt;
+
+    if (this_client == NULL) {
+        return -1;
+    }
+
+    data = i2c_get_clientdata(this_client);
+    rt = down_interruptible(&data->driver_lock);
+    if (rt < 0) {
+        up(&data->driver_lock);
+    }
+    return rt;
+}
+
+static int
+geomagnetic_unlock(void)
+{
+    struct geomagnetic_data *data = NULL;
+
+    if (this_client == NULL) {
+        return -1;
+    }
+
+    data = i2c_get_clientdata(this_client);
+    up(&data->driver_lock);
+    return 0;
+}
+
+static void
+geomagnetic_msleep(int ms)
+{
+    msleep(ms);
+}
+
+static void
+geomagnetic_current_time(int32_t *sec, int32_t *msec)
+{
+    struct timeval tv;
+
+    do_gettimeofday(&tv);
+
+    *sec = tv.tv_sec;
+    *msec = tv.tv_usec / 1000;
+}
+
+static int
+geomagnetic_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    struct geomagnetic_data *data = NULL;
+    struct input_dev *input_data = NULL, *input_raw = NULL;
+    int rt, sysfs_created = 0, sysfs_raw_created = 0;
+    int data_registered = 0, raw_registered = 0, i;
+    struct yas_mag_filter filter;
+
+	printk("YA530 probe called!\n");
+
+    i2c_set_clientdata(client, NULL);
+    data = kzalloc(sizeof(struct geomagnetic_data), GFP_KERNEL);
+    if (data == NULL) {
+        rt = -ENOMEM;
+        goto err;
+    }
+    data->threshold = YAS_DEFAULT_THRESHOLD;
+    for (i = 0; i < 3; i++) {
+        data->distortion[i] = YAS_DEFAULT_DISTORTION;
+    }
+    data->shape = YAS_DEFAULT_SHAPE;
+    atomic_set(&data->enable, 0);
+    for (i = 0; i < 3; i++) {
+        atomic_set(&data->last_data[i], 0);
+    }
+    atomic_set(&data->last_status, 0);
+    INIT_DELAYED_WORK(&data->work, geomagnetic_input_work_func);
+    init_MUTEX(&data->driver_lock);
+    init_MUTEX(&data->multi_lock);
+
+    input_data = input_allocate_device();
+    if (input_data == NULL) {
+        rt = -ENOMEM;
+        YLOGE(("geomagnetic_probe: Failed to allocate input_data device\n"));
+        goto err;
+    }
+
+    input_data->name = GEOMAGNETIC_INPUT_NAME;
+    input_data->id.bustype = BUS_I2C;
+    set_bit(EV_ABS, input_data->evbit);
+    input_set_capability(input_data, EV_ABS, ABS_X);
+    input_set_capability(input_data, EV_ABS, ABS_Y);
+    input_set_capability(input_data, EV_ABS, ABS_Z);
+    input_set_capability(input_data, EV_ABS, ABS_RX);
+    input_set_capability(input_data, EV_ABS, ABS_RY);
+    input_set_capability(input_data, EV_ABS, ABS_RZ);
+    input_set_capability(input_data, EV_ABS, ABS_STATUS);
+    input_set_capability(input_data, EV_ABS, ABS_WAKE);
+    input_data->dev.parent = &client->dev;
+
+    rt = input_register_device(input_data);
+    if (rt) {
+        YLOGE(("geomagnetic_probe: Unable to register input_data device: %s\n",
+               input_data->name));
+        goto err;
+    }
+    data_registered = 1;
+
+    rt = sysfs_create_group(&input_data->dev.kobj,
+            &geomagnetic_attribute_group);
+    if (rt) {
+        YLOGE(("geomagnetic_probe: sysfs_create_group failed[%s]\n",
+               input_data->name));
+        goto err;
+    }
+    sysfs_created = 1;
+
+    input_raw = input_allocate_device();
+    if (input_raw == NULL) {
+        rt = -ENOMEM;
+        YLOGE(("geomagnetic_probe: Failed to allocate input_raw device\n"));
+        goto err;
+    }
+
+    input_raw->name = GEOMAGNETIC_INPUT_RAW_NAME;
+    input_raw->id.bustype = BUS_I2C;
+    set_bit(EV_ABS, input_raw->evbit);
+    input_set_capability(input_raw, EV_ABS, ABS_X);
+    input_set_capability(input_raw, EV_ABS, ABS_Y);
+    input_set_capability(input_raw, EV_ABS, ABS_Z);
+    input_set_capability(input_raw, EV_ABS, ABS_RX);
+    input_set_capability(input_raw, EV_ABS, ABS_RY);
+    input_set_capability(input_raw, EV_ABS, ABS_RZ);
+    input_set_capability(input_raw, EV_ABS, ABS_RAW_DISTORTION);
+    input_set_capability(input_raw, EV_ABS, ABS_RAW_THRESHOLD);
+    input_set_capability(input_raw, EV_ABS, ABS_RAW_SHAPE);
+    input_set_capability(input_raw, EV_ABS, ABS_RAW_REPORT);
+    input_raw->dev.parent = &client->dev;
+
+    rt = input_register_device(input_raw);
+    if (rt) {
+        YLOGE(("geomagnetic_probe: Unable to register input_raw device: %s\n",
+               input_raw->name));
+        goto err;
+    }
+    raw_registered = 1;
+
+    rt = sysfs_create_group(&input_raw->dev.kobj,
+            &geomagnetic_raw_attribute_group);
+    if (rt) {
+        YLOGE(("geomagnetic_probe: sysfs_create_group failed[%s]\n",
+               input_data->name));
+        goto err;
+    }
+    sysfs_raw_created = 1;
+
+    this_client = client;
+    data->input_raw = input_raw;
+    data->input_data = input_data;
+    input_set_drvdata(input_data, data);
+    input_set_drvdata(input_raw, data);
+    i2c_set_clientdata(client, data);
+
+    if ((rt = yas_mag_driver_init(&hwdep_driver)) < 0) {
+        YLOGE(("yas_mag_driver_init failed[%d]\n", rt));
+        goto err;
+    }
+    if (hwdep_driver.init != NULL) {
+        if ((rt = hwdep_driver.init()) < 0) {
+            YLOGE(("hwdep_driver.init() failed[%d]\n", rt));
+            goto err;
+        }
+    }
+    if (hwdep_driver.set_position != NULL) {
+        if (hwdep_driver.set_position(CONFIG_COMPASS_YAS530_POSITION) < 0) {
+            YLOGE(("hwdep_driver.set_position() failed[%d]\n", rt));
+            goto err;
+        }
+    }
+    if (hwdep_driver.get_offset != NULL) {
+        if (hwdep_driver.get_offset(&data->driver_offset) < 0) {
+            YLOGE(("hwdep_driver get_driver_state failed\n"));
+            goto err;
+        }
+    }
+    if (hwdep_driver.get_delay != NULL) {
+        atomic_set(&data->delay, hwdep_driver.get_delay());
+    }
+    if (hwdep_driver.get_filter_enable != NULL) {
+        atomic_set(&data->filter_enable, hwdep_driver.get_filter_enable());
+    }
+    if (hwdep_driver.get_filter != NULL) {
+        if (hwdep_driver.get_filter(&filter) < 0) {
+            YLOGE(("hwdep_driver get_filter failed\n"));
+            goto err;
+        }
+        atomic_set(&data->filter_len, filter.len);
+        atomic_set(&data->filter_threshold, filter.threshold);
+    }
+
+    return 0;
+
+err:
+    if (data != NULL) {
+        if (input_raw != NULL) {
+            if (sysfs_raw_created) {
+                sysfs_remove_group(&input_raw->dev.kobj,
+                        &geomagnetic_raw_attribute_group);
+            }
+            if (raw_registered) {
+                input_unregister_device(input_raw);
+            }
+            else {
+                input_free_device(input_raw);
+            }
+        }
+        if (input_data != NULL) {
+            if (sysfs_created) {
+                sysfs_remove_group(&input_data->dev.kobj,
+                        &geomagnetic_attribute_group);
+            }
+            if (data_registered) {
+                input_unregister_device(input_data);
+            }
+            else {
+                input_free_device(input_data);
+            }
+        }
+        kfree(data);
+    }
+
+    return rt;
+}
+
+static int
+geomagnetic_remove(struct i2c_client *client)
+{
+    struct geomagnetic_data *data = i2c_get_clientdata(client);
+
+    if (data != NULL) {
+        geomagnetic_disable(data);
+        if (hwdep_driver.term != NULL) {
+            hwdep_driver.term();
+        }
+
+        input_unregister_device(data->input_raw);
+        sysfs_remove_group(&data->input_data->dev.kobj,
+                &geomagnetic_attribute_group);
+        sysfs_remove_group(&data->input_raw->dev.kobj,
+                &geomagnetic_raw_attribute_group);
+        input_unregister_device(data->input_data);
+        kfree(data);
+    }
+
+    return 0;
+}
+
+/* I2C Device Driver */
+static struct i2c_device_id geomagnetic_idtable[] = {
+    {GEOMAGNETIC_I2C_DEVICE_NAME, 0},
+    {}
+};
+MODULE_DEVICE_TABLE(i2c, geomagnetic_idtable);
+
+static struct i2c_driver geomagnetic_i2c_driver = {
+    .driver = {
+        .name       = GEOMAGNETIC_I2C_DEVICE_NAME,
+        .owner      = THIS_MODULE,
+    },
+
+    .id_table       = geomagnetic_idtable,
+    .probe          = geomagnetic_probe,
+    .remove         = geomagnetic_remove,
+    .suspend        = geomagnetic_suspend,
+    .resume         = geomagnetic_resume,
+};
+
+static int __init
+geomagnetic_init(void)
+{
+    return i2c_add_driver(&geomagnetic_i2c_driver);
+}
+
+static void __exit
+geomagnetic_term(void)
+{
+    i2c_del_driver(&geomagnetic_i2c_driver);
+}
+
+module_init(geomagnetic_init);
+module_exit(geomagnetic_term);
+
+MODULE_AUTHOR("Yamaha Corporation");
+MODULE_DESCRIPTION("YAS530 Geomagnetic Sensor Driver");
+MODULE_LICENSE( "GPL" );
+MODULE_VERSION("1.2.0");
Index: Kernel/drivers/sensors/compass/yas530.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/compass/yas530.h	2011-01-05 19:32:57.049733122 +0530
@@ -0,0 +1,404 @@
+/*
+ * Copyright (c) 2010 Yamaha Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+#ifndef __YAS_H__
+#define __YAS_H__
+
+#define __LINUX_KERNEL_DRIVER__
+
+#ifndef __YAS_CFG_H__
+#define __YAS_CFG_H__
+
+#define YAS_MAG_DRIVER_YAS529       (1)
+#define YAS_MAG_DRIVER_YAS530       (2)
+
+#define YAS_ACC_DRIVER_ADXL345      (0)
+#define YAS_ACC_DRIVER_ADXL346      (1)
+#define YAS_ACC_DRIVER_BMA150       (2)
+#define YAS_ACC_DRIVER_BMA222       (3)
+#define YAS_ACC_DRIVER_KXSD9        (4)
+#define YAS_ACC_DRIVER_KXTE9        (5)
+#define YAS_ACC_DRIVER_KXTF9        (6)
+#define YAS_ACC_DRIVER_LIS331DL     (7)
+#define YAS_ACC_DRIVER_LIS331DLH    (8)
+#define YAS_ACC_DRIVER_LIS331DLM    (9)
+#define YAS_ACC_DRIVER_LIS3DH       (10)
+#define YAS_ACC_DRIVER_MMA8453Q     (11)
+
+/*----------------------------------------------------------------------------*/
+/*                               Configuration                                */
+/*----------------------------------------------------------------------------*/
+
+#define YAS_DEFAULT_THRESHOLD       (1)
+#define YAS_DEFAULT_DISTORTION      (15)
+#define YAS_DEFAULT_SHAPE           (0)
+#define YAS_SHAPE_NUM               (2)
+
+#define YAS_ACC_DRIVER              (YAS_ACC_DRIVER_BMA150)
+#define YAS_MAG_DRIVER              (YAS_MAG_DRIVER_YAS530)
+
+#endif
+
+#define YAS_VERSION                        (0.9.0)
+
+/* -------------------------------------------------------------------------- */
+/*  Typedef definition                                                        */
+/* -------------------------------------------------------------------------- */
+
+#if defined(__LINUX_KERNEL_DRIVER__)
+#include <linux/types.h>
+#elif defined(__ANDROID__)
+#include <stdint.h>
+#else
+typedef signed char         int8_t;
+typedef unsigned char       uint8_t;
+typedef signed short        int16_t;
+typedef unsigned short      uint16_t;
+typedef signed int          int32_t;
+typedef unsigned int        uint32_t;
+#endif
+
+#if defined(__LINUX_KERNEL_DRIVER__)
+#define STATIC static
+#else
+#define STATIC 
+#endif
+
+/* -------------------------------------------------------------------------- */
+/*  Macro definition                                                          */
+/* -------------------------------------------------------------------------- */
+
+/* Debugging */
+#define DEBUG                               (1)
+
+#if DEBUG
+#ifdef __LINUX_KERNEL_DRIVER__
+#include <linux/kernel.h>
+#define YLOGD(args) (printk args )
+#define YLOGI(args) (printk args )
+#define YLOGE(args) (printk args )
+#define YLOGW(args) (printk args )
+#elif defined __ANDROID__
+#include <cutils/log.h>
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+#define LOG_TAG "geomagneticd"
+#define YLOGD(args) (LOGD args )
+#define YLOGI(args) (LOGD args )
+#define YLOGE(args) (LOGE args )
+#define YLOGW(args) (LOGW args )
+#else /* __ANDROID__ */
+#include <stdio.h>
+#define YLOGD(args) (printf args )
+#define YLOGI(args) (printf args )
+#define YLOGE(args) (printf args )
+#define YLOGW(args) (printf args )
+#endif /* __ANDROID__ */
+#else /* DEBUG */
+#define YLOGD(args) 
+#define YLOGI(args) 
+#define YLOGW(args) 
+#define YLOGE(args) 
+#endif /* DEBUG */
+
+#define YAS_REPORT_DATA                     (0x01)
+#define YAS_REPORT_CALIB                    (0x02)
+#define YAS_REPORT_OVERFLOW_OCCURED         (0x04)
+#define YAS_REPORT_HARD_OFFSET_CHANGED      (0x08)
+#define YAS_REPORT_CALIB_OFFSET_CHANGED     (0x10)
+
+#define YAS_HARD_OFFSET_UNKNOWN             (0x7f)
+#define YAS_CALIB_OFFSET_UNKNOWN            (0x7fffffff)
+
+#define YAS_NO_ERROR                        (0)
+#define YAS_ERROR_ARG                       (-1)
+#define YAS_ERROR_NOT_INITIALIZED           (-2)
+#define YAS_ERROR_BUSY                      (-3)
+#define YAS_ERROR_I2C                       (-4)
+#define YAS_ERROR_CHIP_ID                   (-5)
+#define YAS_ERROR_NOT_ACTIVE                (-6)
+#define YAS_ERROR_RESTARTSYS                (-7)
+#define YAS_ERROR_ERROR                     (-128)
+
+#ifndef NULL
+#define NULL ((void*)(0))
+#endif
+#ifndef FALSE
+#define FALSE (0)
+#endif
+#ifndef TRUE
+#define TRUE (!(0))
+#endif
+#ifndef NELEMS
+#define NELEMS(a) ((int)(sizeof(a)/sizeof(a[0])))
+#endif
+#ifndef ABS
+#define ABS(a) ((a) > 0 ? (a) : -(a))
+#endif
+#ifndef M_PI
+#define M_PI (3.14159265358979323846)
+#endif
+
+/* -------------------------------------------------------------------------- */
+/*  Structure definition                                                      */
+/* -------------------------------------------------------------------------- */
+
+struct yas_mag_filter {
+    int len;
+    int threshold; /* nT */
+};
+struct yas_vector {
+    int32_t v[3];
+};
+struct yas_matrix {
+    int32_t matrix[9];
+};
+struct yas_acc_data {
+    struct yas_vector xyz;
+    struct yas_vector raw;
+};
+struct yas_mag_data {
+    struct yas_vector xyz; /* without offset, filtered */
+    struct yas_vector raw; /* with offset, not filtered */
+    struct yas_vector xy1y2;
+    int16_t temperature;
+};
+
+struct yas_mag_offset {
+    int8_t hard_offset[3];
+    struct yas_vector calib_offset;
+};
+struct yas_mag_status {
+    struct yas_mag_offset offset;
+    int accuracy;
+};
+struct yas_offset {
+    struct yas_mag_status mag[YAS_SHAPE_NUM];
+};
+
+struct yas_mag_driver_callback {
+    int (*lock)(void);
+    int (*unlock)(void);
+    int (*i2c_open)(void);
+    int (*i2c_close)(void);
+    int (*i2c_write)(uint8_t slave, uint8_t addr, const uint8_t *buf, int len);
+    int (*i2c_read)(uint8_t slave, uint8_t addr, uint8_t *buf, int len);
+    void (*msleep)(int msec);
+    void (*current_time)(int32_t *sec, int32_t *msec);
+};
+
+struct yas_mag_driver {
+    int (*init)(void);
+    int (*term)(void);
+    int (*get_delay)(void);
+    int (*set_delay)(int msec);
+    int (*get_offset)(struct yas_mag_offset *offset);
+    int (*set_offset)(struct yas_mag_offset *offset);
+    int (*get_enable)(void);
+    int (*set_enable)(int enable);
+    int (*get_filter)(struct yas_mag_filter *filter);
+    int (*set_filter)(struct yas_mag_filter *filter);
+    int (*get_filter_enable)(void);
+    int (*set_filter_enable)(int enable);
+    int (*get_position)(void);
+    int (*set_position)(int position);
+    int (*read_reg)(uint8_t addr, uint8_t *buf, int len);
+    int (*write_reg)(uint8_t addr, const uint8_t *buf, int len);
+    int (*measure)(struct yas_mag_data *data, int *time_delay_ms);
+    struct yas_mag_driver_callback callback;
+};
+
+struct yas_mag_calibration_result {
+    int32_t spread;
+    int32_t variation;
+    int32_t radius;
+    int8_t axis;
+    int8_t level;
+    int8_t accuracy;
+};
+
+struct yas_mag_calibration_threshold {
+    int32_t spread;
+    int32_t variation[3];
+};
+
+struct yas_mag_calibration {
+    int (*init)(void);
+    int (*term)(void);
+    int (*update)(struct yas_vector *mag,
+            struct yas_mag_calibration_result *result);
+    int (*get_accuracy)(void);
+    int (*set_accuracy)(int accuracy);
+    int (*get_offset)(struct yas_vector *offset);
+    int (*set_offset)(struct yas_vector *offset);
+    int (*get_shape)(void);
+    int (*set_shape)(int shape);
+    int (*get_threshold)(struct yas_mag_calibration_threshold *threshold);
+    int (*set_threshold)(struct yas_mag_calibration_threshold *threshold);
+};
+
+struct yas_acc_filter {
+    int threshold; /* um/s^2 */
+};
+
+struct yas_acc_driver_callback {
+    int (*lock)(void);
+    int (*unlock)(void);
+    int (*i2c_open)(void);
+    int (*i2c_close)(void);
+    int (*i2c_write)(uint8_t slave, uint8_t adr, const uint8_t *buf, int len);
+    int (*i2c_read) (uint8_t slave, uint8_t adr, uint8_t *buf, int len);
+    void (*msleep)(int msec);
+};
+
+struct yas_acc_driver {
+    int (*init)(void);
+    int (*term)(void);
+    int (*get_delay)(void);
+    int (*set_delay)(int delay);
+    int (*get_offset)(struct yas_vector *offset);
+    int (*set_offset)(struct yas_vector *offset);
+    int (*get_enable)(void);
+    int (*set_enable)(int enable);
+    int (*get_filter)(struct yas_acc_filter *filter);
+    int (*set_filter)(struct yas_acc_filter *filter);
+    int (*get_filter_enable)(void);
+    int (*set_filter_enable)(int enable);
+    int (*get_position)(void);
+    int (*set_position)(int position);
+    int (*measure)(struct yas_acc_data *data);
+#if DEBUG
+    int (*get_register)(uint8_t adr, uint8_t *val);
+#endif
+    struct yas_acc_driver_callback callback;
+};
+
+struct yas_utility {
+    int (*get_rotation_matrix)(struct yas_vector *acc, struct yas_vector *mag,
+            struct yas_matrix *matrix);
+    int (*get_euler)(struct yas_matrix *matrix, struct yas_vector *euler);
+};
+
+/* -------------------------------------------------------------------------- */
+/*  Global function definition                                                */
+/* -------------------------------------------------------------------------- */
+
+STATIC int yas_mag_driver_init(struct yas_mag_driver *f);
+/*STATIC int yas_mag_calibration_init(struct yas_mag_calibration *f);*/
+/*STATIC int yas_utility_init(struct yas_utility *f);*/
+/*STATIC int yas_acc_driver_init(struct yas_acc_driver *f);*/
+
+#endif /* __YAS_H__ */
+
+#ifndef __UTIMER_H__
+#define __UTIMER_H__
+
+#ifndef STATIC
+#define STATIC 
+#endif
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
+
+struct utimeval {
+    int32_t tv_sec;
+    int32_t tv_msec;
+};
+
+struct utimer {
+    struct utimeval prev_time;
+    struct utimeval total_time;
+    struct utimeval delay_ms;
+};
+
+STATIC int utimeval_init(struct utimeval *val);
+STATIC int utimeval_is_initial(struct utimeval *val);
+STATIC int utimeval_is_overflow(struct utimeval *val);
+STATIC struct utimeval utimeval_plus(struct utimeval *first, struct utimeval *second);
+STATIC struct utimeval utimeval_minus(struct utimeval *first, struct utimeval *second);
+STATIC int utimeval_greater_than(struct utimeval *first, struct utimeval *second);
+STATIC int utimeval_greater_or_equal(struct utimeval *first, struct utimeval *second);
+STATIC int utimeval_greater_than_zero(struct utimeval *val);
+STATIC int utimeval_less_than_zero(struct utimeval *val);
+STATIC struct utimeval *msec_to_utimeval(struct utimeval *result, uint32_t msec);
+STATIC uint32_t utimeval_to_msec(struct utimeval *val);
+
+STATIC struct utimeval utimer_calc_next_time(struct utimer *ut,
+                                             struct utimeval *cur);
+STATIC struct utimeval utimer_current_time(void);
+STATIC int utimer_is_timeout(struct utimer *ut);
+STATIC int utimer_clear_timeout(struct utimer *ut);
+STATIC uint32_t utimer_get_total_time(struct utimer *ut);
+STATIC uint32_t utimer_get_delay(struct utimer *ut);
+STATIC int utimer_set_delay(struct utimer *ut, uint32_t delay_ms);
+STATIC int utimer_update(struct utimer *ut);
+STATIC int utimer_update_with_curtime(struct utimer *ut, struct utimeval *cur);
+STATIC uint32_t utimer_sleep_time(struct utimer *ut);
+STATIC uint32_t utimer_sleep_time_with_curtime(struct utimer *ut,
+                                               struct utimeval *cur);
+STATIC int utimer_init(struct utimer *ut, uint32_t delay_ms);
+STATIC int utimer_clear(struct utimer *ut);
+STATIC void utimer_lib_init(void (*func)(int *sec, int *msec));
+
+#endif
+
+#ifndef __YAS_MAG_CDRIVER_H__
+#define __YAS_MAG_CDRIVER_H__
+
+/*#include "yas.h"*/
+
+#define YAS_SLAVE_ADDRESS              (0x2e)
+
+#define YAS_REGADDR_DEVICE_ID          (0x80)
+#define YAS_REGADDR_ACTUATE_INIT_COIL  (0x81)
+#define YAS_REGADDR_MEASURE_COMMAND    (0x82)
+#define YAS_REGADDR_CONFIG             (0x83)
+#define YAS_REGADDR_MEASURE_INTERVAL   (0x84)
+#define YAS_REGADDR_OFFSET_X           (0x85)
+#define YAS_REGADDR_OFFSET_Y1          (0x86)
+#define YAS_REGADDR_OFFSET_Y2          (0x87)
+#define YAS_REGADDR_TEST1              (0x88)
+#define YAS_REGADDR_TEST2              (0x89)
+#define YAS_REGADDR_CAL                (0x90)
+#define YAS_REGADDR_MEASURE_DATA       (0xb0)
+
+struct yas_machdep_func {
+    int (*i2c_open)(void);
+    int (*i2c_close)(void);
+    int (*i2c_write)(uint8_t slave, uint8_t addr, const uint8_t *buf, int len);
+    int (*i2c_read)(uint8_t slave, uint8_t addr, uint8_t *buf, int len);
+    void (*msleep)(int msec);
+};
+
+STATIC int yas_cdrv_actuate_initcoil(void);
+STATIC int yas_cdrv_set_offset(const int8_t *offset);
+STATIC int yas_cdrv_recalc_calib_offset(int32_t *prev_calib_offset,
+                                  int32_t *new_calib_offset,
+                                  int8_t *prev_offset,
+                                  int8_t *new_offset);
+STATIC int yas_cdrv_set_transformatiom_matrix(const int8_t *transform);
+STATIC int yas_cdrv_measure_and_set_offset(int8_t *offset);
+STATIC int yas_cdrv_measure(int32_t *msens, int16_t *raw, int16_t *t);
+STATIC int yas_cdrv_init(const int8_t *transform,
+                   struct yas_machdep_func *func);
+STATIC int yas_cdrv_term(void);
+
+#endif
+
Index: Kernel/drivers/sensors/compass/Kconfig
===================================================================
--- Kernel.orig/drivers/sensors/compass/Kconfig	2010-12-31 12:04:58.000000000 +0530
+++ Kernel/drivers/sensors/compass/Kconfig	2011-01-05 19:36:21.000000000 +0530
@@ -15,3 +15,6 @@
 	help
 	  This option enables magnetic sensors using ak8973 driver.
 
+config COMPASS_YAS530
+	tristate "Yamaha YAS530 Geomagnetic Sensor"
+	depends on COMPASS
Index: Kernel/drivers/sensors/compass/Makefile
===================================================================
--- Kernel.orig/drivers/sensors/compass/Makefile	2010-12-31 12:04:58.000000000 +0530
+++ Kernel/drivers/sensors/compass/Makefile	2011-01-05 19:36:17.000000000 +0530
@@ -7,3 +7,5 @@
 
 obj-$(CONFIG_COMPASS_AK8973B)	+= ak8973b.o
 
+obj-$(CONFIG_COMPASS_YAS530)	+= yas530.o
+
