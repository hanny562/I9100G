Index: Kernel/drivers/sensors/mpu3050/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/Kconfig	2011-02-17 20:39:52.629736343 +0530
@@ -0,0 +1,104 @@
+
+menu "Motion Sensors Support"
+
+choice
+    tristate "Motion Processing Unit"
+    depends on I2C
+    default MPU_NONE
+
+config MPU_NONE
+    bool "None"
+    help
+      This disables support for motion processing using the MPU family of 
+      motion processing units.
+
+config SENSORS_MPU3050
+    tristate "MPU3050"
+    depends on I2C
+    help
+      If you say yes here you get support for the MPU3050 Gyroscope driver
+      This driver can also be built as a module.  If so, the module
+      will be called mpu3050.
+
+config SENSORS_MPU6000
+    tristate "MPU6000"
+    depends on I2C
+    help
+      If you say yes here you get support for the MPU6000 Gyroscope driver
+      This driver can also be built as a module.  If so, the module
+      will be called mpu6000.
+
+endchoice
+
+choice
+    prompt "Accelerometer Type"
+    depends on SENSORS_MPU3050
+    default SENSORS_KXSD9
+
+config SENSORS_ACCELEROMETER_NONE
+    bool "NONE"
+    depends on SENSORS_MPU3050 || SENSORS_MPU6000
+    help
+      This disables accelerometer support for the MPU3050
+      
+config SENSORS_KXSD9
+    bool "Kionix KXSD9"
+    depends on SENSORS_MPU3050
+    help
+      This enables support for the Kionix KXSD9 accelerometer
+
+endchoice
+
+choice
+    prompt "Compass Type"
+    depends on SENSORS_MPU6000 || SENSORS_MPU3050
+    default SENSORS_YAS529
+
+config SENSORS_COMPASS_NONE
+    bool "NONE"
+    depends on SENSORS_MPU6000 || SENSORS_MPU3050
+    help
+      This disables compass support for the MPU6000
+
+config SENSORS_YAS529
+    bool "Yamaha yas529"
+    depends on SENSORS_MPU3050
+    help
+      This enables support for the Yamaha yas529 compass
+
+config SENSORS_HSCDTD00XX
+    bool "Alps hscdtd00XX"
+    depends on SENSORS_MPU3050
+    help
+      This enables support for the Alps hscdtd002b/hscdtd004a compass
+
+endchoice
+
+choice
+    prompt "Pressure Type"
+    depends on SENSORS_MPU6000 || SENSORS_MPU3050
+    default SENSORS_BMA085
+
+config SENSORS_PRESSURE_NONE
+    bool "NONE"
+    depends on SENSORS_MPU6000 || SENSORS_MPU3050
+    help
+      This disables pressure sensor support for the MPU6000
+
+config SENSORS_BMA085
+    bool "Bosch BMA085"
+    depends on SENSORS_MPU6000 || SENSORS_MPU3050
+    help
+      This enables support for the Bosch bma085 pressure sensor
+
+endchoice
+
+config SENSORS_MPU_DEBUG
+    bool "MPU debug"
+    depends on SENSORS_MPU3050 || SENSORS_MPU6000
+    help
+      If you say yes here you get extra debug messages from the MPU3050
+      and other slave sensors.
+
+endmenu
+
Index: Kernel/drivers/sensors/mpu3050/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/Makefile	2011-02-17 20:39:52.629736343 +0530
@@ -0,0 +1,61 @@
+
+# Kernel makefile for motions sensors
+#
+# 
+
+# MPU
+obj-$(CONFIG_SENSORS_MPU3050)	+= mpu3050.o
+mpu3050-objs += mpuirq.o \
+	slaveirq.o \
+	mpu-dev.o \
+	mpu-i2c.o \
+	mlsl-kernel.o \
+	mlos-kernel.o \
+	$(MLLITE_DIR)mldl_cfg.o
+
+#
+# Accel options
+#
+
+ifdef CONFIG_SENSORS_KXSD9
+mpu3050-objs += $(MLLITE_DIR)accel/kxsd9.o
+endif
+
+
+#
+# Compass options
+#
+
+ifdef CONFIG_SENSORS_YAS529
+mpu3050-objs += $(MLLITE_DIR)compass/yas529-kernel.o
+endif
+
+#
+# Pressure options
+#
+ifdef CONFIG_SENSORS_BMA085
+mpu3050-objs += $(MLLITE_DIR)pressure/bma085.o
+endif
+
+EXTRA_CFLAGS += -I$(M)/$(MLLITE_DIR) \
+                -I$(M)/../../include \
+		-Idrivers/sensors/mpu3050 \
+                -Iinclude/linux
+
+ifdef CONFIG_SENSORS_MPU_DEBUG
+EXTRA_CFLAGS += -DDEBUG 
+endif
+
+obj-$(CONFIG_SENSORS_MPU6000)= mpu6000.o
+mpu6000-objs += mpuirq.o \
+	mpu-dev.o \
+	mpu-i2c.o \
+	mlsl-kernel.o \
+	mlos-kernel.o \
+	$(MLLITE_DIR)mldl_cfg.o \
+	$(MLLITE_DIR)accel/mantis.o
+
+
+ifdef CONFIG_SENSORS_MPU6000
+EXTRA_CFLAGS += -DM_HW
+endif
Index: Kernel/drivers/sensors/mpu3050/accel/kxsd9.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/accel/kxsd9.c	2011-02-17 20:39:52.629736343 +0530
@@ -0,0 +1,129 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+/**
+ *  @defgroup   ACCELDL (Motion Library - Accelerometer Driver Layer)
+ *  @brief      Provides the interface to setup and handle an accelerometers
+ *              connected to the secondary I2C interface of the gyroscope.
+ *
+ *  @{
+ *      @file   kxsd9.c
+ *      @brief  Accelerometer setup and handling methods.
+ */
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/module.h>
+#endif
+
+#include "mpu.h"
+#include "../mlsl.h"
+#include "../mlos.h"
+
+#include <log.h>
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* --------------------- */
+/* -    Variables.     - */
+/* --------------------- */
+
+/*****************************************
+    Accelerometer Initialization Functions
+*****************************************/
+
+static int kxsd9_suspend(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	(void *) slave;
+	/* CTRL_REGB: low-power standby mode */
+	result =
+	    MLSLSerialWriteSingle(mlsl_handle, pdata->address, 0x0d, 0x0);
+	ERROR_CHECK(result);
+	return result;
+}
+
+/* full scale setting - register and mask */
+#define ACCEL_KIONIX_CTRL_REG      (0x0C)
+#define ACCEL_KIONIX_CTRL_MASK     (0x3)
+
+static int kxsd9_resume(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata)
+{
+	int result = ML_SUCCESS;
+	unsigned char reg;
+
+	/* Full Scale */
+	reg = 0x0;
+	reg &= ~ACCEL_KIONIX_CTRL_MASK;
+	reg |= 0x00;
+	if (slave->range.mantissa == 4) {	/* 4g scale = 4.9951 */
+		reg |= 0x2;
+		slave->range.fraction = 9951;
+	} else if (slave->range.mantissa == 7) { /* 6g scale = 7.5018 */
+		reg |= 0x1;
+		slave->range.fraction = 5018;
+	} else if (slave->range.mantissa == 9) {	/* 8g scale = 9.9902 */
+		reg |= 0x0;
+		slave->range.fraction = 9902;
+	} else {
+		slave->range.mantissa = 2; /* 2g scale = 2.5006 */
+		slave->range.fraction = 5006;
+		reg |= 0x3;
+	}
+	reg |= 0xC0;		/* 100Hz LPF */
+	result =
+	    MLSLSerialWriteSingle(mlsl_handle, pdata->address,
+				  ACCEL_KIONIX_CTRL_REG, reg);
+	ERROR_CHECK(result);
+	/* normal operation */
+	result =
+	    MLSLSerialWriteSingle(mlsl_handle, pdata->address, 0x0d, 0x40);
+	ERROR_CHECK(result);
+
+	return ML_SUCCESS;
+}
+
+static int kxsd9_read(void *mlsl_handle,
+		      struct ext_slave_descr *slave,
+		      struct ext_slave_platform_data *pdata,
+		      unsigned char *data)
+{
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+static struct ext_slave_descr kxsd9_descr = {
+	/*.init             = */ NULL,
+	/*.exit             = */ NULL,
+	/*.suspend          = */ kxsd9_suspend,
+	/*.resume           = */ kxsd9_resume,
+	/*.read             = */ kxsd9_read,
+	/*.config           = */ NULL,
+	/*.name             = */ "kxsd9",
+	/*.type             = */ EXT_SLAVE_TYPE_ACCELEROMETER,
+	/*.id               = */ ACCEL_ID_KXSD9,
+	/*.reg              = */ 0x00,
+	/*.len              = */ 6,
+	/*.endian           = */ EXT_SLAVE_BIG_ENDIAN,
+	/*.range            = */ {2, 5006},
+};
+
+struct ext_slave_descr *kxsd9_get_slave_descr(void)
+{
+	return &kxsd9_descr;
+}
+EXPORT_SYMBOL(kxsd9_get_slave_descr);
+
+/**
+ *  @}
+**/
Index: Kernel/drivers/sensors/mpu3050/compass/yas529-kernel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/compass/yas529-kernel.c	2011-02-17 20:39:52.629736343 +0530
@@ -0,0 +1,463 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+/**
+ *  @defgroup   ACCELDL (Motion Library - Accelerometer Driver Layer)
+ *  @brief      Provides the interface to setup and handle an accelerometers
+ *              connected to the secondary I2C interface of the gyroscope.
+ *
+ *  @{
+ *      @file   yas529.c
+ *      @brief  Magnetometer setup and handling methods for Yamaha yas529
+ *              compass.
+ */
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/i2c.h>
+#endif
+
+#include "mpu.h"
+#include "../mlos.h"
+
+#include <log.h>
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/*----- YAMAHA YAS529 Registers ------*/
+enum YAS_REG {
+	YAS_REG_CMDR		= 0x00,	/* 000 < 5 */
+	YAS_REG_XOFFSETR	= 0x20,	/* 001 < 5 */
+	YAS_REG_Y1OFFSETR	= 0x40,	/* 010 < 5 */
+	YAS_REG_Y2OFFSETR	= 0x60,	/* 011 < 5 */
+	YAS_REG_ICOILR		= 0x80,	/* 100 < 5 */
+	YAS_REG_CAL		= 0xA0,	/* 101 < 5 */
+	YAS_REG_CONFR		= 0xC0,	/* 110 < 5 */
+	YAS_REG_DOUTR		= 0xE0	/* 111 < 5 */
+};
+
+/* --------------------- */
+/* -    Variables.     - */
+/* --------------------- */
+
+static long a1;
+static long a2;
+static long a3;
+static long a4;
+static long a5;
+static long a6;
+static long a7;
+static long a8;
+static long a9;
+
+/*****************************************
+    Yamaha I2C access functions
+*****************************************/
+
+static int yas529_sensor_i2c_write(struct i2c_adapter *i2c_adap,
+				   unsigned char address,
+				   unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[1];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = (unsigned char *) data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1)
+		return res;
+	else
+		return 0;
+}
+
+static int yas529_sensor_i2c_read(struct i2c_adapter *i2c_adap,
+				  unsigned char address,
+				  unsigned char reg,
+				  unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = I2C_M_RD;
+	msgs[0].buf = data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1)
+		return res;
+	else
+		return 0;
+}
+
+/*****************************************
+    Accelerometer Initialization Functions
+*****************************************/
+
+int yas529_suspend(void *mlsl_handle,
+		   struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = ML_SUCCESS;
+
+	return result;
+}
+
+int yas529_resume(void *mlsl_handle,
+		  struct ext_slave_descr *slave,
+		  struct ext_slave_platform_data *pdata)
+{
+	int result = ML_SUCCESS;
+
+	unsigned char dummyData[1] = { 0 };
+	unsigned char dummyRegister = 0;
+	unsigned char rawData[6];
+	unsigned char calData[9];
+
+	short xoffset, y1offset, y2offset;
+	short d2, d3, d4, d5, d6, d7, d8, d9;
+
+	/* YAS529 Application Manual MS-3C - Section 4.4.5 */
+	/* =============================================== */
+	/* Step 1 - register initialization */
+	/* zero initialization coil register - "100 00 000" */
+	dummyData[0] = YAS_REG_ICOILR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	/* zero config register - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+
+	/* Step 2 - initialization coil operation */
+	dummyData[0] = YAS_REG_ICOILR | 0x11;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x01;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x12;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x02;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x13;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x03;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x14;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x04;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x15;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x05;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x16;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x06;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x17;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x07;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x10;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_ICOILR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+
+	/* Step 3 - rough offset measurement */
+	/* Config register - Measurements results - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	/* Measurements command register - Rough offset measurement -
+	   "000 00001" */
+	dummyData[0] = YAS_REG_CMDR | 0x01;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	MLOSSleep(2);		/* wait at least 1.5ms */
+
+	/* Measurement data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 6, rawData);
+	ERROR_CHECK(result);
+	xoffset =
+	    (short) ((unsigned short) rawData[5] +
+		     ((unsigned short) rawData[4] & 0x7) * 256) - 5;
+	if (xoffset < 0)
+		xoffset = 0;
+	y1offset =
+	    (short) ((unsigned short) rawData[3] +
+		     ((unsigned short) rawData[2] & 0x7) * 256) - 5;
+	if (y1offset < 0)
+		y1offset = 0;
+	y2offset =
+	    (short) ((unsigned short) rawData[1] +
+		     ((unsigned short) rawData[0] & 0x7) * 256) - 5;
+	if (y2offset < 0)
+		y2offset = 0;
+
+	/* Step 4 - rough offset setting */
+	/* Set rough offset register values */
+	dummyData[0] = YAS_REG_XOFFSETR | xoffset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_Y1OFFSETR | y1offset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	dummyData[0] = YAS_REG_Y2OFFSETR | y2offset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+
+	/* CAL matrix read (first read is invalid) */
+	/* Config register - CAL register read - "110 01 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x08;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	/* CAL data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 9, calData);
+	ERROR_CHECK(result);
+	/* Config register - CAL register read - "110 01 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x08;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	/* CAL data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 9, calData);
+	ERROR_CHECK(result);
+
+	/* Calculate coefficients of the sensitivity corrcetion matrix */
+#if 1				/* production sensor */
+	a1 = 100;
+	d2 = (calData[0] & 0xFC) >> 2;	/* [71..66] 6bit */
+	a2 = (short) (d2 - 32);
+	/* [65..62] 4bit */
+	d3 = ((calData[0] & 0x03) << 2) | ((calData[1] & 0xC0) >> 6);
+	a3 = (short) (d3 - 8);
+	d4 = (calData[1] & 0x3F);	/* [61..56] 6bit */
+	a4 = (short) (d4 - 32);
+	d5 = (calData[2] & 0xFC) >> 2;	/* [55..50] 6bit */
+	a5 = (short) (d5 - 32) + 70;
+	/* [49..44] 6bit */
+	d6 = ((calData[2] & 0x03) << 4) | ((calData[3] & 0xF0) >> 4);
+	a6 = (short) (d6 - 32);
+	/* [43..38] 6bit */
+	d7 = ((calData[3] & 0x0F) << 2) | ((calData[4] & 0xC0) >> 6);
+	a7 = (short) (d7 - 32);
+	d8 = (calData[4] & 0x3F);	/* [37..32] 6bit */
+	a8 = (short) (d8 - 32);
+	d9 = (calData[5] & 0xFE) >> 1;	/* [31..25] 7bit */
+	a9 = (short) (d9 - 64) + 130;
+#else				/* evaluation sensor */
+	a1 = 1.0f;
+	/* [71..66] 6bit */
+	d2 = (calData[0] & 0xFC) >> 2;
+	a2 = (short) d2;
+	/* [65..60] 6bit */
+	d3 = ((calData[0] & 0x03) << 4) | ((calData[1] & 0xF0) >> 4);
+	a3 = (short) d3;
+	/* [59..54] 6bit */
+	d4 = ((calData[1] & 0x0F) << 2) | ((calData[2] & 0xC0) >> 6);
+	a4 = (short) d4;
+	/* [53..48] 6bit */
+	d5 = (calData[2] & 0x3F);
+	a5 = (short) (d5 + 70);
+	/* [47..42] 6bit */
+	d6 = ((calData[3] & 0xFC) >> 2);
+	a6 = (short) d6;
+	/* [41..36] 6bit */
+	d7 = ((calData[3] & 0x03) << 4) | ((calData[4] & 0xF0) >> 4);
+	a7 = (short) d7;
+	/* [35..30] 6bit */
+	d8 = ((calData[4] & 0x0F) << 2) | ((calData[5] & 0xC0) >> 6);
+	a8 = (short) d8;
+	/* [29..24] 6bit */
+	d9 = (calData[5] & 0x3F);
+	a9 = (short) (d9 + 150);
+#endif
+
+	return result;
+}
+
+int yas529_read(void *mlsl_handle,
+		struct ext_slave_descr *slave,
+		struct ext_slave_platform_data *pdata, unsigned char *data)
+{
+	unsigned char stat;
+	unsigned char rawData[6];
+	unsigned char dummyData[1] = { 0 };
+	unsigned char dummyRegister = 0;
+	tMLError result = ML_SUCCESS;
+	short SX, SY1, SY2, SY, SZ;
+	short row1fixed, row2fixed, row3fixed;
+
+	/* Config register - Measurements results - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	/* Measurements command register - Normal magnetic field measurement -
+	   "000 00000" */
+	dummyData[0] = YAS_REG_CMDR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1,
+				    dummyData);
+	ERROR_CHECK(result);
+	MLOSSleep(10);
+	/* Measurement data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 6,
+				   (unsigned char *) &rawData);
+	ERROR_CHECK(result);
+
+	stat = rawData[0] & 0x80;
+	if (stat == 0x00) {
+		/* Extract raw data */
+		SX = (short) ((unsigned short) rawData[5] +
+			      ((unsigned short) rawData[4] & 0x7) * 256);
+		SY1 =
+		    (short) ((unsigned short) rawData[3] +
+			     ((unsigned short) rawData[2] & 0x7) * 256);
+		SY2 =
+		    (short) ((unsigned short) rawData[1] +
+			     ((unsigned short) rawData[0] & 0x7) * 256);
+		if ((SX <= 1) || (SY1 <= 1) || (SY2 <= 1))
+			return ML_ERROR_COMPASS_DATA_UNDERFLOW;
+		if ((SX >= 1024) || (SY1 >= 1024) || (SY2 >= 1024))
+			return ML_ERROR_COMPASS_DATA_OVERFLOW;
+		/* Convert to XYZ axis */
+		SX = -1 * SX;
+		SY = SY2 - SY1;
+		SZ = SY1 + SY2;
+
+		/* Apply sensitivity correction matrix */
+		row1fixed =
+		    (short) ((a1 * SX + a2 * SY + a3 * SZ) >> 7) * 41;
+		row2fixed =
+		    (short) ((a4 * SX + a5 * SY + a6 * SZ) >> 7) * 41;
+		row3fixed =
+		    (short) ((a7 * SX + a8 * SY + a9 * SZ) >> 7) * 41;
+
+		data[0] = row1fixed >> 8;
+		data[1] = row1fixed & 0xFF;
+		data[2] = row2fixed >> 8;
+		data[3] = row2fixed & 0xFF;
+		data[4] = row3fixed >> 8;
+		data[5] = row3fixed & 0xFF;
+
+		return ML_SUCCESS;
+	} else {
+		return ML_ERROR_COMPASS_DATA_NOT_READY;
+	}
+}
+
+struct ext_slave_descr yas529_descr = {
+	/*.init             = */ NULL,
+	/*.exit             = */ NULL,
+	/*.suspend          = */ yas529_suspend,
+	/*.resume           = */ yas529_resume,
+	/*.read             = */ yas529_read,
+	/*.config           = */ NULL,
+	/*.name             = */ "yas529",
+	/*.type             = */ EXT_SLAVE_TYPE_COMPASS,
+	/*.id               = */ COMPASS_ID_YAS529,
+	/*.reg              = */ 0x06,
+	/*.len              = */ 6,
+	/*.endian           = */ EXT_SLAVE_BIG_ENDIAN,
+	/*.range            = */ {19660, 8000},
+};
+
+struct ext_slave_descr *yas529_get_slave_descr(void)
+{
+	return &yas529_descr;
+}
+EXPORT_SYMBOL(yas529_get_slave_descr);
+
+/**
+ *  @}
+ */
Index: Kernel/drivers/sensors/mpu3050/log.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/log.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2010 InvenSense Inc
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * C/C++ logging functions.  See the logging documentation for API details.
+ *
+ * We'd like these to be available from C code (in case we import some from
+ * somewhere), so this has a C interface.
+ *
+ * The output will be correct when the log file is shared between multiple
+ * threads and/or multiple processes so long as the operating system
+ * supports O_APPEND.  These calls have mutex-protected data structures
+ * and so are NOT reentrant.  Do not use MPL_LOG in a signal handler.
+ */
+#ifndef _LIBS_CUTILS_MPL_LOG_H
+#define _LIBS_CUTILS_MPL_LOG_H
+
+#include <stdarg.h>
+
+#ifdef ANDROID
+#include <utils/Log.h>		/* For the LOG macro */
+#endif
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Normally we strip MPL_LOGV (VERBOSE messages) from release builds.
+ * You can modify this (for example with "#define MPL_LOG_NDEBUG 0"
+ * at the top of your source file) to change that behavior.
+ */
+#ifndef MPL_LOG_NDEBUG
+#ifdef NDEBUG
+#define MPL_LOG_NDEBUG 1
+#else
+#define MPL_LOG_NDEBUG 0
+#endif
+#endif
+
+#ifdef __KERNEL__
+#define MPL_LOG_UNKNOWN MPL_LOG_VERBOSE
+#define MPL_LOG_DEFAULT KERN_DEFAULT
+#define MPL_LOG_VERBOSE KERN_CONT
+#define MPL_LOG_DEBUG   KERN_NOTICE
+#define MPL_LOG_INFO    KERN_INFO
+#define MPL_LOG_WARN    KERN_WARNING
+#define MPL_LOG_ERROR   KERN_ERR
+#define MPL_LOG_SILENT  MPL_LOG_VERBOSE
+
+#else
+	/* Based off the log priorities in android
+	   /system/core/include/android/log.h */
+#define MPL_LOG_UNKNOWN (0)
+#define MPL_LOG_DEFAULT (1)
+#define MPL_LOG_VERBOSE (2)
+#define MPL_LOG_DEBUG (3)
+#define MPL_LOG_INFO (4)
+#define MPL_LOG_WARN (5)
+#define MPL_LOG_ERROR (6)
+#define MPL_LOG_SILENT (8)
+#endif
+
+
+/*
+ * This is the local tag used for the following simplified
+ * logging macros.  You can change this preprocessor definition
+ * before using the other macros to change the tag.
+ */
+#ifndef MPL_LOG_TAG
+#ifdef __KERNEL__
+#define MPL_LOG_TAG
+#else
+#define MPL_LOG_TAG NULL
+#endif
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Simplified macro to send a verbose log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGV
+#if MPL_LOG_NDEBUG
+#define MPL_LOGV(...) ((void)0)
+#else
+#define MPL_LOGV(...) ((void)MPL_LOG(LOG_VERBOSE, MPL_LOG_TAG, __VA_ARGS__))
+#endif
+#endif
+
+#ifndef CONDITION
+#define CONDITION(cond)     ((cond) != 0)
+#endif
+
+#ifndef MPL_LOGV_IF
+#if MPL_LOG_NDEBUG
+#define MPL_LOGV_IF(cond, ...)   ((void)0)
+#else
+#define MPL_LOGV_IF(cond, ...) \
+	((CONDITION(cond))						\
+		? ((void)MPL_LOG(LOG_VERBOSE, MPL_LOG_TAG, __VA_ARGS__)) \
+		: (void)0)
+#endif
+#endif
+
+/*
+ * Simplified macro to send a debug log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGD
+#define MPL_LOGD(...) ((void)MPL_LOG(LOG_DEBUG, MPL_LOG_TAG, __VA_ARGS__))
+#endif
+
+#ifndef MPL_LOGD_IF
+#define MPL_LOGD_IF(cond, ...) \
+	((CONDITION(cond))					       \
+		? ((void)MPL_LOG(LOG_DEBUG, MPL_LOG_TAG, __VA_ARGS__)) \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send an info log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGI
+#define MPL_LOGI(...) ((void)MPL_LOG(LOG_INFO, MPL_LOG_TAG, __VA_ARGS__))
+#endif
+
+#ifndef MPL_LOGI_IF
+#define MPL_LOGI_IF(cond, ...) \
+	((CONDITION(cond))                                              \
+		? ((void)MPL_LOG(LOG_INFO, MPL_LOG_TAG, __VA_ARGS__))   \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send a warning log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGW
+#define MPL_LOGW(...) ((void)MPL_LOG(LOG_WARN, MPL_LOG_TAG, __VA_ARGS__))
+#endif
+
+#ifndef MPL_LOGW_IF
+#define MPL_LOGW_IF(cond, ...) \
+	((CONDITION(cond))					       \
+		? ((void)MPL_LOG(LOG_WARN, MPL_LOG_TAG, __VA_ARGS__))  \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send an error log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGE
+#define MPL_LOGE(...) ((void)MPL_LOG(LOG_ERROR, MPL_LOG_TAG, __VA_ARGS__))
+#endif
+
+#ifndef MPL_LOGE_IF
+#define MPL_LOGE_IF(cond, ...) \
+	((CONDITION(cond))					       \
+		? ((void)MPL_LOG(LOG_ERROR, MPL_LOG_TAG, __VA_ARGS__)) \
+		: (void)0)
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Log a fatal error.  If the given condition fails, this stops program
+ * execution like a normal assertion, but also generating the given message.
+ * It is NOT stripped from release builds.  Note that the condition test
+ * is -inverted- from the normal assert() semantics.
+ */
+#define MPL_LOG_ALWAYS_FATAL_IF(cond, ...) \
+	((CONDITION(cond))					   \
+		? ((void)android_printAssert(#cond, MPL_LOG_TAG, __VA_ARGS__)) \
+		: (void)0)
+
+#define MPL_LOG_ALWAYS_FATAL(...) \
+	(((void)android_printAssert(NULL, MPL_LOG_TAG, __VA_ARGS__)))
+
+/*
+ * Versions of MPL_LOG_ALWAYS_FATAL_IF and MPL_LOG_ALWAYS_FATAL that
+ * are stripped out of release builds.
+ */
+#if MPL_LOG_NDEBUG
+
+#define MPL_LOG_FATAL_IF(cond, ...) ((void)0)
+#define MPL_LOG_FATAL(...)          ((void)0)
+
+#else
+
+#define MPL_LOG_FATAL_IF(cond, ...) MPL_LOG_ALWAYS_FATAL_IF(cond, __VA_ARGS__)
+#define MPL_LOG_FATAL(...)          MPL_LOG_ALWAYS_FATAL(__VA_ARGS__)
+
+#endif
+
+/*
+ * Assertion that generates a log message when the assertion fails.
+ * Stripped out of release builds.  Uses the current MPL_LOG_TAG.
+ */
+#define MPL_LOG_ASSERT(cond, ...) MPL_LOG_FATAL_IF(!(cond), __VA_ARGS__)
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Basic log message macro.
+ *
+ * Example:
+ *  MPL_LOG(MPL_LOG_WARN, NULL, "Failed with error %d", errno);
+ *
+ * The second argument may be NULL or "" to indicate the "global" tag.
+ */
+#ifndef MPL_LOG
+#define MPL_LOG(priority, tag, ...) \
+    MPL_LOG_PRI(priority, tag, __VA_ARGS__)
+#endif
+
+/*
+ * Log macro that allows you to specify a number for the priority.
+ */
+#ifndef MPL_LOG_PRI
+#ifdef ANDROID
+#define MPL_LOG_PRI(priority, tag, ...) \
+	LOG(priority, tag, __VA_ARGS__)
+#elif defined __KERNEL__
+#define MPL_LOG_PRI(priority, tag, ...) \
+	printk(MPL_##priority tag __VA_ARGS__)
+#else
+#define MPL_LOG_PRI(priority, tag, ...) \
+	_MLPrintLog(MPL_##priority, tag, __VA_ARGS__)
+#endif
+#endif
+
+/*
+ * Log macro that allows you to pass in a varargs ("args" is a va_list).
+ */
+#ifndef MPL_LOG_PRI_VA
+#ifdef ANDROID
+#define MPL_LOG_PRI_VA(priority, tag, fmt, args) \
+    android_vprintLog(priority, NULL, tag, fmt, args)
+#elif defined __KERNEL__
+#define MPL_LOG_PRI_VA(priority, tag, fmt, args) \
+    vprintk(MPL_##priority tag fmt, args)
+#else
+#define MPL_LOG_PRI_VA(priority, tag, fmt, args) \
+    _MLPrintVaLog(priority, NULL, tag, fmt, args)
+#endif
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * ===========================================================================
+ *
+ * The stuff in the rest of this file should not be used directly.
+ */
+
+#ifndef ANDROID
+	int _MLPrintLog(int priority, const char *tag, const char *fmt,
+			...);
+	int _MLPrintVaLog(int priority, const char *tag, const char *fmt,
+			  va_list args);
+/* Final implementation of actual writing to a character device */
+	int _MLWriteLog(const char *buf, int buflen);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* _LIBS_CUTILS_MPL_LOG_H */
Index: Kernel/drivers/sensors/mpu3050/mldl_cfg.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mldl_cfg.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,1646 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+/*******************************************************************************
+ *
+ * $Id: mldl_cfg.c 4635 2011-01-27 07:49:49Z nroyer $
+ *
+ ******************************************************************************/
+
+/**
+ *  @addtogroup MLDL
+ *
+ *  @{
+ *      @file   mldl_cfg.c
+ *      @brief  The Motion Library Driver Layer.
+ */
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#include <stddef.h>
+
+#include "mldl_cfg.h"
+#include "mpu.h"
+
+#include "mlsl.h"
+#include "mlos.h"
+
+#include "log.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "mldl_cfg:"
+
+/* --------------------- */
+/* -    Variables.     - */
+/* --------------------- */
+#ifdef M_HW
+#define SLEEP   0
+#define WAKE_UP 7
+#define RESET   1
+#define STANDBY 1
+#else
+/* licteral significance of all parameters used in MLDLPowerMgmtMPU */
+#define SLEEP   1
+#define WAKE_UP 0
+#define RESET   1
+#define STANDBY 1
+#endif
+
+/*---------------------*/
+/*-    Prototypes.    -*/
+/*---------------------*/
+
+/*----------------------*/
+/*-  Static Functions. -*/
+/*----------------------*/
+
+static int dmp_stop(struct mldl_cfg *mldl_cfg, void *gyro_handle)
+{
+	unsigned char userCtrlReg;
+	int result;
+
+	if (!mldl_cfg->dmp_is_running)
+		return ML_SUCCESS;
+
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_USER_CTRL, 1, &userCtrlReg);
+	ERROR_CHECK(result);
+	userCtrlReg = (userCtrlReg & (~BIT_FIFO_EN)) | BIT_FIFO_RST;
+	userCtrlReg = (userCtrlReg & (~BIT_DMP_EN)) | BIT_DMP_RST;
+
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				       MPUREG_USER_CTRL, userCtrlReg);
+	ERROR_CHECK(result);
+	mldl_cfg->dmp_is_running = 0;
+
+	return result;
+
+}
+/**
+ * @brief Starts the DMP running
+ *
+ * @return ML_SUCCESS or non-zero error code
+ */
+static int dmp_start(struct mldl_cfg *pdata, void *mlsl_handle)
+{
+	unsigned char userCtrlReg;
+	int result;
+
+	if (pdata->dmp_is_running == pdata->dmp_enable)
+		return ML_SUCCESS;
+
+	result = MLSLSerialRead(mlsl_handle, pdata->addr,
+				MPUREG_USER_CTRL, 1, &userCtrlReg);
+	ERROR_CHECK(result);
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_USER_CTRL,
+				       ((userCtrlReg & (~BIT_FIFO_EN))
+						|   BIT_FIFO_RST));
+	ERROR_CHECK(result);
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_USER_CTRL, userCtrlReg);
+	ERROR_CHECK(result);
+
+	result = MLSLSerialRead(mlsl_handle, pdata->addr,
+				MPUREG_USER_CTRL, 1, &userCtrlReg);
+	ERROR_CHECK(result);
+
+	if (pdata->dmp_enable)
+		userCtrlReg |= BIT_DMP_EN;
+	else
+		userCtrlReg &= ~BIT_DMP_EN;
+
+	if (pdata->fifo_enable)
+		userCtrlReg |= BIT_FIFO_EN;
+	else
+		userCtrlReg &= ~BIT_FIFO_EN;
+
+	userCtrlReg |= BIT_DMP_RST;
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_USER_CTRL, userCtrlReg);
+	ERROR_CHECK(result);
+	pdata->dmp_is_running = pdata->dmp_enable;
+
+	return result;
+}
+
+/**
+ *  @brief  enables/disables the I2C bypass to an external device
+ *          connected to MPU's secondary I2C bus.
+ *  @param  enable
+ *              Non-zero to enable pass through.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+static int MLDLSetI2CBypass(struct mldl_cfg *mldl_cfg,
+			    void *mlsl_handle,
+			    unsigned char enable)
+{
+	unsigned char b;
+	int result;
+
+	if ((mldl_cfg->gyro_is_bypassed && enable) ||
+	    (!mldl_cfg->gyro_is_bypassed && !enable))
+		return ML_SUCCESS;
+
+	/*---- get current 'USER_CTRL' into b ----*/
+	result = MLSLSerialRead(mlsl_handle, mldl_cfg->addr,
+				MPUREG_USER_CTRL, 1, &b);
+	ERROR_CHECK(result);
+
+	b &= ~BIT_AUX_IF_EN;
+
+	if (!enable) {
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_USER_CTRL,
+					       (b | BIT_AUX_IF_EN));
+		ERROR_CHECK(result);
+	} else {
+		/* Coming out of I2C is tricky due to several erratta.  Do not
+		 * modify this algorithm
+		 */
+		/*
+		 * 1) wait for the right time and send the command to change
+		 * the aux i2c slave address to an invalid address that will
+		 * get nack'ed
+		 *
+		 * 0x00 is broadcast.  0x7F is unlikely to be used by any aux.
+		 */
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_AUX_SLV_ADDR, 0x7F);
+		ERROR_CHECK(result);
+		/*
+		 * 2) wait enough time for a nack to occur, then go into
+		 *    bypass mode:
+		 */
+		MLOSSleep(2);
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_USER_CTRL, (b));
+		ERROR_CHECK(result);
+		/*
+		 * 3) wait for up to one MPU cycle then restore the slave
+		 *    address
+		 */
+		MLOSSleep(SAMPLING_PERIOD_US(mldl_cfg) / 1000);
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_AUX_SLV_ADDR,
+					       mldl_cfg->pdata->
+					       accel.address);
+		ERROR_CHECK(result);
+
+		/*
+		 * 4) reset the ime interface
+		 */
+#ifdef M_HW
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_USER_CTRL,
+					       (b | BIT_I2C_MST_RST));
+
+#else
+		result = MLSLSerialWriteSingle(mlsl_handle, mldl_cfg->addr,
+					       MPUREG_USER_CTRL,
+					       (b | BIT_AUX_IF_RST));
+#endif
+		ERROR_CHECK(result);
+		MLOSSleep(2);
+	}
+	mldl_cfg->gyro_is_bypassed = enable;
+
+	return result;
+}
+
+struct tsProdRevMap {
+	unsigned char siliconRev;
+	unsigned short sensTrim;
+};
+
+#define NUM_OF_PROD_REVS (DIM(prodRevsMap))
+
+/* NOTE : 'npp' is a non production part */
+#ifdef M_HW
+#define OLDEST_PROD_REV_SUPPORTED 1
+static struct tsProdRevMap prodRevsMap[] = {
+	{0, 0},
+	{MPU_SILICON_REV_A1, 131},	/* 1 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 2 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 3 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 4 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 5 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 6 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 7 A1 (npp) */
+	{MPU_SILICON_REV_A1, 131},	/* 8 A1 (npp) */
+};
+
+#else				/* !M_HW */
+#define OLDEST_PROD_REV_SUPPORTED 11
+
+static struct tsProdRevMap prodRevsMap[] = {
+	{0, 0},
+	{MPU_SILICON_REV_A4, 131},	/* 1 A? OBSOLETED */
+	{MPU_SILICON_REV_A4, 131},	/* 2 | */
+	{MPU_SILICON_REV_A4, 131},	/* 3 V */
+	{MPU_SILICON_REV_A4, 131},	/* 4 */
+	{MPU_SILICON_REV_A4, 131},	/* 5 */
+	{MPU_SILICON_REV_A4, 131},	/* 6 */
+	{MPU_SILICON_REV_A4, 131},	/* 7 */
+	{MPU_SILICON_REV_A4, 131},	/* 8 */
+	{MPU_SILICON_REV_A4, 131},	/* 9 */
+	{MPU_SILICON_REV_A4, 131},	/* 10 */
+	{MPU_SILICON_REV_B1, 131},	/* 11 B1 */
+	{MPU_SILICON_REV_B1, 131},	/* 12 | */
+	{MPU_SILICON_REV_B1, 131},	/* 13 V */
+	{MPU_SILICON_REV_B1, 131},	/* 14 B4 */
+	{MPU_SILICON_REV_B4, 131},	/* 15 | */
+	{MPU_SILICON_REV_B4, 131},	/* 16 V */
+	{MPU_SILICON_REV_B4, 131},	/* 17 */
+	{MPU_SILICON_REV_B4, 131},	/* 18 */
+	{MPU_SILICON_REV_B4, 115},	/* 19  */
+	{MPU_SILICON_REV_B4, 115},	/* 20 */
+	{MPU_SILICON_REV_B6, 131},	/* 21 B6 (B6/A9)  */
+	{MPU_SILICON_REV_B4, 115},	/* 22 B4 (B7/A10) */
+	{MPU_SILICON_REV_B6, 0},	/* 23 B6 (npp)    */
+	{MPU_SILICON_REV_B6, 0},	/* 24 |  (npp)    */
+	{MPU_SILICON_REV_B6, 0},	/* 25 V  (npp)    */
+	{MPU_SILICON_REV_B6, 131},	/* 26    (B6/A11) */
+};
+#endif				/* !M_HW */
+
+/**
+ *  @internal
+ *  @brief  Get the silicon revision ID from OTP.
+ *          The silicon revision number is in read from OTP bank 0,
+ *          ADDR6[7:2].  The corresponding ID is retrieved by lookup
+ *          in a map.
+ *  @return The silicon revision ID (0 on error).
+ */
+static int MLDLGetSiliconRev(struct mldl_cfg *pdata,
+			     void *mlsl_handle)
+{
+	int result;
+	unsigned char index = 0x00;
+	unsigned char bank =
+	    (BIT_PRFTCH_EN | BIT_CFG_USER_BANK | MPU_MEM_OTP_BANK_0);
+	unsigned short memAddr = ((bank << 8) | 0x06);
+
+	result = MLSLSerialReadMem(mlsl_handle, pdata->addr,
+				   memAddr, 1, &index);
+	ERROR_CHECK(result)
+	if (result)
+		return result;
+	index >>= 2;
+
+	/* clean the prefetch and cfg user bank bits */
+	result =
+	    MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				  MPUREG_BANK_SEL, 0);
+	ERROR_CHECK(result)
+	if (result)
+		return result;
+
+	if (index < OLDEST_PROD_REV_SUPPORTED || NUM_OF_PROD_REVS <= index) {
+		pdata->silicon_revision = 0;
+		pdata->trim = 0;
+		MPL_LOGE("Unsupported Product Revision Detected : %d\n", index);
+		return ML_ERROR_INVALID_MODULE;
+	}
+
+	pdata->silicon_revision = prodRevsMap[index].siliconRev;
+	pdata->trim = prodRevsMap[index].sensTrim;
+
+	if (pdata->trim == 0) {
+		MPL_LOGE("sensitivity trim is 0"
+			 " - unsupported non production part.\n");
+		return ML_ERROR_INVALID_MODULE;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief      Enable/Disable the use MPU's VDDIO level shifters.
+ *              When enabled the voltage interface with AUX or other external
+ *              accelerometer is using Vlogic instead of VDD (supply).
+ *
+ *  @note       Must be called after MLSerialOpen().
+ *  @note       Typically be called before MLDmpOpen().
+ *              If called after MLDmpOpen(), must be followed by a call to
+ *              MLDLApplyLevelShifterBit() to write the setting on the hw.
+ *
+ *  @param[in]  enable
+ *                  1 to enable, 0 to disable
+ *
+ *  @return     ML_SUCCESS if successfull, a non-zero error code otherwise.
+**/
+static int MLDLSetLevelShifterBit(struct mldl_cfg *pdata,
+				  void *mlsl_handle,
+				  unsigned char enable)
+{
+#ifndef M_HW
+	int result;
+	unsigned char reg;
+	unsigned char mask;
+	unsigned char regval;
+
+	if (0 == pdata->silicon_revision)
+		return ML_ERROR_INVALID_PARAMETER;
+
+	/*-- on parts before B6 the VDDIO bit is bit 7 of ACCEL_BURST_ADDR --
+	  NOTE: this is incompatible with ST accelerometers where the VDDIO
+		bit MUST be set to enable ST's internal logic to autoincrement
+		the register address on burst reads --*/
+	if ((pdata->silicon_revision & 0xf) < MPU_SILICON_REV_B6) {
+		reg = MPUREG_ACCEL_BURST_ADDR;
+		mask = 0x80;
+	} else {
+		/*-- on B6 parts the VDDIO bit was moved to FIFO_EN2 =>
+		  the mask is always 0x04 --*/
+		reg = MPUREG_FIFO_EN2;
+		mask = 0x04;
+	}
+
+	result = MLSLSerialRead(mlsl_handle, pdata->addr, reg, 1, &regval);
+	if (result)
+		return result;
+
+	if (enable)
+		regval |= mask;
+	else
+		regval &= ~mask;
+
+	result =
+	    MLSLSerialWriteSingle(mlsl_handle, pdata->addr, reg, regval);
+
+	return result;
+#else
+	return ML_SUCCESS;
+#endif
+}
+
+
+#ifdef M_HW
+/**
+ *  @internal
+ * @param reset 1 to reset hardware
+ */
+static tMLError mpu60xx_pwr_mgmt(struct mldl_cfg *pdata,
+				 void *mlsl_handle,
+				 unsigned char reset,
+				 unsigned char powerselection)
+{
+	unsigned char b;
+	tMLError result;
+
+	if (powerselection < 0 || powerselection > 7)
+		return ML_ERROR_INVALID_PARAMETER;
+
+	result =
+	    MLSLSerialRead(mlsl_handle, pdata->addr, MPUREG_PWR_MGMT_1, 1,
+			   &b);
+	ERROR_CHECK(result);
+
+	b &= ~(BITS_PWRSEL);
+
+	if (reset) {
+		/* Current sillicon has an errata where the reset will get
+		 * nacked.  Ignore the error code for now. */
+		result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+					       MPUREG_PWR_MGM, b | BIT_H_RESET);
+#define M_HW_RESET_ERRATTA
+#ifndef M_HW_RESET_ERRATTA
+		ERROR_CHECK(result);
+#else
+		MLOSSleep(50);
+#endif
+	}
+
+	b |= (powerselection << 4);
+
+	if (b & BITS_PWRSEL)
+		pdata->gyro_is_suspended = FALSE;
+	else
+		pdata->gyro_is_suspended = TRUE;
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_PWR_MGM, b);
+	ERROR_CHECK(result);
+
+	return ML_SUCCESS;
+}
+
+/**
+ *  @internal
+ */
+static tMLError MLDLStandByGyros(struct mldl_cfg *pdata,
+				 void *mlsl_handle,
+				 unsigned char disable_gx,
+				 unsigned char disable_gy,
+				 unsigned char disable_gz)
+{
+	unsigned char b;
+	tMLError result;
+
+	result =
+	    MLSLSerialRead(mlsl_handle, pdata->addr, MPUREG_PWR_MGMT_2, 1,
+			   &b);
+	ERROR_CHECK(result);
+
+	b &= ~(BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG);
+	b |= (disable_gx << 2 | disable_gy << 1 | disable_gz);
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_PWR_MGMT_2, b);
+	ERROR_CHECK(result);
+
+	return ML_SUCCESS;
+}
+
+/**
+ *  @internal
+ */
+static tMLError MLDLStandByAccels(struct mldl_cfg *pdata,
+				  void *mlsl_handle,
+				  unsigned char disable_ax,
+				  unsigned char disable_ay,
+				  unsigned char disable_az)
+{
+	unsigned char b;
+	tMLError result;
+
+	result =
+	    MLSLSerialRead(mlsl_handle, pdata->addr, MPUREG_PWR_MGMT_2, 1,
+			   &b);
+	ERROR_CHECK(result);
+
+	b &= ~(BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA);
+	b |= (disable_ax << 2 | disable_ay << 1 | disable_az);
+
+	result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+				       MPUREG_PWR_MGMT_2, b);
+	ERROR_CHECK(result);
+
+	return ML_SUCCESS;
+}
+
+#else				/* ! M_HW */
+
+/**
+ * @internal
+ * @brief   This function controls the power management on the MPU device.
+ *          The entire chip can be put to low power sleep mode, or individual
+ *          gyros can be turned on/off.
+ *
+ *          Putting the device into sleep mode depending upon the changing needs
+ *          of the associated applications is a recommended method for reducing
+ *          power consuption.  It is a safe opearation in that sleep/wake up of
+ *          gyros while running will not result in any interruption of data.
+ *
+ *          Although it is entirely allowed to put the device into full sleep
+ *          while running the DMP, it is not recomended because it will disrupt
+ *          the ongoing calculations carried on inside the DMP and consequently
+ *          the sensor fusion algorithm. Furthermore, while in sleep mode
+ *          read & write operation from the app processor on both registers and
+ *          memory are disabled and can only regained by restoring the MPU in
+ *          normal power mode.
+ *          Disabling any of the gyro axis will reduce the associated power
+ *          consuption from the PLL but will not stop the DMP from running
+ *          state.
+ *
+ * @param   reset
+ *              Non-zero to reset the device. Note that this setting
+ *              is volatile and the corresponding register bit will
+ *              clear itself right after being applied.
+ * @param   sleep
+ *              Non-zero to put device into full sleep.
+ * @param   disable_gx
+ *              Non-zero to disable gyro X.
+ * @param   disable_gy
+ *              Non-zero to disable gyro Y.
+ * @param   disable_gz
+ *              Non-zero to disable gyro Z.
+ *
+ * @return  ML_SUCCESS if successfull; a non-zero error code otherwise.
+ */
+static int MLDLPowerMgmtMPU(struct mldl_cfg *pdata,
+			    void *mlsl_handle,
+			    unsigned char reset,
+			    unsigned char sleep,
+			    unsigned char disable_gx,
+			    unsigned char disable_gy,
+			    unsigned char disable_gz)
+{
+	unsigned char b;
+	int result;
+
+	result =
+	    MLSLSerialRead(mlsl_handle, pdata->addr, MPUREG_PWR_MGM, 1,
+			   &b);
+	ERROR_CHECK(result);
+
+	/* If we are awake, we need to put it in bypass before resetting */
+	if ((!(b & BIT_SLEEP)) && reset)
+		result = MLDLSetI2CBypass(pdata, mlsl_handle, 1);
+
+	/* If we are awake, we need stop the dmp sleeping */
+	if ((!(b & BIT_SLEEP)) && sleep)
+		dmp_stop(pdata, mlsl_handle);
+
+	/* Reset if requested */
+	if (reset) {
+		result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+					MPUREG_PWR_MGM, b | BIT_H_RESET);
+		ERROR_CHECK(result);
+		MLOSSleep(5);
+		pdata->gyro_needs_reset = FALSE;
+		/* Some chips are awake after reset and some are asleep,
+		 * check the status */
+		result = MLSLSerialRead(mlsl_handle, pdata->addr,
+					MPUREG_PWR_MGM, 1, &b);
+		ERROR_CHECK(result);
+	}
+
+	/* Update the suspended state just in case we return early */
+	if (b & BIT_SLEEP)
+		pdata->gyro_is_suspended = TRUE;
+	else
+		pdata->gyro_is_suspended = FALSE;
+
+	/* if power status match requested, nothing else's left to do */
+	if ((b & (BIT_SLEEP | BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)) ==
+		(((sleep != 0) * BIT_SLEEP) |
+		((disable_gx != 0) * BIT_STBY_XG) |
+		((disable_gy != 0) * BIT_STBY_YG) |
+		((disable_gz != 0) * BIT_STBY_ZG))) {
+		return ML_SUCCESS;
+	}
+
+	/*
+	 * This specific transition between states needs to be reinterpreted:
+	 *    (1,1,1,1) -> (0,1,1,1) has to become
+	 *    (1,1,1,1) -> (1,0,0,0) -> (0,1,1,1)
+	 * where
+	 *    (1,1,1,1) is (sleep=1,disable_gx=1,disable_gy=1,disable_gz=1)
+	 */
+	if ((b & (BIT_SLEEP | BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)) ==
+		 (BIT_SLEEP | BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
+		&& ((!sleep) && disable_gx && disable_gy && disable_gz)) {
+		result = MLDLPowerMgmtMPU(pdata, mlsl_handle, 0, 1, 0, 0, 0);
+		if (result)
+			return result;
+		b |= BIT_SLEEP;
+		b &= ~(BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG);
+	}
+
+	if ((b & BIT_SLEEP) != ((sleep != 0) * BIT_SLEEP)) {
+		if (sleep) {
+			result = MLDLSetI2CBypass(pdata, mlsl_handle, 1);
+			ERROR_CHECK(result);
+			b |= BIT_SLEEP;
+			result =
+			    MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+						  MPUREG_PWR_MGM, b);
+			ERROR_CHECK(result);
+			pdata->gyro_is_suspended = TRUE;
+		} else {
+			b &= ~BIT_SLEEP;
+			result =
+			    MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+						  MPUREG_PWR_MGM, b);
+			ERROR_CHECK(result);
+			pdata->gyro_is_suspended = FALSE;
+			MLOSSleep(5);
+		}
+	}
+	/*---
+	  WORKAROUND FOR PUTTING GYRO AXIS in STAND-BY MODE
+	  1) put one axis at a time in stand-by
+	  ---*/
+	if ((b & BIT_STBY_XG) != ((disable_gx != 0) * BIT_STBY_XG)) {
+		b ^= BIT_STBY_XG;
+		result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+						MPUREG_PWR_MGM, b);
+		ERROR_CHECK(result);
+	}
+	if ((b & BIT_STBY_YG) != ((disable_gy != 0) * BIT_STBY_YG)) {
+		b ^= BIT_STBY_YG;
+		result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+					       MPUREG_PWR_MGM, b);
+		ERROR_CHECK(result);
+	}
+	if ((b & BIT_STBY_ZG) != ((disable_gz != 0) * BIT_STBY_ZG)) {
+		b ^= BIT_STBY_ZG;
+		result = MLSLSerialWriteSingle(mlsl_handle, pdata->addr,
+					       MPUREG_PWR_MGM, b);
+		ERROR_CHECK(result);
+	}
+
+	return ML_SUCCESS;
+}
+#endif				/* M_HW */
+
+
+void mpu_print_cfg(struct mldl_cfg *mldl_cfg)
+{
+	struct mpu3050_platform_data *pdata = mldl_cfg->pdata;
+	struct ext_slave_platform_data *accel = &mldl_cfg->pdata->accel;
+	struct ext_slave_platform_data *compass =
+	    &mldl_cfg->pdata->compass;
+	struct ext_slave_platform_data *pressure =
+	    &mldl_cfg->pdata->pressure;
+
+	MPL_LOGD("mldl_cfg.addr             = %02x\n", mldl_cfg->addr);
+	MPL_LOGD("mldl_cfg.int_config       = %02x\n",
+		 mldl_cfg->int_config);
+	MPL_LOGD("mldl_cfg.ext_sync         = %02x\n", mldl_cfg->ext_sync);
+	MPL_LOGD("mldl_cfg.full_scale       = %02x\n",
+		 mldl_cfg->full_scale);
+	MPL_LOGD("mldl_cfg.lpf              = %02x\n", mldl_cfg->lpf);
+	MPL_LOGD("mldl_cfg.clk_src          = %02x\n", mldl_cfg->clk_src);
+	MPL_LOGD("mldl_cfg.divider          = %02x\n", mldl_cfg->divider);
+	MPL_LOGD("mldl_cfg.dmp_enable       = %02x\n",
+		 mldl_cfg->dmp_enable);
+	MPL_LOGD("mldl_cfg.fifo_enable      = %02x\n",
+		 mldl_cfg->fifo_enable);
+	MPL_LOGD("mldl_cfg.dmp_cfg1         = %02x\n", mldl_cfg->dmp_cfg1);
+	MPL_LOGD("mldl_cfg.dmp_cfg2         = %02x\n", mldl_cfg->dmp_cfg2);
+	MPL_LOGD("mldl_cfg.offset_tc[0]     = %02x\n",
+		 mldl_cfg->offset_tc[0]);
+	MPL_LOGD("mldl_cfg.offset_tc[1]     = %02x\n",
+		 mldl_cfg->offset_tc[1]);
+	MPL_LOGD("mldl_cfg.offset_tc[2]     = %02x\n",
+		 mldl_cfg->offset_tc[2]);
+	MPL_LOGD("mldl_cfg.silicon_revision = %02x\n",
+		 mldl_cfg->silicon_revision);
+	MPL_LOGD("mldl_cfg.product_id       = %02x\n",
+		 mldl_cfg->product_id);
+	MPL_LOGD("mldl_cfg.trim             = %02x\n", mldl_cfg->trim);
+	MPL_LOGD("mldl_cfg.requested_sensors= %04lx\n",
+		 mldl_cfg->requested_sensors);
+
+	if (mldl_cfg->accel) {
+		MPL_LOGD("slave_accel->suspend      = %02x\n",
+			 (int) mldl_cfg->accel->suspend);
+		MPL_LOGD("slave_accel->resume       = %02x\n",
+			 (int) mldl_cfg->accel->resume);
+		MPL_LOGD("slave_accel->read         = %02x\n",
+			 (int) mldl_cfg->accel->read);
+		MPL_LOGD("slave_accel->type         = %02x\n",
+			 mldl_cfg->accel->type);
+		MPL_LOGD("slave_accel->reg          = %02x\n",
+			 mldl_cfg->accel->reg);
+		MPL_LOGD("slave_accel->len          = %02x\n",
+			 mldl_cfg->accel->len);
+		MPL_LOGD("slave_accel->endian       = %02x\n",
+			 mldl_cfg->accel->endian);
+		MPL_LOGD("slave_accel->range.mantissa= %02lx\n",
+			 mldl_cfg->accel->range.mantissa);
+		MPL_LOGD("slave_accel->range.fraction= %02lx\n",
+			 mldl_cfg->accel->range.fraction);
+	} else {
+		MPL_LOGD("slave_accel               = NULL\n");
+	}
+
+	if (mldl_cfg->compass) {
+		MPL_LOGD("slave_compass->suspend    = %02x\n",
+			 (int) mldl_cfg->compass->suspend);
+		MPL_LOGD("slave_compass->resume     = %02x\n",
+			 (int) mldl_cfg->compass->resume);
+		MPL_LOGD("slave_compass->read       = %02x\n",
+			 (int) mldl_cfg->compass->read);
+		MPL_LOGD("slave_compass->type       = %02x\n",
+			 mldl_cfg->compass->type);
+		MPL_LOGD("slave_compass->reg        = %02x\n",
+			 mldl_cfg->compass->reg);
+		MPL_LOGD("slave_compass->len        = %02x\n",
+			 mldl_cfg->compass->len);
+		MPL_LOGD("slave_compass->endian     = %02x\n",
+			 mldl_cfg->compass->endian);
+		MPL_LOGD("slave_compass->range.mantissa= %02lx\n",
+			 mldl_cfg->compass->range.mantissa);
+		MPL_LOGD("slave_compass->range.fraction= %02lx\n",
+			 mldl_cfg->compass->range.fraction);
+
+	} else {
+		MPL_LOGD("slave_compass             = NULL\n");
+	}
+
+	if (mldl_cfg->pressure) {
+		MPL_LOGD("slave_pressure->suspend    = %02x\n",
+			 (int) mldl_cfg->pressure->suspend);
+		MPL_LOGD("slave_pressure->resume     = %02x\n",
+			 (int) mldl_cfg->pressure->resume);
+		MPL_LOGD("slave_pressure->read       = %02x\n",
+			 (int) mldl_cfg->pressure->read);
+		MPL_LOGD("slave_pressure->type       = %02x\n",
+			 mldl_cfg->pressure->type);
+		MPL_LOGD("slave_pressure->reg        = %02x\n",
+			 mldl_cfg->pressure->reg);
+		MPL_LOGD("slave_pressure->len        = %02x\n",
+			 mldl_cfg->pressure->len);
+		MPL_LOGD("slave_pressure->endian     = %02x\n",
+			 mldl_cfg->pressure->endian);
+		MPL_LOGD("slave_pressure->range.mantissa= %02lx\n",
+			 mldl_cfg->pressure->range.mantissa);
+		MPL_LOGD("slave_pressure->range.fraction= %02lx\n",
+			 mldl_cfg->pressure->range.fraction);
+
+	} else {
+		MPL_LOGD("slave_pressure             = NULL\n");
+	}
+	MPL_LOGD("accel->get_slave_descr    = %x\n",
+		 (unsigned int) accel->get_slave_descr);
+	MPL_LOGD("accel->irq                = %02x\n", accel->irq);
+	MPL_LOGD("accel->adapt_num          = %02x\n", accel->adapt_num);
+	MPL_LOGD("accel->bus                = %02x\n", accel->bus);
+	MPL_LOGD("accel->address            = %02x\n", accel->address);
+	MPL_LOGD("accel->orientation        =\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n",
+		 accel->orientation[0], accel->orientation[1],
+		 accel->orientation[2], accel->orientation[3],
+		 accel->orientation[4], accel->orientation[5],
+		 accel->orientation[6], accel->orientation[7],
+		 accel->orientation[8]);
+	MPL_LOGD("compass->get_slave_descr  = %x\n",
+		 (unsigned int) compass->get_slave_descr);
+	MPL_LOGD("compass->irq              = %02x\n", compass->irq);
+	MPL_LOGD("compass->adapt_num        = %02x\n", compass->adapt_num);
+	MPL_LOGD("compass->bus              = %02x\n", compass->bus);
+	MPL_LOGD("compass->address          = %02x\n", compass->address);
+	MPL_LOGD("compass->orientation      =\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n",
+		 compass->orientation[0], compass->orientation[1],
+		 compass->orientation[2], compass->orientation[3],
+		 compass->orientation[4], compass->orientation[5],
+		 compass->orientation[6], compass->orientation[7],
+		 compass->orientation[8]);
+	MPL_LOGD("pressure->get_slave_descr  = %x\n",
+		 (unsigned int) pressure->get_slave_descr);
+	MPL_LOGD("pressure->irq             = %02x\n", pressure->irq);
+	MPL_LOGD("pressure->adapt_num       = %02x\n", pressure->adapt_num);
+	MPL_LOGD("pressure->bus             = %02x\n", pressure->bus);
+	MPL_LOGD("pressure->address         = %02x\n", pressure->address);
+	MPL_LOGD("pressure->orientation     =\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n",
+		 pressure->orientation[0], pressure->orientation[1],
+		 pressure->orientation[2], pressure->orientation[3],
+		 pressure->orientation[4], pressure->orientation[5],
+		 pressure->orientation[6], pressure->orientation[7],
+		 pressure->orientation[8]);
+
+	MPL_LOGD("pdata->int_config         = %02x\n", pdata->int_config);
+	MPL_LOGD("pdata->level_shifter      = %02x\n",
+		 pdata->level_shifter);
+	MPL_LOGD("pdata->orientation        =\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n",
+		 pdata->orientation[0], pdata->orientation[1],
+		 pdata->orientation[2], pdata->orientation[3],
+		 pdata->orientation[4], pdata->orientation[5],
+		 pdata->orientation[6], pdata->orientation[7],
+		 pdata->orientation[8]);
+
+	MPL_LOGD("Struct sizes: mldl_cfg: %d, "
+		 "ext_slave_descr:%d, "
+		 "mpu3050_platform_data:%d: RamOffset: %d\n",
+		 sizeof(struct mldl_cfg), sizeof(struct ext_slave_descr),
+		 sizeof(struct mpu3050_platform_data),
+		 offsetof(struct mldl_cfg, ram));
+}
+
+int mpu_set_slave(struct mldl_cfg *mldl_cfg,
+		void *gyro_handle,
+		struct ext_slave_descr *slave,
+		struct ext_slave_platform_data *slave_pdata)
+{
+	int result;
+	unsigned char reg;
+	unsigned char slave_reg;
+	unsigned char slave_len;
+	unsigned char slave_endian;
+	unsigned char slave_address;
+
+	result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, TRUE);
+
+	if (NULL == slave || NULL == slave_pdata) {
+		slave_reg = 0;
+		slave_len = 0;
+		slave_endian = 0;
+		slave_address = 0;
+	} else {
+		slave_reg = slave->reg;
+		slave_len = slave->len;
+		slave_endian = slave->endian;
+		slave_address = slave_pdata->address;
+	}
+
+	/* Address */
+	result = MLSLSerialWriteSingle(gyro_handle,
+				mldl_cfg->addr,
+				MPUREG_AUX_SLV_ADDR,
+				slave_address);
+	ERROR_CHECK(result);
+	/* Register */
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_ACCEL_BURST_ADDR, 1,
+				&reg);
+	ERROR_CHECK(result);
+	reg = ((reg & 0x80) | slave_reg);
+	result = MLSLSerialWriteSingle(gyro_handle,
+				mldl_cfg->addr,
+				MPUREG_ACCEL_BURST_ADDR,
+				reg);
+	ERROR_CHECK(result);
+
+#ifdef M_HW
+	/* Length, byte swapping, grouping & enable */
+	if (slave_len > BITS_SLV_LENG) {
+		MPL_LOGW("Limiting slave burst read length to "
+			"the allowed maximum (15B, req. %d)\n",
+			slave_len);
+		slave_len = BITS_SLV_LENG;
+	}
+	reg = slave_len;
+	if (slave_endian == EXT_SLAVE_LITTLE_ENDIAN)
+		reg |= BIT_SLV_BYTE_SW;
+	reg |= BIT_SLV_GRP;
+	reg |= BIT_SLV_ENABLE;
+
+	result = MLSLSerialWriteSingle(gyro_handle,
+				mldl_cfg->addr,
+				MPUREG_I2C_SLV0_CTRL,
+				reg);
+#else
+	/* Length */
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_USER_CTRL, 1, &reg);
+	ERROR_CHECK(result);
+	reg = (reg & ~BIT_AUX_RD_LENG);
+	result = MLSLSerialWriteSingle(gyro_handle,
+				mldl_cfg->addr,
+				MPUREG_USER_CTRL, reg);
+	ERROR_CHECK(result);
+#endif
+
+	if (slave_address) {
+		result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, FALSE);
+		ERROR_CHECK(result);
+	}
+	return result;
+}
+
+/**
+ * Check to see if the gyro was reset by testing a couple of registers known
+ * to change on reset.
+ *
+ * @param mldl_cfg mldl configuration structure
+ * @param gyro_handle handle used to communicate with the gyro
+ *
+ * @return ML_SUCCESS or non-zero error code
+ */
+static int mpu_was_reset(struct mldl_cfg *mldl_cfg, void *gyro_handle)
+{
+	int result = ML_SUCCESS;
+	unsigned char reg;
+
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_DMP_CFG_2, 1, &reg);
+	ERROR_CHECK(result);
+
+	if (mldl_cfg->dmp_cfg2 != reg)
+		return TRUE;
+
+	if (0 != mldl_cfg->dmp_cfg1)
+		return FALSE;
+
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_SMPLRT_DIV, 1, &reg);
+	ERROR_CHECK(result);
+	if (reg != mldl_cfg->divider)
+		return TRUE;
+
+	if (0 != mldl_cfg->divider)
+		return FALSE;
+
+	/* Inconclusive assume it was reset */
+	return TRUE;
+}
+
+static int gyro_resume(struct mldl_cfg *mldl_cfg, void *gyro_handle)
+{
+	int result;
+	int ii;
+	int jj;
+	unsigned char reg;
+	unsigned char regs[7];
+
+	/* Wake up the part */
+#ifdef M_HW
+	result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, RESET,
+				WAKE_UP);
+	ERROR_CHECK(result);
+
+	/* Configure the MPU */
+	result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, 1);
+	ERROR_CHECK(result);
+	/* setting int_config with the propert flag BIT_BYPASS_EN
+	   should be done by the setup functions */
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_INT_PIN_CFG,
+				(mldl_cfg->pdata->int_config |
+					BIT_BYPASS_EN));
+	ERROR_CHECK(result);
+	/* temporary: masking out higher bits to avoid switching
+	   intelligence */
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_INT_ENABLE,
+				(mldl_cfg->int_config));
+	ERROR_CHECK(result);
+#else
+	result = MLDLPowerMgmtMPU(mldl_cfg, gyro_handle, 0, 0,
+				mldl_cfg->gyro_power & BIT_STBY_XG,
+				mldl_cfg->gyro_power & BIT_STBY_YG,
+				mldl_cfg->gyro_power & BIT_STBY_ZG);
+
+	if (!mldl_cfg->gyro_needs_reset &&
+	    !mpu_was_reset(mldl_cfg, gyro_handle)) {
+		return ML_SUCCESS;
+	}
+
+	result = MLDLPowerMgmtMPU(mldl_cfg, gyro_handle, 1, 0,
+				mldl_cfg->gyro_power & BIT_STBY_XG,
+				mldl_cfg->gyro_power & BIT_STBY_YG,
+				mldl_cfg->gyro_power & BIT_STBY_ZG);
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_INT_CFG,
+				(mldl_cfg->int_config |
+					mldl_cfg->pdata->int_config));
+	ERROR_CHECK(result);
+#endif
+
+	result = MLSLSerialRead(gyro_handle, mldl_cfg->addr,
+				MPUREG_PWR_MGM, 1, &reg);
+	ERROR_CHECK(result);
+	reg &= ~BITS_CLKSEL;
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_PWR_MGM,
+				mldl_cfg->clk_src | reg);
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_SMPLRT_DIV,
+				mldl_cfg->divider);
+	ERROR_CHECK(result);
+
+#ifdef M_HW
+	reg = DLPF_FS_SYNC_VALUE(0, mldl_cfg->full_scale, 0);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_GYRO_CONFIG, reg);
+	reg = DLPF_FS_SYNC_VALUE(mldl_cfg->ext_sync, 0, mldl_cfg->lpf);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_CONFIG, reg);
+#else
+	reg = DLPF_FS_SYNC_VALUE(mldl_cfg->ext_sync,
+				mldl_cfg->full_scale, mldl_cfg->lpf);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_DLPF_FS_SYNC, reg);
+#endif
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_DMP_CFG_1,
+				mldl_cfg->dmp_cfg1);
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_DMP_CFG_2,
+				mldl_cfg->dmp_cfg2);
+	ERROR_CHECK(result);
+
+	/* Write and verify memory */
+	for (ii = 0; ii < MPU_MEM_NUM_RAM_BANKS; ii++) {
+		unsigned char read[MPU_MEM_BANK_SIZE];
+
+		result = MLSLSerialWriteMem(gyro_handle,
+					mldl_cfg->addr,
+					((ii << 8) | 0x00),
+					MPU_MEM_BANK_SIZE,
+					mldl_cfg->ram[ii]);
+		ERROR_CHECK(result);
+		result = MLSLSerialReadMem(gyro_handle, mldl_cfg->addr,
+					((ii << 8) | 0x00),
+					MPU_MEM_BANK_SIZE, read);
+		ERROR_CHECK(result);
+
+#ifdef M_HW
+#define ML_SKIP_CHECK 38
+#else
+#define ML_SKIP_CHECK 20
+#endif
+		for (jj = 0; jj < MPU_MEM_BANK_SIZE; jj++) {
+			/* skip the register memory locations */
+			if (ii == 0 && jj < ML_SKIP_CHECK)
+				continue;
+			if (mldl_cfg->ram[ii][jj] != read[jj]) {
+				result = ML_ERROR_SERIAL_WRITE;
+				break;
+			}
+		}
+		ERROR_CHECK(result);
+	}
+
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_XG_OFFS_TC,
+				mldl_cfg->offset_tc[0]);
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_YG_OFFS_TC,
+				mldl_cfg->offset_tc[1]);
+	ERROR_CHECK(result);
+	result = MLSLSerialWriteSingle(gyro_handle, mldl_cfg->addr,
+				MPUREG_ZG_OFFS_TC,
+				mldl_cfg->offset_tc[2]);
+	ERROR_CHECK(result);
+
+	regs[0] = MPUREG_X_OFFS_USRH;
+	for (ii = 0; ii < DIM(mldl_cfg->offset); ii++) {
+		regs[1 + ii * 2] =
+			(unsigned char)(mldl_cfg->offset[ii] >> 8)
+			& 0xff;
+		regs[1 + ii * 2 + 1] =
+			(unsigned char)(mldl_cfg->offset[ii] & 0xff);
+	}
+	result = MLSLSerialWrite(gyro_handle, mldl_cfg->addr, 7, regs);
+	ERROR_CHECK(result);
+
+	/* Configure slaves */
+	result = MLDLSetLevelShifterBit(mldl_cfg, gyro_handle,
+					mldl_cfg->pdata->level_shifter);
+	ERROR_CHECK(result);
+	return result;
+}
+/*******************************************************************************
+ *******************************************************************************
+ * Exported functions
+ *******************************************************************************
+ ******************************************************************************/
+
+/**
+ * Initializes the pdata structure to defaults.
+ *
+ * Opens the device to read silicon revision, product id and whoami.
+ *
+ * @param mldl_cfg
+ *          The internal device configuration data structure.
+ * @param mlsl_handle
+ *          The serial communication handle.
+ *
+ * @return ML_SUCCESS if silicon revision, product id and woami are supported
+ *         by this software.
+ */
+int mpu3050_open(struct mldl_cfg *mldl_cfg,
+		 void *mlsl_handle,
+		 void *accel_handle,
+		 void *compass_handle,
+		 void *pressure_handle)
+{
+	int result;
+	/* Default is Logic HIGH, pushpull, latch disabled, anyread to clear */
+	mldl_cfg->int_config = BIT_INT_ANYRD_2CLEAR | BIT_DMP_INT_EN;
+	mldl_cfg->clk_src = MPU_CLK_SEL_PLLGYROZ;
+	mldl_cfg->lpf = MPU_FILTER_42HZ;
+	mldl_cfg->full_scale = MPU_FS_2000DPS;
+	mldl_cfg->divider = 4;
+	mldl_cfg->dmp_enable = 1;
+	mldl_cfg->fifo_enable = 1;
+	mldl_cfg->ext_sync = 0;
+	mldl_cfg->dmp_cfg1 = 0;
+	mldl_cfg->dmp_cfg2 = 0;
+	mldl_cfg->gyro_power = 0;
+	mldl_cfg->gyro_is_bypassed = TRUE;
+	mldl_cfg->dmp_is_running = FALSE;
+	mldl_cfg->gyro_is_suspended = TRUE;
+	mldl_cfg->accel_is_suspended = TRUE;
+	mldl_cfg->compass_is_suspended = TRUE;
+	mldl_cfg->pressure_is_suspended = TRUE;
+	mldl_cfg->gyro_needs_reset = FALSE;
+	if (mldl_cfg->addr == 0) {
+#ifdef __KERNEL__
+		return ML_ERROR_INVALID_PARAMETER;
+#else
+		mldl_cfg->addr = 0x68;
+#endif
+	}
+
+	/*
+	 * Reset,
+	 * Take the DMP out of sleep, and
+	 * read the product_id, sillicon rev and whoami
+	 */
+#ifdef M_HW
+	result = mpu60xx_pwr_mgmt(mldl_cfg, mlsl_handle,
+				  RESET, WAKE_UP);
+#else
+	result = MLDLPowerMgmtMPU(mldl_cfg, mlsl_handle, RESET, 0, 0, 0, 0);
+#endif
+	ERROR_CHECK(result);
+
+	result = MLDLGetSiliconRev(mldl_cfg, mlsl_handle);
+	ERROR_CHECK(result);
+#ifndef M_HW
+	result = MLSLSerialRead(mlsl_handle, mldl_cfg->addr,
+				MPUREG_PRODUCT_ID, 1,
+				&mldl_cfg->product_id);
+	ERROR_CHECK(result);
+#endif
+
+	/* Get the factory temperature compensation offsets */
+	result = MLSLSerialRead(mlsl_handle, mldl_cfg->addr,
+				MPUREG_XG_OFFS_TC, 1,
+				&mldl_cfg->offset_tc[0]);
+	ERROR_CHECK(result);
+	result = MLSLSerialRead(mlsl_handle, mldl_cfg->addr,
+				MPUREG_YG_OFFS_TC, 1,
+				&mldl_cfg->offset_tc[1]);
+	ERROR_CHECK(result);
+	result = MLSLSerialRead(mlsl_handle, mldl_cfg->addr,
+				MPUREG_ZG_OFFS_TC, 1,
+				&mldl_cfg->offset_tc[2]);
+	ERROR_CHECK(result);
+
+	/* Configure the MPU */
+#ifdef M_HW
+	result = mpu60xx_pwr_mgmt(mldl_cfg, mlsl_handle,
+				  FALSE, SLEEP);
+#else
+	result =
+	    MLDLPowerMgmtMPU(mldl_cfg, mlsl_handle, 0, SLEEP, 0, 0, 0);
+#endif
+	ERROR_CHECK(result);
+
+	if (mldl_cfg->accel && mldl_cfg->accel->init) {
+		result = mldl_cfg->accel->init(accel_handle,
+					       mldl_cfg->accel,
+					       &mldl_cfg->pdata->accel);
+		ERROR_CHECK(result);
+	}
+
+	if (mldl_cfg->compass && mldl_cfg->compass->init) {
+		result = mldl_cfg->compass->init(compass_handle,
+						 mldl_cfg->compass,
+						 &mldl_cfg->pdata->compass);
+		if (ML_SUCCESS != result) {
+			MPL_LOGE("mldl_cfg->compass->init returned %d\n",
+				result);
+			goto out_accel;
+		}
+	}
+	if (mldl_cfg->pressure && mldl_cfg->pressure->init) {
+		result = mldl_cfg->pressure->init(pressure_handle,
+						  mldl_cfg->pressure,
+						  &mldl_cfg->pdata->pressure);
+		if (ML_SUCCESS != result) {
+			MPL_LOGE("mldl_cfg->pressure->init returned %d\n",
+				result);
+			goto out_compass;
+		}
+	}
+
+	mldl_cfg->requested_sensors = ML_THREE_AXIS_GYRO;
+	if (mldl_cfg->accel && mldl_cfg->accel->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_ACCEL;
+
+	if (mldl_cfg->compass && mldl_cfg->compass->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_COMPASS;
+
+	if (mldl_cfg->pressure && mldl_cfg->pressure->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_PRESSURE;
+
+	return result;
+
+out_compass:
+	if (mldl_cfg->compass->init)
+		mldl_cfg->compass->exit(compass_handle,
+				mldl_cfg->compass,
+				&mldl_cfg->pdata->compass);
+out_accel:
+	if (mldl_cfg->accel->init)
+		mldl_cfg->accel->exit(accel_handle,
+				mldl_cfg->accel,
+				&mldl_cfg->pdata->accel);
+	return result;
+
+}
+
+/**
+ * Close the mpu3050 interface
+ *
+ * @param mldl_cfg pointer to the configuration structure
+ * @param mlsl_handle pointer to the serial layer handle
+ *
+ * @return ML_SUCCESS or non-zero error code
+ */
+int mpu3050_close(struct mldl_cfg *mldl_cfg,
+		  void *mlsl_handle,
+		  void *accel_handle,
+		  void *compass_handle,
+		  void *pressure_handle)
+{
+	int result = ML_SUCCESS;
+	int ret_result = ML_SUCCESS;
+
+	if (mldl_cfg->accel && mldl_cfg->accel->exit) {
+		result = mldl_cfg->accel->exit(accel_handle,
+					mldl_cfg->accel,
+					&mldl_cfg->pdata->accel);
+		if (ML_SUCCESS != result)
+			MPL_LOGE("Accel exit failed %d\n", result);
+		ret_result = result;
+	}
+	if (ML_SUCCESS == ret_result)
+		ret_result = result;
+
+	if (mldl_cfg->compass && mldl_cfg->compass->exit) {
+		result = mldl_cfg->compass->exit(compass_handle,
+						mldl_cfg->compass,
+						&mldl_cfg->pdata->compass);
+		if (ML_SUCCESS != result)
+			MPL_LOGE("Compass exit failed %d\n", result);
+	}
+	if (ML_SUCCESS == ret_result)
+		ret_result = result;
+
+	if (mldl_cfg->pressure && mldl_cfg->pressure->exit) {
+		result = mldl_cfg->pressure->exit(pressure_handle,
+						mldl_cfg->pressure,
+						&mldl_cfg->pdata->pressure);
+		if (ML_SUCCESS != result)
+			MPL_LOGE("Pressure exit failed %d\n", result);
+	}
+	if (ML_SUCCESS == ret_result)
+		ret_result = result;
+
+	return ret_result;
+}
+
+/**
+ *  @brief  resume the MPU3050 device and all the other sensor
+ *          devices from their low power state.
+ *  @param  mlsl_handle
+ *              the main file handle to the MPU3050 device.
+ *  @param  accel_handle
+ *              an handle to the accelerometer device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the accelerometer device operates on the same
+ *              primary bus of MPU.
+ *  @param  compass_handle
+ *              an handle to the compass device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the compass device operates on the same
+ *              primary bus of MPU.
+ *  @param  pressure_handle
+ *              an handle to the pressure sensor device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the pressure sensor device operates on the same
+ *              primary bus of MPU.
+ *  @param  resume_accel
+ *              whether resuming the accelerometer device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @param  resume_compass
+ *              whether resuming the compass device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @param  resume_pressure
+ *              whether resuming the pressure sensor device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @return  ML_SUCCESS or a non-zero error code.
+ */
+int mpu3050_resume(struct mldl_cfg *mldl_cfg,
+		   void *gyro_handle,
+		   void *accel_handle,
+		   void *compass_handle,
+		   void *pressure_handle,
+		   bool resume_gyro,
+		   bool resume_accel,
+		   bool resume_compass,
+		   bool resume_pressure)
+{
+	int result = ML_SUCCESS;
+
+#ifdef CONFIG_SENSORS_MPU_DEBUG
+	mpu_print_cfg(mldl_cfg);
+#endif
+
+	if (resume_accel &&
+	    ((!mldl_cfg->accel) || (!mldl_cfg->accel->resume)))
+		return ML_ERROR_INVALID_PARAMETER;
+	if (resume_compass &&
+	    ((!mldl_cfg->compass) || (!mldl_cfg->compass->resume)))
+		return ML_ERROR_INVALID_PARAMETER;
+	if (resume_pressure &&
+	    ((!mldl_cfg->pressure) || (!mldl_cfg->pressure->resume)))
+		return ML_ERROR_INVALID_PARAMETER;
+
+	if (resume_gyro && mldl_cfg->gyro_is_suspended) {
+		result = gyro_resume(mldl_cfg, gyro_handle);
+		ERROR_CHECK(result);
+	}
+
+	if (resume_accel && mldl_cfg->accel_is_suspended) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->accel.bus) {
+			result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, TRUE);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->accel->resume(accel_handle,
+						 mldl_cfg->accel,
+						 &mldl_cfg->pdata->accel);
+		ERROR_CHECK(result);
+		mldl_cfg->accel_is_suspended = FALSE;
+
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->accel.bus) {
+			result = mpu_set_slave(mldl_cfg,
+					       gyro_handle,
+					       mldl_cfg->accel,
+					       &mldl_cfg->pdata->accel);
+			ERROR_CHECK(result);
+		}
+	}
+
+	if (resume_compass && mldl_cfg->compass_is_suspended) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->compass.bus) {
+			result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, TRUE);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->compass->resume(compass_handle,
+						   mldl_cfg->compass,
+						   &mldl_cfg->pdata->
+						   compass);
+		ERROR_CHECK(result);
+		mldl_cfg->compass_is_suspended = FALSE;
+
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->compass.bus) {
+			result = mpu_set_slave(mldl_cfg,
+					       gyro_handle,
+					       mldl_cfg->compass,
+					       &mldl_cfg->pdata->compass);
+			ERROR_CHECK(result);
+		}
+	}
+
+	if (resume_pressure && mldl_cfg->pressure_is_suspended) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->pressure.bus) {
+			result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, TRUE);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->pressure->resume(pressure_handle,
+						    mldl_cfg->pressure,
+						    &mldl_cfg->pdata->
+						    pressure);
+		ERROR_CHECK(result);
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->pressure.bus) {
+			result = mpu_set_slave(mldl_cfg,
+					       gyro_handle,
+					       mldl_cfg->pressure,
+					       &mldl_cfg->pdata->pressure);
+			ERROR_CHECK(result);
+		}
+		mldl_cfg->pressure_is_suspended = FALSE;
+	}
+
+	/* Now start */
+	if (resume_gyro) {
+		result = dmp_start(mldl_cfg, gyro_handle);
+		ERROR_CHECK(result);
+	}
+
+	return result;
+}
+
+
+/**
+ *  @brief  suspend the MPU3050 device and all the other sensor
+ *          devices into their low power state.
+ *  @param  gyro_handle
+ *              the main file handle to the MPU3050 device.
+ *  @param  accel_handle
+ *              an handle to the accelerometer device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the accelerometer device operates on the same
+ *              primary bus of MPU.
+ *  @param  compass_handle
+ *              an handle to the compass device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the compass device operates on the same
+ *              primary bus of MPU.
+ *  @param  pressure_handle
+ *              an handle to the pressure sensor device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the pressure sensor device operates on the same
+ *              primary bus of MPU.
+ *  @param  accel
+ *              whether suspending the accelerometer device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @param  compass
+ *              whether suspending the compass device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @param  pressure
+ *              whether suspending the pressure sensor device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @return  ML_SUCCESS or a non-zero error code.
+ */
+int mpu3050_suspend(struct mldl_cfg *mldl_cfg,
+		    void *gyro_handle,
+		    void *accel_handle,
+		    void *compass_handle,
+		    void *pressure_handle,
+		    bool suspend_gyro,
+		    bool suspend_accel,
+		    bool suspend_compass,
+		    bool suspend_pressure)
+{
+	int result = ML_SUCCESS;
+
+	if (suspend_gyro && !mldl_cfg->gyro_is_suspended) {
+#ifdef M_HW
+		/* This puts the bus into bypass mode */
+		result = MLDLSetI2CBypass(mldl_cfg, gyro_handle, 1);
+		ERROR_CHECK(result);
+		result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, 0, SLEEP);
+#else
+		result = MLDLPowerMgmtMPU(mldl_cfg, gyro_handle,
+					  0, SLEEP, 0, 0, 0);
+#endif
+		ERROR_CHECK(result);
+	}
+
+	if (!mldl_cfg->accel_is_suspended && suspend_accel &&
+	    mldl_cfg->accel && mldl_cfg->accel->suspend) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->accel.bus) {
+			result = mpu_set_slave(mldl_cfg, gyro_handle,
+					       NULL, NULL);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->accel->suspend(accel_handle,
+						  mldl_cfg->accel,
+						  &mldl_cfg->pdata->accel);
+		ERROR_CHECK(result);
+		mldl_cfg->accel_is_suspended = TRUE;
+	}
+
+	if (!mldl_cfg->compass_is_suspended && suspend_compass &&
+	    mldl_cfg->compass && mldl_cfg->compass->suspend) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->compass.bus) {
+			result = mpu_set_slave(mldl_cfg, gyro_handle,
+					       NULL, NULL);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->compass->suspend(compass_handle,
+						    mldl_cfg->compass,
+						    &mldl_cfg->
+						    pdata->compass);
+		ERROR_CHECK(result);
+		mldl_cfg->compass_is_suspended = TRUE;
+	}
+
+	if (!mldl_cfg->pressure_is_suspended && suspend_pressure &&
+	    mldl_cfg->pressure && mldl_cfg->pressure->suspend) {
+		if (!mldl_cfg->gyro_is_suspended &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata->pressure.bus) {
+			result = mpu_set_slave(mldl_cfg, gyro_handle,
+					       NULL, NULL);
+			ERROR_CHECK(result);
+		}
+		result = mldl_cfg->pressure->suspend(pressure_handle,
+						    mldl_cfg->pressure,
+						    &mldl_cfg->
+						    pdata->pressure);
+		ERROR_CHECK(result);
+		mldl_cfg->pressure_is_suspended = TRUE;
+	}
+	return result;
+}
+
+
+/**
+ *  @brief  read raw sensor data from the accelerometer device
+ *          in use.
+ *  @param  data
+ *              a buffer to store the raw sensor data.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+int mpu3050_read_accel(struct mldl_cfg *mldl_cfg,
+		       void *accel_handle, unsigned char *data)
+{
+	if (NULL != mldl_cfg->accel && NULL != mldl_cfg->accel->read)
+		return mldl_cfg->accel->read(accel_handle,
+					     mldl_cfg->accel,
+					     &mldl_cfg->pdata->accel,
+					     data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+/**
+ *  @brief  read raw sensor data from the compass device
+ *          in use.
+ *  @param  data
+ *              a buffer to store the raw sensor data.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+int mpu3050_read_compass(struct mldl_cfg *mldl_cfg,
+			 void *compass_handle, unsigned char *data)
+{
+	if (NULL != mldl_cfg->compass && NULL != mldl_cfg->compass->read)
+		return mldl_cfg->compass->read(compass_handle,
+					       mldl_cfg->compass,
+					       &mldl_cfg->pdata->compass,
+					       data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+/**
+ *  @brief  read raw sensor data from the pressure device
+ *          in use.
+ *  @param  data
+ *              a buffer to store the raw sensor data.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+int mpu3050_read_pressure(struct mldl_cfg *mldl_cfg,
+			 void *pressure_handle, unsigned char *data)
+{
+	if (NULL != mldl_cfg->pressure && NULL != mldl_cfg->pressure->read)
+		return mldl_cfg->pressure->read(pressure_handle,
+						mldl_cfg->pressure,
+						&mldl_cfg->pdata->pressure,
+						data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+int mpu3050_config_accel(struct mldl_cfg *mldl_cfg,
+			void *accel_handle,
+			struct ext_slave_config *data)
+{
+	if (NULL != mldl_cfg->accel && NULL != mldl_cfg->accel->config)
+		return mldl_cfg->accel->config(accel_handle,
+					       mldl_cfg->accel,
+					       &mldl_cfg->pdata->accel,
+					       data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+
+}
+
+int mpu3050_config_compass(struct mldl_cfg *mldl_cfg,
+			void *compass_handle,
+			struct ext_slave_config *data)
+{
+	if (NULL != mldl_cfg->compass && NULL != mldl_cfg->compass->config)
+		return mldl_cfg->compass->config(compass_handle,
+						 mldl_cfg->compass,
+						 &mldl_cfg->pdata->compass,
+						 data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+
+}
+
+int mpu3050_config_pressure(struct mldl_cfg *mldl_cfg,
+			void *pressure_handle,
+			struct ext_slave_config *data)
+{
+	if (NULL != mldl_cfg->pressure && NULL != mldl_cfg->pressure->config)
+		return mldl_cfg->pressure->config(pressure_handle,
+						  mldl_cfg->pressure,
+						  &mldl_cfg->pdata->pressure,
+						  data);
+	else
+		return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+
+/**
+ *@}
+ */
Index: Kernel/drivers/sensors/mpu3050/mldl_cfg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mldl_cfg.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,175 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+/**
+ *  @addtogroup MLDL
+ *
+ *  @{
+ *      @file   mldl_cfg.h
+ *      @brief  The Motion Library Driver Layer Configuration header file.
+ */
+
+#ifndef __MLDL_CFG_H__
+#define __MLDL_CFG_H__
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#include "mlsl.h"
+#include "mpu.h"
+
+/* --------------------- */
+/* -    Defines.       - */
+/* --------------------- */
+
+    /*************************************************************************/
+    /*  Sensors                                                              */
+    /*************************************************************************/
+
+#define ML_X_GYRO			(0x0001)
+#define ML_Y_GYRO			(0x0002)
+#define ML_Z_GYRO			(0x0004)
+#define ML_DMP_PROCESSOR		(0x0008)
+
+#define ML_X_ACCEL			(0x0010)
+#define ML_Y_ACCEL			(0x0020)
+#define ML_Z_ACCEL			(0x0040)
+
+#define ML_X_COMPASS			(0x0080)
+#define ML_Y_COMPASS			(0x0100)
+#define ML_Z_COMPASS			(0x0200)
+
+#define ML_X_PRESSURE			(0x0300)
+#define ML_Y_PRESSURE			(0x0800)
+#define ML_Z_PRESSURE			(0x1000)
+
+#define ML_TEMPERATURE			(0x2000)
+#define ML_TIME				(0x4000)
+
+#define ML_THREE_AXIS_GYRO		(0x000F)
+#define ML_THREE_AXIS_ACCEL		(0x0070)
+#define ML_THREE_AXIS_COMPASS		(0x0380)
+#define ML_THREE_AXIS_PRESSURE		(0x1C00)
+
+#define ML_FIVE_AXIS			(0x007B)
+#define ML_SIX_AXIS_GYRO_ACCEL		(0x007F)
+#define ML_SIX_AXIS_ACCEL_COMPASS	(0x03F0)
+#define ML_NINE_AXIS			(0x03FF)
+#define ML_ALL_SENSORS			(0x7FFF)
+
+#define SAMPLING_RATE_HZ(mldl_cfg)					\
+	((((((mldl_cfg)->lpf) == 0) || (((mldl_cfg)->lpf) == 7))	\
+		? (8000)						\
+		: (1000))						\
+		/ ((mldl_cfg)->divider + 1))
+
+#define SAMPLING_PERIOD_US(mldl_cfg)					\
+	((1000000L * ((mldl_cfg)->divider + 1)) /			\
+	(((((mldl_cfg)->lpf) == 0) || (((mldl_cfg)->lpf) == 7))		\
+		? (8000)						\
+		: (1000)))
+/* --------------------- */
+/* -    Variables.     - */
+/* --------------------- */
+
+/* Platform data for the MPU */
+struct mldl_cfg {
+	/* MPU related configuration */
+	unsigned long requested_sensors;
+	unsigned char addr;
+	unsigned char int_config;
+	unsigned char ext_sync;
+	unsigned char full_scale;
+	unsigned char lpf;
+	unsigned char clk_src;
+	unsigned char divider;
+	unsigned char dmp_enable;
+	unsigned char fifo_enable;
+	unsigned char dmp_cfg1;
+	unsigned char dmp_cfg2;
+	unsigned char gyro_power;
+	unsigned char offset_tc[MPU_NUM_AXES];
+	unsigned short offset[MPU_NUM_AXES];
+	unsigned char ram[MPU_MEM_NUM_RAM_BANKS][MPU_MEM_BANK_SIZE];
+
+	/* MPU Related stored status and info */
+	unsigned char silicon_revision;
+	unsigned char product_id;
+	unsigned short trim;
+
+	/* Driver/Kernel related state information */
+	int gyro_is_bypassed;
+	int dmp_is_running;
+	int gyro_is_suspended;
+	int accel_is_suspended;
+	int compass_is_suspended;
+	int pressure_is_suspended;
+	int gyro_needs_reset;
+
+	/* Slave related information */
+	struct ext_slave_descr *accel;
+	struct ext_slave_descr *compass;
+	struct ext_slave_descr *pressure;
+
+	/* Platform Data */
+	struct mpu3050_platform_data *pdata;
+};
+
+
+int mpu3050_open(struct mldl_cfg *mldl_cfg,
+		 void *mlsl_handle,
+		 void *accel_handle,
+		 void *compass_handle,
+		 void *pressure_handle);
+int mpu3050_close(struct mldl_cfg *mldl_cfg,
+		  void *mlsl_handle,
+		  void *accel_handle,
+		  void *compass_handle,
+		  void *pressure_handle);
+int mpu3050_resume(struct mldl_cfg *mldl_cfg,
+		   void *gyro_handle,
+		   void *accel_handle,
+		   void *compass_handle,
+		   void *pressure_handle,
+		   bool resume_gyro,
+		   bool resume_accel,
+		   bool resume_compass,
+		   bool resume_pressure);
+int mpu3050_suspend(struct mldl_cfg *mldl_cfg,
+		    void *gyro_handle,
+		    void *accel_handle,
+		    void *compass_handle,
+		    void *pressure_handle,
+		    bool suspend_gyro,
+		    bool suspend_accel,
+		    bool suspend_compass,
+		    bool suspend_pressure);
+int mpu3050_read_accel(struct mldl_cfg *mldl_cfg,
+		       void *accel_handle,
+		       unsigned char *data);
+int mpu3050_read_compass(struct mldl_cfg *mldl_cfg,
+			 void *compass_handle,
+			 unsigned char *data);
+int mpu3050_read_pressure(struct mldl_cfg *mldl_cfg, void *mlsl_handle,
+			  unsigned char *data);
+
+int mpu3050_config_accel(struct mldl_cfg *mldl_cfg,
+			 void *accel_handle,
+			 struct ext_slave_config *data);
+int mpu3050_config_compass(struct mldl_cfg *mldl_cfg,
+			   void *compass_handle,
+			   struct ext_slave_config *data);
+int mpu3050_config_pressure(struct mldl_cfg *mldl_cfg,
+			    void *pressure_handle,
+			    struct ext_slave_config *data);
+
+
+#endif				/* __MLDL_CFG_H__ */
+
+/**
+ *@}
+ */
Index: Kernel/drivers/sensors/mpu3050/mlos-kernel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mlos-kernel.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,76 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+/**
+ * @defgroup
+ * @brief
+ *
+ * @{
+ * @file     mlos-kernel.c
+ * @brief
+ *
+ *
+ */
+
+#include "mlos.h"
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+void *MLOSMalloc(unsigned int numBytes)
+{
+	return kmalloc(numBytes, GFP_KERNEL);
+}
+
+tMLError MLOSFree(void *ptr)
+{
+	kfree(ptr);
+	return ML_SUCCESS;
+}
+
+tMLError MLOSCreateMutex(HANDLE *mutex)
+{
+	/* @todo implement if needed */
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+tMLError MLOSLockMutex(HANDLE mutex)
+{
+	/* @todo implement if needed */
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+tMLError MLOSUnlockMutex(HANDLE mutex)
+{
+	/* @todo implement if needed */
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+tMLError MLOSDestroyMutex(HANDLE handle)
+{
+	/* @todo implement if needed */
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+FILE *MLOSFOpen(char *filename)
+{
+	/* @todo implement if needed */
+	return NULL;
+}
+
+void MLOSFClose(FILE *fp)
+{
+	/* @todo implement if needed */
+}
+
+void MLOSSleep(int mSecs)
+{
+	msleep(mSecs);
+}
+
+unsigned long MLOSGetTickCount(void)
+{
+	/* @todo implement if needed */
+	return ML_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
Index: Kernel/drivers/sensors/mpu3050/mlos.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mlos.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,60 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef _MLOS_H
+#define _MLOS_H
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#endif
+
+#include "mltypes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	/* ------------ */
+	/* - Defines. - */
+	/* ------------ */
+
+	/* - MLOSCreateFile defines. - */
+
+#define MLOS_GENERIC_READ         ((unsigned int)0x80000000)
+#define MLOS_GENERIC_WRITE        ((unsigned int)0x40000000)
+#define MLOS_FILE_SHARE_READ      ((unsigned int)0x00000001)
+#define MLOS_FILE_SHARE_WRITE     ((unsigned int)0x00000002)
+#define MLOS_OPEN_EXISTING        ((unsigned int)0x00000003)
+
+	/* ---------- */
+	/* - Enums. - */
+	/* ---------- */
+
+	/* --------------- */
+	/* - Structures. - */
+	/* --------------- */
+
+	/* --------------------- */
+	/* - Function p-types. - */
+	/* --------------------- */
+
+	void *MLOSMalloc(unsigned int numBytes);
+	tMLError MLOSFree(void *ptr);
+	tMLError MLOSCreateMutex(HANDLE *mutex);
+	tMLError MLOSLockMutex(HANDLE mutex);
+	tMLError MLOSUnlockMutex(HANDLE mutex);
+	FILE *MLOSFOpen(char *filename);
+	void MLOSFClose(FILE *fp);
+
+	tMLError MLOSDestroyMutex(HANDLE handle);
+
+	void MLOSSleep(int mSecs);
+	unsigned long MLOSGetTickCount(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* _MLOS_H */
Index: Kernel/drivers/sensors/mpu3050/mlsl-kernel.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mlsl-kernel.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,318 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#include "mlsl.h"
+#include "mpu-i2c.h"
+
+/* ------------ */
+/* - Defines. - */
+/* ------------ */
+
+/* ---------------------- */
+/* - Types definitions. - */
+/* ---------------------- */
+
+/* --------------------- */
+/* - Function p-types. - */
+/* --------------------- */
+
+/**
+ *  @brief  used to open the I2C or SPI serial port.
+ *          This port is used to send and receive data to the MPU device.
+ *  @param  portNum
+ *              The COM port number associated with the device in use.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+tMLError MLSLSerialOpen(char const *port, void **sl_handle)
+{
+	return ML_SUCCESS;
+}
+
+/**
+ *  @brief  used to reset any buffering the driver may be doing
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+tMLError MLSLSerialReset(void *sl_handle)
+{
+	return ML_SUCCESS;
+}
+
+/**
+ *  @brief  used to close the I2C or SPI serial port.
+ *          This port is used to send and receive data to the MPU device.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+tMLError MLSLSerialClose(void *sl_handle)
+{
+	return ML_SUCCESS;
+}
+
+/**
+ *  @brief  used to read a single byte of data.
+ *          This should be sent by I2C or SPI.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  registerAddr    Register address to read.
+ *  @param  data            Single byte of data to read.
+ *
+ *  @return ML_SUCCESS if the command is successful, an error code otherwise.
+ */
+tMLError MLSLSerialWriteSingle(void *sl_handle,
+			       unsigned char slaveAddr,
+			       unsigned char registerAddr,
+			       unsigned char data)
+{
+	return sensor_i2c_write_register((struct i2c_adapter *) sl_handle,
+					 slaveAddr, registerAddr, data);
+}
+
+
+/**
+ *  @brief  used to write multiple bytes of data from registers.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  registerAddr    Register address to write.
+ *  @param  length          Length of burst of data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+tMLError MLSLSerialWrite(void *sl_handle,
+			 unsigned char slaveAddr,
+			 unsigned short length, unsigned char const *data)
+{
+	tMLError result;
+	const unsigned short dataLength = length - 1;
+	const unsigned char startRegAddr = data[0];
+	unsigned char i2cWrite[SERIAL_MAX_TRANSFER_SIZE + 1];
+	unsigned short bytesWritten = 0;
+
+	while (bytesWritten < dataLength) {
+		unsigned short thisLen = min(SERIAL_MAX_TRANSFER_SIZE,
+					     dataLength - bytesWritten);
+		if (bytesWritten == 0) {
+			result = sensor_i2c_write((struct i2c_adapter *)
+						  sl_handle, slaveAddr,
+						  1 + thisLen, data);
+		} else {
+			/* manually increment register addr between chunks */
+			i2cWrite[0] = startRegAddr + bytesWritten;
+			memcpy(&i2cWrite[1], &data[1 + bytesWritten],
+			       thisLen);
+			result = sensor_i2c_write((struct i2c_adapter *)
+						  sl_handle, slaveAddr,
+						  1 + thisLen, i2cWrite);
+		}
+		if (ML_SUCCESS != result)
+			return result;
+		bytesWritten += thisLen;
+	}
+	return ML_SUCCESS;
+}
+
+
+/**
+ *  @brief  used to read multiple bytes of data from registers.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  registerAddr    Register address to read.
+ *  @param  length          Length of burst of data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return Zero if successful; an error code otherwise
+ */
+tMLError MLSLSerialRead(void *sl_handle,
+			unsigned char slaveAddr,
+			unsigned char registerAddr,
+			unsigned short length, unsigned char *data)
+{
+	tMLError result;
+	unsigned short bytesRead = 0;
+
+	if (registerAddr == MPUREG_FIFO_R_W
+	    || registerAddr == MPUREG_MEM_R_W) {
+		return ML_ERROR_INVALID_PARAMETER;
+	}
+	while (bytesRead < length) {
+		unsigned short thisLen =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytesRead);
+		result =
+		    sensor_i2c_read((struct i2c_adapter *) sl_handle,
+				    slaveAddr, registerAddr + bytesRead,
+				    thisLen, &data[bytesRead]);
+		if (ML_SUCCESS != result)
+			return result;
+		bytesRead += thisLen;
+	}
+	return ML_SUCCESS;
+}
+
+
+/**
+ *  @brief  used to write multiple bytes of data to the memory.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  memAddr         The location in the memory to write to.
+ *  @param  length          Length of burst data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return Zero if successful; an error code otherwise
+ */
+tMLError MLSLSerialWriteMem(void *sl_handle,
+			    unsigned char slaveAddr,
+			    unsigned short memAddr,
+			    unsigned short length,
+			    unsigned char const *data)
+{
+	tMLError result;
+	unsigned short bytesWritten = 0;
+
+	if ((memAddr & 0xFF) + length > MPU_MEM_BANK_SIZE) {
+		printk
+		    ("memory read length (%d B) extends beyond its limits (%d) "
+		     "if started at location %d\n", length,
+		     MPU_MEM_BANK_SIZE, memAddr & 0xFF);
+		return ML_ERROR_INVALID_PARAMETER;
+	}
+	while (bytesWritten < length) {
+		unsigned short thisLen =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytesWritten);
+		result =
+		    mpu_memory_write((struct i2c_adapter *) sl_handle,
+				     slaveAddr, memAddr + bytesWritten,
+				     thisLen, &data[bytesWritten]);
+		if (ML_SUCCESS != result)
+			return result;
+		bytesWritten += thisLen;
+	}
+	return ML_SUCCESS;
+}
+
+
+/**
+ *  @brief  used to read multiple bytes of data from the memory.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  memAddr         The location in the memory to read from.
+ *  @param  length          Length of burst data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return Zero if successful; an error code otherwise
+ */
+tMLError MLSLSerialReadMem(void *sl_handle,
+			   unsigned char slaveAddr,
+			   unsigned short memAddr,
+			   unsigned short length, unsigned char *data)
+{
+	tMLError result;
+	unsigned short bytesRead = 0;
+
+	if ((memAddr & 0xFF) + length > MPU_MEM_BANK_SIZE) {
+		printk
+		    ("memory read length (%d B) extends beyond its limits (%d) "
+		     "if started at location %d\n", length,
+		     MPU_MEM_BANK_SIZE, memAddr & 0xFF);
+		return ML_ERROR_INVALID_PARAMETER;
+	}
+	while (bytesRead < length) {
+		unsigned short thisLen =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytesRead);
+		result =
+		    mpu_memory_read((struct i2c_adapter *) sl_handle,
+				    slaveAddr, memAddr + bytesRead,
+				    thisLen, &data[bytesRead]);
+		if (ML_SUCCESS != result)
+			return result;
+		bytesRead += thisLen;
+	}
+	return ML_SUCCESS;
+}
+
+
+/**
+ *  @brief  used to write multiple bytes of data to the fifo.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  length          Length of burst of data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return Zero if successful; an error code otherwise
+ */
+tMLError MLSLSerialWriteFifo(void *sl_handle,
+			     unsigned char slaveAddr,
+			     unsigned short length,
+			     unsigned char const *data)
+{
+	tMLError result;
+	unsigned char i2cWrite[SERIAL_MAX_TRANSFER_SIZE + 1];
+	unsigned short bytesWritten = 0;
+
+	if (length > FIFO_HW_SIZE) {
+		printk(KERN_ERR
+		       "maximum fifo write length is %d\n", FIFO_HW_SIZE);
+		return ML_ERROR_INVALID_PARAMETER;
+	}
+	while (bytesWritten < length) {
+		unsigned short thisLen =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytesWritten);
+		i2cWrite[0] = MPUREG_FIFO_R_W;
+		memcpy(&i2cWrite[1], &data[bytesWritten], thisLen);
+		result = sensor_i2c_write((struct i2c_adapter *) sl_handle,
+					  slaveAddr, thisLen + 1,
+					  i2cWrite);
+		if (ML_SUCCESS != result)
+			return result;
+		bytesWritten += thisLen;
+	}
+	return ML_SUCCESS;
+}
+
+
+/**
+ *  @brief  used to read multiple bytes of data from the fifo.
+ *          This should be sent by I2C.
+ *
+ *  @param  slaveAddr       I2C slave address of device.
+ *  @param  length          Length of burst of data.
+ *  @param  data            Pointer to block of data.
+ *
+ *  @return Zero if successful; an error code otherwise
+ */
+tMLError MLSLSerialReadFifo(void *sl_handle,
+			    unsigned char slaveAddr,
+			    unsigned short length, unsigned char *data)
+{
+	tMLError result;
+	unsigned short bytesRead = 0;
+
+	if (length > FIFO_HW_SIZE) {
+		printk(KERN_ERR
+		       "maximum fifo read length is %d\n", FIFO_HW_SIZE);
+		return ML_ERROR_INVALID_PARAMETER;
+	}
+	while (bytesRead < length) {
+		unsigned short thisLen =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytesRead);
+		result =
+		    sensor_i2c_read((struct i2c_adapter *) sl_handle,
+				    slaveAddr, MPUREG_FIFO_R_W, thisLen,
+				    &data[bytesRead]);
+		if (ML_SUCCESS != result)
+			return result;
+		bytesRead += thisLen;
+	}
+
+	return ML_SUCCESS;
+}
+
+/**
+ *  @}
+ */
Index: Kernel/drivers/sensors/mpu3050/mlsl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mlsl.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,90 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef __MSSL_H__
+#define __MSSL_H__
+
+#include "mltypes.h"
+#include "mpu.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ------------ */
+/* - Defines. - */
+/* ------------ */
+
+/*
+ * NOTE : to properly support Yamaha compass reads,
+ * the max transfer size should be at least 9 B.
+ * Length in bytes, typically a power of 2 >= 2
+ */
+#define SERIAL_MAX_TRANSFER_SIZE 128
+
+/* ---------------------- */
+/* - Types definitions. - */
+/* ---------------------- */
+
+/* --------------------- */
+/* - Function p-types. - */
+/* --------------------- */
+
+	tMLError MLSLSerialOpen(char const *port,
+				void **sl_handle);
+	tMLError MLSLSerialReset(void *sl_handle);
+	tMLError MLSLSerialClose(void *sl_handle);
+
+	tMLError MLSLSerialWriteSingle(void *sl_handle,
+				       unsigned char slaveAddr,
+				       unsigned char registerAddr,
+				       unsigned char data);
+
+	tMLError MLSLSerialRead(void *sl_handle,
+				unsigned char slaveAddr,
+				unsigned char registerAddr,
+				unsigned short length,
+				unsigned char *data);
+
+	tMLError MLSLSerialWrite(void *sl_handle,
+				 unsigned char slaveAddr,
+				 unsigned short length,
+				 unsigned char const *data);
+
+	tMLError MLSLSerialReadMem(void *sl_handle,
+				   unsigned char slaveAddr,
+				   unsigned short memAddr,
+				   unsigned short length,
+				   unsigned char *data);
+
+	tMLError MLSLSerialWriteMem(void *sl_handle,
+				    unsigned char slaveAddr,
+				    unsigned short memAddr,
+				    unsigned short length,
+				    unsigned char const *data);
+
+	tMLError MLSLSerialReadFifo(void *sl_handle,
+				    unsigned char slaveAddr,
+				    unsigned short length,
+				    unsigned char *data);
+
+	tMLError MLSLSerialWriteFifo(void *sl_handle,
+				     unsigned char slaveAddr,
+				     unsigned short length,
+				     unsigned char const *data);
+
+	tMLError MLSLWriteCal(unsigned char *cal, unsigned int len);
+	tMLError MLSLReadCal(unsigned char *cal, unsigned int len);
+	tMLError MLSLGetCalLength(unsigned int *len);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+#endif				/* MLSL_H */
Index: Kernel/drivers/sensors/mpu3050/mltypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mltypes.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,212 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+/******************************************************************************
+ *
+ * $Id: mltypes.h 4598 2011-01-25 19:33:13Z prao $
+ *
+ *****************************************************************************/
+
+/**
+ *  @defgroup MLERROR
+ *  @brief  Motion Library - Error definitions.
+ *          Definition of the error codes used within the MPL and returned
+ *          to the user.
+ *          Every function tries to return a meaningful error code basing
+ *          on the occuring error condition. The error code is numeric.
+ *
+ *          The available error codes and their associated values are:
+ *          - (0)       ML_SUCCESS
+ *          - (1)       ML_ERROR
+ *          - (2)       ML_ERROR_INVALID_PARAMETER
+ *          - (3)       ML_ERROR_FEATURE_NOT_ENABLED
+ *          - (4)       ML_ERROR_FEATURE_NOT_IMPLEMENTED
+ *          - (6)       ML_ERROR_DMP_NOT_STARTED
+ *          - (7)       ML_ERROR_DMP_STARTED
+ *          - (8)       ML_ERROR_NOT_OPENED
+ *          - (9)       ML_ERROR_OPENED
+ *          - (10)      ML_ERROR_INVALID_MODULE
+ *          - (11)      ML_ERROR_MEMORY_EXAUSTED
+ *          - (12)      ML_ERROR_DIVIDE_BY_ZERO
+ *          - (13)      ML_ERROR_ASSERTION_FAILURE
+ *          - (14)      ML_ERROR_FILE_OPEN
+ *          - (15)      ML_ERROR_FILE_READ
+ *          - (16)      ML_ERROR_FILE_WRITE
+ *          - (20)      ML_ERROR_SERIAL_CLOSED
+ *          - (21)      ML_ERROR_SERIAL_OPEN_ERROR
+ *          - (22)      ML_ERROR_SERIAL_READ
+ *          - (23)      ML_ERROR_SERIAL_WRITE
+ *          - (24)      ML_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED
+ *          - (25)      ML_ERROR_SM_TRANSITION
+ *          - (26)      ML_ERROR_SM_IMPROPER_STATE
+ *          - (30)      ML_ERROR_FIFO_OVERFLOW
+ *          - (31)      ML_ERROR_FIFO_FOOTER
+ *          - (32)      ML_ERROR_FIFO_READ_COUNT
+ *          - (33)      ML_ERROR_FIFO_READ_DATA
+ *          - (40)      ML_ERROR_MEMORY_SET
+ *          - (50)      ML_ERROR_LOG_MEMORY_ERROR
+ *          - (51)      ML_ERROR_LOG_OUTPUT_ERROR
+ *          - (60)      ML_ERROR_OS_BAD_PTR
+ *          - (61)      ML_ERROR_OS_BAD_HANDLE
+ *          - (62)      ML_ERROR_OS_CREATE_FAILED
+ *          - (63)      ML_ERROR_OS_LOCK_FAILED
+ *          - (70)      ML_ERROR_COMPASS_DATA_OVERFLOW
+ *          - (71)      ML_ERROR_COMPASS_DATA_UNDERFLOW
+ *          - (72)      ML_ERROR_COMPASS_DATA_NOT_READY
+ *          - (73)      ML_ERROR_COMPASS_DATA_ERROR
+ *          - (75)      ML_ERROR_CALIBRATION_LOAD
+ *          - (76)      ML_ERROR_CALIBRATION_STORE
+ *          - (77)      ML_ERROR_CALIBRATION_LEN
+ *          - (78)      ML_ERROR_CALIBRATION_CHECKSUM
+ *
+ *  @{
+ *      @file mltypes.h
+ *  @}
+ */
+
+#ifndef MLTYPES_H
+#define MLTYPES_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include "stdint_invensense.h"
+#endif
+#include "log.h"
+
+/*---------------------------
+    ML Types
+---------------------------*/
+
+/**
+ * @struct tMLError The MPL Error Code return type.
+ *
+ * @code
+ *      typedef unsigned char tMLError;
+ * @endcode
+ */
+typedef unsigned char tMLError;
+
+#if defined(LINUX) || defined(__KERNEL__)
+typedef unsigned int HANDLE;
+#endif
+
+#ifdef __KERNEL__
+typedef HANDLE FILE;
+#endif
+
+#ifndef __cplusplus
+#ifndef __KERNEL__
+typedef int_fast8_t bool;
+#endif
+#endif
+
+/*---------------------------
+    ML Defines
+---------------------------*/
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+/* Dimension of an array */
+#ifndef DIM
+#define DIM(array) (sizeof(array)/sizeof((array)[0]))
+#endif
+
+/* - ML Errors. - */
+#define ERROR_NAME(x)   (#x)
+#define ERROR_CHECK(x)                                                  \
+	{								\
+		if (ML_SUCCESS != x) {					\
+			MPL_LOGE("%s|%s|%d returning %d\n",		\
+				__FILE__, __func__, __LINE__, x);	\
+			return x;					\
+		}							\
+	}
+
+#define ERROR_CHECK_FIRST(first, x)                                     \
+	{ if (ML_SUCCESS == first) first = x; }
+
+#define ML_SUCCESS                       (0)
+/* Generic Error code.  Proprietary Error Codes only */
+#define ML_ERROR                         (1)
+
+/* Compatibility and other generic error codes */
+#define ML_ERROR_INVALID_PARAMETER       (2)
+#define ML_ERROR_FEATURE_NOT_ENABLED     (3)
+#define ML_ERROR_FEATURE_NOT_IMPLEMENTED (4)
+#define ML_ERROR_DMP_NOT_STARTED         (6)
+#define ML_ERROR_DMP_STARTED             (7)
+#define ML_ERROR_NOT_OPENED              (8)
+#define ML_ERROR_OPENED                  (9)
+#define ML_ERROR_INVALID_MODULE         (10)
+#define ML_ERROR_MEMORY_EXAUSTED        (11)
+#define ML_ERROR_DIVIDE_BY_ZERO         (12)
+#define ML_ERROR_ASSERTION_FAILURE      (13)
+#define ML_ERROR_FILE_OPEN              (14)
+#define ML_ERROR_FILE_READ              (15)
+#define ML_ERROR_FILE_WRITE             (16)
+#define ML_ERROR_INVALID_CONFIGURATION  (17)
+
+/* Serial Communication */
+#define ML_ERROR_SERIAL_CLOSED          (20)
+#define ML_ERROR_SERIAL_OPEN_ERROR      (21)
+#define ML_ERROR_SERIAL_READ            (22)
+#define ML_ERROR_SERIAL_WRITE           (23)
+#define ML_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED  (24)
+
+/* SM = State Machine */
+#define ML_ERROR_SM_TRANSITION          (25)
+#define ML_ERROR_SM_IMPROPER_STATE      (26)
+
+/* Fifo */
+#define ML_ERROR_FIFO_OVERFLOW          (30)
+#define ML_ERROR_FIFO_FOOTER            (31)
+#define ML_ERROR_FIFO_READ_COUNT        (32)
+#define ML_ERROR_FIFO_READ_DATA         (33)
+
+/* Memory & Registers, Set & Get */
+#define ML_ERROR_MEMORY_SET             (40)
+
+#define ML_ERROR_LOG_MEMORY_ERROR       (50)
+#define ML_ERROR_LOG_OUTPUT_ERROR       (51)
+
+/* OS interface errors */
+#define ML_ERROR_OS_BAD_PTR             (60)
+#define ML_ERROR_OS_BAD_HANDLE          (61)
+#define ML_ERROR_OS_CREATE_FAILED       (62)
+#define ML_ERROR_OS_LOCK_FAILED         (63)
+
+/* Compass errors */
+#define ML_ERROR_COMPASS_DATA_OVERFLOW  (70)
+#define ML_ERROR_COMPASS_DATA_UNDERFLOW (71)
+#define ML_ERROR_COMPASS_DATA_NOT_READY (72)
+#define ML_ERROR_COMPASS_DATA_ERROR     (73)
+
+/* Load/Store calibration */
+#define ML_ERROR_CALIBRATION_LOAD       (75)
+#define ML_ERROR_CALIBRATION_STORE      (76)
+#define ML_ERROR_CALIBRATION_LEN        (77)
+#define ML_ERROR_CALIBRATION_CHECKSUM   (78)
+
+/* For Linux coding compliance */
+#ifndef __KERNEL__
+#define EXPORT_SYMBOL(x)
+#endif
+
+/*---------------------------
+    p-Types
+---------------------------*/
+
+#endif				/* MLTYPES_H */
Index: Kernel/drivers/sensors/mpu3050/mpu-dev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mpu-dev.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,1219 @@
+/*
+    mpu-dev.c - mpu3050 char device interface
+
+    Copyright (C) 1995-97 Simon G. Vogl
+    Copyright (C) 1998-99 Frodo Looijaard <frodol@dds.nl>
+    Copyright (C) 2003 Greg Kroah-Hartman <greg@kroah.com>
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+/* Code inside mpudev_ioctl_rdrw is copied from i2c-dev.c
+ */
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include "mpuirq.h"
+#include "slaveirq.h"
+#include "mlsl.h"
+#include "mpu-i2c.h"
+#include "mldl_cfg.h"
+#include "mpu.h"
+
+#define MPU3050_EARLY_SUSPEND_IN_DRIVER 0
+
+/* Platform data for the MPU */
+struct mpu_private_data {
+	struct mldl_cfg mldl_cfg;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+static int pid;
+
+static struct i2c_client *this_client;
+
+static int mpu_open(struct inode *inode, struct file *file)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(this_client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+
+	dev_dbg(&this_client->adapter->dev, "mpu_open\n");
+	dev_dbg(&this_client->adapter->dev, "current->pid %d\n",
+		current->pid);
+	pid = current->pid;
+	file->private_data = this_client;
+	/* we could do some checking on the flags supplied by "open" */
+	/* i.e. O_NONBLOCK */
+	/* -> set some flag to disable interruptible_sleep_on in mpu_read */
+
+	/* Reset the sensors to the default */
+	mldl_cfg->requested_sensors = ML_THREE_AXIS_GYRO;
+	if (mldl_cfg->accel && mldl_cfg->accel->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_ACCEL;
+
+	if (mldl_cfg->compass && mldl_cfg->compass->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_COMPASS;
+
+	if (mldl_cfg->pressure && mldl_cfg->pressure->resume)
+		mldl_cfg->requested_sensors |= ML_THREE_AXIS_PRESSURE;
+
+	return 0;
+}
+
+/* close function - called when the "file" /dev/mpu is closed in userspace   */
+static int mpu_release(struct inode *inode, struct file *file)
+{
+	struct i2c_client *client =
+	    (struct i2c_client *) file->private_data;
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+	int result = 0;
+
+	pid = 0;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter = i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter = i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+	result = mpu3050_suspend(mldl_cfg, client->adapter,
+				 accel_adapter, compass_adapter,
+				 pressure_adapter,
+				 TRUE, TRUE, TRUE, TRUE);
+
+	dev_dbg(&this_client->adapter->dev, "mpu_release\n");
+	return result;
+}
+
+static noinline int mpudev_ioctl_rdrw(struct i2c_client *client,
+				      unsigned long arg)
+{
+	struct i2c_rdwr_ioctl_data rdwr_arg;
+	struct i2c_msg *rdwr_pa;
+	u8 __user **data_ptrs;
+	int i, res;
+
+	if (copy_from_user(&rdwr_arg,
+			   (struct i2c_rdwr_ioctl_data __user *) arg,
+			   sizeof(rdwr_arg)))
+		return -EFAULT;
+
+	/* Put an arbitrary limit on the number of messages that can
+	 * be sent at once */
+	if (rdwr_arg.nmsgs > I2C_RDRW_IOCTL_MAX_MSGS)
+		return -EINVAL;
+
+	rdwr_pa = (struct i2c_msg *)
+	    kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg), GFP_KERNEL);
+	if (!rdwr_pa)
+		return -ENOMEM;
+
+	if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
+			   rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
+		kfree(rdwr_pa);
+		return -EFAULT;
+	}
+
+	data_ptrs =
+	    kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);
+	if (data_ptrs == NULL) {
+		kfree(rdwr_pa);
+		return -ENOMEM;
+	}
+
+	res = 0;
+	for (i = 0; i < rdwr_arg.nmsgs; i++) {
+		/* Limit the size of the message to a sane amount;
+		 * and don't let length change either. */
+		if ((rdwr_pa[i].len > 8192) ||
+		    (rdwr_pa[i].flags & I2C_M_RECV_LEN)) {
+			res = -EINVAL;
+			break;
+		}
+		data_ptrs[i] = (u8 __user *) rdwr_pa[i].buf;
+		rdwr_pa[i].buf = kmalloc(rdwr_pa[i].len, GFP_KERNEL);
+		if (rdwr_pa[i].buf == NULL) {
+			res = -ENOMEM;
+			break;
+		}
+		if (copy_from_user(rdwr_pa[i].buf, data_ptrs[i],
+				   rdwr_pa[i].len)) {
+			++i;	/* Needs to be kfreed too */
+			res = -EFAULT;
+			break;
+		}
+	}
+	if (res < 0) {
+		int j;
+		for (j = 0; j < i; ++j)
+			kfree(rdwr_pa[j].buf);
+		kfree(data_ptrs);
+		kfree(rdwr_pa);
+		return res;
+	}
+
+	res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
+	while (i-- > 0) {
+		if (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {
+			if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,
+					 rdwr_pa[i].len))
+				res = -EFAULT;
+		}
+		kfree(rdwr_pa[i].buf);
+	}
+	kfree(data_ptrs);
+	kfree(rdwr_pa);
+	return res;
+}
+
+/* read function called when from /dev/mpu is read.  Read from the FIFO */
+static ssize_t mpu_read(struct file *file,
+			char __user *buf, size_t count, loff_t *offset)
+{
+	char *tmp;
+	int ret;
+
+	struct i2c_client *client =
+	    (struct i2c_client *) file->private_data;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = kmalloc(count, GFP_KERNEL);
+	if (tmp == NULL)
+		return -ENOMEM;
+
+	pr_debug("i2c-dev: i2c-%d reading %zu bytes.\n",
+		 iminor(file->f_path.dentry->d_inode), count);
+
+/* @todo fix this to do a i2c trasnfer from the FIFO */
+	ret = i2c_master_recv(client, tmp, count);
+	if (ret >= 0)
+		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;
+	kfree(tmp);
+	return ret;
+}
+
+static int
+mpu_ioctl_set_mpu_pdata(struct i2c_client *client, unsigned long arg)
+{
+	int ii;
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mpu3050_platform_data *pdata = mpu->mldl_cfg.pdata;
+	struct mpu3050_platform_data local_pdata;
+
+	if (copy_from_user(&local_pdata, (unsigned char __user *) arg,
+				sizeof(local_pdata)))
+		return -EFAULT;
+
+	pdata->int_config = local_pdata.int_config;
+	for (ii = 0; ii < DIM(pdata->orientation); ii++)
+		pdata->orientation[ii] = local_pdata.orientation[ii];
+	pdata->level_shifter = local_pdata.level_shifter;
+
+	pdata->accel.address = local_pdata.accel.address;
+	for (ii = 0; ii < DIM(pdata->accel.orientation); ii++)
+		pdata->accel.orientation[ii] =
+			local_pdata.accel.orientation[ii];
+
+	pdata->compass.address = local_pdata.compass.address;
+	for (ii = 0; ii < DIM(pdata->compass.orientation); ii++)
+		pdata->compass.orientation[ii] =
+			local_pdata.compass.orientation[ii];
+
+	pdata->pressure.address = local_pdata.pressure.address;
+	for (ii = 0; ii < DIM(pdata->pressure.orientation); ii++)
+		pdata->pressure.orientation[ii] =
+			local_pdata.pressure.orientation[ii];
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	return ML_SUCCESS;
+}
+
+static int
+mpu_ioctl_set_mpu_config(struct i2c_client *client, unsigned long arg)
+{
+	int ii;
+	int result = ML_SUCCESS;
+	struct mpu_private_data *mpu =
+		(struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct mldl_cfg *temp_mldl_cfg;
+
+	dev_dbg(&this_client->adapter->dev, "%s\n", __func__);
+
+	temp_mldl_cfg = kzalloc(sizeof(struct mldl_cfg), GFP_KERNEL);
+	if (NULL == temp_mldl_cfg)
+		return -ENOMEM;
+
+	/*
+	 * User space is not allowed to modify accel compass pressure or
+	 * pdata structs, as well as silicon_revision product_id or trim
+	 */
+	if (copy_from_user(temp_mldl_cfg, (struct mldl_cfg __user *) arg,
+				offsetof(struct mldl_cfg, silicon_revision))) {
+		result = -EFAULT;
+		goto out;
+	}
+
+	if (mldl_cfg->gyro_is_suspended) {
+		if (mldl_cfg->addr != temp_mldl_cfg->addr)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->int_config != temp_mldl_cfg->int_config)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->ext_sync != temp_mldl_cfg->ext_sync)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->full_scale != temp_mldl_cfg->full_scale)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->lpf != temp_mldl_cfg->lpf)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->clk_src != temp_mldl_cfg->clk_src)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->divider != temp_mldl_cfg->divider)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->dmp_enable != temp_mldl_cfg->dmp_enable)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->fifo_enable != temp_mldl_cfg->fifo_enable)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->dmp_cfg1 != temp_mldl_cfg->dmp_cfg1)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->dmp_cfg2 != temp_mldl_cfg->dmp_cfg2)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (mldl_cfg->gyro_power != temp_mldl_cfg->gyro_power)
+			mldl_cfg->gyro_needs_reset = TRUE;
+
+		for (ii = 0; ii < MPU_NUM_AXES; ii++)
+			if (mldl_cfg->offset_tc[ii] !=
+			    temp_mldl_cfg->offset_tc[ii])
+				mldl_cfg->gyro_needs_reset = TRUE;
+
+		for (ii = 0; ii < MPU_NUM_AXES; ii++)
+			if (mldl_cfg->offset[ii] != temp_mldl_cfg->offset[ii])
+				mldl_cfg->gyro_needs_reset = TRUE;
+
+		if (memcmp(mldl_cfg->ram, temp_mldl_cfg->ram,
+				MPU_MEM_NUM_RAM_BANKS * MPU_MEM_BANK_SIZE *
+				sizeof(unsigned char)))
+			mldl_cfg->gyro_needs_reset = TRUE;
+	}
+
+	memcpy(mldl_cfg, temp_mldl_cfg,
+		offsetof(struct mldl_cfg, silicon_revision));
+
+out:
+	kfree(temp_mldl_cfg);
+	return result;
+}
+
+static int
+mpu_ioctl_get_mpu_config(struct i2c_client *client, unsigned long arg)
+{
+	/* Have to be careful as there are 3 pointers in the mldl_cfg
+	 * structure */
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct mldl_cfg *local_mldl_cfg;
+	int retval = 0;
+
+	local_mldl_cfg = kzalloc(sizeof(struct mldl_cfg), GFP_KERNEL);
+	if (NULL == local_mldl_cfg)
+		return -ENOMEM;
+
+	retval =
+	    copy_from_user(local_mldl_cfg, (struct mldl_cfg __user *) arg,
+			   sizeof(struct mldl_cfg));
+	if (retval)
+		goto out;
+
+	/* Fill in the accel, compass, pressure and pdata pointers */
+	if (mldl_cfg->accel) {
+		retval = copy_to_user((void __user *)local_mldl_cfg->accel,
+				      mldl_cfg->accel,
+				      sizeof(*mldl_cfg->accel));
+		if (retval)
+			goto out;
+	}
+
+	if (mldl_cfg->compass) {
+		retval = copy_to_user((void __user *)local_mldl_cfg->compass,
+				      mldl_cfg->compass,
+				      sizeof(*mldl_cfg->compass));
+		if (retval)
+			goto out;
+	}
+
+	if (mldl_cfg->pressure) {
+		retval = copy_to_user(local_mldl_cfg->pressure,
+				      mldl_cfg->pressure,
+				      sizeof(*mldl_cfg->pressure));
+		if (retval)
+			goto out;
+	}
+
+	if (mldl_cfg->pdata) {
+		retval = copy_to_user((void __user *)local_mldl_cfg->pdata,
+				      mldl_cfg->pdata,
+				      sizeof(*mldl_cfg->pdata));
+		if (retval)
+			goto out;
+	}
+
+	/* Do not modify the accel, compass, pressure and pdata pointers */
+	retval = copy_to_user((struct mldl_cfg __user *) arg,
+			      mldl_cfg, offsetof(struct mldl_cfg, accel));
+
+out:
+	kfree(local_mldl_cfg);
+	return retval;
+}
+
+/* ioctl - I/O control */
+static long mpu_ioctl(struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	struct i2c_client *client =
+	    (struct i2c_client *) file->private_data;
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	int retval = 0;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	switch (cmd) {
+	case I2C_RDWR:
+		mpudev_ioctl_rdrw(client, arg);
+		break;
+	case I2C_SLAVE:
+		if ((arg & 0x7E) != (client->addr & 0x7E)) {
+			dev_err(&this_client->adapter->dev,
+				"%s: Invalid I2C_SLAVE arg %lu\n",
+				__func__, arg);
+		}
+		break;
+	case MPU_SET_MPU_CONFIG:
+		retval = mpu_ioctl_set_mpu_config(client, arg);
+		break;
+	case MPU_SET_INT_CONFIG:
+		mldl_cfg->int_config = (unsigned char) arg;
+		break;
+	case MPU_SET_EXT_SYNC:
+		mldl_cfg->ext_sync = (enum mpu_ext_sync) arg;
+		break;
+	case MPU_SET_FULL_SCALE:
+		mldl_cfg->full_scale = (enum mpu_fullscale) arg;
+		break;
+	case MPU_SET_LPF:
+		mldl_cfg->lpf = (enum mpu_filter) arg;
+		break;
+	case MPU_SET_CLK_SRC:
+		mldl_cfg->clk_src = (enum mpu_clock_sel) arg;
+		break;
+	case MPU_SET_DIVIDER:
+		mldl_cfg->divider = (unsigned char) arg;
+		break;
+	case MPU_SET_LEVEL_SHIFTER:
+		mldl_cfg->pdata->level_shifter = (unsigned char) arg;
+		break;
+	case MPU_SET_DMP_ENABLE:
+		mldl_cfg->dmp_enable = (unsigned char) arg;
+		break;
+	case MPU_SET_FIFO_ENABLE:
+		mldl_cfg->fifo_enable = (unsigned char) arg;
+		break;
+	case MPU_SET_DMP_CFG1:
+		mldl_cfg->dmp_cfg1 = (unsigned char) arg;
+		break;
+	case MPU_SET_DMP_CFG2:
+		mldl_cfg->dmp_cfg2 = (unsigned char) arg;
+		break;
+	case MPU_SET_OFFSET_TC:
+		retval = copy_from_user(mldl_cfg->offset_tc,
+					(unsigned char __user *) arg,
+					sizeof(mldl_cfg->offset_tc));
+		break;
+	case MPU_SET_RAM:
+		retval = copy_from_user(mldl_cfg->ram,
+					(unsigned char __user *) arg,
+					sizeof(mldl_cfg->ram));
+		break;
+	case MPU_SET_PLATFORM_DATA:
+		retval = mpu_ioctl_set_mpu_pdata(client, arg);
+		break;
+	case MPU_GET_MPU_CONFIG:
+		retval = mpu_ioctl_get_mpu_config(client, arg);
+		break;
+	case MPU_GET_INT_CONFIG:
+		retval = put_user(mldl_cfg->int_config,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_EXT_SYNC:
+		retval = put_user(mldl_cfg->ext_sync,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_FULL_SCALE:
+		retval = put_user(mldl_cfg->full_scale,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_LPF:
+		retval = put_user(mldl_cfg->lpf,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_CLK_SRC:
+		retval = put_user(mldl_cfg->clk_src,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_DIVIDER:
+		retval = put_user(mldl_cfg->divider,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_LEVEL_SHIFTER:
+		retval = put_user(mldl_cfg->pdata->level_shifter,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_DMP_ENABLE:
+		retval = put_user(mldl_cfg->dmp_enable,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_FIFO_ENABLE:
+		retval = put_user(mldl_cfg->fifo_enable,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_DMP_CFG1:
+		retval = put_user(mldl_cfg->dmp_cfg1,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_DMP_CFG2:
+		retval = put_user(mldl_cfg->dmp_cfg2,
+				  (unsigned char __user *) arg);
+		break;
+	case MPU_GET_OFFSET_TC:
+		retval = copy_to_user((unsigned char __user *) arg,
+				      mldl_cfg->offset_tc,
+				      sizeof(mldl_cfg->offset_tc));
+		break;
+	case MPU_GET_RAM:
+		retval = copy_to_user((unsigned char __user *) arg,
+				      mldl_cfg->ram,
+				      sizeof(mldl_cfg->ram));
+		break;
+	case MPU_CONFIG_ACCEL:
+	{
+		if ((mldl_cfg->accel) && (mldl_cfg->accel->config)) {
+			struct ext_slave_config config;
+			retval = copy_from_user(
+				&config,
+				(struct ext_slave_config *)arg,
+				sizeof(config));
+			if (retval)
+				break;
+
+			if (config.len && config.data) {
+				int *data;
+				data = kzalloc(config.len, GFP_KERNEL);
+				if (!data) {
+					retval = ML_ERROR_MEMORY_EXAUSTED;
+					break;
+				}
+				retval = copy_from_user(data,
+							(void *)config.data,
+							config.len);
+				if (retval) {
+					kfree(data);
+					break;
+				}
+				config.data = data;
+			}
+			retval = mldl_cfg->accel->config(
+				accel_adapter,
+				mldl_cfg->accel,
+				&mldl_cfg->pdata->accel,
+				&config);
+			kfree(config.data);
+		}
+		break;
+	}
+	case MPU_CONFIG_COMPASS:
+	{
+		if ((mldl_cfg->compass) && (mldl_cfg->compass->config)) {
+			struct ext_slave_config config;
+			retval = copy_from_user(
+				&config,
+				(struct ext_slave_config *)arg,
+				sizeof(config));
+			if (retval)
+				break;
+
+			if (config.len && config.data) {
+				int *data;
+				data = kzalloc(config.len, GFP_KERNEL);
+				if (!data) {
+					retval = ML_ERROR_MEMORY_EXAUSTED;
+					break;
+				}
+				retval = copy_from_user(data,
+							(void *)config.data,
+							config.len);
+				if (retval) {
+					kfree(data);
+					break;
+				}
+				config.data = data;
+			}
+			retval = mldl_cfg->compass->config(
+				compass_adapter,
+				mldl_cfg->compass,
+				&mldl_cfg->pdata->compass,
+				&config);
+			kfree(config.data);
+		}
+		break;
+	}
+	case MPU_CONFIG_PRESSURE:
+	{
+		if ((mldl_cfg->pressure) && (mldl_cfg->pressure->config)) {
+			struct ext_slave_config config;
+			retval = copy_from_user(
+				&config,
+				(struct ext_slave_config *)arg,
+				sizeof(config));
+			if (retval)
+				break;
+
+			if (config.len && config.data) {
+				int *data;
+				data = kzalloc(config.len, GFP_KERNEL);
+				if (!data) {
+					retval = ML_ERROR_MEMORY_EXAUSTED;
+					break;
+				}
+				retval = copy_from_user(data,
+							(void *)config.data,
+							config.len);
+				if (retval) {
+					kfree(data);
+					break;
+				}
+				config.data = data;
+			}
+			retval = mldl_cfg->pressure->config(
+				pressure_adapter,
+				mldl_cfg->pressure,
+				&mldl_cfg->pdata->pressure,
+				&config);
+			kfree(config.data);
+		}
+		break;
+	}
+	case MPU_READ_MEMORY:
+	case MPU_WRITE_MEMORY:
+	case MPU_SUSPEND:
+	{
+		unsigned long sensors;
+		sensors = ~(mldl_cfg->requested_sensors);
+		retval = mpu3050_suspend(mldl_cfg,
+					client->adapter,
+					accel_adapter,
+					compass_adapter,
+					pressure_adapter,
+					((sensors & ML_THREE_AXIS_GYRO)
+						== ML_THREE_AXIS_GYRO),
+					((sensors & ML_THREE_AXIS_ACCEL)
+						== ML_THREE_AXIS_ACCEL),
+					((sensors & ML_THREE_AXIS_COMPASS)
+						== ML_THREE_AXIS_COMPASS),
+					((sensors & ML_THREE_AXIS_PRESSURE)
+						== ML_THREE_AXIS_PRESSURE));
+	}
+	break;
+	case MPU_RESUME:
+	{
+		unsigned long sensors;
+		sensors = mldl_cfg->requested_sensors;
+		retval = mpu3050_resume(mldl_cfg,
+					client->adapter,
+					accel_adapter,
+					compass_adapter,
+					pressure_adapter,
+					sensors & ML_THREE_AXIS_GYRO,
+					sensors & ML_THREE_AXIS_ACCEL,
+					sensors & ML_THREE_AXIS_COMPASS,
+					sensors & ML_THREE_AXIS_PRESSURE);
+	}
+	break;
+	case MPU_READ_ACCEL:
+		{
+			unsigned char data[6];
+			retval =
+			    mpu3050_read_accel(mldl_cfg, client->adapter,
+					       data);
+			if (ML_SUCCESS == retval)
+				retval =
+				    copy_to_user((unsigned char __user *) arg,
+						 data, sizeof(data));
+		}
+		break;
+	case MPU_READ_COMPASS:
+		{
+			unsigned char data[6];
+			struct i2c_adapter *compass_adapt =
+			    i2c_get_adapter(mldl_cfg->pdata->compass.
+					    adapt_num);
+			retval =
+			    mpu3050_read_compass(mldl_cfg, compass_adapt,
+						 data);
+			if (ML_SUCCESS == retval)
+				retval =
+				    copy_to_user((unsigned char *) arg,
+						 data, sizeof(data));
+		}
+		break;
+	case MPU_READ_PRESSURE:
+		{
+			unsigned char data[3];
+			struct i2c_adapter *pressure_adapt =
+			    i2c_get_adapter(mldl_cfg->pdata->pressure.
+					    adapt_num);
+			retval =
+			    mpu3050_read_pressure(mldl_cfg, pressure_adapt,
+						 data);
+			if (ML_SUCCESS == retval)
+				retval =
+				    copy_to_user((unsigned char __user *) arg,
+						 data, sizeof(data));
+		}
+		break;
+	default:
+		dev_err(&this_client->adapter->dev,
+			"%s: Unknown cmd %d, arg %lu\n", __func__, cmd,
+			arg);
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void mpu3050_early_suspend(struct early_suspend *h)
+{
+	struct mpu_private_data *mpu = container_of(h,
+						    struct
+						    mpu_private_data,
+						    early_suspend);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	dev_dbg(&this_client->adapter->dev, "%s: %d, %d\n", __func__,
+		h->level, mpu->mldl_cfg.gyro_is_suspended);
+	if (MPU3050_EARLY_SUSPEND_IN_DRIVER)
+		(void) mpu3050_suspend(mldl_cfg, this_client->adapter,
+				accel_adapter, compass_adapter,
+				pressure_adapter, TRUE, TRUE, TRUE, TRUE);
+}
+
+void mpu3050_early_resume(struct early_suspend *h)
+{
+	struct mpu_private_data *mpu = container_of(h,
+						    struct
+						    mpu_private_data,
+						    early_suspend);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	if (MPU3050_EARLY_SUSPEND_IN_DRIVER) {
+		if (pid) {
+			unsigned long sensors = mldl_cfg->requested_sensors;
+			(void) mpu3050_resume(mldl_cfg,
+					this_client->adapter,
+					accel_adapter,
+					compass_adapter,
+					pressure_adapter,
+					sensors & ML_THREE_AXIS_GYRO,
+					sensors & ML_THREE_AXIS_ACCEL,
+					sensors & ML_THREE_AXIS_COMPASS,
+					sensors & ML_THREE_AXIS_PRESSURE);
+			dev_dbg(&this_client->adapter->dev,
+				"%s for pid %d\n", __func__, pid);
+		}
+	}
+	dev_dbg(&this_client->adapter->dev, "%s: %d\n", __func__, h->level);
+}
+#endif
+
+void mpu_shutdown(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	(void) mpu3050_suspend(mldl_cfg, this_client->adapter,
+			       accel_adapter, compass_adapter, pressure_adapter,
+			       TRUE, TRUE, TRUE, TRUE);
+	dev_dbg(&this_client->adapter->dev, "%s\n", __func__);
+}
+
+int mpu_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	if (!mpu->mldl_cfg.gyro_is_suspended) {
+		dev_dbg(&this_client->adapter->dev,
+			"%s: suspending on event %d\n", __func__,
+			mesg.event);
+		(void) mpu3050_suspend(mldl_cfg, this_client->adapter,
+				       accel_adapter, compass_adapter,
+				       pressure_adapter,
+				       TRUE, TRUE, TRUE, TRUE);
+	} else {
+		dev_dbg(&this_client->adapter->dev,
+			"%s: Already suspended %d\n", __func__,
+			mesg.event);
+	}
+	return 0;
+}
+
+int mpu_resume(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *) i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	if (pid) {
+		unsigned long sensors = mldl_cfg->requested_sensors;
+		(void) mpu3050_resume(mldl_cfg, this_client->adapter,
+				      accel_adapter,
+				      compass_adapter,
+				      pressure_adapter,
+				      sensors & ML_THREE_AXIS_GYRO,
+				      sensors & ML_THREE_AXIS_ACCEL,
+				      sensors & ML_THREE_AXIS_COMPASS,
+				      sensors & ML_THREE_AXIS_PRESSURE);
+		dev_dbg(&this_client->adapter->dev,
+			"%s for pid %d\n", __func__, pid);
+	}
+	return 0;
+}
+
+/* define which file operations are supported */
+static const struct file_operations mpu_fops = {
+	.owner = THIS_MODULE,
+	.read = mpu_read,
+#if HAVE_COMPAT_IOCTL
+	.compat_ioctl = mpu_ioctl,
+#endif
+#if HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = mpu_ioctl,
+#endif
+	.open = mpu_open,
+	.release = mpu_release,
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
+I2C_CLIENT_INSMOD;
+#endif
+
+static struct miscdevice i2c_mpu_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mpu", /* Same for both 3050 and 6000 */
+	.fops = &mpu_fops,
+};
+
+
+int mpu3050_probe(struct i2c_client *client,
+		  const struct i2c_device_id *devid)
+{
+	struct mpu3050_platform_data *pdata;
+	struct mpu_private_data *mpu;
+	struct mldl_cfg *mldl_cfg;
+	int res = 0;
+	struct i2c_adapter *accel_adapter = NULL;
+	struct i2c_adapter *compass_adapter = NULL;
+	struct i2c_adapter *pressure_adapter = NULL;
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		res = -ENODEV;
+		goto out_check_functionality_failed;
+	}
+
+	mpu = kzalloc(sizeof(struct mpu_private_data), GFP_KERNEL);
+	if (!mpu) {
+		res = -ENOMEM;
+		goto out_alloc_data_failed;
+	}
+
+	i2c_set_clientdata(client, mpu);
+	this_client = client;
+	mldl_cfg = &mpu->mldl_cfg;
+	pdata = (struct mpu3050_platform_data *) client->dev.platform_data;
+	if (!pdata) {
+		dev_warn(&this_client->adapter->dev,
+			 "Warning no platform data for mpu3050\n");
+	} else {
+		mldl_cfg->pdata = pdata;
+
+#if defined(CONFIG_SENSORS_MPU3050_MODULE) || \
+    defined(CONFIG_SENSORS_MPU6000_MODULE)
+		pdata->accel.get_slave_descr = get_accel_slave_descr;
+		pdata->compass.get_slave_descr = get_compass_slave_descr;
+		pdata->pressure.get_slave_descr = get_pressure_slave_descr;
+#endif
+
+		if (pdata->accel.get_slave_descr) {
+			mldl_cfg->accel =
+			    pdata->accel.get_slave_descr();
+			dev_info(&this_client->adapter->dev,
+				 "%s: +%s\n", MPU_NAME,
+				 mldl_cfg->accel->name);
+			accel_adapter =
+				i2c_get_adapter(pdata->accel.adapt_num);
+			if (pdata->accel.irq > 0) {
+				dev_info(&this_client->adapter->dev,
+					"Installing Accel irq using %d\n",
+					pdata->accel.irq);
+				res = slaveirq_init(accel_adapter,
+						&pdata->accel,
+						"accelirq");
+				if (res)
+					goto out_accelirq_failed;
+			} else {
+				dev_warn(&this_client->adapter->dev,
+					"WARNING: Accel irq not assigned\n");
+			}
+		} else {
+			dev_warn(&this_client->adapter->dev,
+				 "%s: No Accel Present\n", MPU_NAME);
+		}
+
+		if (pdata->compass.get_slave_descr) {
+			mldl_cfg->compass =
+			    pdata->compass.get_slave_descr();
+			dev_info(&this_client->adapter->dev,
+				 "%s: +%s\n", MPU_NAME,
+				 mldl_cfg->compass->name);
+			compass_adapter =
+				i2c_get_adapter(pdata->compass.adapt_num);
+			if (pdata->compass.irq > 0) {
+				dev_info(&this_client->adapter->dev,
+					"Installing Compass irq using %d\n",
+					pdata->compass.irq);
+				res = slaveirq_init(compass_adapter,
+						&pdata->compass,
+						"compassirq");
+				if (res)
+					goto out_compassirq_failed;
+			} else {
+				dev_warn(&this_client->adapter->dev,
+					"WARNING: Compass irq not assigned\n");
+			}
+		} else {
+			dev_warn(&this_client->adapter->dev,
+				 "%s: No Compass Present\n", MPU_NAME);
+		}
+
+		if (pdata->pressure.get_slave_descr) {
+			mldl_cfg->pressure =
+			    pdata->pressure.get_slave_descr();
+			dev_info(&this_client->adapter->dev,
+				 "%s: +%s\n", MPU_NAME,
+				 mldl_cfg->pressure->name);
+			pressure_adapter =
+				i2c_get_adapter(pdata->pressure.adapt_num);
+
+			if (pdata->pressure.irq > 0) {
+				dev_info(&this_client->adapter->dev,
+					"Installing Pressure irq using %d\n",
+					pdata->pressure.irq);
+				res = slaveirq_init(pressure_adapter,
+						&pdata->pressure,
+						"pressureirq");
+				if (res)
+					goto out_pressureirq_failed;
+			} else {
+				dev_warn(&this_client->adapter->dev,
+					"WARNING: Pressure irq not assigned\n");
+			}
+		} else {
+			dev_warn(&this_client->adapter->dev,
+				 "%s: No Pressure Present\n", MPU_NAME);
+		}
+	}
+
+	mldl_cfg->addr = client->addr;
+	res = mpu3050_open(&mpu->mldl_cfg, client->adapter,
+			accel_adapter, compass_adapter, pressure_adapter);
+
+	if (res) {
+		dev_err(&this_client->adapter->dev,
+			"Unable to open %s %d\n", MPU_NAME, res);
+		res = -ENODEV;
+		goto out_whoami_failed;
+	}
+
+	res = misc_register(&i2c_mpu_device);
+	if (res < 0) {
+		dev_err(&this_client->adapter->dev,
+			"ERROR: misc_register returned %d\n", res);
+		goto out_misc_register_failed;
+	}
+
+	if (this_client->irq > 0) {
+		dev_info(&this_client->adapter->dev,
+			 "Installing irq using %d\n", this_client->irq);
+		res = mpuirq_init(this_client);
+		if (res)
+			goto out_mpuirq_failed;
+	} else {
+		dev_warn(&this_client->adapter->dev,
+			 "WARNING: %s irq not assigned\n", MPU_NAME);
+	}
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	mpu->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	mpu->early_suspend.suspend = mpu3050_early_suspend;
+	mpu->early_suspend.resume = mpu3050_early_resume;
+	register_early_suspend(&mpu->early_suspend);
+#endif
+	return res;
+
+out_mpuirq_failed:
+	misc_deregister(&i2c_mpu_device);
+out_misc_register_failed:
+	mpu3050_close(&mpu->mldl_cfg, client->adapter,
+		accel_adapter, compass_adapter, pressure_adapter);
+out_whoami_failed:
+	if (pdata &&
+	    pdata->pressure.get_slave_descr &&
+	    pdata->pressure.irq)
+		slaveirq_exit(&pdata->pressure);
+out_pressureirq_failed:
+	if (pdata &&
+	    pdata->compass.get_slave_descr &&
+	    pdata->compass.irq)
+		slaveirq_exit(&pdata->compass);
+out_compassirq_failed:
+	if (pdata &&
+	    pdata->accel.get_slave_descr &&
+	    pdata->accel.irq)
+		slaveirq_exit(&pdata->accel);
+out_accelirq_failed:
+	kfree(mpu);
+out_alloc_data_failed:
+out_check_functionality_failed:
+	dev_err(&this_client->adapter->dev, "%s failed %d\n", __func__,
+		res);
+	return res;
+
+}
+
+static int mpu3050_remove(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu = i2c_get_clientdata(client);
+	struct i2c_adapter *accel_adapter;
+	struct i2c_adapter *compass_adapter;
+	struct i2c_adapter *pressure_adapter;
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct mpu3050_platform_data *pdata = mldl_cfg->pdata;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	compass_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->compass.adapt_num);
+	pressure_adapter =
+	    i2c_get_adapter(mldl_cfg->pdata->pressure.adapt_num);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&mpu->early_suspend);
+#endif
+	mpu3050_close(mldl_cfg, client->adapter,
+		accel_adapter, compass_adapter, pressure_adapter);
+
+	if (client->irq)
+		mpuirq_exit();
+
+	if (pdata &&
+	    pdata->pressure.get_slave_descr &&
+	    pdata->pressure.irq)
+		slaveirq_exit(&pdata->pressure);
+
+	if (pdata &&
+	    pdata->compass.get_slave_descr &&
+	    pdata->compass.irq)
+		slaveirq_exit(&pdata->compass);
+
+	if (pdata &&
+	    pdata->accel.get_slave_descr &&
+	    pdata->accel.irq)
+		slaveirq_exit(&pdata->accel);
+
+	misc_deregister(&i2c_mpu_device);
+	kfree(mpu);
+
+	return 0;
+}
+
+static const struct i2c_device_id mpu3050_id[] = {
+	{MPU_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, mpu3050_id);
+
+static struct i2c_driver mpu3050_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = mpu3050_probe,
+	.remove = mpu3050_remove,
+	.id_table = mpu3050_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = MPU_NAME,
+		   },
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
+	.address_data = &addr_data,
+#else
+	.address_list = normal_i2c,
+#endif
+
+	.shutdown = mpu_shutdown,	/* optional */
+	.suspend = mpu_suspend,	/* optional */
+	.resume = mpu_resume,	/* optional */
+
+};
+
+static int __init mpu_init(void)
+{
+	int res = i2c_add_driver(&mpu3050_driver);
+	pid = 0;
+	printk(KERN_DEBUG "%s\n", __func__);
+	if (res)
+		dev_err(&this_client->adapter->dev, "%s failed\n",
+			__func__);
+	return res;
+}
+
+static void __exit mpu_exit(void)
+{
+	printk(KERN_DEBUG "%s\n", __func__);
+	i2c_del_driver(&mpu3050_driver);
+}
+
+module_init(mpu_init);
+module_exit(mpu_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("User space character device interface for MPU3050");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(MPU_NAME);
Index: Kernel/drivers/sensors/mpu3050/mpu-i2c.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mpu-i2c.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,183 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+/**
+ *  @defgroup
+ *  @brief
+ *
+ *  @{
+ *      @file   mpu-i2c.c
+ *      @brief
+ *
+ */
+
+#include <linux/i2c.h>
+#include "mpu.h"
+
+int sensor_i2c_write(struct i2c_adapter *i2c_adap,
+		     unsigned char address,
+		     unsigned int len, unsigned char const *data)
+{
+	struct i2c_msg msgs[1];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = (unsigned char *) data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1)
+		return res;
+	else
+		return 0;
+}
+
+int sensor_i2c_write_register(struct i2c_adapter *i2c_adap,
+			      unsigned char address,
+			      unsigned char reg, unsigned char value)
+{
+	unsigned char data[2];
+
+	data[0] = reg;
+	data[1] = value;
+	return sensor_i2c_write(i2c_adap, address, 2, data);
+}
+
+int sensor_i2c_read(struct i2c_adapter *i2c_adap,
+		    unsigned char address,
+		    unsigned char reg,
+		    unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = &reg;
+	msgs[0].len = 1;
+
+	msgs[1].addr = address;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].buf = data;
+	msgs[1].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 2);
+	if (res < 2)
+		return res;
+	else
+		return 0;
+}
+
+int mpu_memory_read(struct i2c_adapter *i2c_adap,
+		    unsigned char mpu_addr,
+		    unsigned short mem_addr,
+		    unsigned int len, unsigned char *data)
+{
+	unsigned char bank[2];
+	unsigned char addr[2];
+	unsigned char buf;
+
+	struct i2c_msg msgs[4];
+	int ret;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	bank[0] = MPUREG_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = MPUREG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf = MPUREG_MEM_R_W;
+
+	/* Write Message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = &buf;
+	msgs[2].len = 1;
+
+	msgs[3].addr = mpu_addr;
+	msgs[3].flags = I2C_M_RD;
+	msgs[3].buf = data;
+	msgs[3].len = len;
+
+	ret = i2c_transfer(i2c_adap, msgs, 4);
+	if (ret != 4)
+		return ret;
+	else
+		return 0;
+}
+
+int mpu_memory_write(struct i2c_adapter *i2c_adap,
+		     unsigned char mpu_addr,
+		     unsigned short mem_addr,
+		     unsigned int len, unsigned char const *data)
+{
+	unsigned char bank[2];
+	unsigned char addr[2];
+	unsigned char buf[513];
+
+	struct i2c_msg msgs[3];
+	int ret;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+	if (len >= (sizeof(buf) - 1))
+		return -ENOMEM;
+
+	bank[0] = MPUREG_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = MPUREG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf[0] = MPUREG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+
+	/* Write Message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = (unsigned char *) buf;
+	msgs[2].len = len + 1;
+
+	ret = i2c_transfer(i2c_adap, msgs, 3);
+	if (ret != 3)
+		return ret;
+	else
+		return 0;
+}
+
+/**
+ *  @}
+ */
Index: Kernel/drivers/sensors/mpu3050/mpu-i2c.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mpu-i2c.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,45 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+/**
+ * @defgroup
+ * @brief
+ *
+ * @{
+ * @file     mpu-i2c.c
+ * @brief
+ *
+ *
+ */
+
+#ifndef __MPU_I2C_H__
+#define __MPU_I2C_H__
+
+#include <linux/i2c.h>
+
+int sensor_i2c_write(struct i2c_adapter *i2c_adap,
+		     unsigned char address,
+		     unsigned int len, unsigned char const *data);
+
+int sensor_i2c_write_register(struct i2c_adapter *i2c_adap,
+			      unsigned char address,
+			      unsigned char reg, unsigned char value);
+
+int sensor_i2c_read(struct i2c_adapter *i2c_adap,
+		    unsigned char address,
+		    unsigned char reg,
+		    unsigned int len, unsigned char *data);
+
+int mpu_memory_read(struct i2c_adapter *i2c_adap,
+		    unsigned char mpu_addr,
+		    unsigned short mem_addr,
+		    unsigned int len, unsigned char *data);
+
+int mpu_memory_write(struct i2c_adapter *i2c_adap,
+		     unsigned char mpu_addr,
+		     unsigned short mem_addr,
+		     unsigned int len, unsigned char const *data);
+
+#endif	/* __MPU_I2C_H__ */
Index: Kernel/drivers/sensors/mpu3050/mpuirq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mpuirq.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,312 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/workqueue.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include "mpu.h"
+#include "mpuirq.h"
+#include "mldl_cfg.h"
+#include "mpu-i2c.h"
+
+#define MPUIRQ_NAME "mpuirq"
+
+/* function which gets accel data and sends it to MPU */
+
+DECLARE_WAIT_QUEUE_HEAD(mpuirq_wait);
+
+struct mpuirq_dev_data {
+	struct work_struct work;
+	struct i2c_client *mpu_client;
+	struct miscdevice *dev;
+	int irq;
+	int pid;
+	int accel_divider;
+	int data_ready;
+	int timeout;
+};
+
+static struct mpuirq_dev_data mpuirq_dev_data;
+static struct irq_data mpuirq_data;
+static char *interface = MPUIRQ_NAME;
+
+static void mpu_accel_data_work_fcn(struct work_struct *work);
+
+static int mpuirq_open(struct inode *inode, struct file *file)
+{
+	dev_dbg(mpuirq_dev_data.dev->this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+	mpuirq_dev_data.pid = current->pid;
+	file->private_data = &mpuirq_dev_data;
+	/* we could do some checking on the flags supplied by "open" */
+	/* i.e. O_NONBLOCK */
+	/* -> set some flag to disable interruptible_sleep_on in mpuirq_read */
+	return 0;
+}
+
+/* close function - called when the "file" /dev/mpuirq is closed in userspace */
+static int mpuirq_release(struct inode *inode, struct file *file)
+{
+	dev_dbg(mpuirq_dev_data.dev->this_device, "mpuirq_release\n");
+	return 0;
+}
+
+/* read function called when from /dev/mpuirq is read */
+static ssize_t mpuirq_read(struct file *file,
+			   char *buf, size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct mpuirq_dev_data *p_mpuirq_dev_data = file->private_data;
+
+	if (!mpuirq_dev_data.data_ready) {
+		wait_event_interruptible_timeout(mpuirq_wait,
+						 mpuirq_dev_data.
+						 data_ready,
+						 mpuirq_dev_data.timeout);
+	}
+
+	if (mpuirq_dev_data.data_ready && NULL != buf
+	    && count >= sizeof(mpuirq_data)) {
+		err = copy_to_user(buf, &mpuirq_data, sizeof(mpuirq_data));
+		mpuirq_data.data_type = 0;
+	} else {
+		return 0;
+	}
+	if (err != 0) {
+		dev_err(p_mpuirq_dev_data->dev->this_device,
+			"Corq_dev_datapy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	mpuirq_dev_data.data_ready = 0;
+	len = sizeof(mpuirq_data);
+	return len;
+}
+
+unsigned int mpuirq_poll(struct file *file, struct poll_table_struct *poll)
+{
+	int mask = 0;
+
+	poll_wait(file, &mpuirq_wait, poll);
+	if (mpuirq_dev_data.data_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl - I/O control */
+static long mpuirq_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int data;
+
+	switch (cmd) {
+	case MPUIRQ_SET_TIMEOUT:
+		mpuirq_dev_data.timeout = arg;
+		break;
+
+	case MPUIRQ_GET_INTERRUPT_CNT:
+		data = mpuirq_data.interruptcount - 1;
+		if (mpuirq_data.interruptcount > 1)
+			mpuirq_data.interruptcount = 1;
+
+		if (copy_to_user((int *) arg, &data, sizeof(int)))
+			return -EFAULT;
+		break;
+	case MPUIRQ_GET_IRQ_TIME:
+		if (copy_to_user((int *) arg, &mpuirq_data.irqtime,
+				 sizeof(mpuirq_data.irqtime)))
+			return -EFAULT;
+		mpuirq_data.irqtime = 0;
+		break;
+	case MPUIRQ_SET_FREQUENCY_DIVIDER:
+		mpuirq_dev_data.accel_divider = arg;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+static void mpu_accel_data_work_fcn(struct work_struct *work)
+{
+	struct mpuirq_dev_data *mpuirq_dev_data =
+	    (struct mpuirq_dev_data *) work;
+	struct mldl_cfg *mldl_cfg =
+	    (struct mldl_cfg *)
+	    i2c_get_clientdata(mpuirq_dev_data->mpu_client);
+	struct i2c_adapter *accel_adapter;
+	unsigned char wbuff[16];
+	unsigned char rbuff[16];
+	int ii;
+
+	accel_adapter = i2c_get_adapter(mldl_cfg->pdata->accel.adapt_num);
+	mldl_cfg->accel->read(accel_adapter,
+			      mldl_cfg->accel,
+			      &mldl_cfg->pdata->accel, rbuff);
+
+
+	/* @todo add other data formats here as well */
+	if (EXT_SLAVE_BIG_ENDIAN == mldl_cfg->accel->endian) {
+		for (ii = 0; ii < 3; ii++) {
+			wbuff[2 * ii + 1] = rbuff[2 * ii + 1];
+			wbuff[2 * ii + 2] = rbuff[2 * ii + 0];
+		}
+	} else {
+		memcpy(wbuff + 1, rbuff, mldl_cfg->accel->len);
+	}
+
+	wbuff[7] = 0;
+	wbuff[8] = 1;		/*set semaphore */
+
+	mpu_memory_write(mpuirq_dev_data->mpu_client->adapter,
+			 mldl_cfg->addr, 0x0108, 8, wbuff);
+}
+
+static irqreturn_t mpuirq_handler(int irq, void *dev_id)
+{
+	static int mycount;
+	struct timeval irqtime;
+	mycount++;
+
+	mpuirq_data.interruptcount++;
+
+	printk("\n\n############# mpuirq_handler called #############\n\n");
+
+	/* wake up (unblock) for reading data from userspace */
+	/* and ignore first interrupt generated in module init */
+	if (mpuirq_data.interruptcount > 1) {
+		mpuirq_dev_data.data_ready = 1;
+
+		do_gettimeofday(&irqtime);
+		mpuirq_data.irqtime = (((long long) irqtime.tv_sec) << 32);
+		mpuirq_data.irqtime += irqtime.tv_usec;
+
+		if ((mpuirq_dev_data.accel_divider >= 0) &&
+		    (0 ==
+		     (mycount % (mpuirq_dev_data.accel_divider + 1)))) {
+			schedule_work((struct work_struct
+				       *) (&mpuirq_dev_data));
+		}
+
+		wake_up_interruptible(&mpuirq_wait);
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+/* define which file operations are supported */
+const struct file_operations mpuirq_fops = {
+	.owner = THIS_MODULE,
+	.read = mpuirq_read,
+	.poll = mpuirq_poll,
+
+#if HAVE_COMPAT_IOCTL
+	.compat_ioctl = mpuirq_ioctl,
+#endif
+#if HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = mpuirq_ioctl,
+#endif
+	.open = mpuirq_open,
+	.release = mpuirq_release,
+};
+
+static struct miscdevice mpuirq_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = MPUIRQ_NAME,
+	.fops = &mpuirq_fops,
+};
+
+int mpuirq_init(struct i2c_client *mpu_client)
+{
+
+	int res;
+	struct mldl_cfg *mldl_cfg =
+	    (struct mldl_cfg *) i2c_get_clientdata(mpu_client);
+
+	/* work_struct initialization */
+	INIT_WORK((struct work_struct *) &mpuirq_dev_data,
+		  mpu_accel_data_work_fcn);
+	mpuirq_dev_data.mpu_client = mpu_client;
+
+	dev_info(&mpu_client->adapter->dev,
+		 "Module Param interface = %s\n", interface);
+
+	mpuirq_dev_data.irq = mpu_client->irq;
+	mpuirq_dev_data.pid = 0;
+	mpuirq_dev_data.accel_divider = -1;
+	mpuirq_dev_data.data_ready = 0;
+	mpuirq_dev_data.timeout = 0;
+	mpuirq_dev_data.dev = &mpuirq_device;
+
+	if (mpuirq_dev_data.irq) {
+		unsigned long flags;
+		if (BIT_ACTL_LOW ==
+		    ((mldl_cfg->pdata->int_config) & BIT_ACTL))
+			flags = IRQF_TRIGGER_FALLING;
+		else
+			flags = IRQF_TRIGGER_RISING;
+
+		res =
+		    request_irq(mpuirq_dev_data.irq, mpuirq_handler, flags,
+				interface, &mpuirq_dev_data.irq);
+		if (res) {
+			dev_err(&mpu_client->adapter->dev,
+				"myirqtest: cannot register IRQ %d\n",
+				mpuirq_dev_data.irq);
+		} else {
+			res = misc_register(&mpuirq_device);
+			if (res < 0) {
+				dev_err(&mpu_client->adapter->dev,
+					"misc_register returned %d\n",
+					res);
+				free_irq(mpuirq_dev_data.irq,
+					 &mpuirq_dev_data.irq);
+			}
+		}
+
+	} else {
+		res = 0;
+	}
+
+	return res;
+}
+
+void mpuirq_exit(void)
+{
+	/* Free the IRQ first before flushing the work */
+	if (mpuirq_dev_data.irq > 0)
+		free_irq(mpuirq_dev_data.irq, &mpuirq_dev_data.irq);
+
+	flush_scheduled_work();
+
+	dev_info(mpuirq_device.this_device, "Unregistering %s\n",
+		 MPUIRQ_NAME);
+	misc_deregister(&mpuirq_device);
+
+	return;
+}
+
+module_param(interface, charp, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(interface, "The Interface name");
Index: Kernel/drivers/sensors/mpu3050/mpuirq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/mpuirq.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,29 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef __MPUIRQ__
+#define __MPUIRQ__
+
+#ifdef __KERNEL__
+#include <linux/i2c-dev.h>
+#endif
+
+#define MPUIRQ_ENABLE_DEBUG          (1)
+#define MPUIRQ_GET_INTERRUPT_CNT     (2)
+#define MPUIRQ_GET_IRQ_TIME          (3)
+#define MPUIRQ_GET_LED_VALUE         (4)
+#define MPUIRQ_SET_TIMEOUT           (5)
+#define MPUIRQ_SET_ACCEL_INFO        (6)
+#define MPUIRQ_SET_FREQUENCY_DIVIDER (7)
+
+#ifdef __KERNEL__
+
+void mpuirq_exit(void);
+int mpuirq_init(struct i2c_client *mpu_client);
+
+#endif
+
+#endif
Index: Kernel/drivers/sensors/mpu3050/slaveirq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/slaveirq.c	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,259 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include "mpu.h"
+#include "slaveirq.h"
+#include "mldl_cfg.h"
+#include "mpu-i2c.h"
+#include <linux/wait.h>
+#include <linux/slab.h>
+
+/* function which gets slave data and sends it to SLAVE */
+
+struct slaveirq_dev_data {
+	struct miscdevice dev;
+	struct i2c_client *slave_client;
+	struct irq_data data;
+	wait_queue_head_t slaveirq_wait;
+	int irq;
+	int pid;
+	int data_ready;
+	int timeout;
+};
+
+/* The following depends on patch fa1f68db6ca7ebb6fc4487ac215bffba06c01c28
+ * drivers: misc: pass miscdevice pointer via file private data
+ */
+static int slaveirq_open(struct inode *inode, struct file *file)
+{
+	/* Device node is availabe in the file->private_data, this is
+	 * exactly what we want so we leave it there */
+	struct slaveirq_dev_data *data =
+		container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	dev_dbg(data->dev.this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+	data->pid = current->pid;
+	return 0;
+}
+
+static int slaveirq_release(struct inode *inode, struct file *file)
+{
+	struct slaveirq_dev_data *data =
+		container_of(file->private_data, struct slaveirq_dev_data, dev);
+	dev_dbg(data->dev.this_device, "slaveirq_release\n");
+	return 0;
+}
+
+/* read function called when from /dev/slaveirq is read */
+static ssize_t slaveirq_read(struct file *file,
+			   char *buf, size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct slaveirq_dev_data *data =
+		container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	if (!data->data_ready) {
+		wait_event_interruptible_timeout(data->slaveirq_wait,
+						 data->data_ready,
+						 data->timeout);
+	}
+
+	if (data->data_ready && NULL != buf
+	    && count >= sizeof(data->data)) {
+		err = copy_to_user(buf, &data->data, sizeof(data->data));
+		data->data.data_type = 0;
+	} else {
+		return 0;
+	}
+	if (err != 0) {
+		dev_err(data->dev.this_device,
+			"Copy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	data->data_ready = 0;
+	len = sizeof(data->data);
+	return len;
+}
+
+unsigned int slaveirq_poll(struct file *file, struct poll_table_struct *poll)
+{
+	int mask = 0;
+	struct slaveirq_dev_data *data =
+		container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	poll_wait(file, &data->slaveirq_wait, poll);
+	if (data->data_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl - I/O control */
+static long slaveirq_ioctl(struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int tmp;
+	struct slaveirq_dev_data *data =
+		container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	switch (cmd) {
+	case SLAVEIRQ_SET_TIMEOUT:
+		data->timeout = arg;
+		break;
+
+	case SLAVEIRQ_GET_INTERRUPT_CNT:
+		tmp = data->data.interruptcount - 1;
+		if (data->data.interruptcount > 1)
+			data->data.interruptcount = 1;
+
+		if (copy_to_user((int *) arg, &tmp, sizeof(int)))
+			return -EFAULT;
+		break;
+	case SLAVEIRQ_GET_IRQ_TIME:
+		if (copy_to_user((int *) arg, &data->data.irqtime,
+				 sizeof(data->data.irqtime)))
+			return -EFAULT;
+		data->data.irqtime = 0;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+static irqreturn_t slaveirq_handler(int irq, void *dev_id)
+{
+	struct slaveirq_dev_data *data = (struct slaveirq_dev_data *)dev_id;
+	static int mycount;
+	struct timeval irqtime;
+	mycount++;
+
+	data->data.interruptcount++;
+
+	/* wake up (unblock) for reading data from userspace */
+	/* and ignore first interrupt generated in module init */
+	if (data->data.interruptcount > 1) {
+		data->data_ready = 1;
+
+		do_gettimeofday(&irqtime);
+		data->data.irqtime = (((long long) irqtime.tv_sec) << 32);
+		data->data.irqtime += irqtime.tv_usec;
+		data->data.data_type |= 1;
+
+		wake_up_interruptible(&data->slaveirq_wait);
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+/* define which file operations are supported */
+static const struct file_operations slaveirq_fops = {
+	.owner = THIS_MODULE,
+	.read = slaveirq_read,
+	.poll = slaveirq_poll,
+
+#if HAVE_COMPAT_IOCTL
+	.compat_ioctl = slaveirq_ioctl,
+#endif
+#if HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = slaveirq_ioctl,
+#endif
+	.open = slaveirq_open,
+	.release = slaveirq_release,
+};
+
+int slaveirq_init(struct i2c_adapter *slave_adapter,
+		  struct ext_slave_platform_data *pdata,
+		  char *name)
+{
+
+	int res;
+	struct slaveirq_dev_data *data;
+
+	if (!pdata->irq)
+		return -EINVAL;
+
+	pdata->irq_data = kzalloc(sizeof(*data),
+				GFP_KERNEL);
+	data = (struct slaveirq_dev_data *) pdata->irq_data;
+	if (!data)
+		return -ENOMEM;
+
+	data->dev.minor = MISC_DYNAMIC_MINOR;
+	data->dev.name = name;
+	data->dev.fops = &slaveirq_fops;
+	data->irq = pdata->irq;
+	data->pid = 0;
+	data->data_ready = 0;
+	data->timeout = 0;
+
+	res = request_irq(data->irq, slaveirq_handler, IRQF_TRIGGER_RISING,
+			  data->dev.name, data);
+
+	if (res) {
+		dev_err(&slave_adapter->dev,
+			"myirqtest: cannot register IRQ %d\n",
+			data->irq);
+		goto out_request_irq;
+	}
+
+	res = misc_register(&data->dev);
+	if (res < 0) {
+		dev_err(&slave_adapter->dev,
+			"misc_register returned %d\n",
+			res);
+		goto out_misc_register;
+	}
+
+	init_waitqueue_head(&data->slaveirq_wait);
+	return res;
+
+out_misc_register:
+	free_irq(data->irq, data);
+out_request_irq:
+	kfree(pdata->irq_data);
+	pdata->irq_data = NULL;
+
+	return res;
+}
+
+void slaveirq_exit(struct ext_slave_platform_data *pdata)
+{
+	struct slaveirq_dev_data *data = pdata->irq_data;
+
+	if (!pdata->irq_data || data->irq <= 0)
+		return;
+
+	dev_info(data->dev.this_device, "Unregistering %s\n",
+		 data->dev.name);
+
+	free_irq(data->irq, data);
+	misc_deregister(&data->dev);
+	kfree(pdata->irq_data);
+	pdata->irq_data = NULL;
+}
Index: Kernel/drivers/sensors/mpu3050/slaveirq.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/drivers/sensors/mpu3050/slaveirq.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,33 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef __SLAVEIRQ__
+#define __SLAVEIRQ__
+
+#ifdef __KERNEL__
+#include <linux/i2c-dev.h>
+#endif
+
+#include "mpu.h"
+#include "mpuirq.h"
+
+#define SLAVEIRQ_ENABLE_DEBUG          (1)
+#define SLAVEIRQ_GET_INTERRUPT_CNT     (2)
+#define SLAVEIRQ_GET_IRQ_TIME          (3)
+#define SLAVEIRQ_GET_LED_VALUE         (4)
+#define SLAVEIRQ_SET_TIMEOUT           (5)
+#define SLAVEIRQ_SET_SLAVE_INFO        (6)
+
+#ifdef __KERNEL__
+
+void slaveirq_exit(struct ext_slave_platform_data *pdata);
+int slaveirq_init(struct i2c_adapter *slave_adapter,
+		struct ext_slave_platform_data *pdata,
+		char *name);
+
+#endif
+
+#endif
Index: Kernel/drivers/sensors/Kconfig
===================================================================
--- Kernel.orig/drivers/sensors/Kconfig	2011-02-15 16:24:37.000000000 +0530
+++ Kernel/drivers/sensors/Kconfig	2011-02-17 20:39:52.639727417 +0530
@@ -10,5 +10,6 @@
 source "drivers/sensors/accel/Kconfig"
 source "drivers/sensors/compass/Kconfig"
 source "drivers/sensors/gyro-mpu3050/Kconfig"
+source "drivers/sensors/mpu3050/Kconfig"
 endif # NEW_SENSORS
 
Index: Kernel/drivers/sensors/Makefile
===================================================================
--- Kernel.orig/drivers/sensors/Makefile	2011-02-15 16:24:37.000000000 +0530
+++ Kernel/drivers/sensors/Makefile	2011-02-17 20:39:52.639727417 +0530
@@ -6,5 +6,6 @@
 obj-$(CONFIG_ACCEL)		+= accel/
 obj-$(CONFIG_OPTICAL)		+= optical/
 obj-$(CONFIG_COMPASS)		+= compass/
-obj-$(CONFIG_GYRO_MPU3050)    += gyro-mpu3050/
+obj-$(CONFIG_GYRO_MPU3050)	+= gyro-mpu3050/
+obj-$(CONFIG_SENSORS_MPU3050)	+= mpu3050/
 
Index: Kernel/arch/arm/configs/android_omap4tab_rev05_defconfig
===================================================================
--- Kernel.orig/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-02-17 18:53:23.000000000 +0530
+++ Kernel/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-02-17 20:39:52.639727417 +0530
@@ -805,13 +805,37 @@
 CONFIG_OPTICAL=y
 # CONFIG_OPTICAL_ISL29023 is not set
 CONFIG_OPTICAL_GP2A=y
-CONFIG_ACCEL=y
-CONFIG_ACCEL_KXSD9=y
-CONFIG_COMPASS=y
-# CONFIG_COMPASS_AK8973B is not set
-CONFIG_COMPASS_YAS530=y
-CONFIG_GYRO=y
-CONFIG_GYRO_MPU3050=y
+# CONFIG_ACCEL is not set
+# CONFIG_COMPASS is not set
+# CONFIG_GYRO is not set
+
+#
+# Motion Sensors Support
+#
+# CONFIG_MPU_NONE is not set
+CONFIG_SENSORS_MPU3050=y
+# CONFIG_SENSORS_MPU6000 is not set
+# CONFIG_SENSORS_ACCELEROMETER_NONE is not set
+# CONFIG_SENSORS_ADXL346 is not set
+# CONFIG_SENSORS_BMA150 is not set
+# CONFIG_SENSORS_BMA222 is not set
+CONFIG_SENSORS_KXSD9=y
+# CONFIG_SENSORS_KXTF9 is not set
+# CONFIG_SENSORS_LIS331DLH is not set
+# CONFIG_SENSORS_LSM303DLHA is not set
+# CONFIG_SENSORS_MMA8450 is not set
+# CONFIG_SENSORS_MMA8451 is not set
+# CONFIG_SENSORS_COMPASS_NONE is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_SENSORS_MMC314X is not set
+# CONFIG_SENSORS_AMI30X is not set
+# CONFIG_SENSORS_HMC5883 is not set
+# CONFIG_SENSORS_LSM303DLHM is not set
+CONFIG_SENSORS_YAS529=y
+# CONFIG_SENSORS_HSCDTD00XX is not set
+CONFIG_SENSORS_PRESSURE_NONE=y
+# CONFIG_SENSORS_BMA085 is not set
+# CONFIG_SENSORS_MPU_DEBUG is not set
 CONFIG_MISC_DEVICES=y
 # CONFIG_AD525X_DPOT is not set
 CONFIG_ANDROID_PMEM=y
@@ -822,7 +846,6 @@
 # CONFIG_SENSORS_TSL2550 is not set
 CONFIG_TWL6030_POWER_OFF=y
 # CONFIG_SENSORS_BH1780 is not set
-CONFIG_SENSORS_AK8975=y
 # CONFIG_TWL6040_VIB is not set
 # CONFIG_DS1682 is not set
 # CONFIG_TI_DAC7512 is not set
Index: Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c
===================================================================
--- Kernel.orig/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-02-17 18:53:23.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-02-17 20:39:52.639727417 +0530
@@ -65,6 +65,7 @@
 #include <plat/opp_twl_tps.h>
 #include <linux/fsa9480.h>
 #include <linux/gp2a.h>
+#include <linux/mpu.h>
 
 #include <linux/i2c/twl6030-gpadc.h>
 #include "board-4430sdp-wifi.h"
@@ -267,6 +268,36 @@
        .reset_cb       = omap4_fsa9480_reset_cb,
 };
 
+
+#define SENSOR_MPU_NAME "mpu3050"
+
+static struct mpu3050_platform_data mpu_data = {
+	.int_config  = 0x12,
+	.orientation = {  -1,  0,  0, 
+			   0,  1,  0, 
+			   0,  0, -1 },
+	/* accel */
+	.accel = {
+	.get_slave_descr = get_accel_slave_descr,
+	.adapt_num   = 4,
+	.bus         = EXT_SLAVE_BUS_SECONDARY,
+	.address     = 0x18,
+	.orientation = {  -1,  0,  0, 
+			   0,  1,  0, 
+			   0,  0, -1 },
+	 },
+	/* compass */
+	.compass = {
+	.get_slave_descr = get_compass_slave_descr,
+	.adapt_num   = 4,
+	.bus         = EXT_SLAVE_BUS_PRIMARY,
+	.address     = 0x2E,
+	.orientation = { 1, 0, 0, 
+			 0, 1, 0, 
+			 0, 0, 1 },
+	 },
+};
+
 /* For gp2a light/proximity sensor */
 
 static int gp2a_power(bool on)
@@ -1505,22 +1536,27 @@
 
 #elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5 )
 	{
-		I2C_BOARD_INFO("kxsd9", 0x18),
-		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
-	},
-	{
-		I2C_BOARD_INFO("mpu3050", 0x68),
-		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
-	},
+		I2C_BOARD_INFO(SENSOR_MPU_NAME, 0x68),
+		.irq = OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
+		.platform_data = &mpu_data,
+	},
+//	{
+//		I2C_BOARD_INFO("kxsd9", 0x18),
+//		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
+//	},
+//	{
+//		I2C_BOARD_INFO("mpu3050", 0x68),
+//		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
+//	},
 	{
 		I2C_BOARD_INFO("gp2a",0x44),
 		.platform_data = &gp2a_pdata,
 		
 	},
-	{
-		I2C_BOARD_INFO("yas530",0x2E),
-		
-	},
+//	{
+//		I2C_BOARD_INFO("yas530",0x2E),
+//		
+//	},
         {
                I2C_BOARD_INFO("fsa9480", (0x4A >> 1)),
                .platform_data = &omap4_fsa9480_pdata,
@@ -2122,6 +2158,11 @@
         omap4_ctrl_pad_writel(control_io2_3 & 0xFFFFFFF0,
                 OMAP4_CTRL_MODULE_PAD_CORE_CONTROL_LPDDR2IO2_3);
 }
+static void omap4_mpl_init(void)
+{
+	gpio_request(OMAP4TAB_MPU3050_INT_GPIO,"MPUIRQ");
+	gpio_direction_input(OMAP4TAB_MPU3050_INT_GPIO);
+}
 
 static void __init omap4_tab_10_1_init(void)
 {
@@ -2147,7 +2188,8 @@
 	wake_lock_init(&uart_lock, WAKE_LOCK_SUSPEND, "uart_wake_lock");
 	omap_serial_init(omap_serial_platform_data);
 	omap4_twl6030_hsmmc_init(mmc);
-	
+	omap4_mpl_init();
+
 #ifdef CONFIG_TIWLAN_SDIO
 	config_wlan_mux();
 #endif
Index: Kernel/include/linux/mpu.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/include/linux/mpu.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,401 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef __MPU_H_
+#define __MPU_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+#ifdef M_HW
+#include "mpu6000.h"
+#else
+#include "mpu3050.h"
+#endif
+
+/* Number of axes on each sensor */
+#define GYRO_NUM_AXES               (3)
+#define ACCEL_NUM_AXES              (3)
+#define COMPASS_NUM_AXES            (3)
+
+/* IOCTL commands for /dev/mpu */
+#define MPU_SET_MPU_CONFIG          (0x00)
+#define MPU_SET_INT_CONFIG          (0x01)
+#define MPU_SET_EXT_SYNC            (0x02)
+#define MPU_SET_FULL_SCALE          (0x03)
+#define MPU_SET_LPF                 (0x04)
+#define MPU_SET_CLK_SRC             (0x05)
+#define MPU_SET_DIVIDER             (0x06)
+#define MPU_SET_LEVEL_SHIFTER       (0x07)
+#define MPU_SET_DMP_ENABLE          (0x08)
+#define MPU_SET_FIFO_ENABLE         (0x09)
+#define MPU_SET_DMP_CFG1            (0x0a)
+#define MPU_SET_DMP_CFG2            (0x0b)
+#define MPU_SET_OFFSET_TC           (0x0c)
+#define MPU_SET_RAM                 (0x0d)
+
+#define MPU_SET_PLATFORM_DATA       (0x0e)
+
+#define MPU_GET_MPU_CONFIG          (0x80)
+#define MPU_GET_INT_CONFIG          (0x81)
+#define MPU_GET_EXT_SYNC            (0x82)
+#define MPU_GET_FULL_SCALE          (0x83)
+#define MPU_GET_LPF                 (0x84)
+#define MPU_GET_CLK_SRC             (0x85)
+#define MPU_GET_DIVIDER             (0x86)
+#define MPU_GET_LEVEL_SHIFTER       (0x87)
+#define MPU_GET_DMP_ENABLE          (0x88)
+#define MPU_GET_FIFO_ENABLE         (0x89)
+#define MPU_GET_DMP_CFG1            (0x8a)
+#define MPU_GET_DMP_CFG2            (0x8b)
+#define MPU_GET_OFFSET_TC           (0x8c)
+#define MPU_GET_RAM                 (0x8d)
+
+#define MPU_READ_REGISTER           (0x40)
+#define MPU_WRITE_REGISTER          (0x41)
+#define MPU_READ_MEMORY             (0x42)
+#define MPU_WRITE_MEMORY            (0x43)
+
+#define MPU_SUSPEND                 (0x44)
+#define MPU_RESUME                  (0x45)
+#define MPU_READ_COMPASS            (0x46)
+#define MPU_READ_ACCEL              (0x47)
+#define MPU_READ_PRESSURE           (0x48)
+
+#define MPU_CONFIG_ACCEL            (0x20)
+#define MPU_CONFIG_COMPASS          (0x21)
+#define MPU_CONFIG_PRESSURE         (0x22)
+
+/* Structure for the following IOCTL's:
+   MPU_SET_RAM
+   MPU_GET_RAM
+   MPU_READ_REGISTER
+   MPU_WRITE_REGISTER
+   MPU_READ_MEMORY
+   MPU_WRITE_MEMORY
+*/
+struct mpu_read_write {
+	unsigned short address;
+	unsigned short length;
+	unsigned char *data;
+};
+
+struct irq_data {
+	int interruptcount;
+	unsigned long long irqtime;
+	int data_type;
+	int data_size;
+	void *data;
+};
+enum ext_slave_config_key {
+    MPU_SLAVE_CONFIG_ODR_SUSPEND,
+    MPU_SLAVE_CONFIG_ODR_RESUME,
+    MPU_SLAVE_CONFIG_FSR_SUSPEND,
+    MPU_SLAVE_CONFIG_FSR_RESUME,
+    MPU_SLAVE_CONFIG_MOT_THS,
+    MPU_SLAVE_CONFIG_NMOT_THS,
+    MPU_SLAVE_CONFIG_MOT_DUR,
+    MPU_SLAVE_CONFIG_NMOT_DUR,
+    MPU_SLAVE_CONFIG_NUM_CONFIG_KEYS,
+};
+/* Structure for the following IOCTS's
+ * MPU_CONFIG_ACCEL
+ * MPU_CONFIG_COMPASS
+ * MPU_CONFIG_PRESSURE
+ */
+struct ext_slave_config {
+	int key;
+	int len;
+	void *data;
+};
+
+enum ext_slave_type {
+	EXT_SLAVE_TYPE_GYROSCOPE,
+	EXT_SLAVE_TYPE_ACCELEROMETER,
+	EXT_SLAVE_TYPE_COMPASS,
+	EXT_SLAVE_TYPE_PRESSURE,
+	/*EXT_SLAVE_TYPE_TEMPERATURE */
+};
+
+enum ext_slave_id {
+	ID_INVALID = 0,
+
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_ADI346,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA8451,
+	ACCEL_ID_MPU6000,
+
+	COMPASS_ID_AKM,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_HSCDTD00XX,
+
+	PRESSURE_ID_BMA085,
+};
+
+enum ext_slave_endian {
+	EXT_SLAVE_BIG_ENDIAN,
+	EXT_SLAVE_LITTLE_ENDIAN,
+	EXT_SLAVE_FS8_BIG_ENDIAN,
+	EXT_SLAVE_FS16_BIG_ENDIAN,
+};
+
+enum ext_slave_bus {
+	EXT_SLAVE_BUS_INVALID = -1,
+	EXT_SLAVE_BUS_PRIMARY = 0,
+	EXT_SLAVE_BUS_SECONDARY = 1
+};
+
+
+/**
+ *  struct ext_slave_platform_data - Platform data for mpu3050 slave devices
+ *
+ *  @get_slave_descr: Function pointer to retrieve the struct ext_slave_descr
+ *                    for this slave
+ *  @irq: the irq number attached to the slave if any.
+ *  @adapt_num: the I2C adapter number.
+ *  @bus: the bus the slave is attached to: enum ext_slave_bus
+ *  @address: the I2C slave address of the slave device.
+ *  @orientation: the mounting matrix of the device relative to MPU.
+ *  @irq_data: private data for the slave irq handler
+ *  @private_data: additional data, user customizable.  Not touched by the MPU
+ *                 driver.
+ *
+ * The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct ext_slave_platform_data {
+	struct ext_slave_descr *(*get_slave_descr) (void);
+	int irq;
+	int adapt_num;
+	int bus;
+	unsigned char address;
+	signed char orientation[9];
+	void *irq_data;
+	void *private_data;
+};
+
+
+struct tFixPntRange {
+	long mantissa;
+	long fraction;
+};
+
+/**
+ *  struct ext_slave_descr - Description of the slave device for programming.
+ *
+ *  @suspend:	function pointer to put the device in suspended state
+ *  @resume:	function pointer to put the device in running state
+ *  @read:	function that reads the device data
+ *  @init:	function used to preallocate memory used by the driver
+ *  @exit:	function used to free memory allocated for the driver
+ *  @config:	function used to configure the device
+ *
+ *  @name:	text name of the device
+ *  @type:	device type. enum ext_slave_type
+ *  @id:	enum ext_slave_id
+ *  @reg:	starting register address to retrieve data.
+ *  @len:	length in bytes of the sensor data.  Should be 6.
+ *  @endian:	byte order of the data. enum ext_slave_endian
+ *  @range:	full scale range of the slave ouput: struct tFixPntRange
+ *
+ *  Defines the functions and information about the slave the mpu3050 needs to
+ *  use the slave device.
+ */
+struct ext_slave_descr {
+	int (*init) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata);
+	int (*exit) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata);
+	int (*suspend) (void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata);
+	int (*resume) (void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata);
+	int (*read) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata,
+		     unsigned char *data);
+	int (*config) (void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       struct ext_slave_config *config);
+
+	char *name;
+	unsigned char type;
+	unsigned char id;
+	unsigned char reg;
+	unsigned int len;
+	unsigned char endian;
+	struct tFixPntRange range;
+};
+
+/**
+ * struct mpu3050_platform_data - Platform data for the mpu3050 driver
+ * @int_config:		Bits [7:3] of the int config register.
+ * @orientation:	Orientation matrix of the gyroscope
+ * @level_shifter:	0: VLogic, 1: VDD
+ * @accel:		Accel platform data
+ * @compass:		Compass platform data
+ * @pressure:		Pressure platform data
+ *
+ * Contains platform specific information on how to configure the MPU3050 to
+ * work on this platform.  The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct mpu3050_platform_data {
+	unsigned char int_config;
+	signed char orientation[MPU_NUM_AXES * MPU_NUM_AXES];
+	unsigned char level_shifter;
+	struct ext_slave_platform_data accel;
+	struct ext_slave_platform_data compass;
+	struct ext_slave_platform_data pressure;
+};
+
+
+/*
+    Accelerometer
+*/
+#define get_accel_slave_descr NULL
+
+#ifdef CONFIG_SENSORS_ADXL346	/* ADI accelerometer */
+struct ext_slave_descr *adxl346_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr adxl346_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_BMA150	/* Bosch accelerometer */
+struct ext_slave_descr *bma150_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr bma150_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_BMA222	/* Bosch 222 accelerometer */
+struct ext_slave_descr *bma222_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr bma222_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_KXSD9	/* Kionix accelerometer */
+struct ext_slave_descr *kxsd9_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr kxsd9_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_KXTF9	/* Kionix accelerometer */
+struct ext_slave_descr *kxtf9_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr kxtf9_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_LIS331DLH	/* ST accelerometer */
+struct ext_slave_descr *lis331dlh_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr lis331dlh_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_LSM303DLHA	/* ST accelerometer */
+struct ext_slave_descr *lsm303dlha_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr lsm303dlha_get_slave_descr
+#endif
+
+/* MPU6000 Accel */
+#if defined(CONFIG_SENSORS_MPU6000) || defined(CONFIG_SENSORS_MPU6000_MODULE)
+struct ext_slave_descr *mantis_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr mantis_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_MMA8450	/* Freescale accelerometer */
+struct ext_slave_descr *mma8450_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr mma8450_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_MMA8451	/* Freescale accelerometer */
+struct ext_slave_descr *mma8451_get_slave_descr(void);
+#undef get_accel_slave_descr
+#define get_accel_slave_descr mma8451_get_slave_descr
+#endif
+
+
+/*
+    Compass
+*/
+#define get_compass_slave_descr NULL
+
+#ifdef CONFIG_SENSORS_AK8975	/* AKM compass */
+struct ext_slave_descr *ak8975_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr ak8975_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_AMI30X	/* AICHI Steel compass */
+struct ext_slave_descr *ami30x_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr ami30x_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_HMC5883	/* Honeywell compass */
+struct ext_slave_descr *hmc5883_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr hmc5883_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_MMC314X	/* MEMSIC compass */
+struct ext_slave_descr *mmc314x_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr mmc314x_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_LSM303DLHM	/* ST compass */
+struct ext_slave_descr *lsm303dlhm_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr lsm303dlhm_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_YAS529	/* Yamaha compass */
+struct ext_slave_descr *yas529_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr yas529_get_slave_descr
+#endif
+
+#ifdef CONFIG_SENSORS_HSCDTD00XX	/* Alps compass */
+struct ext_slave_descr *hscdtd00xx_get_slave_descr(void);
+#undef get_compass_slave_descr
+#define get_compass_slave_descr hscdtd00xx_get_slave_descr
+#endif
+
+/*
+    Pressure
+*/
+#define get_pressure_slave_descr NULL
+
+#ifdef CONFIG_SENSORS_BMA085	/* BMA pressure */
+struct ext_slave_descr *bma085_get_slave_descr(void);
+#undef get_pressure_slave_descr
+#define get_pressure_slave_descr bma085_get_slave_descr
+#endif
+
+#endif				/* __MPU_H_ */
Index: Kernel/include/linux/mpu3050.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ Kernel/include/linux/mpu3050.h	2011-02-17 20:39:52.639727417 +0530
@@ -0,0 +1,242 @@
+/*
+ $License:
+    Copyright (C) 2010 InvenSense Corporation, All Rights Reserved.
+ $
+ */
+
+#ifndef __MPU3050_H_
+#define __MPU3050_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+#ifdef M_HW
+#error MPU6000 build including MPU3050 header
+#endif
+
+#define MPU_NAME "mpu3050"
+#define DEFAULT_MPU_SLAVEADDR       0x68
+
+/*==== MPU REGISTER SET ====*/
+enum mpu_register {
+	MPUREG_WHO_AM_I = 0,	/* 00 0x00 */
+	MPUREG_PRODUCT_ID,	/* 01 0x01 */
+	MPUREG_02_RSVD,		/* 02 0x02 */
+	MPUREG_03_RSVD,		/* 03 0x03 */
+	MPUREG_04_RSVD,		/* 04 0x04 */
+	MPUREG_XG_OFFS_TC,	/* 05 0x05 */
+	MPUREG_06_RSVD,		/* 06 0x06 */
+	MPUREG_07_RSVD,		/* 07 0x07 */
+	MPUREG_YG_OFFS_TC,	/* 08 0x08 */
+	MPUREG_09_RSVD,		/* 09 0x09 */
+	MPUREG_0A_RSVD,		/* 10 0x0a */
+	MPUREG_ZG_OFFS_TC,	/* 11 0x0b */
+	MPUREG_X_OFFS_USRH,	/* 12 0x0c */
+	MPUREG_X_OFFS_USRL,	/* 13 0x0d */
+	MPUREG_Y_OFFS_USRH,	/* 14 0x0e */
+	MPUREG_Y_OFFS_USRL,	/* 15 0x0f */
+	MPUREG_Z_OFFS_USRH,	/* 16 0x10 */
+	MPUREG_Z_OFFS_USRL,	/* 17 0x11 */
+	MPUREG_FIFO_EN1,	/* 18 0x12 */
+	MPUREG_FIFO_EN2,	/* 19 0x13 */
+	MPUREG_AUX_SLV_ADDR,	/* 20 0x14 */
+	MPUREG_SMPLRT_DIV,	/* 21 0x15 */
+	MPUREG_DLPF_FS_SYNC,	/* 22 0x16 */
+	MPUREG_INT_CFG,		/* 23 0x17 */
+	MPUREG_ACCEL_BURST_ADDR,/* 24 0x18 */
+	MPUREG_19_RSVD,		/* 25 0x19 */
+	MPUREG_INT_STATUS,	/* 26 0x1a */
+	MPUREG_TEMP_OUT_H,	/* 27 0x1b */
+	MPUREG_TEMP_OUT_L,	/* 28 0x1c */
+	MPUREG_GYRO_XOUT_H,	/* 29 0x1d */
+	MPUREG_GYRO_XOUT_L,	/* 30 0x1e */
+	MPUREG_GYRO_YOUT_H,	/* 31 0x1f */
+	MPUREG_GYRO_YOUT_L,	/* 32 0x20 */
+	MPUREG_GYRO_ZOUT_H,	/* 33 0x21 */
+	MPUREG_GYRO_ZOUT_L,	/* 34 0x22 */
+	MPUREG_23_RSVD,		/* 35 0x23 */
+	MPUREG_24_RSVD,		/* 36 0x24 */
+	MPUREG_25_RSVD,		/* 37 0x25 */
+	MPUREG_26_RSVD,		/* 38 0x26 */
+	MPUREG_27_RSVD,		/* 39 0x27 */
+	MPUREG_28_RSVD,		/* 40 0x28 */
+	MPUREG_29_RSVD,		/* 41 0x29 */
+	MPUREG_2A_RSVD,		/* 42 0x2a */
+	MPUREG_2B_RSVD,		/* 43 0x2b */
+	MPUREG_2C_RSVD,		/* 44 0x2c */
+	MPUREG_2D_RSVD,		/* 45 0x2d */
+	MPUREG_2E_RSVD,		/* 46 0x2e */
+	MPUREG_2F_RSVD,		/* 47 0x2f */
+	MPUREG_30_RSVD,		/* 48 0x30 */
+	MPUREG_31_RSVD,		/* 49 0x31 */
+	MPUREG_32_RSVD,		/* 50 0x32 */
+	MPUREG_33_RSVD,		/* 51 0x33 */
+	MPUREG_34_RSVD,		/* 52 0x34 */
+	MPUREG_DMP_CFG_1,	/* 53 0x35 */
+	MPUREG_DMP_CFG_2,	/* 54 0x36 */
+	MPUREG_BANK_SEL,	/* 55 0x37 */
+	MPUREG_MEM_START_ADDR,	/* 56 0x38 */
+	MPUREG_MEM_R_W,		/* 57 0x39 */
+	MPUREG_FIFO_COUNTH,	/* 58 0x3a */
+	MPUREG_FIFO_COUNTL,	/* 59 0x3b */
+	MPUREG_FIFO_R_W,	/* 60 0x3c */
+	MPUREG_USER_CTRL,	/* 61 0x3d */
+	MPUREG_PWR_MGM,		/* 62 0x3e */
+	MPUREG_3F_RSVD,		/* 63 0x3f */
+	NUM_OF_MPU_REGISTERS	/* 64 0x40 */
+};
+
+/*==== BITS FOR MPU ====*/
+
+/*---- MPU 'FIFO_EN1' register (12) ----*/
+#define BIT_TEMP_OUT                0x80
+#define BIT_GYRO_XOUT               0x40
+#define BIT_GYRO_YOUT               0x20
+#define BIT_GYRO_ZOUT               0x10
+#define BIT_ACCEL_XOUT              0x08
+#define BIT_ACCEL_YOUT              0x04
+#define BIT_ACCEL_ZOUT              0x02
+#define BIT_AUX_1OUT                0x01
+/*---- MPU 'FIFO_EN2' register (13) ----*/
+#define BIT_AUX_2OUT                0x02
+#define BIT_AUX_3OUT                0x01
+/*---- MPU 'DLPF_FS_SYNC' register (16) ----*/
+#define BITS_EXT_SYNC_NONE          0x00
+#define BITS_EXT_SYNC_TEMP          0x20
+#define BITS_EXT_SYNC_GYROX         0x40
+#define BITS_EXT_SYNC_GYROY         0x60
+#define BITS_EXT_SYNC_GYROZ         0x80
+#define BITS_EXT_SYNC_ACCELX        0xA0
+#define BITS_EXT_SYNC_ACCELY        0xC0
+#define BITS_EXT_SYNC_ACCELZ        0xE0
+#define BITS_EXT_SYNC_MASK          0xE0
+#define BITS_FS_250DPS              0x00
+#define BITS_FS_500DPS              0x08
+#define BITS_FS_1000DPS             0x10
+#define BITS_FS_2000DPS             0x18
+#define BITS_FS_MASK                0x18
+#define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
+#define BITS_DLPF_CFG_188HZ         0x01
+#define BITS_DLPF_CFG_98HZ          0x02
+#define BITS_DLPF_CFG_42HZ          0x03
+#define BITS_DLPF_CFG_20HZ          0x04
+#define BITS_DLPF_CFG_10HZ          0x05
+#define BITS_DLPF_CFG_5HZ           0x06
+#define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
+#define BITS_DLPF_CFG_MASK          0x07
+/*---- MPU 'INT_CFG' register (17) ----*/
+#define BIT_ACTL                    0x80
+#define BIT_ACTL_LOW                0x80
+#define BIT_ACTL_HIGH               0x00
+#define BIT_OPEN                    0x40
+#define BIT_OPEN_DRAIN              0x40
+#define BIT_PUSH_PULL               0x00
+#define BIT_LATCH_INT_EN            0x20
+#define BIT_LATCH_INT_EN            0x20
+#define BIT_INT_PULSE_WIDTH_50US    0x00
+#define BIT_INT_ANYRD_2CLEAR        0x10
+#define BIT_INT_STAT_READ_2CLEAR    0x00
+#define BIT_MPU_RDY_EN              0x04
+#define BIT_DMP_INT_EN              0x02
+#define BIT_RAW_RDY_EN              0x01
+/*---- MPU 'INT_STATUS' register (1A) ----*/
+#define BIT_INT_STATUS_FIFO_OVERLOW 0x80
+#define BIT_MPU_RDY                 0x04
+#define BIT_DMP_INT                 0x02
+#define BIT_RAW_RDY                 0x01
+/*---- MPU 'BANK_SEL' register (37) ----*/
+#define BIT_PRFTCH_EN               0x20
+#define BIT_CFG_USER_BANK           0x10
+#define BITS_MEM_SEL                0x0f
+/*---- MPU 'USER_CTRL' register (3D) ----*/
+#define BIT_DMP_EN                  0x80
+#define BIT_FIFO_EN                 0x40
+#define BIT_AUX_IF_EN               0x20
+#define BIT_AUX_RD_LENG             0x10
+#define BIT_AUX_IF_RST              0x08
+#define BIT_DMP_RST                 0x04
+#define BIT_FIFO_RST                0x02
+#define BIT_GYRO_RST                0x01
+/*---- MPU 'PWR_MGM' register (3E) ----*/
+#define BIT_H_RESET                 0x80
+#define BIT_SLEEP                   0x40
+#define BIT_STBY_XG                 0x20
+#define BIT_STBY_YG                 0x10
+#define BIT_STBY_ZG                 0x08
+#define BITS_CLKSEL                 0x07
+
+/*---- MPU Silicon Revision ----*/
+#define MPU_SILICON_REV_A4           1	/* MPU A4 Device */
+#define MPU_SILICON_REV_B1           2	/* MPU B1 Device */
+#define MPU_SILICON_REV_B4           3	/* MPU B4 Device */
+#define MPU_SILICON_REV_B6           4	/* MPU B6 Device */
+
+/*---- MPU Memory ----*/
+#define MPU_MEM_BANK_SIZE           (256)
+#define FIFO_HW_SIZE                (512)
+
+enum MPU_MEMORY_BANKS {
+	MPU_MEM_RAM_BANK_0 = 0,
+	MPU_MEM_RAM_BANK_1,
+	MPU_MEM_RAM_BANK_2,
+	MPU_MEM_RAM_BANK_3,
+	MPU_MEM_NUM_RAM_BANKS,
+	MPU_MEM_OTP_BANK_0 = MPU_MEM_NUM_RAM_BANKS,
+	/* This one is always last */
+	MPU_MEM_NUM_BANKS
+};
+
+#define MPU_NUM_AXES (3)
+
+/*---- structure containing control variables used by MLDL ----*/
+/*---- MPU clock source settings ----*/
+/*---- MPU filter selections ----*/
+enum mpu_filter {
+	MPU_FILTER_256HZ_NOLPF2 = 0,
+	MPU_FILTER_188HZ,
+	MPU_FILTER_98HZ,
+	MPU_FILTER_42HZ,
+	MPU_FILTER_20HZ,
+	MPU_FILTER_10HZ,
+	MPU_FILTER_5HZ,
+	MPU_FILTER_2100HZ_NOLPF,
+	NUM_MPU_FILTER
+};
+
+enum mpu_fullscale {
+	MPU_FS_250DPS = 0,
+	MPU_FS_500DPS,
+	MPU_FS_1000DPS,
+	MPU_FS_2000DPS,
+	NUM_MPU_FS
+};
+
+enum mpu_clock_sel {
+	MPU_CLK_SEL_INTERNAL = 0,
+	MPU_CLK_SEL_PLLGYROX,
+	MPU_CLK_SEL_PLLGYROY,
+	MPU_CLK_SEL_PLLGYROZ,
+	MPU_CLK_SEL_PLLEXT32K,
+	MPU_CLK_SEL_PLLEXT19M,
+	MPU_CLK_SEL_RESERVED,
+	MPU_CLK_SEL_STOP,
+	NUM_CLK_SEL
+};
+
+enum mpu_ext_sync {
+	MPU_EXT_SYNC_NONE = 0,
+	MPU_EXT_SYNC_TEMP,
+	MPU_EXT_SYNC_GYROX,
+	MPU_EXT_SYNC_GYROY,
+	MPU_EXT_SYNC_GYROZ,
+	MPU_EXT_SYNC_ACCELX,
+	MPU_EXT_SYNC_ACCELY,
+	MPU_EXT_SYNC_ACCELZ,
+	NUM_MPU_EXT_SYNC
+};
+
+#define DLPF_FS_SYNC_VALUE(ext_sync, full_scale, lpf) \
+    ((ext_sync << 5) | (full_scale << 3) | lpf)
+
+#endif				/* __MPU3050_H_ */
