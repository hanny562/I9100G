Index: android-2.6.35/arch/arm/mach-omap2/board-omap4tab10-1.c
===================================================================
--- android-2.6.35.orig/arch/arm/mach-omap2/board-omap4tab10-1.c	2010-12-24 21:15:41.081037141 +0530
+++ android-2.6.35/arch/arm/mach-omap2/board-omap4tab10-1.c	2010-12-24 21:15:43.981667952 +0530
@@ -66,6 +66,12 @@
 #define CONTROL_CORE_PAD0_I2C3_SDA_PAD1_I2C4_SCL	0x4A10012C
 #define CONTROL_CORE_PAD0_I2C4_SDA_PAD1_MCSPI1_CLK	0x4A100130
 
+/* For Battery Driver */
+#define OMAP4430_GPIO_TA_NCONNECTED			151
+#define OMAP4430_GPIO_TA_EN				54
+#define OMAP4430_GPIO_TA_NSTAT				11
+#define OMAP4430_GPIO_TA_NCHG				12
+#define OMAP4430_GPIO_USBSW_NINT			44
 
 static unsigned backlight_gpio;
 static unsigned mlcd1_enable_gpio;
@@ -309,6 +315,134 @@
 	.dev.platform_data = &pwmblk_platformdata,
 };
 
+static struct resource samsung_charger_resources[] = {
+	[0] = { // USB IRQ
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
+	},
+	[1] = { // TA IRQ
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE | IORESOURCE_IRQ_LOWEDGE,
+	},
+	[2] = { // TA_NCHG
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE | IORESOURCE_IRQ_LOWEDGE,
+	},
+	[3] = { // TA_NSTAT
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE | IORESOURCE_IRQ_LOWEDGE,
+	},
+	[4] = { // TA_EN
+		.start = 0,
+		.end   = 0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static int samsung_charger_config_data[] = {
+	// [ CHECK VF USING ADC ]
+	/*   1. ENABLE  (true, flase) */
+	true,
+	/*   2. ADCPORT (ADCPORT NUM) */
+	1,
+	// [ SUPPORT TA_NCHG IRQ FOR CHECKING FULL ]
+	/*   1. ENABLE  (true, flase) */
+	true,
+};
+
+static int samsung_battery_config_data[] = {
+	// [ SUPPORT MONITORING CHARGE CURRENT FOR CHECKING FULL ]
+	/* ENABLE  (true, flase) */
+	true,
+
+	// [ SUPPORT MONITORING TEMPERATURE OF THE SYSTEM FOR BLOCKING CHARGE ]
+	/* ENABLE  (true, flase) */
+	false,  // TODO: Need to support this and make this as 'true',
+};
+
+static struct platform_device samsung_charger_device = {
+	.name		= "secChargerDev",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(samsung_charger_resources),
+	.resource	= samsung_charger_resources,
+	.dev = {
+		.platform_data = &samsung_charger_config_data,
+	},
+};
+
+static struct platform_device samsung_battery_device = {
+	.name		= "secBattMonitor",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev = {
+		.platform_data = &samsung_battery_config_data,
+	},
+};
+
+static inline void __init samsung_omap4_battery_init(void)
+{
+	/* Set Pin Muxing */
+	omap_writew(0x0103, 0x4A100154);	// TA_nCONNECTED
+	omap_writew(0x0103, 0x4A1001AE);	// TA_nSTAT
+	omap_writew(0x0103, 0x4A1001B0);	// TA_nCHG
+	omap_writew(0x0003, 0x4A10007C);	// TA_EN
+	omap_writew(0x0003, 0x4A100068);	// USB IRQ
+
+	/* TA_CURRENT_SEL*/
+	if (gpio_request(OMAP4430_GPIO_USBSW_NINT, "ta_current_sel irq") < 0) {
+		printk(KERN_ERR "Failed to request GPIO%d for ta_current_sel IRQ\n",
+				OMAP4430_GPIO_USBSW_NINT);
+		samsung_charger_resources[0].start = -1;
+	} else  {
+		samsung_charger_resources[0].start = gpio_to_irq(OMAP4430_GPIO_USBSW_NINT);
+		gpio_direction_input(OMAP4430_GPIO_USBSW_NINT);
+	}
+
+	/* TA_nCONNECTED */
+	if (gpio_request(OMAP4430_GPIO_TA_NCONNECTED, "ta_nconnected irq") < 0) {
+		printk(KERN_ERR "Failed to request GPIO%d for ta_nconnected IRQ\n",
+				OMAP4430_GPIO_TA_NCONNECTED);
+		samsung_charger_resources[1].start = -1;
+	} else {
+		samsung_charger_resources[1].start = gpio_to_irq(OMAP4430_GPIO_TA_NCONNECTED);
+		gpio_direction_input(OMAP4430_GPIO_TA_NCONNECTED);
+	}
+
+	/* TA_nCHG */
+	if (gpio_request(OMAP4430_GPIO_TA_NCHG, "charge full irq") < 0) {
+		printk(KERN_ERR "Failed to request GPIO%d for charge full IRQ\n",
+				OMAP4430_GPIO_TA_NCHG);
+		samsung_charger_resources[2].start = -1;
+	} else {
+		samsung_charger_resources[2].start = gpio_to_irq(OMAP4430_GPIO_TA_NCHG);
+		gpio_direction_input(OMAP4430_GPIO_TA_NCHG);
+	}
+
+	/* TA_nSTAT */
+	if (gpio_request(OMAP4430_GPIO_TA_NSTAT, "charge full irq") < 0) {
+		printk(KERN_ERR "Failed to request GPIO%d for charge full IRQ\n",
+				OMAP4430_GPIO_TA_NSTAT);
+		samsung_charger_resources[3].start = -1;
+	} else {
+		samsung_charger_resources[3].start = gpio_to_irq(OMAP4430_GPIO_TA_NSTAT);
+		gpio_direction_input(OMAP4430_GPIO_TA_NSTAT);
+	}
+
+	/* TA_EA */
+	if (gpio_request(OMAP4430_GPIO_TA_EN, "Charge enable gpio") < 0) {
+		printk(KERN_ERR "Failed to request GPIO%d for charge enable gpio\n",
+				OMAP4430_GPIO_TA_EN);
+		samsung_charger_resources[4].start = -1;
+	} else {
+		samsung_charger_resources[4].start = gpio_to_irq(OMAP4430_GPIO_TA_EN);
+		gpio_direction_output(OMAP4430_GPIO_TA_EN, 0);
+	}
+}
+
 static struct platform_device *omap4tab_devices[] __initdata = {
 	&wl128x_device,
 	&omap4tab_hdmi_audio_device,
@@ -318,6 +452,8 @@
 	&samsung_omap4_gyro_lp530al_device,
 	&pwmbacklight_device,
 	&pwm_bl_device,
+	&samsung_battery_device,
+	&samsung_charger_device,
 };
 
 static void __init omap4_tab_10_1_init_irq(void)
@@ -639,6 +775,9 @@
 		I2C_BOARD_INFO("isl29023", 0x44),
 		.irq	= OMAP_GPIO_IRQ(OMAP4430UNIV_ISL29023_INT_GPIO),
 	},
+	{
+		I2C_BOARD_INFO("secFuelgaugeDev", 0x34),
+	},
 };
 
 static struct i2c_board_info __initdata omap4tab_i2c_3_boardinfo[] = {
@@ -730,9 +869,9 @@
 {
 	pad_config(0x4A100078, 0xFFECFFFF, 0x00030000);
 	pad_config(0x4A10007C, 0xFFFFFFEF, 0x0000000B);
-	if (gpio_request(54, NULL) != 0)
-		printk(KERN_ERR "GPIO 54 request failed\n");
-	gpio_direction_output(54, 0);
+	if (gpio_request(104, NULL) != 0)
+		printk(KERN_ERR "GPIO 104 request failed\n");
+	gpio_direction_output(104, 0);
 	return ;
 }
 #endif
@@ -917,6 +1056,7 @@
 	samsung_omap4_pwr_key_irq_init();
 
 	omap4430univ_sensors_init();
+	samsung_omap4_battery_init();
 }
 
 static void __init omap4_tab_10_1_map_io(void)
Index: android-2.6.35/arch/arm/plat-omap/include/plat/microusbic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/arch/arm/plat-omap/include/plat/microusbic.h	2010-12-24 21:15:43.981667952 +0530
@@ -0,0 +1,34 @@
+#ifndef __MICROUSBIC_DRV__
+#define __MICROUSBIC_DRV__
+
+#define MICROUSBIC_5W_CHARGER		6
+#define MICROUSBIC_JIG_UART_OFF		5
+
+#define MICROUSBIC_TA_CHARGER		3
+#define MICROUSBIC_USB_CHARGER		2
+#define MICROUSBIC_USB_CABLE		1
+#define MICROUSBIC_NO_DEVICE		0
+#define MICROUSBIC_PHONE_USB		-1
+
+#define MICROUSBIC_ATTACH		1
+#define MICROUSBIC_DETACH		0
+
+struct microusbic_event
+{
+	int device;
+	int event;
+};
+
+int get_usbic_state(void);
+int get_real_usbic_state(void);
+void usbic_usb_switch(int sel);
+int get_interrupt_event(struct microusbic_event * evt);
+
+// DEBUG
+#define _get_real_usbic_state() \
+	do { \
+		printk("[uic] >>>>> %s (%d)\n", __FUNCTION__,__LINE__); \
+		get_real_usbic_state(); \
+	} while(0)
+
+#endif
Index: android-2.6.35/drivers/mfd/twl-core.c
===================================================================
--- android-2.6.35.orig/drivers/mfd/twl-core.c	2010-12-10 15:11:21.000000000 +0530
+++ android-2.6.35/drivers/mfd/twl-core.c	2010-12-24 21:15:43.981667952 +0530
@@ -61,6 +61,7 @@
 #if defined(CONFIG_TWL4030_BCI_BATTERY) || \
 	defined(CONFIG_TWL4030_BCI_BATTERY_MODULE) || \
 	defined(CONFIG_TWL6030_BCI_BATTERY) || \
+	defined(CONFIG_FUEL_GAUGE_TWL6030) || \
 	defined(CONFIG_TWL6030_BCI_BATTERY_MODULE)
 #define twl_has_bci()		true
 #else
@@ -129,7 +130,7 @@
 /* Triton Core internal information (BEGIN) */
 
 /* Last - for index max*/
-#define TWL4030_MODULE_LAST		TWL4030_MODULE_SECURED_REG
+#define TWL4030_MODULE_LAST		TWL6030_MODULE_AUX
 
 #define TWL_NUM_SLAVES		4
 
@@ -342,6 +343,7 @@
 
 	{ SUB_CHIP_ID0, TWL6030_BASEADD_RTC },
 	{ SUB_CHIP_ID0, TWL6030_BASEADD_MEM },
+	{ SUB_CHIP_ID1, TWL6030_BASEADD_AUX },
 };
 
 /*----------------------------------------------------------------------*/
Index: android-2.6.35/arch/arm/configs/android_4430_samsung_defconfig
===================================================================
--- android-2.6.35.orig/arch/arm/configs/android_4430_samsung_defconfig	2010-12-24 21:15:41.081037141 +0530
+++ android-2.6.35/arch/arm/configs/android_4430_samsung_defconfig	2010-12-24 21:15:43.991662151 +0530
@@ -1133,10 +1133,14 @@
 # CONFIG_TEST_POWER is not set
 # CONFIG_BATTERY_DS2760 is not set
 # CONFIG_BATTERY_DS2782 is not set
-CONFIG_TWL6030_BCI_BATTERY=y
-CONFIG_CHARGER_BQ2415x=y
+# CONFIG_TWL6030_BCI_BATTERY is not set
 # CONFIG_BATTERY_BQ27x00 is not set
 # CONFIG_BATTERY_MAX17040 is not set
+CONFIG_BATTERY_MONITOR=y
+# CONFIG_BATTERY_MONITOR_DEBUG is not set
+CONFIG_BATTERY_CHARGER_ISL9220=y
+# CONFIG_FUEL_GAUGE_MAX17042 is not set
+CONFIG_FUEL_GAUGE_TWL6030=y
 CONFIG_HWMON=y
 # CONFIG_HWMON_VID is not set
 # CONFIG_HWMON_DEBUG_CHIP is not set
@@ -1803,7 +1807,7 @@
 # CONFIG_RTC_DRV_PCF8583 is not set
 # CONFIG_RTC_DRV_M41T80 is not set
 # CONFIG_RTC_DRV_BQ32K is not set
-CONFIG_RTC_DRV_TWL4030=y
+# CONFIG_RTC_DRV_TWL4030 is not set
 # CONFIG_RTC_DRV_S35390A is not set
 # CONFIG_RTC_DRV_FM3130 is not set
 # CONFIG_RTC_DRV_RX8581 is not set
Index: android-2.6.35/arch/arm/mach-omap2/Kconfig
===================================================================
--- android-2.6.35.orig/arch/arm/mach-omap2/Kconfig	2010-12-24 21:15:23.652294304 +0530
+++ android-2.6.35/arch/arm/mach-omap2/Kconfig	2010-12-24 21:15:43.991662151 +0530
@@ -256,8 +256,6 @@
 	select INPUT_TOUCHSCREEN
 	select TOUCHSCREEN_SYNTM12XX
 	select POWER_SUPPLY
-	select TWL6030_BCI_BATTERY
-	select CHARGER_BQ2415x
 	select SECURITY_MIDDLEWARE_COMPONENT
 
 config  SAMSUNG_OMAP4_TAB_REV
Index: android-2.6.35/drivers/power/Kconfig
===================================================================
--- android-2.6.35.orig/drivers/power/Kconfig	2010-12-10 15:11:22.000000000 +0530
+++ android-2.6.35/drivers/power/Kconfig	2010-12-24 21:15:43.991662151 +0530
@@ -155,4 +155,6 @@
 	help
 	 Say Y to include support for NXP PCF50633 Main Battery Charger.
 
+source "drivers/power/battery/Kconfig"
+
 endif # POWER_SUPPLY
Index: android-2.6.35/drivers/power/Makefile
===================================================================
--- android-2.6.35.orig/drivers/power/Makefile	2010-12-10 15:11:22.000000000 +0530
+++ android-2.6.35/drivers/power/Makefile	2010-12-24 21:15:43.991662151 +0530
@@ -36,3 +36,5 @@
 obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
 obj-$(CONFIG_TWL6030_BCI_BATTERY)	+= twl6030_bci_battery.o
 obj-$(CONFIG_CHARGER_BQ2415x)	+= bq2415x_charger.o
+
+obj-$(CONFIG_BATTERY_MONITOR)	+= battery/
Index: android-2.6.35/drivers/power/battery/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/Kconfig	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,33 @@
+if POWER_SUPPLY
+
+config BATTERY_MONITOR
+	bool "Battery Monitor device driver"
+	help
+	  Say Y here to enable battery monitoring device driver
+
+config BATTERY_MONITOR_DEBUG
+	bool "Battery Monitor debug"
+	depends on BATTERY_MONITOR
+	help
+	  Say Y here to enable debugging messages for battery monitor device
+	  drivers.
+
+config BATTERY_CHARGER_ISL9220
+	bool "ISL9220 Battery Charger"
+	depends on BATTERY_MONITOR
+	help
+	 Say Y to include support for ISL9220 battery charging device.
+
+config FUEL_GAUGE_MAX17042
+	bool "Maxim MAX17042 Fuel Gauge"
+	depends on BATTERY_MONITOR
+	help
+	 Say Y to include support for MAX17042 fuel guage device driver.
+
+config FUEL_GAUGE_TWL6030
+	bool "TWL6030 Fuel Gauge"
+	depends on BATTERY_MONITOR
+	help
+	 Say Y to include support for TWL6030 fuel guage device driver.
+
+endif # POWER_SUPPLY
Index: android-2.6.35/drivers/power/battery/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/Makefile	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,9 @@
+ifeq ($(CONFIG_BATTERY_MONITOR_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
+
+obj-$(CONFIG_BATTERY_MONITOR)		+= battery_monitor.o
+obj-$(CONFIG_BATTERY_CHARGER_ISL9220)	+= charger_isl9220.o
+obj-$(CONFIG_FUEL_GAUGE_MAX17042)	+= fuelgauge_max17042.o
+obj-$(CONFIG_FUEL_GAUGE_TWL6030)	+= fuelgauge_twl6030.o
+
Index: android-2.6.35/drivers/power/battery/battery_monitor.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/battery_monitor.c	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,1084 @@
+/*
+ * module/samsung_battery/battery_monitor.c
+ *
+ * SAMSUNG battery driver for Linux
+ *
+ * Copyright (C) 2009 SAMSUNG ELECTRONICS.
+ * Author: EUNGON KIM (egstyle.kim@samsung.com)
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/i2c/twl.h>
+#include <linux/power_supply.h>
+#include <linux/wakelock.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <mach/gpio.h>
+#include "common.h"
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#define DRIVER_NAME "secBattMonitor"
+
+#define TEMP_DEG    0
+#define TEMP_ADC    1
+
+
+/* TODO: To be moved to board specific file */
+struct battery_device_config {
+	/* Support Charge Current monitoring */
+	int MONITORING_CHG_CURRENT;
+	/* Support Battery temperature monitoring */
+	int MONITORING_SYSTEM_TEMP;
+};
+
+struct battery_device_info
+{
+	struct device *dev;
+	struct delayed_work battery_monitor_work;
+	struct power_supply sec_battery;
+	struct power_supply sec_ac;
+	struct power_supply sec_usb;
+};
+
+
+/* globals */
+static struct battery_device_config *device_config;
+static DEFINE_MUTEX(battery_lock);
+static struct device *this_dev;
+static SEC_battery_charger_info sec_bci;
+static struct wake_lock sec_bc_wakelock, adc_wakelock;
+
+/* Prototype */
+static int do_fuelgauge_reset(void);
+static int get_battery_level_ptg(void);
+static int get_system_temperature(bool);
+static int get_battery_level_adc(void);
+static int get_charging_source(void);
+
+/* Functions defined in charger driver */
+extern int charger_init( void );
+extern void charger_exit( void );
+extern int _battery_state_change_( int category, int value, bool is_sleep );
+extern int _check_full_charge_dur_sleep_( void );
+extern int _cable_status_now_( void );
+
+/* Functions defined in fuelgauge driver */
+extern int fuelgauge_init( void );
+extern void fuelgauge_exit( void );
+extern int fuelgauge_quickstart( void );
+extern int get_fuelgauge_adc_value( int count, bool is_sleep );
+extern int get_fuelgauge_ptg_value( bool is_sleep );
+extern int twl6030_charge_current(void);
+
+
+
+SEC_battery_charger_info *get_sec_bci( void )
+{
+	return &sec_bci;
+}
+
+// ------------------------------------------------------------------------- //
+//                           sysfs interface                                 //
+// ------------------------------------------------------------------------- //
+#define  __ATTR_SHOW_CALLBACK( _name, _ret_val ) \
+static ssize_t _name( struct kobject *kobj, \
+		      struct kobj_attribute *attr, \
+		      char *buf ) \
+{ \
+	return sprintf ( buf, "%d\n", _ret_val ); \
+}
+
+
+static int get_batt_monitor_temp(void)
+{
+	return sec_bci.battery.support_monitor_temp;
+}
+
+
+static ssize_t store_batt_monitor_temp(struct kobject *kobj,
+				    struct kobj_attribute *attr,
+				    const char *buf, size_t size)
+{
+	int flag;
+
+	sscanf(buf, "%d", &flag);
+	dbg("[BR] change value %d\n", flag);
+	sec_bci.battery.support_monitor_temp	= flag;
+	sec_bci.battery.support_monitor_timeout	= flag;
+	sec_bci.battery.support_monitor_full	= flag;
+	return size;
+}
+
+
+__ATTR_SHOW_CALLBACK( show_batt_vol_toolow, sec_bci.battery.battery_vol_toolow )
+
+static struct kobj_attribute batt_vol_toolow =
+	__ATTR( batt_vol_toolow, 0644, show_batt_vol_toolow, NULL );
+
+
+__ATTR_SHOW_CALLBACK( show_charging_source, get_charging_source() )
+
+
+static struct kobj_attribute charging_source =
+	__ATTR( charging_source, 0644, show_charging_source, NULL );
+
+
+__ATTR_SHOW_CALLBACK( show_batt_vol, get_battery_level_adc() )
+__ATTR_SHOW_CALLBACK( show_batt_vol_adc, 0 )
+__ATTR_SHOW_CALLBACK( show_batt_temp, get_system_temperature(TEMP_DEG) )
+__ATTR_SHOW_CALLBACK( show_batt_temp_adc, get_system_temperature(TEMP_ADC) )
+__ATTR_SHOW_CALLBACK( show_batt_v_f_adc, 0 )
+__ATTR_SHOW_CALLBACK( show_batt_capacity, get_battery_level_ptg() )
+__ATTR_SHOW_CALLBACK( do_batt_fuelgauge_reset, do_fuelgauge_reset() )
+__ATTR_SHOW_CALLBACK( show_batt_monitor_temp, get_batt_monitor_temp() )
+
+
+static struct kobj_attribute batt_sysfs_testmode[] = {
+	__ATTR( batt_vol, 0644, show_batt_vol, NULL ),
+	__ATTR( batt_vol_adc, 0644, show_batt_vol_adc, NULL ),
+	__ATTR( batt_temp, 0644, show_batt_temp, NULL ),
+	__ATTR( batt_temp_adc, 0644, show_batt_temp_adc, NULL ),
+	__ATTR( batt_v_f_adc, 0644, show_batt_v_f_adc, NULL ),
+	__ATTR( batt_capacity, 0644, show_batt_capacity, NULL ),
+	__ATTR( batt_fuelgauge_reset, 0644, do_batt_fuelgauge_reset, NULL ),
+	__ATTR( batt_monitor_temp, 0777, show_batt_monitor_temp, store_batt_monitor_temp ),
+};
+
+
+int _charger_state_change_(int category, int value, bool is_sleep)
+{
+	dbg("[BR] _charger_state_change_(category= %d, value= %d)\n",
+			category, value);
+
+	if (category == STATUS_CATEGORY_CABLE) {
+		switch (value)
+		{
+		case POWER_SUPPLY_TYPE_BATTERY:
+			/* Stop monitoring the batt. level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = false;
+
+			/* Stop monitoring the temperature */
+			sec_bci.battery.monitor_field_temp = false;
+
+			sec_bci.battery.confirm_full_by_current	= 0;
+			sec_bci.battery.confirm_recharge	= 0;
+			sec_bci.charger.charging_timeout	= DEFAULT_CHARGING_TIMEOUT;
+			sec_bci.charger.full_charge_dur_sleep	= 0x0;
+			break;
+
+		case POWER_SUPPLY_TYPE_MAINS:
+			sec_bci.charger.charging_timeout = DEFAULT_CHARGING_TIMEOUT;
+			wake_lock_timeout(&sec_bc_wakelock , HZ);
+			break;
+
+		case POWER_SUPPLY_TYPE_USB:
+			break;
+
+		default:
+			break;
+		}
+
+		goto Out_Charger_State_Change;
+
+	} else if (category == STATUS_CATEGORY_CHARGING) {
+		switch (value)
+		{
+		case POWER_SUPPLY_STATUS_UNKNOWN:
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			/* Stop monitoring the batt level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = false;
+
+			if (sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_OVERHEAT
+				&& sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_COLD)
+			{
+				/*Stop monitoring the temperature*/
+				sec_bci.battery.monitor_field_temp = false;
+			}
+			break;
+
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL:
+			/* Start monitoring the batt level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = true;
+
+			/* Stop monitoring the temperature */
+			sec_bci.battery.monitor_field_temp = false;
+			wake_lock_timeout(&sec_bc_wakelock, HZ);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING:
+			/* Start monitoring the temperature */
+			sec_bci.battery.monitor_field_temp = true;
+
+			/* Stop monitoring the batt. level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = false;
+			break;
+
+		case POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL:
+			/* Start monitoring the temperature */
+			sec_bci.battery.monitor_field_temp = true;
+
+			/* Stop monitoring the batt. level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = false;
+			break;
+
+		case POWER_SUPPLY_STATUS_RECHARGING_FOR_TEMP:
+			/* Start monitoring the temperature */
+			sec_bci.battery.monitor_field_temp = true;
+
+			/* Stop monitoring the batt. level for Re-charging */
+			sec_bci.battery.monitor_field_rechg_vol = false;
+			break;
+
+		default :
+			break;
+		}
+	}
+
+	if (!is_sleep) {
+		struct battery_device_info *di;
+		struct platform_device *pdev;
+
+		pdev = to_platform_device(this_dev);
+		di = platform_get_drvdata(pdev);
+
+		cancel_delayed_work(&di->battery_monitor_work);
+		queue_delayed_work(sec_bci.sec_battery_workq, &di->battery_monitor_work, 5 * HZ);
+
+		power_supply_changed(&di->sec_battery);
+		power_supply_changed(&di->sec_ac);
+		power_supply_changed(&di->sec_usb);
+	}
+
+Out_Charger_State_Change:
+	return 0;
+}
+
+
+int _low_battery_alarm_(void)
+{
+	struct battery_device_info *di;
+	struct platform_device *pdev;
+	int level;
+
+	pdev = to_platform_device(this_dev);
+	di = platform_get_drvdata(pdev);
+
+	level = get_battery_level_ptg();
+	if (level == 1)
+		sec_bci.battery.battery_level_ptg = 0;
+	else
+		sec_bci.battery.battery_level_ptg = level;
+
+	wake_lock_timeout(&sec_bc_wakelock, HZ);
+	power_supply_changed(&di->sec_battery);
+	return 0;
+}
+
+
+int _get_average_value_(int *data, int count)
+{
+	int i;
+	int average;
+	int min = 0;
+	int max = 0;
+	int sum = 0;
+
+	if (count >= 5) {
+		min = max = data[0];
+		for (i = 0; i < count; i++) {
+			if (data[i] < min)
+				min = data[i];
+
+			if (data[i] > max)
+				max = data[i];
+
+			sum += data[i];
+		}
+
+		average = (sum - max - min) / (count - 2);
+	} else {
+		for (i = 0; i < count; i++)
+			sum += data[i];
+
+		average = sum / count;
+	}
+	return average;
+}
+
+
+int _get_t2adc_data_(int ch)
+{
+	/* TODO: TBD */
+	wake_lock(&adc_wakelock);
+	wake_unlock(&adc_wakelock);
+
+	return 2;
+}
+
+
+static int get_elapsed_time_secs(unsigned long long *start)
+{
+	unsigned long long now;
+	unsigned long long diff;
+	unsigned long long max = 0xFFFFFFFF;
+
+	max = (max << 32) | 0xFFFFFFFF;
+	now = sched_clock();
+	if (now >= *start) {
+		diff = now - *start;
+	} else {
+		diff = max - *start + now;
+	}
+	do_div(diff, 1000000000L);
+	printk( KERN_DEBUG "[BR] now: %llu, start: %llu, diff:%d\n",
+			now, *start, (int)diff );
+	return (int)diff;
+}
+
+
+static int do_fuelgauge_reset(void)
+{
+	fuelgauge_quickstart();
+	return 1;
+}
+
+
+static int get_charging_source(void)
+{
+	/* android platform type.
+	 * typedef enum {
+	 *	CHARGER_BATTERY = 0,
+	 *	CHARGER_USB,
+	 *	CHARGER_AC,
+	 *	CHARGER_DISCHARGE
+	 * } charger_type_t;
+	 */
+	if (sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_GOOD)
+		return 3;
+
+	switch (sec_bci.charger.cable_status)
+	{
+	case POWER_SUPPLY_TYPE_BATTERY:
+		return 0;
+	case POWER_SUPPLY_TYPE_MAINS:
+		return 2;
+	case POWER_SUPPLY_TYPE_USB:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+
+static int get_battery_level_adc(void)
+{
+	return get_fuelgauge_adc_value(5, CHARGE_DUR_ACTIVE);
+}
+
+
+static int get_battery_level_ptg(void)
+{
+	int value;
+
+	value = get_fuelgauge_ptg_value(CHARGE_DUR_ACTIVE);
+	if ( value < 0 )
+		value = sec_bci.battery.battery_level_ptg;
+
+	return value;
+}
+
+
+static int get_system_temperature(bool flag)
+{
+	static int temp = 0;
+	if (flag == TEMP_DEG) {
+		/* TODO: Get the temperature of the battery in degree C */
+		printk("WARN! Reading battery temperature is not implemented yet\n");
+	} else {
+		/* TODO: Get the temperature of the battery in ADC */
+		printk("WARN! Reading battery temperature is not implemented yet\n");
+	}
+	return temp++;
+}
+
+
+static int get_charging_current(void)
+{
+	return twl6030_charge_current();
+}
+
+
+static int check_full_charge_using_chg_current(int charge_current)
+{
+	/* If charge current is negative, then it means battery is discharging */
+	if (charge_current < 0) {
+		sec_bci.battery.confirm_full_by_current = 0;
+		return 0;
+	}
+
+	if (sec_bci.battery.battery_level_vol < 4000) {
+		sec_bci.battery.confirm_full_by_current = 0;
+		return 0;
+	}
+
+	if (sec_bci.battery.support_monitor_full) {
+		if (charge_current <= CHARGE_FULL_CURRENT) {
+			sec_bci.battery.confirm_full_by_current++;
+			// changing freq. of monitoring adc to Burst.
+			sec_bci.battery.monitor_duration = 5; // sec
+		} else {
+			sec_bci.battery.confirm_full_by_current = 0;
+			// changing freq. of monitoring adc to Default.
+			sec_bci.battery.monitor_duration = MONITOR_DEFAULT_DURATION; // sec
+		}
+
+		if (sec_bci.battery.confirm_full_by_current >= 4) {
+			sec_bci.battery.monitor_duration = MONITOR_DEFAULT_DURATION;
+			sec_bci.battery.confirm_full_by_current = 0;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+
+static void get_system_status_in_sleep(int *battery_level_ptg,
+		int *battery_level_vol, int *battery_temp, int *charge_current)
+{
+	static int bat_temp = 0;
+
+	/* Get bettery level in percentage */
+	*battery_level_ptg = get_battery_level_ptg();
+
+	/* Get battery voltage */
+	*battery_level_vol = get_battery_level_adc();
+
+	if (device_config->MONITORING_CHG_CURRENT) {
+		*charge_current = twl6030_charge_current();
+	} else {
+		*charge_current = 0;
+	}
+
+	if (device_config->MONITORING_SYSTEM_TEMP) {
+		/* TODO: Get battery temperature */
+		*battery_temp = bat_temp++;
+	} else {
+		*battery_temp = 0;
+	}
+}
+
+
+static int battery_monitor_core(bool is_sleep)
+{
+	int charging_time;
+
+	/* Monitoring the system temperature */
+	if (sec_bci.battery.monitor_field_temp) {
+		if (sec_bci.battery.support_monitor_timeout) {
+			/* Check charging time */
+			charging_time = get_elapsed_time_secs(&sec_bci.charger.charge_start_time);
+			if (charging_time >= sec_bci.charger.charging_timeout) {
+				if (is_sleep)
+					sec_bci.charger.full_charge_dur_sleep = 0x2;
+				else
+					_battery_state_change_(STATUS_CATEGORY_CHARGING,
+								POWER_SUPPLY_STATUS_CHARGING_OVERTIME,
+								is_sleep);
+				return -1;
+			}
+		}
+
+		if (sec_bci.battery.support_monitor_temp) {
+			if (sec_bci.battery.battery_health == POWER_SUPPLY_HEALTH_OVERHEAT
+				|| sec_bci.battery.battery_health == POWER_SUPPLY_HEALTH_COLD)
+			{
+				if (sec_bci.battery.battery_temp <= CHARGE_RECOVER_TEMPERATURE_MAX
+					&& sec_bci.battery.battery_temp >= CHARGE_RECOVER_TEMPERATURE_MIN)
+				{
+					sec_bci.battery.battery_health = POWER_SUPPLY_HEALTH_GOOD;
+					_battery_state_change_(STATUS_CATEGORY_TEMP,
+								BATTERY_TEMPERATURE_NORMAL,
+								is_sleep);
+				}
+			} else {
+				if (sec_bci.battery.monitor_duration > MONITOR_TEMP_DURATION)
+					sec_bci.battery.monitor_duration = MONITOR_TEMP_DURATION;
+
+				if (sec_bci.battery.battery_temp >= CHARGE_STOP_TEMPERATURE_MAX) {
+					if (sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_OVERHEAT) {
+						sec_bci.battery.battery_health = POWER_SUPPLY_HEALTH_OVERHEAT;
+						_battery_state_change_(STATUS_CATEGORY_TEMP,
+									BATTERY_TEMPERATURE_HIGH,
+									is_sleep);
+					}
+				} else if (sec_bci.battery.battery_temp <= CHARGE_STOP_TEMPERATURE_MIN) {
+					if (sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_COLD) {
+						sec_bci.battery.battery_health = POWER_SUPPLY_HEALTH_COLD;
+						_battery_state_change_(STATUS_CATEGORY_TEMP,
+									BATTERY_TEMPERATURE_LOW,
+									is_sleep);
+					}
+				} else {
+					if (sec_bci.battery.battery_health != POWER_SUPPLY_HEALTH_GOOD) {
+						sec_bci.battery.battery_health = POWER_SUPPLY_HEALTH_GOOD;
+						_battery_state_change_(STATUS_CATEGORY_TEMP,
+									BATTERY_TEMPERATURE_NORMAL,
+									is_sleep);
+					}
+				}
+			}
+		}
+	}
+
+	/* Monitoring the battery level for Re-charging */
+	if (sec_bci.battery.monitor_field_rechg_vol) {
+		if (sec_bci.battery.monitor_duration > MONITOR_RECHG_VOL_DURATION)
+			sec_bci.battery.monitor_duration = MONITOR_RECHG_VOL_DURATION;
+
+		if (sec_bci.battery.battery_level_vol <= 4120) {
+			sec_bci.battery.confirm_recharge++;
+			if (sec_bci.battery.confirm_recharge >= 2) {
+				dbg("RE-charging vol\n");
+				sec_bci.battery.confirm_recharge = 0;
+				_battery_state_change_(STATUS_CATEGORY_CHARGING,
+							POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL,
+							is_sleep);
+			}
+		} else {
+			sec_bci.battery.confirm_recharge = 0;
+		}
+	}
+
+	return 0;
+}
+
+
+static void battery_monitor_work_handler(struct work_struct *work)
+{
+	int is_full = 0;
+	int charge_current;
+	struct battery_device_info *di = container_of(work, struct battery_device_info,
+							battery_monitor_work.work );
+
+	/*Monitoring the battery info.*/
+	sec_bci.battery.battery_level_ptg = get_battery_level_ptg();
+	sec_bci.battery.battery_level_vol= get_battery_level_adc();
+
+	if (device_config->MONITORING_SYSTEM_TEMP) {
+		sec_bci.battery.battery_temp = get_system_temperature(TEMP_DEG);
+	} else {
+		sec_bci.battery.battery_temp = 0;
+	}
+
+	if ( !(sec_bci.battery.monitor_field_temp)
+			&& !(sec_bci.battery.monitor_field_rechg_vol)) {
+		sec_bci.battery.monitor_duration = MONITOR_DEFAULT_DURATION;
+	} else {
+		// Workaround : check status of cabel at this point.
+		if ( !_cable_status_now_()) {
+			_battery_state_change_(STATUS_CATEGORY_ETC,
+						ETC_CABLE_IS_DISCONNECTED,
+						CHARGE_DUR_ACTIVE);
+		}
+
+		if (sec_bci.charger.is_charging
+				&& device_config->MONITORING_CHG_CURRENT) {
+			// in charging && enable monitor_chg_current
+			charge_current = get_charging_current();
+			is_full = check_full_charge_using_chg_current(charge_current);
+
+			if (is_full) {
+				dbg("Battery is found to be full by charging current\n");
+				_battery_state_change_(STATUS_CATEGORY_CHARGING,
+							POWER_SUPPLY_STATUS_FULL,
+							CHARGE_DUR_ACTIVE);
+			} else {
+				battery_monitor_core(CHARGE_DUR_ACTIVE);
+			}
+		} else {
+			battery_monitor_core(CHARGE_DUR_ACTIVE);
+		}
+	}
+
+	power_supply_changed(&di->sec_battery);
+	power_supply_changed(&di->sec_ac);
+	power_supply_changed(&di->sec_usb);
+
+	queue_delayed_work(sec_bci.sec_battery_workq, &di->battery_monitor_work,
+				sec_bci.battery.monitor_duration * HZ);
+}
+
+
+static int battery_monitor_fleeting_wakeup_handler(unsigned long arg)
+{
+	int ret = 0;
+	static int is_full = 0;
+	int charge_current = 0;
+
+	get_system_status_in_sleep( &sec_bci.battery.battery_level_ptg,
+				&sec_bci.battery.battery_level_vol,
+				&sec_bci.battery.battery_temp,
+				&charge_current);
+
+	if (sec_bci.charger.is_charging) {
+		/* TODO: To be implemented */
+		/* dummy results */
+		is_full = (is_full ? 0 : 1);
+	}
+
+	if (is_full) {
+		sec_bci.charger.full_charge_dur_sleep = 0x1;
+		wake_lock_timeout(&sec_bc_wakelock , HZ);
+		ret = -1;
+	} else {
+		sec_bci.charger.full_charge_dur_sleep = 0x0;
+		ret = battery_monitor_core(CHARGE_DUR_SLEEP);
+	}
+
+	return ret;
+}
+
+
+// ------------------------------------------------------------------------- //
+//                            Power supply monitor                           //
+// ------------------------------------------------------------------------- //
+static enum power_supply_property samsung_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY, // in percents
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property samsung_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+static enum power_supply_property samsung_usb_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+
+static int samsung_battery_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	switch(psp)
+	{
+	case POWER_SUPPLY_PROP_STATUS:
+		if( sec_bci.charger.charge_status == POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL
+			|| sec_bci.charger.charge_status == POWER_SUPPLY_STATUS_RECHARGING_FOR_TEMP )
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = sec_bci.charger.charge_status;
+		break;
+
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = sec_bci.battery.battery_health;
+		break;
+
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = sec_bci.battery.battery_level_vol * 1000;
+		val->intval = val->intval <= 0 ? 0 : 1;
+		break;
+
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = sec_bci.charger.cable_status;
+		break;
+
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = sec_bci.battery.battery_technology;
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = sec_bci.battery.battery_level_vol * 1000;
+		break;
+
+	case POWER_SUPPLY_PROP_CAPACITY: /* in percents! */
+		val->intval = sec_bci.battery.battery_level_ptg;
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = sec_bci.battery.battery_temp * 10;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int samsung_ac_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	switch(psp)
+	{
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (sec_bci.charger.cable_status == POWER_SUPPLY_TYPE_MAINS)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = sec_bci.battery.battery_level_vol * 1000;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int samsung_usb_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	switch(psp)
+	{
+	case POWER_SUPPLY_PROP_ONLINE:
+		if ( sec_bci.charger.cable_status == POWER_SUPPLY_TYPE_USB )
+			val->intval = 1;
+		else
+			val->intval = 0;
+
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = sec_bci.battery.battery_level_vol * 1000;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static char *samsung_bci_supplied_to[] = {
+	"battery",
+};
+
+
+static void samsung_pwr_external_power_changed(struct power_supply *psy)
+{
+	//cancel_delayed_work(&di->twl4030_bci_monitor_work);
+	//schedule_delayed_work(&di->twl4030_bci_monitor_work, 0);
+}
+
+
+// ------------------------------------------------------------------------- //
+//                           Driver interface                                //
+// ------------------------------------------------------------------------- //
+static int __devinit battery_probe( struct platform_device *pdev )
+{
+	struct battery_device_info *di;
+	int ret = 0;
+	int i = 0;
+	int Debug_Usepopup = 1;
+
+	dbg("[BR] Battery Probe...\n");
+	this_dev = &pdev->dev;
+
+	di = kzalloc(sizeof(*di), GFP_KERNEL);
+	if(!di)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, di);
+
+	di->dev = &pdev->dev;
+	device_config = pdev->dev.platform_data;
+
+	INIT_DELAYED_WORK( &di->battery_monitor_work, battery_monitor_work_handler );
+
+	/*Create power supplies*/
+	di->sec_battery.name		= "battery";
+	di->sec_battery.type		= POWER_SUPPLY_TYPE_BATTERY;
+	di->sec_battery.properties	= samsung_battery_props;
+	di->sec_battery.num_properties	= ARRAY_SIZE( samsung_battery_props );
+	di->sec_battery.get_property	= samsung_battery_get_property;
+	di->sec_battery.external_power_changed = samsung_pwr_external_power_changed;
+
+	di->sec_ac.name			= "ac";
+	di->sec_ac.type			= POWER_SUPPLY_TYPE_MAINS;
+	di->sec_ac.supplied_to		= samsung_bci_supplied_to;
+	di->sec_ac.num_supplicants	= ARRAY_SIZE( samsung_bci_supplied_to );
+	di->sec_ac.properties		= samsung_ac_props;
+	di->sec_ac.num_properties	= ARRAY_SIZE( samsung_ac_props );
+	di->sec_ac.get_property		= samsung_ac_get_property;
+	di->sec_ac.external_power_changed = samsung_pwr_external_power_changed;
+
+	di->sec_usb.name		= "usb";
+	di->sec_usb.type		= POWER_SUPPLY_TYPE_USB;
+	di->sec_usb.supplied_to		= samsung_bci_supplied_to;
+	di->sec_usb.num_supplicants	= ARRAY_SIZE( samsung_bci_supplied_to );
+	di->sec_usb.properties		= samsung_usb_props;
+	di->sec_usb.num_properties	= ARRAY_SIZE( samsung_usb_props );
+	di->sec_usb.get_property	= samsung_usb_get_property;
+	di->sec_usb.external_power_changed = samsung_pwr_external_power_changed;
+
+	if(power_supply_register(&pdev->dev, &di->sec_battery))	{
+		printk("Failed to register main battery, charger\n");
+		goto batt_regi_fail1;
+	}
+
+	if(power_supply_register(&pdev->dev, &di->sec_ac)) {
+		printk( "Failed to register ac\n" );
+		goto batt_regi_fail2;
+	}
+
+	if(power_supply_register(&pdev->dev, &di->sec_usb)) {
+		printk("Failed to register usb\n" );
+		goto batt_regi_fail3;
+	}
+
+	if (sysfs_create_file(&di->sec_battery.dev->kobj, &batt_vol_toolow.attr)) {
+		printk( "sysfs create fail - %s\n", batt_vol_toolow.attr.name);
+	}
+
+	if (sysfs_create_file(&di->sec_battery.dev->kobj, &charging_source.attr)) {
+		printk( "sysfs create fail - %s\n", charging_source.attr.name);
+	}
+
+	for(i = 0; i < ARRAY_SIZE(batt_sysfs_testmode); i++) {
+		ret = sysfs_create_file(&di->sec_battery.dev->kobj,
+				&batt_sysfs_testmode[i].attr);
+		if (ret) {
+			printk("sysfs create fail - %s\n", batt_sysfs_testmode[i].attr.name);
+		}
+	}
+
+	if ( Debug_Usepopup ==1 )
+	{
+		sec_bci.battery.support_monitor_temp = 1;
+		sec_bci.battery.support_monitor_timeout = 1;
+		sec_bci.battery.support_monitor_full = 1;
+	}
+	else if ( Debug_Usepopup == 0 )
+	{
+		sec_bci.battery.support_monitor_temp = 0;
+		sec_bci.battery.support_monitor_timeout = 0;
+		sec_bci.battery.support_monitor_full = 0;
+	}
+
+	queue_delayed_work(sec_bci.sec_battery_workq, &di->battery_monitor_work, 3*HZ);
+	sec_bci.ready = true;
+	return 0;
+
+batt_regi_fail3:
+	power_supply_unregister(&di->sec_ac);
+
+batt_regi_fail2:
+	power_supply_unregister(&di->sec_battery);
+
+batt_regi_fail1:
+	kfree(di);
+
+	return ret;
+}
+
+
+static int __devexit battery_remove(struct platform_device *pdev)
+{
+	struct battery_device_info *di = platform_get_drvdata(pdev);
+
+	flush_scheduled_work();
+	cancel_delayed_work(&di->battery_monitor_work);
+
+	power_supply_unregister(&di->sec_usb);
+	power_supply_unregister(&di->sec_ac);
+	power_supply_unregister(&di->sec_battery);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(di);
+	return 0;
+}
+
+
+static int battery_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct battery_device_info *di = platform_get_drvdata(pdev);
+
+	cancel_delayed_work(&di->battery_monitor_work);
+
+	if(sec_bci.charger.cable_status == POWER_SUPPLY_TYPE_MAINS) {
+		struct file *filp;
+		char buf;
+		int count;
+		int retval = 0;
+		mm_segment_t fs;
+
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+		filp = filp_open("/sys/power/vdd1_lock",
+				00000001/*O_WRONLY*/|00010000/*O_SYNC*/,
+				0x0);
+		buf='1';
+		count=filp->f_op->write(filp, &buf, 1, &filp->f_pos);
+		retval = filp_close(filp, NULL);
+		set_fs(fs);
+	}
+	return 0;
+}
+
+
+static int battery_resume(struct platform_device *pdev)
+{
+	struct battery_device_info *di = platform_get_drvdata(pdev);
+
+	// if ( batt_gptimer_12.active )
+	if (0) {
+		struct file *filp;
+		char buf;
+		int count;
+		int retval = 0;
+		mm_segment_t fs;
+
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+		filp = filp_open("/sys/power/vdd1_lock",
+				00000001/*O_WRONLY*/|00010000/*O_SYNC*/,
+				0x0);
+		buf='0';
+		count=filp->f_op->write(filp, &buf, 1, &filp->f_pos);
+		retval = filp_close(filp, NULL);
+		set_fs(fs);
+	}
+
+	switch (sec_bci.charger.full_charge_dur_sleep)
+	{
+	case 0x1:
+		_battery_state_change_(STATUS_CATEGORY_CHARGING,
+					POWER_SUPPLY_STATUS_FULL_DUR_SLEEP,
+					CHARGE_DUR_ACTIVE );
+		break;
+
+	case 0x2:
+		_battery_state_change_(STATUS_CATEGORY_CHARGING,
+					POWER_SUPPLY_STATUS_CHARGING_OVERTIME,
+					CHARGE_DUR_ACTIVE);
+		break;
+
+	default:
+		break;
+	}
+
+
+	power_supply_changed(&di->sec_battery);
+	power_supply_changed(&di->sec_ac);
+	power_supply_changed(&di->sec_usb);
+
+	sec_bci.charger.full_charge_dur_sleep = 0x0;
+
+	queue_delayed_work(sec_bci.sec_battery_workq, &di->battery_monitor_work, HZ);
+	return 0;
+}
+
+
+struct platform_driver battery_platform_driver = {
+	.probe		= battery_probe,
+	.remove		= __devexit_p(battery_remove),
+	.suspend	= &battery_suspend,
+	.resume		= &battery_resume,
+	.driver		= {
+		.name = DRIVER_NAME,
+	},
+};
+
+
+static int __init battery_init( void )
+{
+	int ret;
+
+	dbg( "\n[BR] Battery Init.\n" );
+
+	sec_bci.ready = false;
+
+	sec_bci.battery.battery_health		= POWER_SUPPLY_HEALTH_GOOD;
+	sec_bci.battery.battery_technology	= POWER_SUPPLY_TECHNOLOGY_LION;
+	sec_bci.battery.battery_level_ptg	= 0;
+	sec_bci.battery.battery_level_vol	= 0;
+	sec_bci.battery.monitor_duration	= MONITOR_DEFAULT_DURATION;
+	sec_bci.battery.monitor_field_temp	= false;
+	sec_bci.battery.monitor_field_rechg_vol	= false;
+	sec_bci.battery.confirm_full_by_current	= 0;
+	sec_bci.battery.support_monitor_temp	= 1;
+	sec_bci.battery.support_monitor_timeout	= 1;
+	sec_bci.battery.support_monitor_full	= 1;
+	sec_bci.battery.confirm_recharge	= 0;
+
+	sec_bci.charger.prev_cable_status	= -1;
+	sec_bci.charger.cable_status		= -1;
+	sec_bci.charger.prev_charge_status	= POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL;
+	sec_bci.charger.charge_status		= 0;
+	sec_bci.charger.full_charge_dur_sleep	= 0x0;
+	sec_bci.charger.is_charging		= false;
+	sec_bci.charger.charge_start_time	= 0;
+	sec_bci.charger.charged_time		= 0;
+	sec_bci.charger.charging_timeout	= DEFAULT_CHARGING_TIMEOUT; // 5 hours
+	sec_bci.charger.use_ta_nconnected_irq	= false;
+
+	sec_bci.sec_battery_workq = create_singlethread_workqueue("sec_battery_workq");
+
+	/* Get the charger driver */
+	if((ret = charger_init() < 0)) {
+		printk("Failed to initialize the battery charger driver\n");
+		return ret;
+	}
+
+	/* Get the fuelgauge driver */
+	if((ret = fuelgauge_init() < 0)) {
+		printk("Failed to initialize the fuelgauge driver.\n");
+		return ret;
+	}
+
+	wake_lock_init(&sec_bc_wakelock, WAKE_LOCK_SUSPEND, "samsung-battery");
+	wake_lock_init(&adc_wakelock, WAKE_LOCK_SUSPEND, "adc-battery");
+
+	ret = platform_driver_register(&battery_platform_driver);
+	return ret;
+}
+module_init(battery_init);
+
+
+static void __exit battery_exit( void )
+{
+	charger_exit();
+	fuelgauge_exit();
+	platform_driver_unregister(&battery_platform_driver);
+	dbg("Battery Driver Exit.\n");
+}
+module_exit(battery_exit);
+
+
+MODULE_DESCRIPTION( "Samsung Battery monitor driver" );
+MODULE_LICENSE( "GPL" );
+
Index: android-2.6.35/drivers/power/battery/charger_isl9220.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/charger_isl9220.c	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,761 @@
+/*
+ * module/samsung_battery/charger_max8845.c
+ *
+ * SAMSUNG battery driver for Linux
+ *
+ * Copyright (C) 2009 SAMSUNG ELECTRONICS.
+ * Author: EUNGON KIM (egstyle.kim@samsung.com)
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/wakelock.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <mach/gpio.h>
+#include <plat/mux.h>
+#include <plat/microusbic.h>
+#include "common.h"
+
+#define DRIVER_NAME             "secChargerDev"
+
+
+struct charger_device_config
+// THIS CONFIG IS SET IN BOARD_FILE.(platform_data)
+{
+	/* CHECK BATTERY VF USING ADC */
+	int VF_CHECK_USING_ADC;	// true or false
+	int VF_ADC_PORT;
+
+	/* SUPPORT CHG_ING IRQ FOR CHECKING FULL */
+	int SUPPORT_CHG_ING_IRQ;
+};
+
+static struct charger_device_config	*device_config;
+
+struct charger_driver_info
+{
+	struct device			*dev;
+	struct delayed_work		cable_detection_work;
+	struct delayed_work		full_charge_work;
+};
+
+static struct device *this_dev;
+
+static int KTA_EN_GPIO;
+static int KTA_NSTAT_GPIO;
+static int KTA_NSTAT_IRQ;
+static int KTA_NCHG_GPIO;
+static int KTA_NCHG_IRQ;
+static int KTA_NCONN_GPIO;
+static int KTA_NCONN_IRQ;
+static int KUSB_CONN_IRQ;
+static int KUSB_CONN_GPIO;
+
+
+static SEC_battery_charger_info *sec_bci;
+
+int _check_full_charge_dur_sleep_(void);
+int _battery_state_change_(int, int, bool);
+int _cable_status_now_(void);
+int charger_init(void);
+void charger_exit(void);
+static bool check_battery_vf(void);
+static void cable_detection_work_handler(struct work_struct *);
+
+extern SEC_battery_charger_info *get_sec_bci(void);
+extern int _charger_state_change_(int category, int value, bool is_sleep);
+extern int _get_t2adc_data_(int ch);
+extern int _get_average_value_(int *data, int count);
+extern int omap34xx_pad_get_wakeup_status(int gpio);
+extern int omap34xx_pad_set_padoff(int gpio, int wakeup_en);
+extern unsigned long long sched_clock(void);
+
+
+#undef USE_DISABLE_CONN_IRQ
+
+#ifdef USE_DISABLE_CONN_IRQ
+
+#define MANAGE_CONN_IRQ
+#ifdef MANAGE_CONN_IRQ
+static int enable_irq_conn(bool);
+
+static spinlock_t irqctl_lock = SPIN_LOCK_UNLOCKED;
+static bool is_enabling_conn_irq;
+
+static int enable_irq_conn(bool en)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&irqctl_lock, flags);
+	if (en)	{
+		if (!is_enabling_conn_irq) {
+			if (!sec_bci->charger.use_ta_nconnected_irq)
+				enable_irq(KUSB_CONN_IRQ);
+
+			enable_irq(KTA_NCONN_IRQ);
+			is_enabling_conn_irq = true;
+		}
+		else
+			return -1;
+
+	} else {
+		if (is_enabling_conn_irq) {
+			if (!sec_bci->charger.use_ta_nconnected_irq)
+				disable_irq(KUSB_CONN_IRQ);
+
+			disable_irq(KTA_NCONN_IRQ);
+			is_enabling_conn_irq = false;
+		}
+		else
+			return -1;
+
+	}
+	spin_unlock_irqrestore(&irqctl_lock, flags);
+
+	return 0;
+}
+#endif
+#endif
+
+void get_charger_status(u32 *stat1, u32 *stat2)
+{
+	if (stat1)
+		*stat1 = gpio_get_value(KTA_NSTAT_GPIO);
+	if (stat2)
+		*stat2 = gpio_get_value(KTA_NCHG_GPIO);
+}
+
+
+static void enable_charging(bool is_sleep)
+{
+	gpio_set_value(KTA_EN_GPIO, 0);
+	//gpio_direction_output(KTA_EN_GPIO, 0);
+	sec_bci->charger.is_charging = true;
+}
+
+static void disable_charging(bool is_sleep)
+{
+	gpio_set_value(KTA_EN_GPIO, 1);
+	//gpio_direction_output(KTA_EN_GPIO, 1);
+	sec_bci->charger.is_charging = false;
+}
+
+static void clear_charge_start_time(void)
+{
+	sec_bci->charger.charge_start_time = sched_clock();
+}
+
+
+static void set_charge_start_time(void)
+{
+	sec_bci->charger.charge_start_time = sched_clock();
+}
+
+
+static void change_charge_status(int status, bool is_sleep)
+{
+	switch (status)
+	{
+	case POWER_SUPPLY_STATUS_UNKNOWN:
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		disable_charging(is_sleep);
+		break;
+
+	case POWER_SUPPLY_STATUS_FULL:
+		disable_charging(is_sleep);
+		/* Cancel timer */
+		clear_charge_start_time();
+		break;
+
+	case POWER_SUPPLY_STATUS_CHARGING:
+		sec_bci->battery.battery_vf_ok = check_battery_vf();
+		if (sec_bci->battery.battery_vf_ok)
+		{
+			sec_bci->battery.battery_health = POWER_SUPPLY_HEALTH_GOOD;
+			/*Start monitoring charging time*/
+			set_charge_start_time();
+			enable_charging(is_sleep);
+		} else {
+			sec_bci->battery.battery_health = POWER_SUPPLY_HEALTH_DEAD;
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			disable_charging(is_sleep);
+			printk("[TA] INVALID BATTERY, %d !! \n", status);
+		}
+		break;
+
+	case POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL:
+		/* Start monitoring charging time */
+		sec_bci->charger.charging_timeout = DEFAULT_RECHARGING_TIMEOUT;
+		set_charge_start_time();
+		enable_charging(is_sleep);
+		break;
+
+	case POWER_SUPPLY_STATUS_RECHARGING_FOR_TEMP:
+		enable_charging(is_sleep);
+		break;
+
+	default:
+		break;
+	}
+
+	sec_bci->charger.prev_charge_status = sec_bci->charger.charge_status;
+	sec_bci->charger.charge_status = status;
+	_charger_state_change_(STATUS_CATEGORY_CHARGING, status, is_sleep);
+}
+
+
+int _check_full_charge_dur_sleep_(void)
+{
+	int ret = 0;
+
+#if 1
+	int chg_ing_level = 0;
+	int i;
+	unsigned char confirm_full = 0x0;
+
+	for (i = 0; i < 8; i++)
+	{
+		chg_ing_level = gpio_get_value(KTA_NCHG_GPIO);
+		confirm_full |= chg_ing_level << i;
+		msleep(3);
+	}
+
+	//printk( "<ta> %x\n", confirm_full );
+
+	if (confirm_full == 0xFF)
+	{
+		printk("<ta> Charged!\n");
+		ret = 1;
+	}
+
+#else
+	struct charger_driver_info *di;
+	struct platform_device *pdev;
+	int is_chg_pin_wakeup = 0;
+
+	is_chg_pin_wakeup = omap34xx_pad_get_wakeup_status(KTA_NCHG_GPIO);
+
+	if ( is_chg_pin_wakeup && sec_bci->battery.battery_level_vol >= 4100 )
+	{
+		pdev = to_platform_device(this_dev);
+		di = platform_get_drvdata(pdev);
+		change_charge_status(POWER_SUPPLY_STATUS_FULL, di, CHARGE_DUR_SLEEP);
+		ret = 1;
+	}
+	else
+	{
+		//omap34xx_pad_set_padoff(KTA_NCHG_GPIO, 1);
+	}
+
+#endif
+	return ret;
+
+}
+
+
+static void change_cable_status(int status, struct charger_driver_info *di,
+				bool is_sleep)
+{
+	sec_bci->charger.prev_cable_status = sec_bci->charger.cable_status;
+	sec_bci->charger.cable_status = status;
+
+	_charger_state_change_(STATUS_CATEGORY_CABLE, status, is_sleep);
+
+	switch (status)
+	{
+	case POWER_SUPPLY_TYPE_BATTERY:
+		/* Diable charging */
+		change_charge_status(POWER_SUPPLY_STATUS_NOT_CHARGING, is_sleep);
+		break;
+
+	case POWER_SUPPLY_TYPE_MAINS:
+	case POWER_SUPPLY_TYPE_USB:
+		/* Enable charging */
+		change_charge_status(POWER_SUPPLY_STATUS_CHARGING, is_sleep);
+		break;
+
+	default:
+		break;
+	}
+}
+
+
+int _battery_state_change_(int category, int value, bool is_sleep)
+{
+	struct charger_driver_info *di;
+	struct platform_device *pdev;
+
+	pdev = to_platform_device(this_dev);
+	di = platform_get_drvdata(pdev);
+
+	if (category == STATUS_CATEGORY_TEMP) {
+		switch (value)
+		{
+		case BATTERY_TEMPERATURE_NORMAL:
+			printk("[TA] Charging re start normal TEMP!!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_RECHARGING_FOR_TEMP, is_sleep);
+			break;
+
+		case BATTERY_TEMPERATURE_LOW:
+			printk("[TA] Charging stop LOW TEMP!!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_NOT_CHARGING, is_sleep);
+			break;
+
+		case BATTERY_TEMPERATURE_HIGH:
+			printk("[TA] Charging stop HI TEMP!!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_NOT_CHARGING, is_sleep);
+			break;
+
+		default:
+			break;
+		}
+	} else if (category == STATUS_CATEGORY_CHARGING) {
+		switch (value)
+		{
+		case POWER_SUPPLY_STATUS_FULL:
+			printk("[TA] Charge FULL! (monitoring charge current)\n");
+			change_charge_status(POWER_SUPPLY_STATUS_FULL, is_sleep);
+			break;
+
+		case POWER_SUPPLY_STATUS_CHARGING_OVERTIME:
+			printk("[TA] CHARGING TAKE OVER 5 hours !!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_FULL, is_sleep);
+			break;
+
+		case POWER_SUPPLY_STATUS_FULL_DUR_SLEEP:
+			printk("[TA] Charge FULL!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_FULL, is_sleep);
+			break;
+
+		case POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL:
+			printk("[TA] Re-Charging Start!!\n");
+			change_charge_status(POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL, is_sleep);
+			break;
+
+		default:
+			break;
+		}
+	} else if (category == STATUS_CATEGORY_ETC) {
+		switch (value)
+		{
+		case ETC_CABLE_IS_DISCONNECTED:
+			printk("[TA] CABLE IS NOT CONNECTED.... Charge Stop!!\n");
+			change_cable_status(POWER_SUPPLY_TYPE_BATTERY, di, is_sleep);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+
+int _cable_status_now_(void)
+{
+	int ret = 0;
+
+	if (sec_bci->charger.use_ta_nconnected_irq) {
+		ret = gpio_get_value( KTA_NCONN_GPIO ) ? 0 : 1;
+	} else {
+		/* TODO: Temp hardcoding..need to remove */
+		ret = MICROUSBIC_USB_CABLE;
+		// ret = get_real_usbic_state();
+	}
+	return ret;
+}
+
+
+
+static bool check_battery_vf( void )
+{
+	/* TODO: Implement this function. For now it always return true. */
+	return true;
+}
+
+static irqreturn_t cable_detection_isr(int irq, void *_di)
+{
+	struct charger_driver_info *di = _di;
+
+	if (sec_bci->ready) {
+		cancel_delayed_work(&di->cable_detection_work);
+		queue_delayed_work(sec_bci->sec_battery_workq, &di->cable_detection_work, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void cable_detection_work_handler(struct work_struct * work)
+{
+	int count;
+	int n_usbic_state = 0;
+	int pwr_cable_connted = 0;
+	struct charger_driver_info *di = container_of(work,
+						struct charger_driver_info,
+						cable_detection_work.work);
+
+	if (!sec_bci->ready) {
+		queue_delayed_work(sec_bci->sec_battery_workq, &di->cable_detection_work, HZ);
+		return;
+	}
+
+	clear_charge_start_time();
+
+	/* TODO: Enable line below when get_real_usbic_state() is implemented */
+	// n_usbic_state = get_real_usbic_state();
+
+
+	count = 0;
+	while (count < 10) {
+		count++;
+		if (gpio_get_value(KTA_NCONN_GPIO)) {
+			msleep(1);
+			if (count == 10) {
+				n_usbic_state = -10;
+				pwr_cable_connted = 1;
+				printk( "[TA] Power cable connected.\n" );
+			}
+		} else {
+			printk("[TA] Power cable Unplugged.\n");
+			break;
+		}
+	}
+
+	// Workaround for Archer [
+	if (!n_usbic_state && sec_bci->charger.use_ta_nconnected_irq)
+	{
+		if (!gpio_get_value(KTA_NCONN_GPIO))
+			n_usbic_state = MICROUSBIC_5W_CHARGER;
+	}
+	// ]
+
+	switch (n_usbic_state)
+	{
+	case MICROUSBIC_5W_CHARGER:
+	case MICROUSBIC_TA_CHARGER:
+	case MICROUSBIC_USB_CHARGER:
+	case MICROUSBIC_PHONE_USB:
+	case MICROUSBIC_USB_CABLE:
+		if (sec_bci->charger.cable_status == POWER_SUPPLY_TYPE_USB
+			|| sec_bci->charger.cable_status == POWER_SUPPLY_TYPE_MAINS) {
+			printk("[TA] already Plugged.\n");
+			goto Out_IRQ_Cable_Det;
+		}
+
+		/* Check VF */
+		sec_bci->battery.battery_vf_ok = check_battery_vf();
+
+		/* TA or USB is inserted */
+		if (n_usbic_state == MICROUSBIC_USB_CABLE) {
+			printk("[TA] USB CABLE PLUGGED\n");
+			change_cable_status(POWER_SUPPLY_TYPE_USB, di, CHARGE_DUR_ACTIVE);
+		} else {
+			printk("[TA] CHARGER CABLE PLUGGED\n");
+			change_cable_status(POWER_SUPPLY_TYPE_MAINS, di, CHARGE_DUR_ACTIVE);
+		}
+
+		if (device_config->SUPPORT_CHG_ING_IRQ)
+			enable_irq(KTA_NCHG_IRQ);
+		break;
+
+	default:
+		if (pwr_cable_connted) {
+			change_cable_status(POWER_SUPPLY_TYPE_MAINS, di, CHARGE_DUR_ACTIVE);
+			goto Out_IRQ_Cable_Det;
+		}
+
+		if (sec_bci->charger.prev_cable_status != POWER_SUPPLY_TYPE_BATTERY
+			&& sec_bci->charger.cable_status == POWER_SUPPLY_TYPE_BATTERY) {
+			printk("[TA] already Unplugged.\n");
+			goto Out_IRQ_Cable_Det;
+		} else if (sec_bci->charger.prev_cable_status == -1
+			&& sec_bci->charger.cable_status == -1) {
+			// first time after booting.
+			printk("[TA] Fisrt time after booting.\n");
+			goto FirstTime_Boot;
+		}
+
+		disable_irq(KTA_NCHG_IRQ);
+
+FirstTime_Boot:
+		change_cable_status(POWER_SUPPLY_TYPE_BATTERY, di, CHARGE_DUR_ACTIVE);
+		break;
+	}
+
+Out_IRQ_Cable_Det:
+	;
+#ifdef USE_DISABLE_CONN_IRQ
+#ifdef MANAGE_CONN_IRQ
+	enable_irq_conn(true);
+#else
+	if (!sec_bci->charger.use_ta_nconnected_irq)
+		enable_irq(KUSB_CONN_IRQ);
+
+	enable_irq(KTA_NCONN_IRQ);
+#endif
+#endif
+}
+
+
+static irqreturn_t full_charge_isr(int irq, void *_di)
+{
+	struct charger_driver_info *di = _di;
+
+	if (sec_bci->ready) {
+		disable_irq(KTA_NCHG_IRQ);
+		cancel_delayed_work(&di->full_charge_work);
+		queue_delayed_work(sec_bci->sec_battery_workq, &di->full_charge_work, 2*HZ);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void full_charge_work_handler(struct work_struct *work)
+{
+	struct charger_driver_info *di;
+	int count;
+	int n_usbic_state;
+
+	if (!sec_bci->charger.is_charging)
+		goto Enable_IRQ_Full_Det;
+
+	/* TODO: Temp hardcoding..need to remove */
+	n_usbic_state = MICROUSBIC_USB_CABLE;
+	// n_usbic_state = get_real_usbic_state();
+
+	switch (n_usbic_state)
+	{
+	case MICROUSBIC_5W_CHARGER:
+	case MICROUSBIC_TA_CHARGER:
+	case MICROUSBIC_USB_CHARGER:
+	case MICROUSBIC_USB_CABLE:
+	case MICROUSBIC_PHONE_USB:
+		break;
+
+	default:
+		//not conn
+		goto Enable_IRQ_Full_Det;
+	}
+
+	count = 0;
+	while (count < 10) {
+		if (!gpio_get_value(KTA_NCHG_GPIO)) {
+			goto Enable_IRQ_Full_Det;
+			break;
+		}
+		msleep(10);
+		count++;
+	}
+
+	di  = container_of(work, struct charger_driver_info, full_charge_work.work);
+
+	// check VF INVALID
+	sec_bci->battery.battery_vf_ok = check_battery_vf();
+	if (sec_bci->battery.battery_vf_ok) {
+		if (device_config->SUPPORT_CHG_ING_IRQ)	{
+			if (gpio_get_value(KTA_NCHG_GPIO) && sec_bci->charger.is_charging) {
+				printk("[TA] Charge FULL!\n");
+				change_charge_status(POWER_SUPPLY_STATUS_FULL, CHARGE_DUR_ACTIVE);
+			}
+		}
+	} else {
+		// VF OPEN
+		printk("[TA] VF OPEN !!\n     Stop charging !!\n");
+		sec_bci->battery.battery_health = POWER_SUPPLY_HEALTH_DEAD;
+		change_charge_status(POWER_SUPPLY_STATUS_NOT_CHARGING, CHARGE_DUR_ACTIVE);
+	}
+
+Enable_IRQ_Full_Det :
+	enable_irq(KTA_NCHG_IRQ);
+}
+
+
+static int __devinit charger_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int irq = 0;
+	struct charger_driver_info *di;
+
+	printk("[TA] Charger probe...\n");
+
+	sec_bci = get_sec_bci();
+
+	di = kzalloc(sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, di);
+	di->dev = &pdev->dev;
+	device_config = pdev->dev.platform_data;
+
+	this_dev = &pdev->dev;
+
+	INIT_DELAYED_WORK(&di->cable_detection_work, cable_detection_work_handler);
+	INIT_DELAYED_WORK(&di->full_charge_work, full_charge_work_handler);
+
+	/* Request charger interface interruption */
+	KUSB_CONN_IRQ = platform_get_irq(pdev, 0);
+	KUSB_CONN_GPIO = irq_to_gpio(KUSB_CONN_IRQ);
+	printk("[TA] KUSB_CONN_IRQ = %d\n", KUSB_CONN_IRQ);
+	printk("[TA] KUSB_CONN_GPIO = %d\n", KUSB_CONN_GPIO);
+	if (KUSB_CONN_IRQ) {
+		ret = request_irq(KUSB_CONN_IRQ, cable_detection_isr,
+				IRQF_DISABLED | IRQF_SHARED, pdev->name, di);
+		if (ret) {
+			printk("[TA] could not request irq %d, status %d\n", KUSB_CONN_IRQ, ret);
+			goto usb_irq_fail;
+		}
+		set_irq_type( KUSB_CONN_IRQ, IRQ_TYPE_EDGE_BOTH );
+	} else {
+		sec_bci->charger.use_ta_nconnected_irq = true;
+	}
+
+	/* Configure IRQ for TA_nCONNECTED (detecting power cable connection) */
+	KTA_NCONN_IRQ = platform_get_irq(pdev, 1);
+	ret = request_irq(KTA_NCONN_IRQ, cable_detection_isr, IRQF_DISABLED, pdev->name, di);
+	if (ret) {
+		printk( "[TA] 1. could not request irq1 : %d, status %d\n", KTA_NCONN_IRQ, ret );
+		goto ta_irq_fail;
+	}
+	set_irq_type(KTA_NCONN_IRQ, IRQ_TYPE_EDGE_BOTH);
+	KTA_NCONN_GPIO = irq_to_gpio(KTA_NCONN_IRQ);
+	printk("[TA] KTA_NCONN IRQ : %d \n", KTA_NCONN_IRQ);
+	printk("[TA] KTA_NCONN GPIO : %d \n", KTA_NCONN_GPIO);
+
+	/* Configure IRQ for TA_nCHG */
+	KTA_NCHG_IRQ = platform_get_irq(pdev, 2);
+	KTA_NCHG_GPIO = irq_to_gpio(KTA_NCHG_IRQ);
+	printk("[TA] KTA_NCHG IRQ : %d \n", KTA_NCHG_IRQ);
+	printk("[TA] KTA_NCHG GPIO : %d \n", KTA_NCHG_GPIO);
+
+	if (device_config->SUPPORT_CHG_ING_IRQ)	{
+		ret = request_irq(KTA_NCHG_IRQ, full_charge_isr, IRQF_DISABLED, pdev->name, di);
+		set_irq_type(KTA_NCHG_IRQ, IRQ_TYPE_EDGE_RISING);
+		if (ret) {
+			printk( "[TA] 2. could not request irq2 , status %d\n",ret);
+			goto chg_full_irq_fail;
+		}
+		disable_irq(KTA_NCHG_IRQ);
+	}
+
+	/* Configure GPIO for TA_nSTAT */
+	KTA_NSTAT_IRQ = platform_get_irq(pdev, 3);
+	KTA_NSTAT_GPIO = irq_to_gpio(KTA_NSTAT_IRQ);
+	printk("[TA] KTA_NSTAT IRQ : %d \n", KTA_NSTAT_IRQ);
+	printk("[TA] KTA_NSTAT GPIO : %d \n", KTA_NSTAT_GPIO);
+
+	if (device_config->SUPPORT_CHG_ING_IRQ){
+		ret = request_irq(KTA_NSTAT_IRQ, full_charge_isr, IRQF_DISABLED, pdev->name, di);
+		set_irq_type(KTA_NSTAT_IRQ, IRQ_TYPE_EDGE_RISING);
+		if (ret){
+			printk( "[TA] 3. could not request irq3 %d , status %d\n", KTA_NSTAT_IRQ ,ret);
+			goto chg_full_irq_fail;
+		}
+		disable_irq(KTA_NSTAT_IRQ);
+	}
+
+	/* Configure GPIO for TA_EN */
+	KTA_EN_GPIO = irq_to_gpio(platform_get_irq(pdev,4));
+	printk("[TA] CHG_EN GPIO : %d \n", KTA_EN_GPIO);
+
+	/* disable CHE_EN */
+	disable_charging(CHARGE_DUR_ACTIVE);
+
+	queue_delayed_work(sec_bci->sec_battery_workq, &di->cable_detection_work, HZ);
+	return 0;
+
+
+chg_full_irq_fail:
+	irq = platform_get_irq(pdev, 1);
+	free_irq(irq, di);
+
+ta_irq_fail:
+	irq = platform_get_irq(pdev, 0);
+	free_irq(irq, di);
+
+usb_irq_fail:
+
+	kfree(di);
+	return ret;
+}
+
+static int __devexit charger_remove( struct platform_device *pdev )
+{
+	struct charger_driver_info *di = platform_get_drvdata(pdev);
+	int irq;
+
+	irq = platform_get_irq(pdev, 0);
+	free_irq(irq, di);
+
+	irq = platform_get_irq(pdev, 1);
+	free_irq(irq, di);
+
+	flush_scheduled_work();
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(di);
+	return 0;
+}
+
+
+static int charger_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	//disable_irq_wake(KTA_NCHG_IRQ);
+	//omap34xx_pad_set_padoff(KTA_NCHG_GPIO, 0);
+	return 0;
+}
+
+
+static int charger_resume(struct platform_device *pdev)
+{
+	//omap34xx_pad_set_padoff(KTA_NCHG_GPIO, 1);
+	//enable_irq_wake(KTA_NCHG_IRQ);
+	return 0;
+}
+
+
+struct platform_driver charger_platform_driver = {
+	.probe		= &charger_probe,
+	.remove		= __devexit_p( charger_remove ),
+	.suspend	= &charger_suspend,
+	.resume		= &charger_resume,
+	.driver		= {
+		.name = DRIVER_NAME,
+	},
+};
+
+
+int charger_init(void)
+{
+	printk(KERN_ALERT "[TA] Charger Init.\n");
+	return platform_driver_register(&charger_platform_driver);
+}
+
+
+void charger_exit(void)
+{
+	platform_driver_unregister(&charger_platform_driver);
+	printk(KERN_ALERT "Charger IC Exit.\n");
+}
+
Index: android-2.6.35/drivers/power/battery/common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/common.h	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,119 @@
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+#define WR_ADC
+#ifdef WR_ADC
+/* Workaround to get proper adc value */
+#include <linux/i2c/twl.h>
+#endif
+
+#define MONITOR_DURATION_DUR_SLEEP	30
+#define MONITOR_DEFAULT_DURATION	30
+#define MONITOR_TEMP_DURATION		30	// sec
+#define MONITOR_RECHG_VOL_DURATION	30	// sec
+
+#define DEFAULT_CHARGING_TIMEOUT	(5 * 60 * 60)	// 5 hours (18000 sec)
+#define DEFAULT_RECHARGING_TIMEOUT	(2 * 60 * 60)	// 2 hours (7200 sec)
+
+#define CHARGE_STOP_TEMPERATURE_MAX		50
+#define CHARGE_STOP_TEMPERATURE_MIN		-5
+#define CHARGE_RECOVER_TEMPERATURE_MAX		43
+#define CHARGE_RECOVER_TEMPERATURE_MIN		1
+
+#define CHARGE_FULL_CURRENT		150	// archer: 190mA (ADC 170)==> 170mA (ADC 250)
+
+
+#define CHARGE_DUR_ACTIVE	0
+#define CHARGE_DUR_SLEEP	1
+
+#define STATUS_CATEGORY_CABLE		1
+#define STATUS_CATEGORY_CHARGING	2
+#define STATUS_CATEGORY_TEMP		3
+#define STATUS_CATEGORY_ETC		4
+
+
+enum {
+	/* Following are defined in include/linux/power_supply.h
+	POWER_SUPPLY_STATUS_UNKNOWN = 0,
+	POWER_SUPPLY_STATUS_CHARGING,
+	POWER_SUPPLY_STATUS_DISCHARGING,
+	POWER_SUPPLY_STATUS_NOT_CHARGING,
+	POWER_SUPPLY_STATUS_FULL,
+	*/
+	POWER_SUPPLY_STATUS_CHARGING_OVERTIME = 5,
+	POWER_SUPPLY_STATUS_RECHARGING_FOR_FULL = 6,
+	POWER_SUPPLY_STATUS_RECHARGING_FOR_TEMP = 7,
+	POWER_SUPPLY_STATUS_FULL_DUR_SLEEP = 8,
+};
+
+
+enum {
+	BATTERY_TEMPERATURE_NORMAL = 0,
+	BATTERY_TEMPERATURE_LOW,
+	BATTERY_TEMPERATURE_HIGH,
+};
+
+
+enum {
+	ETC_CABLE_IS_DISCONNECTED = 0,
+};
+
+
+typedef struct
+{
+	bool ready;
+
+	struct _battery		/* Battery info */
+	{
+		int  battery_technology;
+		int  battery_level_ptg;
+		int  battery_level_vol; // mV
+		int  battery_temp;
+		int  battery_health;
+		bool battery_vf_ok;
+		bool battery_vol_toolow;
+
+		int  monitor_duration;
+		bool monitor_field_temp;
+		bool monitor_field_rechg_vol;
+		int  support_monitor_temp;
+		int  support_monitor_timeout;
+		int  support_monitor_full;
+
+		int confirm_full_by_current;
+		int confirm_recharge;
+	}battery;
+
+	struct _charger		/* Charger info */
+	{
+		int prev_cable_status;
+		int cable_status;
+
+		int prev_charge_status;
+		int charge_status;
+
+		char full_charge_dur_sleep;	// 0x0: No Full, 0x1: Full, 0x2: 5Hours
+		bool is_charging;
+
+		unsigned long long  charge_start_time;
+		unsigned long charged_time;
+		int charging_timeout;		// 5 hours (18000 sec), 2 hours for recharging.
+
+		bool use_ta_nconnected_irq;
+
+		int fuelgauge_full_soc;		// for adjust fuelgauge
+	}charger;
+
+	struct workqueue_struct *sec_battery_workq;
+
+} SEC_battery_charger_info;
+
+
+#ifdef CONFIG_BATTERY_MONITOR_DEBUG
+#define dbg(args...)	printk(args)
+#else
+#define dbg(args...)
+#endif
+
+#endif
+
Index: android-2.6.35/drivers/power/battery/fuelgauge_twl6030.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/fuelgauge_twl6030.c	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,332 @@
+/*
+ * module/samsung_battery/fuelgauge_max17040.c
+ *
+ * SAMSUNG battery driver for Linux
+ *
+ * Copyright (C) 2009 SAMSUNG ELECTRONICS.
+ * Author: EUNGON KIM (egstyle.kim@samsung.com)
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <mach/gpio.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/i2c/twl.h>
+#include <linux/i2c/twl6030-gpadc.h>
+#include "common.h"
+
+/* Gas gauge module register offsets in TWL6030 */
+#define FG_REG_00	0x00
+#define FG_REG_01	0x01
+#define FG_REG_02	0x02
+#define FG_REG_03	0x03
+#define FG_REG_04	0x04
+#define FG_REG_05	0x05
+#define FG_REG_06	0x06
+#define FG_REG_07	0x07
+#define FG_REG_08	0x08
+#define FG_REG_09	0x09
+#define FG_REG_10	0x0A
+#define FG_REG_11	0x0B
+
+/* Auxillary module register offsets in TWL6030 */
+#define REG_TOGGLE1		0x00
+#define REG_TOGGLE2		0x01
+#define REG_TOGGLE3		0x02
+#define REG_PWDNSTATUS1		0x03
+#define REG_PWDNSTATUS2		0x04
+#define REG_VIBCTRL		0x0B
+#define REG_VIBMODE		0x0C
+
+/* PMC Miscellaneous register in TWL6030 */
+#define REG_MISC1		0xE4
+
+/* Some registers bits that we are interested in */
+#define BIT_FG_EN		0x10
+#define BIT_FGS			0x20
+#define BIT_FGR			0x10
+#define BIT_CC_PAUSE		0x01
+#define BIT_CC_AUTOCLEAR	0x04
+#define BIT_CC_OFFSET_09	0x0200
+#define BIT_CC_INTEG_13		0x2000
+
+#define VAC_MEAS		0x04
+#define VBAT_MEAS		0x02
+#define BB_MEAS			0x01
+#define ENABLE_ISOURCE		0x80
+
+#define WORK_DELAY		(30 * HZ)
+#define CONVERSION_FACTOR	1640
+
+
+struct delayed_work twl6030_gasgauge_work;
+static SEC_battery_charger_info *sec_bci;
+static int cc_offset = 0;
+
+extern SEC_battery_charger_info *get_sec_bci( void );
+extern int _low_battery_alarm_( void );
+extern int _battery_state_change_(int category, int value, bool is_sleep);
+extern void get_charger_status(u32 *stat1, u32 *stat2);
+
+
+static void twl6030_gasgauge_enable(void)
+{
+	u8 val[4];
+
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	/* If FG_EN bit is reset then Gas Gauge is disable */
+	if (!(val[0] & BIT_FG_EN)) {
+		/* Enable gag gauge */
+		val[1] = BIT_FGS;
+		twl_i2c_write(TWL6030_MODULE_AUX, val, REG_TOGGLE1, 1);
+	}
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	dbg("Gas gauge is %s\n", (val[0] & BIT_FG_EN)? "enabled" : "disabled");
+#endif
+}
+
+
+static void twl6030_gasgauge_disable(void)
+{
+	u8 val[4];
+
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	/* If FG_EN bit is set then Gas Gauge is enabled */
+	if (val[0] & BIT_FG_EN) {
+		/* Disable gag gauge */
+		val[1] = BIT_FGR;
+		twl_i2c_write(TWL6030_MODULE_AUX, val, REG_TOGGLE1, 1);
+	}
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	dbg("Gas gauge is %s\n", (val[0] & BIT_FG_EN)? "enabled" : "disabled");
+#endif
+}
+
+
+static void twl6030_gasgauge_autoclear(void)
+{
+	u8 val[5];
+
+	/* Before changing the integration period, CC_PAUSE bit must be set to 1 */
+	val[1] = BIT_CC_PAUSE;
+	twl_i2c_write(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+
+	/* Clear offset, accumulator and sample counter */
+	val[1] = BIT_CC_AUTOCLEAR;
+	twl_i2c_write(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+	dbg("Gas Gauge regisers are %s\n", (val[0] & BIT_CC_AUTOCLEAR)? "not yet reset" : "reset");
+#endif
+}
+
+
+int twl6030_charge_current(void)
+{
+	u8 val[4];
+	int integ;
+	int charge_current;
+
+	memset(val, 0, sizeof(val));
+	twl_i2c_read(TWL6030_MODULE_GASGAUGE, val, FG_REG_10, 2);
+	integ = (val[1] << 8) | val[0];
+
+	/* convert from 13 bit signed to 32 bit signed */
+	if (integ & BIT_CC_INTEG_13)
+		integ = 0xFFFFC000 | integ;
+
+	charge_current = ((integ - cc_offset) * CONVERSION_FACTOR / 1000);
+	return charge_current;
+}
+
+
+static void twl6030_gasgauge_work_handler(struct work_struct *work)
+{
+	int stat1 = 0;
+	int stat2 = 0;
+
+	get_charger_status(&stat1, &stat2);
+
+	if ((stat1 == 0) && (stat2 == 1)) {
+		dbg("Battery status: CHARGE COMPLETE\n");
+		if (sec_bci->charger.is_charging) {
+			dbg("Battery Status changed to 'FULL'\n");
+			sec_bci->battery.battery_level_ptg = 100;
+			_battery_state_change_(STATUS_CATEGORY_CHARGING,
+					POWER_SUPPLY_STATUS_FULL,
+					CHARGE_DUR_ACTIVE);
+		}
+	}
+
+#ifdef CONFIG_BATTERY_MONITOR_DEBUG
+	dbg("Battery current = %dmA\n", twl6030_charge_current());
+	/* if ((stat1 == 0) && (stat2 == 0)) {
+		dbg("Battery status: Precharge, or fast charge in progress\n");
+	} else if ((stat1 == 1) && (stat2 == 0)) {
+		dbg("Battery status: Fault\n");
+	} else if ((stat1 == 1) && (stat2 == 1)) {
+		dbg("Battery status: Charging Suspend\n");
+	} */
+#endif
+
+	if ((sec_bci->ready)
+			&& (sec_bci->battery.battery_level_ptg <= 15)
+			&& (sec_bci->charger.is_charging == false) ) {
+		dbg("*** Low battery alarm\n");
+		_low_battery_alarm_();
+	}
+
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+}
+
+
+int get_fuelgauge_adc_value(int count, bool is_sleep)
+{
+	struct twl6030_gpadc_request req;
+	int batt_volt;
+
+	req.channels = (1 << 7);
+	req.method = TWL6030_GPADC_SW2;
+	req.active = 0;
+	req.func_cb = NULL;
+
+	twl6030_gpadc_conversion(&req);
+	batt_volt = (u16)req.rbuf[7];
+
+	dbg("Battery voltage = %d\n", batt_volt);
+	/* Computng battery capacity
+	 * Lets consider battery operating range as 3.25v to 4.25V Battery
+	 * 3.25V means 0% and 4.25V means 100%.
+	 * If Y is percentage of battery capacity and x is voltage then
+	 * Y = mx + c
+	 * 0   = m * 3250 + c
+	 * 100 = m * 4250 + c
+	 * This implies m = 1/10 and c = -3250/10
+	 * so, Y = (x * 1/10) - (3250)/10
+	 * Y = (x - 3250) / 10;
+	 */
+
+	if (batt_volt < 3250) {
+		sec_bci->battery.battery_level_ptg = 0;
+	} else {
+		sec_bci->battery.battery_level_ptg = (batt_volt - 3250) / 10;
+	}
+
+	if (sec_bci->battery.battery_level_ptg > 100)
+		sec_bci->battery.battery_level_ptg = 100;
+
+	return batt_volt;
+}
+
+
+int get_fuelgauge_ptg_value( bool is_sleep )
+{
+	/* No need to calculate this again. This already done */
+	return sec_bci->battery.battery_level_ptg;
+}
+
+
+int fuelgauge_quickstart(void)
+{
+	twl6030_gasgauge_disable();
+	mdelay(10);
+	twl6030_gasgauge_enable();
+	return 0;
+}
+
+
+static int __init twl6030_bci_battery_probe(struct platform_device *pdev)
+{
+	u8 rd_reg = 0;
+
+	dbg("[FG] Fuelgauge Probe.\n");
+	sec_bci = get_sec_bci();
+
+	/* Initialize TWL6030 Gas gauge */
+	twl6030_gasgauge_enable();
+	twl6030_gasgauge_autoclear();
+	/* TODO: Calibration needs to be done */
+
+	INIT_DELAYED_WORK_DEFERRABLE(&twl6030_gasgauge_work, twl6030_gasgauge_work_handler);
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+
+	twl_i2c_read_u8(TWL6030_MODULE_ID0, &rd_reg, REG_MISC1);
+	rd_reg = rd_reg | VAC_MEAS | VBAT_MEAS | BB_MEAS;
+	twl_i2c_write_u8(TWL6030_MODULE_ID0, rd_reg, REG_MISC1);
+
+	twl_i2c_read_u8(TWL_MODULE_MADC, &rd_reg, TWL6030_GPADC_CTRL);
+	rd_reg = rd_reg | ENABLE_ISOURCE;
+	twl_i2c_write_u8(TWL_MODULE_MADC, rd_reg, TWL6030_GPADC_CTRL);
+
+	return 0;
+}
+
+
+static int __exit twl6030_bci_battery_remove(struct platform_device *pdev)
+{
+	twl6030_gasgauge_disable();
+	cancel_delayed_work(&twl6030_gasgauge_work);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int twl6030_bci_battery_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	cancel_delayed_work(&twl6030_gasgauge_work);
+	return 0;
+}
+
+static int twl6030_bci_battery_resume(struct platform_device *pdev)
+{
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+	return 0;
+}
+#else
+#define twl6030_bci_battery_suspend	NULL
+#define twl6030_bci_battery_resume	NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver twl6030_bci_battery_driver = {
+	.probe		= twl6030_bci_battery_probe,
+	.remove		= __exit_p(twl6030_bci_battery_remove),
+	.suspend	= twl6030_bci_battery_suspend,
+	.resume		= twl6030_bci_battery_resume,
+	.driver		= {
+		.name	= "twl6030_bci",
+	},
+};
+
+int fuelgauge_init(void)
+{
+	dbg("[FG] Fuelgauge Init.\n");
+	return platform_driver_register(&twl6030_bci_battery_driver);
+}
+
+
+void fuelgauge_exit(void)
+{
+	dbg("[FG] Fuelgauge Exit.\n");
+	platform_driver_unregister(&twl6030_bci_battery_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Texas Instruments Inc");
+
Index: android-2.6.35/include/linux/i2c/twl.h
===================================================================
--- android-2.6.35.orig/include/linux/i2c/twl.h	2010-12-10 15:11:25.000000000 +0530
+++ android-2.6.35/include/linux/i2c/twl.h	2010-12-24 21:15:43.991662151 +0530
@@ -82,6 +82,7 @@
 #define TWL_MODULE_RTC		TWL4030_MODULE_RTC
 #define TWL_MODULE_PWM		TWL4030_MODULE_PWM0
 #define TWL6030_MODULE_CHARGER	TWL4030_MODULE_MAIN_CHARGE
+#define TWL6030_MODULE_AUX	0x18
 
 #define TWL6030_MODULE_GASGAUGE 0x0B
 #define TWL6030_MODULE_ID0	0x0D
Index: android-2.6.35/drivers/power/battery/fuelgauge_max17042.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/power/battery/fuelgauge_max17042.c	2010-12-24 21:15:43.991662151 +0530
@@ -0,0 +1,839 @@
+/*
+ * module/samsung_battery/fuelgauge_max17040.c
+ *
+ * SAMSUNG battery driver for Linux
+ *
+ * Copyright (C) 2009 SAMSUNG ELECTRONICS.
+ * Author: EUNGON KIM (egstyle.kim@samsung.com)
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <mach/gpio.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include "common.h"
+
+#define FUEL_GAUGE_DEBUG
+
+#ifdef FUEL_GAUGE_DEBUG
+#define dbg(args...)	printk(args)
+#else
+#define dbg(args...)
+#endif
+
+
+/* Gas gauge module register offsets in TWL6030 */
+#define FG_REG_00	0x00
+#define FG_REG_01	0x01
+#define FG_REG_02	0x02
+#define FG_REG_03	0x03
+#define FG_REG_04	0x04
+#define FG_REG_05	0x05
+#define FG_REG_06	0x06
+#define FG_REG_07	0x07
+#define FG_REG_08	0x08
+#define FG_REG_09	0x09
+#define FG_REG_10	0x0A
+#define FG_REG_11	0x0B
+
+/* Auxillary module register offsets in TWL6030 */
+#define REG_TOGGLE1		0x00
+#define REG_TOGGLE2		0x01
+#define REG_TOGGLE3		0x02
+#define REG_PWDNSTATUS1		0x03
+#define REG_PWDNSTATUS2		0x04
+#define REG_VIBCTRL		0x0B
+#define REG_VIBMODE		0x0C
+
+/* Some registers bits that we are interested in */
+#define BIT_FG_EN		0x10
+#define BIT_FGS			0x20
+#define BIT_FGR			0x10
+#define BIT_CC_PAUSE		0x01
+#define BIT_CC_AUTOCLEAR	0x04
+#define BIT_CC_OFFSET_09	0x0200
+#define BIT_CC_INTEG_13		0x2000
+
+#define WORK_DELAY		1000
+#define CONVERSION_FACTOR	1640
+
+#define I2C_M_WR    0x00
+
+#define DRIVER_NAME "secFuelgaugeDev"
+
+
+/* MAX17042 Register address */
+#define STATUS_REG		0x00
+#define VALRT_THRESHOLD_REG	0x01
+#define TALRT_THRESHOLD_REG	0x02
+#define SALRT_THRESHOLD_REG	0x03
+#define REMCAP_REP_REG		0x05
+#define SOCREP_REG		0x06
+#define AGE_REG			0x07
+#define VCELL_REG		0x09
+#define CURRENT_REG		0x0A
+#define AVG_CURRENT_REG		0x0B
+#define SOCMIX_REG		0x0D
+#define SOCAV_REG		0x0E
+#define REMCAP_MIX_REG		0x0F
+#define CONFIG_REG		0x1D
+#define MISCCFG_REG		0x2B
+#define RCOMP_REG		0x38
+#define FilterCFG_REG		0x29
+#define RelaxCFG_REG		0x2A
+#define TEMPR_REG		0x08
+#define VFOCV_REG		0xFB
+#define VFSOC_REG		0xFF
+
+#define OMAP4430_UART3_RTS_SD_GPIO_142		142
+
+typedef enum {
+	POSITIVE = 0,
+	NEGATIVE = 1
+} sign_type;
+
+static struct i2c_client *fuelgauge_i2c_client;
+struct delayed_work fuelgauge_work;
+struct delayed_work twl6030_gasgauge_work;
+static SEC_battery_charger_info *sec_bci;
+static int cc_offset = 0;
+
+static int stat_soc = 10;	/* TODO: To be removed. Added until MAX17042 works */
+
+
+extern SEC_battery_charger_info *get_sec_bci( void );
+extern int _low_battery_alarm_( void );
+extern int _battery_state_change_(int category, int value, bool is_sleep);
+extern void get_charger_status(u32 *stat1, u32 *stat2);
+
+
+static void twl6030_gasgauge_enable(void)
+{
+	u8 val[4];
+
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	/* If FG_EN bit is reset then Gas Gauge is disable */
+	if (!(val[0] & BIT_FG_EN)) {
+		/* Enable gag gauge */
+		val[1] = BIT_FGS;
+		twl_i2c_write(TWL6030_MODULE_AUX, val, REG_TOGGLE1, 1);
+	}
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	dbg("Gas gauge is %s\n", (val[0] & BIT_FG_EN)? "enabled" : "disabled");
+#endif
+}
+
+
+static void twl6030_gasgauge_disable(void)
+{
+	u8 val[4];
+
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	/* If FG_EN bit is set then Gas Gauge is enabled */
+	if (val[0] & BIT_FG_EN) {
+		/* Disable gag gauge */
+		val[1] = BIT_FGR;
+		twl_i2c_write(TWL6030_MODULE_AUX, val, REG_TOGGLE1, 1);
+	}
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_AUX, val, REG_PWDNSTATUS1, 1);
+	dbg("Gas gauge is %s\n", (val[0] & BIT_FG_EN)? "enabled" : "disabled");
+#endif
+}
+
+
+static void twl6030_gasgauge_autoclear(void)
+{
+	u8 val[5];
+
+	/* Before changing the integration period, CC_PAUSE bit must be set to 1 */
+	val[1] = BIT_CC_PAUSE;
+	twl_i2c_write(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+
+	/* Clear offset, accumulator and sample counter */
+	val[1] = BIT_CC_AUTOCLEAR;
+	twl_i2c_write(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+
+#ifdef GAS_GAUGE_DEBUG
+	twl_i2c_read(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 1);
+	dbg("Gas Gauge regisers are %s\n", (val[0] & BIT_CC_AUTOCLEAR)? "not yet reset" : "reset");
+#endif
+}
+
+
+static void twl6030_gasgauge_work_handler(struct work_struct *work)
+{
+	u8 val[16];
+	u32 sample_cntr;
+	int accum, offset, integ;
+	int stat1, stat2;
+
+	/* Read Sample counter, Accumulator and Integrator */
+	memset(val, 0, sizeof(val));
+	twl_i2c_read(TWL6030_MODULE_GASGAUGE, val, FG_REG_00, 12);
+	sample_cntr = (val[3] << 16) | (val[2] << 8) | val[1];
+	accum = (val[7] << 24) | (val[6] << 16) | (val[5] << 8) | val[4];
+	offset = (val[9] << 8) | val[8];
+	integ = (val[11] << 8) | val[10];
+
+	/* convert from 10 bit signed to 32 bit signed */
+	if (offset & BIT_CC_OFFSET_09)
+		offset = 0xFFFFFC00 | offset;
+
+	cc_offset = offset;
+
+	/* convert from 13 bit signed to 32 bit signed */
+	if (integ & BIT_CC_INTEG_13)
+		integ = 0xFFFFC000 | integ;
+
+	//dbg("sample_cntr = %u, accum = %d, offset = %d, integ = %d\n",
+	//		sample_cntr, accum, offset, integ);
+	dbg("Battery current = %d mA\n", (integ * CONVERSION_FACTOR / 1000));
+
+	/* TODO: This is temporary fix to detect charging is full */
+	stat1 = 0;
+	stat2 = 0;
+	get_charger_status(&stat1, &stat2);
+
+	if ((stat1 == 0) && (stat2 == 0)) {
+		dbg("Battery status: Precharge, or fast charge in progress\n");
+		/* TODO: Remove this later. Added temporarility. */
+		if (stat_soc == 100) {
+			stat_soc -= 5;
+		}
+	} else if ((stat1 == 0) && (stat2 == 1)) {
+		dbg("Battery status: CHARGE COMPLETE\n");
+		stat_soc = 100; /* TODO: To be removed. Added temporariliy */
+		if (sec_bci->charger.is_charging) {
+			dbg("Battery Status changed to 'FULL'\n");
+			_battery_state_change_(STATUS_CATEGORY_CHARGING,
+					POWER_SUPPLY_STATUS_FULL,
+					CHARGE_DUR_ACTIVE);
+		}
+	} else if ((stat1 == 1) && (stat2 == 0)) {
+		dbg("Battery status: Fault\n");
+	} else if ((stat1 == 1) && (stat2 == 1)) {
+		dbg("Battery status: Charging Suspend\n");
+	}
+
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+}
+
+
+int twl6030_charge_current(void)
+{
+	u8 val[4];
+	int integ;
+	int charge_current;
+
+	memset(val, 0, sizeof(val));
+	twl_i2c_read(TWL6030_MODULE_GASGAUGE, val, FG_REG_10, 2);
+	integ = (val[1] << 8) | val[0];
+
+	/* convert from 13 bit signed to 32 bit signed */
+	if (integ & BIT_CC_INTEG_13)
+		integ = 0xFFFFC000 | integ;
+
+
+	charge_current = ((integ - cc_offset) * CONVERSION_FACTOR / 1000);
+	return charge_current;
+}
+
+
+static int get_average_value(int *data, int count)
+{
+	int average;
+	int min = 0;
+	int max = 0;
+	int sum = 0;
+	int i;
+
+	if (count >= 5) {
+		min = max = data[0];
+		for (i = 0; i < count; i++) {
+			if(data[i] < min)
+				min = data[i];
+
+			if (data[i] > max)
+				max = data[i];
+
+			sum += data[i];
+		}
+
+		average = (sum - max - min) / (count - 2);
+	} else {
+		for (i = 0; i < count; i++)
+			sum += data[i];
+
+		average = sum / count;
+	}
+
+	return average;
+}
+
+static int max17042_i2c_read(unsigned char reg_addr, u8 *buf, size_t len)
+{
+	int ret = 0;
+	struct i2c_msg msg[2];
+
+	if (fuelgauge_i2c_client == NULL) {
+		printk("WARN! Fuel guage is not completely initialized yet\n");
+		return -1;
+	}
+	msg[0].addr = fuelgauge_i2c_client->addr;
+	msg[0].flags = I2C_M_WR;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = fuelgauge_i2c_client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(fuelgauge_i2c_client->adapter, msg, 2);
+	if(ret != 2) {
+		printk("[FG] Fail to read max17040.\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int max17042_i2c_write(unsigned char reg_addr, u8 *buf, u8 len)
+{
+	int ret = 0;
+	struct i2c_msg msg;
+	u8 t_buf[20];
+
+	t_buf[0] = reg_addr;
+	memcpy(&t_buf[1], buf, len);
+
+	msg.addr = fuelgauge_i2c_client->addr;
+	msg.flags = I2C_M_WR;
+	msg.len = len;
+	msg.buf = t_buf;
+
+	ret = i2c_transfer(fuelgauge_i2c_client->adapter, &msg, 1);
+	if(ret < 0) {
+		printk("[FG] Fail to write max17040.");
+		return -1;
+	}
+	return ret;
+}
+
+
+static int stat_vcell = 100;
+int max17042_read_vcell(void)
+{
+	u8 data[2];
+	u32 vcell = 0;
+	u16 w_data;
+	u32 temp;
+	u32 temp2;
+
+	if (max17042_i2c_read(VCELL_REG, data, (u8)2) < 0) {
+		printk("max17042_read_vcell: Failed to read VCELL\n");
+		/* TODO: Returning dummy VCELL value. We should return -1 here. */
+		stat_vcell += 25;
+		return ((stat_vcell < 4500) ? stat_vcell : 4500);
+		//return -1;
+	}
+
+	w_data = ((data[1] << 8) | data[0]);
+	temp = (w_data & 0xFFFF) * 78125;
+	vcell = temp / 1000000;
+
+	temp = ((w_data & 0xF000) >> 4) * 78125;
+	temp2 = temp / 1000000;
+	vcell += (temp2 << 4);
+
+	dbg("max17042_read_vcell: VCELL(%d), data(0x%04x)\n", vcell, (data[1]<<8) | data[0]);
+	return vcell ;
+}
+
+int max17042_read_soc(void)
+{
+	u8 data[2];
+	u32 soc = 0;
+	u32 temp = 0;
+
+	if (max17042_i2c_read(SOCREP_REG, data, (u8)2) < 0) {
+		printk("max17042_read_soc: Failed to read SOCREP\n");
+		/* TODO: Returning some SOC value. We should return -1 here. */
+		stat_soc += 1;
+		return ((stat_soc <= 100)? stat_soc : 100);
+		//return -1;
+	}
+
+	temp = data[0] * 39 / 1000;
+	soc = data[1];
+	if(soc == 0) {
+		if(temp > 1)
+			soc = 1;
+	}
+
+	dbg("max17042_read_soc: SOC (%d)\n", soc);
+	soc = ((soc * 100) / 255);
+	if (soc==0)
+		soc =1;
+	dbg("SOC(%d)", soc);
+	return soc;
+}
+
+
+int max17042_check_status_reg(void)
+{
+	u8 status_data[2];
+	int ret=1;
+
+	if (max17042_i2c_read(STATUS_REG, status_data, (u8)2) < 0) {
+		printk("max17042_check_status_reg: Failed to read STATUS_REG\n");
+		return -1;
+	}
+
+	if(status_data[1] & (0x1 << 2)) {
+		ret = 1;
+		status_data[1] = 0;
+		if (max17042_i2c_write(STATUS_REG, status_data, (u8)2) < 0) {
+			printk("max17042_check_status_reg: Failed to write STATUS_REG\n");
+			return -1;
+		}
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+
+int get_fuelgauge_adc_value(int count, bool is_sleep)
+{
+	int val[count];
+	int result;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		val[i] = max17042_read_vcell();
+	}
+	result = get_average_value(val, count);
+	return result;
+}
+
+
+int get_fuelgauge_ptg_value( bool is_sleep )
+{
+	return max17042_read_soc();
+}
+
+
+int fuelgauge_quickstart(void)
+{
+	twl6030_gasgauge_disable();
+	mdelay(10);
+	twl6030_gasgauge_enable();
+
+	/* TODO: Implement MAX17042 restart */
+	dbg("WARN! fuelgauge_quickstart() doest not implement MAX17042 restart\n");
+	return 0;
+}
+
+
+static irqreturn_t low_battery_isr(int irq, void *_di)
+{
+	if (sec_bci->ready) {
+		cancel_delayed_work(&fuelgauge_work);
+		schedule_delayed_work(&fuelgauge_work, 0);
+	}
+	return IRQ_HANDLED;
+}
+
+
+static void fuelgauge_work_handler(struct work_struct *work)
+{
+	dbg("[FG] ext.low_battery!\n");
+	if (max17042_check_status_reg() == 1) {
+		dbg("LOW BATTERY ALARM\n");
+		_low_battery_alarm_();
+	}
+}
+
+
+int max17042_read_vfsoc(void)
+{
+	u8 data[2];
+	u32 vfsoc = 0;
+	u32 temp = 0;
+
+	if (max17042_i2c_read(VFSOC_REG, data, (u8)2) < 0) {
+		printk("max17042_read_vfsoc: Failed to read VFSOC\n");
+		return -1;
+	}
+
+	temp = data[0] * 39 / 1000;
+	vfsoc = data[1];
+	if(vfsoc == 0) {
+		if(temp > 1)  // over 0.1 %
+			vfsoc = 1;
+	}
+
+	dbg("max17042_read_vfsoc: VfSOC(%d), data(0x%04x)\n", vfsoc, (data[1]<<8) | data[0]);
+	return vfsoc;
+}
+
+
+unsigned int max17042_read_temp(void)
+{
+	u8 data[2];
+	u32 tempr = 0;
+	u32 buff = 0;
+
+	if (max17042_i2c_read(TEMPR_REG, data, (u8)2) < 0) {
+		printk("max17042_read_temp: Failed to read SOCREP\n");
+		return -1;
+	}
+
+	buff = data[0] * 39 / 1000;
+	tempr = data[1];
+	if(tempr == 0) {
+		if(buff > 1)  // over 0.1 %
+			tempr = 1;
+	}
+
+	dbg("max17042_read_temp:  TEMPRTRE(%d), data(0x%04x)\n", tempr, (data[1]<<8) | data[0]);
+	return tempr;
+}
+
+
+int max17042_read_current(void)
+{
+	u8 data1[2], data2[2];
+	u32 temp, sign;
+	s32 i_current = 0;
+	s32 avg_current = 0;
+
+	if (max17042_i2c_read(CURRENT_REG, data1, (u8)2) < 0) {
+		printk("max17042_read_current: Failed to read CURRENT\n");
+		return -1;
+	}
+
+	if (max17042_i2c_read(AVG_CURRENT_REG, data2, (u8)2) < 0) {
+		printk("max17042_read_current: Failed to read AVERAGE CURRENT\n");
+		return -1;
+	}
+
+	temp = ((data1[1]<<8) | data1[0]) & 0xFFFF;
+	if(temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~(temp) & 0xFFFF) + 1;
+	} else {
+		sign = POSITIVE;
+	}
+
+	temp = temp * 15625;
+	i_current = temp / 100000;
+	if(sign)
+		i_current *= -1;
+
+	temp = ((data2[1]<<8) | data2[0]) & 0xFFFF;
+	if(temp & (0x1 << 15)) {
+		sign = NEGATIVE;
+		temp = (~(temp) & 0xFFFF) + 1;
+	} else {
+		sign = POSITIVE;
+	}
+
+	temp = temp * 15625;
+	avg_current = temp / 100000;
+	if(sign)
+		avg_current *= -1;
+
+	dbg("max17042_read_current: CURRENT(%dmA), AVG_CURRENT(%dmA)\n", i_current, avg_current);
+	return 0;
+}
+
+
+int max17042_reset_soc(void)
+{
+	u8 data[2];
+
+	if(max17042_i2c_read(MISCCFG_REG, data, (u8)2) < 0) {
+		printk("max17042_reset_soc: Failed to read MiscCFG\n");
+		return -1;
+	}
+
+	data[1] |= (0x1 << 2);  // Set bit10 makes quick start
+	if (max17042_i2c_write(MISCCFG_REG, data, (u8)2) < 0){
+		printk("max17042_reset_soc: Failed to write MiscCFG\n");
+		return -1;
+	}
+
+	msleep(250);
+
+	// FullCAP
+	data[0] = 0x08;
+	data[1] = 0x20;
+	if (max17042_i2c_write(0x10, data, (u8)2) < 0)
+		printk("max17042_reset_soc: Failed to write FullCAP\n");
+	msleep(500);
+
+	dbg("max17042_reset_soc: After quick-start - VfSOC(%d), RepSOC(%d)\n", max17042_read_vfsoc(), max17042_read_soc());
+	return 0;
+}
+
+
+int max17042_reset_capacity(void)
+{
+	u8 data[2];
+
+	data[0] = 0x6C;
+	data[1] = 0x20;
+	if (max17042_i2c_write(0x18, data, (u8)2) < 0) {
+		printk("max17042_reset_capacity: Failed to write DesignCap\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+int max17042_check_chip_state(void)
+{
+	u32 vcell, soc;
+
+	vcell = max17042_read_vcell();
+	soc = max17042_read_soc();
+	dbg("max17042_check_chip_state: vcell(%d), soc(%d)\n", vcell, soc);
+	if( (vcell < 0) || (soc < 0) )
+		return 0;
+	else
+		return 1;
+}
+
+
+int max17042_adjust_capacity(void)
+{
+	u8 data[2];
+
+	data[1] = 0;
+	data[2] = 0;
+	if (max17042_i2c_write(REMCAP_REP_REG, data, (u8)2) < 0) {
+		printk("max17042_adjust_capacity: Failed to write RemCap_REP\n");
+		return -1;
+	}
+
+	if (max17042_i2c_write(SOCREP_REG, data, (u8)2) < 0) {
+		printk("max17042_adjust_capacity: Failed to write SOC_REP\n");
+		return -1;
+	}
+
+	if (max17042_i2c_write(SOCMIX_REG, data, (u8)2) < 0) {
+		printk("max17042_adjust_capacity: Failed to write SOC_MIX\n");
+		return -1;
+	}
+
+	if (max17042_i2c_write(REMCAP_MIX_REG, data, (u8)2) < 0) {
+		printk("max17042_adjust_capacity: Failed to write RemCap_MIX\n");
+		return -1;
+	}
+
+	msleep(200);
+	dbg("After adjust - RepSOC(%d)", max17042_read_soc());
+	return 0;
+}
+
+
+int max17042_check_battery_connected(void)
+{
+	u8 data[2];
+	if (max17042_i2c_read(STATUS_REG, data, (u8)2) < 0) {
+		return -1;
+	}
+
+	if (data[0] & (0x1<<3)) {
+		dbg("Battery Status: Battt is not present\n");
+		return 0;
+	} else {
+		dbg("Battery Status: Battt is present!!!!\n");
+		return 1;
+	}
+}
+
+
+static int max17042_alert_init(void)
+{
+	u8 misccgf_data[2];
+	u8 salrt_data[2];
+	u8 config_data[2];
+
+	dbg("Enter max17042_alert_init()\n");
+	// using RepSOC
+	if (max17042_i2c_read(MISCCFG_REG, misccgf_data, (u8)2) < 0) {
+		printk("Failed to read MISCCFG_REG\n");
+		return -1;
+	}
+	misccgf_data[0] = misccgf_data[0] & ~(0x03);
+
+	if (max17042_i2c_write(MISCCFG_REG, misccgf_data, (u8)2) < 0) {
+		printk("Failed to write MISCCFG_REG\n");
+		return -1;
+	}
+
+	// SALRT Threshold setting
+	salrt_data[1]=0xff;
+	salrt_data[0]=0x01; //1%
+	if (max17042_i2c_write(SALRT_THRESHOLD_REG, salrt_data, (u8)2) < 0) {
+		printk("Failed to write SALRT_THRESHOLD_REG\n");
+		return -1;
+	}
+
+	// Enable SOC alerts
+	if (max17042_i2c_read(CONFIG_REG, config_data, (u8)2) < 0) {
+		printk("Failed to read CONFIG_REG\n");
+		return -1;
+	}
+
+	config_data[0] = config_data[0] | (0x1 << 2);
+	if (max17042_i2c_write(CONFIG_REG, config_data, (u8)2) < 0) {
+		printk("Failed to write CONFIG_REG\n");
+		return -1;
+	}
+
+	dbg("Exit  max17042_alert_init()\n");
+	return 0;
+}
+
+
+static int fuelgauge_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+
+	dbg("[FG] Fuelgauge Probe. new.\n");
+	sec_bci = get_sec_bci();
+
+	if (strcmp(client->name, DRIVER_NAME) != 0) {
+		ret = -1;
+		printk("[FG] device not supported.\n");
+	}
+
+	fuelgauge_i2c_client = client;
+
+	/* Configure interrupt for FUEL_ALRT */
+	if (gpio_request(OMAP4430_UART3_RTS_SD_GPIO_142, "fuel_alrt irq") < 0) {
+		dbg("Failed to request GPIO%d\n", OMAP4430_UART3_RTS_SD_GPIO_142);
+		client->irq = 0;
+	} else {
+		dbg("Requesting for GPIO%d\n", OMAP4430_UART3_RTS_SD_GPIO_142);
+		client->irq = gpio_to_irq(OMAP4430_UART3_RTS_SD_GPIO_142);
+		gpio_direction_input(OMAP4430_UART3_RTS_SD_GPIO_142);
+	}
+
+	/* Initialize MAX17042 */
+	max17042_alert_init();
+
+	if (client->irq) {
+		INIT_DELAYED_WORK(&fuelgauge_work, fuelgauge_work_handler);
+		dbg("[FG] FUEL_ALRT_IRQ  : %d \n", client->irq);
+		dbg("[FG] FUEL_ALRT_GPIO : %d \n", irq_to_gpio(client->irq));
+		set_irq_type(client->irq, IRQ_TYPE_EDGE_FALLING );
+		ret = request_irq(client->irq, low_battery_isr, IRQF_DISABLED, client->name, NULL);
+		if (ret) {
+			printk("[FG] could not request irq %d, status %d\n", client->irq, ret);
+		}
+	}
+	return ret;
+}
+
+
+static int fuelgauge_remove(struct i2c_client *client)
+{
+	cancel_delayed_work(&twl6030_gasgauge_work);
+	return 0;
+}
+
+
+static void fuelgauge_shutdown(struct i2c_client *client)
+{
+	return;
+}
+
+
+static int fuelgauge_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	cancel_delayed_work(&twl6030_gasgauge_work);
+	return 0;
+}
+
+
+static int fuelgauge_resume(struct i2c_client *client)
+{
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+	return 0;
+}
+
+
+static const struct i2c_device_id fuelgauge_i2c_id[] = {
+	{ DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, fuelgauge_i2c_id);
+
+
+static struct i2c_driver fuelgauge_i2c_driver =
+{
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= fuelgauge_probe,
+	.remove		= __devexit_p(fuelgauge_remove),
+	.shutdown	= fuelgauge_shutdown,
+	.suspend	= fuelgauge_suspend,
+	.resume		= fuelgauge_resume,
+	.id_table	= fuelgauge_i2c_id,
+};
+
+
+int fuelgauge_init(void)
+{
+	int ret;
+
+	dbg("[FG] Fuelgauge Init.\n");
+	fuelgauge_i2c_client = NULL;
+
+	/* Initialize TWL6030 Gas gauge */
+	twl6030_gasgauge_enable();
+	twl6030_gasgauge_autoclear();
+	/* TODO: Calibration needs to be done */
+
+	INIT_DELAYED_WORK_DEFERRABLE(&twl6030_gasgauge_work, twl6030_gasgauge_work_handler);
+	schedule_delayed_work(&twl6030_gasgauge_work, WORK_DELAY);
+
+	if ((ret = i2c_add_driver(&fuelgauge_i2c_driver) < 0)) {
+		printk(KERN_ERR "[FG] i2c_add_driver failed.\n");
+	}
+	return ret;
+}
+
+
+void fuelgauge_exit(void)
+{
+	dbg("[FG] Fuelgauge Exit.\n");
+
+	twl6030_gasgauge_disable();
+	cancel_delayed_work(&twl6030_gasgauge_work);
+
+	i2c_del_driver( &fuelgauge_i2c_driver );
+}
+
Index: android-2.6.35/drivers/mfd/twl6030-gpadc.c
===================================================================
--- android-2.6.35.orig/drivers/mfd/twl6030-gpadc.c	2010-12-10 15:11:21.000000000 +0530
+++ android-2.6.35/drivers/mfd/twl6030-gpadc.c	2010-12-24 21:15:43.991662151 +0530
@@ -101,8 +101,8 @@
 	8,	/* CHANNEL 5 */
 	8,	/* CHANNEL 6 */
 
-	/* 5 */
-	40,	/* CHANNEL 7 */
+	/* 6.25 */
+	50,	/* CHANNEL 7 */
 
 	/* 6.25 */
 	50,	/* CHANNEL 8 */
