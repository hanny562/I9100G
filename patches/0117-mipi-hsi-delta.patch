diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/arch/arm/configs/android_omap4tab_rev04_defconfig Kernel/arch/arm/configs/android_omap4tab_rev04_defconfig
--- Kernel-org/arch/arm/configs/android_omap4tab_rev04_defconfig	2011-01-24 14:36:07.950274812 +0530
+++ Kernel/arch/arm/configs/android_omap4tab_rev04_defconfig	2011-01-24 11:07:43.717780810 +0530
@@ -1894,10 +1894,10 @@
 CONFIG_ST_GPS=m
 # CONFIG_ADIS16255 is not set
 CONFIG_OMAP_HSI=y
-CONFIG_SAMSUNG_IPC_HSI=y
 CONFIG_OMAP_HSI_DEVICE=y
 # CONFIG_OMAP_SSI_DEVICE is not set
-CONFIG_OMAP_HSI_CHAR=y
+CONFIG_OMAP_HSI_CHAR=m
+CONFIG_OMAP_HSI_PROTOCOL=y
 CONFIG_Sys_Link=y
 CONFIG_SYSLINK_PROC=y
 CONFIG_SYSLINK_PROC4430=y
@@ -1920,7 +1920,7 @@
 CONFIG_PHONE_MODEMCTL=m
 # CONFIG_PHONE_ONEDRAM is not set
 # CONFIG_PHONE_IPC_SPI is not set
-CONFIG_PHONE_IPC_HSI=m
+CONFIG_PHONE_IPC_HSI=y
 CONFIG_PHONE_SVNET=m
 # CONFIG_PHONE_LOOPBACK_TEST is not set
 # CONFIG_PHONE_STORAGE is not set
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/arch/arm/configs/android_omap4tab_rev05_defconfig Kernel/arch/arm/configs/android_omap4tab_rev05_defconfig
--- Kernel-org/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-01-24 14:55:40.239022814 +0530
+++ Kernel/arch/arm/configs/android_omap4tab_rev05_defconfig	2011-01-24 11:07:43.717780810 +0530
@@ -1918,7 +1918,8 @@
 CONFIG_OMAP_HSI=y
 CONFIG_OMAP_HSI_DEVICE=y
 # CONFIG_OMAP_SSI_DEVICE is not set
-CONFIG_OMAP_HSI_CHAR=y
+CONFIG_OMAP_HSI_CHAR=m
+CONFIG_OMAP_HSI_PROTOCOL=y
 CONFIG_Sys_Link=y
 CONFIG_SYSLINK_PROC=y
 CONFIG_SYSLINK_PROC4430=y
@@ -1940,7 +1941,7 @@
 CONFIG_PHONE_MODEMCTL=m
 # CONFIG_PHONE_ONEDRAM is not set
 # CONFIG_PHONE_IPC_SPI is not set
-CONFIG_PHONE_IPC_HSI=m
+CONFIG_PHONE_IPC_HSI=y
 CONFIG_PHONE_SVNET=m
 # CONFIG_PHONE_LOOPBACK_TEST is not set
 # CONFIG_PHONE_STORAGE is not set
@@ -2147,11 +2148,7 @@
 # CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
-CONFIG_KGDB=y
-CONFIG_KGDB_SERIAL_CONSOLE=y
-# CONFIG_KGDB_TESTS is not set
-CONFIG_KGDB_KDB=y
-# CONFIG_KDB_KEYBOARD is not set
+# CONFIG_KGDB is not set
 # CONFIG_ARM_UNWIND is not set
 # CONFIG_DEBUG_USER is not set
 # CONFIG_DEBUG_ERRORS is not set
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/arch/arm/mach-omap2/board-omap4tab10-1.c Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c
--- Kernel-org/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-24 14:56:46.387770843 +0530
+++ Kernel/arch/arm/mach-omap2/board-omap4tab10-1.c	2011-01-21 15:17:47.308980519 +0530
@@ -162,9 +162,6 @@
 #define OMAP4430_GPIO_MIPI_HSI_RESET_REQ_N			50
 #define OMAP4430_GPIO_MIPI_HSI_CP_ON					36
 #define OMAP4430_GPIO_MIPI_HSI_CP_RST				2	//wk2
-#define OMAP4430_GPIO_MIPI_HSI_IPC_SLAVE_WAKEUP	53
-#define OMAP4430_GPIO_MIPI_HSI_IPC_HOST_WAKEUP		52
-#define OMAP4430_GPIO_MIPI_HSI_ACTIVE_STATE			55
 #define OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST		56
 #define OMAP4430_GPIO_MIPI_HSI_PDA_ACTIVE			119
 #define OMAP4430_GPIO_MIPI_HSI_PHONE_ACTIVE			120
@@ -848,23 +845,16 @@
 
 #if defined( CONFIG_SAMSUNG_PHONE_SVNET )
 
-static void mipi_hsi_cfg_gpio( void );
+static void ipc_hsi_cfg_gpio( void );
 
-static struct ipc_hsi_platform_data mipi_hsi_data = {
-	.gpio_ipc_host_wakeup = OMAP4430_GPIO_MIPI_HSI_IPC_HOST_WAKEUP,
-	.gpio_ipc_slave_wakeup = OMAP4430_GPIO_MIPI_HSI_IPC_SLAVE_WAKEUP,
+static struct ipc_hsi_platform_data ipc_hsi_data = {
 	.gpio_suspend_request = OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST,
 
-	.cfg_gpio = mipi_hsi_cfg_gpio,
+	.cfg_gpio = ipc_hsi_cfg_gpio,
 };
 
-static struct resource mipi_hsi_res[] = {
-	[ 0 ] = {
-		.start = OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_IPC_HOST_WAKEUP ),
-		.end = OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_IPC_HOST_WAKEUP ),
-		.flags = IORESOURCE_IRQ,
-	},
-	[ 1 ] = {	 // suspend_request irq
+static struct resource ipc_hsi_res[] = {
+	[ 0 ] = {	 // suspend_request irq
 		.start = OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST ),
 		.end = OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST ),
 		.flags = IORESOURCE_IRQ,
@@ -881,93 +871,48 @@
 	},
 };
 #else
-static struct platform_device mipi_hsi = {
+static struct platform_device ipc_hsi = {
 	.name = "onedram",
 	.id = -1,
-	.num_resources = ARRAY_SIZE( mipi_hsi_res ),
-	.resource = mipi_hsi_res,
+	.num_resources = ARRAY_SIZE( ipc_hsi_res ),
+	.resource = ipc_hsi_res,
 	.dev = {
-		.platform_data = &mipi_hsi_data,
+		.platform_data = &ipc_hsi_data,
 	},
 };
 #endif
 
-static void mipi_hsi_cfg_gpio( void )
+static void ipc_hsi_cfg_gpio( void )
 {
 	int err = 0;
-	printk( "mipi_hsi_cfg_gpio - start...\n" );
 	
 #ifdef _OMAP_MUX_SETTING
 	void __iomem* gpio_reg_addr;
 	u32 reg_val;
 #endif
 	
-	unsigned gpio_ipc_host_wakeup= mipi_hsi_data.gpio_ipc_host_wakeup;
-	unsigned gpio_ipc_slave_wakeup = mipi_hsi_data.gpio_ipc_slave_wakeup;
-	unsigned gpio_suspend_request = mipi_hsi_data.gpio_suspend_request;	
-
-#if 1 //test
+	unsigned gpio_suspend_request = ipc_hsi_data.gpio_suspend_request;
 
 #ifdef _OMAP_MUX_SETTING
-
-	// gpio_53 ( IPC_SLAVE_WAKEUP ), gpio_52 ( IPC_HOST_WAKEUP )
-      	gpio_reg_addr = ( u32 ) ( OMAP4_CTRL_MODULE_PAD_CORE_MUX_PBASE + OMAP4_CTRL_MODULE_PAD_GPMC_NCS2_OFFSET );
-      	reg_val = omap_readl( gpio_reg_addr );
-      	reg_val &= 0x00000000; // save origin val
-      	reg_val |= 0xc10bc10b; // 14,15bit set1 : wakeup event, Muxmod 3, Muxmod 3
-      	omap_writel( reg_val, gpio_reg_addr );
-	printk( "mipi_hsi_cfg_gpio - %s gpio setting done...\n", "IPC_SLAVE_WAKEUP" );
-	printk( "mipi_hsi_cfg_gpio - %s gpio setting done...\n", "IPC_HOST_WAKEUP" );
-
-	// gpio_55 ( ACTIVE_STATE )
-      	gpio_reg_addr = ( u32 ) ( OMAP4_CTRL_MODULE_PAD_CORE_MUX_PBASE + OMAP4_CTRL_MODULE_PAD_GPMC_NWP_OFFSET );
-      	reg_val = omap_readl( gpio_reg_addr );
-      	reg_val &= 0x0000FFFF; // save origin val
-      	reg_val |= 0xc10b0000; // 14,15bit set1 : wakeup event, Muxmod 3
-      	omap_writel( reg_val, gpio_reg_addr );
-	printk( "mipi_hsi_cfg_gpio - %s gpio setting done...\n", "ACTIVE_STATE" );
-
 	// gpio_56 ( SUSPEND_REQUEST )
-      	gpio_reg_addr = ( u32 ) ( OMAP4_CTRL_MODULE_PAD_CORE_MUX_PBASE + OMAP4_CTRL_MODULE_PAD_GPMC_NADV_ALE_OFFSET );
-      	reg_val = omap_readl( gpio_reg_addr );
+      	gpio_reg_addr = ( void __iomem* )( OMAP4_CTRL_MODULE_PAD_CORE_MUX_PBASE + OMAP4_CTRL_MODULE_PAD_GPMC_NADV_ALE_OFFSET );
+      	reg_val = omap_readl( ( u32 )gpio_reg_addr );
       	reg_val &= 0xFFFF0000; // save origin val
       	reg_val |= 0x0000c10b; // Muxmod 3,  14,15bit set1 : wakeup event
-      	omap_writel( reg_val, gpio_reg_addr );
-	printk( "mipi_hsi_cfg_gpio - %s gpio setting done...\n", "SUSPEND_REQUEST" );
-	
+      	omap_writel( reg_val, ( u32 )gpio_reg_addr );
+	printk( "ipc_hsi_cfg_gpio - %s gpio setting done...\n", "SUSPEND_REQUEST" );
 #endif  //_OMAP_MUX_SETTING
 
-
-	err = gpio_request( gpio_ipc_host_wakeup, "IPC_HOST_WAKEUP" );
-	if( err ) {
-		printk( "mipi_hsi_cfg_gpio - fail to request gpio %s : %d\n", "IPC_HOST_WAKEUP", err );
-	}
-	else {
-		gpio_direction_input( gpio_ipc_host_wakeup );
-	}
-
-	err = gpio_request( gpio_ipc_slave_wakeup, "IPC_SLAVE_WAKEUP" );
-	if( err ) {
-		printk( "mipi_hsi_cfg_gpio - fail to request gpio %s : %d\n", "IPC_SLAVE_WAKEUP", err );
-	}
-	else {
-		gpio_direction_output( gpio_ipc_slave_wakeup, 0 );
-	}
-
 	err = gpio_request( gpio_suspend_request, "SUSPEND_REQUEST" );
 	if( err ) {
-		printk( "mipi_hsi_cfg_gpio - fail to request gpio %s : %d\n", "SUSPEND_REQUEST", err );
+		printk( "ipc_hsi_cfg_gpio - fail to request gpio %s : %d\n", "SUSPEND_REQUEST", err );
 	}
 	else {
 		gpio_direction_input( gpio_suspend_request );
 	}
 	
-	// Irq Setting -
-	set_irq_type( OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_IPC_HOST_WAKEUP ), IRQ_TYPE_EDGE_RISING );
-	set_irq_type( OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST ), IRQ_TYPE_LEVEL_HIGH );
-	
-#endif //test
-
+	// Irq Setting
+	set_irq_type( OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_SUSPEND_REQUEST ), IRQ_TYPE_EDGE_BOTH );
 }
 
 static void modemctl_cfg_gpio( void );
@@ -1060,7 +1005,6 @@
       	omap_writel( reg_val, gpio_reg_addr );  
 	printk( "modemctl_cfg_gpio - %s gpio setting done...\n", "PDA_ACTIVE" );
 	printk( "modemctl_cfg_gpio - %s gpio setting done...\n", "PHONE_ACTIVE" );
-
 #endif  //_OMAP_MUX_SETTING
 
 	err = gpio_request( gpio_reset_req_n, "RESET_REQ_N" );
@@ -1104,7 +1048,6 @@
 	}
 	
 	set_irq_type( OMAP_GPIO_IRQ( OMAP4430_GPIO_MIPI_HSI_PHONE_ACTIVE ), IRQ_TYPE_EDGE_BOTH );
-
 	//set_irq_type( gpio_sim_ndetect, IRQ_TYPE_EDGE_BOTH );
 }
 #endif // CONFIG_SAMSUNG_PHONE_SVNET
@@ -1126,7 +1069,7 @@
 #if defined( CONFIG_MIPI_HSI_LOOPBACK_TEST )
 	&mipi_hsi_test,
 #else
-	&mipi_hsi,
+	&ipc_hsi,
 #endif
 	&modemctl,
 #endif // CONFIG_SAMSUNG_PHONE_SVNET
@@ -1468,7 +1411,12 @@
 	{
 		I2C_BOARD_INFO("secFuelgaugeDev", 0x34),
 	},
-
+	{
+		I2C_BOARD_INFO("cam_pmic", 0x7D),
+	},
+	{
+		I2C_BOARD_INFO("M5MO", 0x3E >> 1),
+	}
 };
 #endif
 #if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
@@ -1487,7 +1435,7 @@
 #if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 5)
 	{
 		I2C_BOARD_INFO("max17040", 0x36),
- 	}
+ 	},
 #endif
 #if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
 	{
@@ -1545,7 +1493,7 @@
         },
         {
                 I2C_BOARD_INFO("gp2a",0x44),
-
+		.platform_data = &gp2a_pdata,
         },
         {
                I2C_BOARD_INFO("fsa9480", (0x4A >> 1)),
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/ipc_hsi/ipc_hsi.c Kernel/drivers/phone_svn/ipc_hsi/ipc_hsi.c
--- Kernel-org/drivers/phone_svn/ipc_hsi/ipc_hsi.c	2011-01-24 14:36:07.820274072 +0530
+++ Kernel/drivers/phone_svn/ipc_hsi/ipc_hsi.c	2011-01-24 11:07:43.797946165 +0530
@@ -20,13 +20,18 @@
 
 #define DEBUG
 
-//#define FORMAT_TX_DUMP
-//#define RAW_TX_DUMP
-//#define RFS_TX_DUMP
-//#define FORMAT_RX_DUMP
-//#define RAW_RX_DUMP
-//#define RFS_RX_DUMP
-//#define RFS_TX_RX_LENGTH_DUMP
+#define FORMAT_TX_DUMP
+#define RAW_TX_DUMP
+#define RFS_TX_DUMP
+#define ALL_TX_DUMP
+
+#define FORMAT_RX_DUMP
+#define RAW_RX_DUMP
+#define RFS_RX_DUMP
+#define ALL_RX_DUMP
+
+#define RAW_TX_RX_LENGTH_DUMP
+#define RFS_TX_RX_LENGTH_DUMP
 
 
 #include <linux/init.h>
@@ -51,6 +56,8 @@
 #include <linux/gpio.h>
 #include <linux/delay.h>
 #include <linux/in.h>
+#include <linux/workqueue.h>
+
 #include <linux/hsi_driver_if.h>
 
 
@@ -95,57 +102,40 @@
 };
 #define MBC_MASK					0xFF
 
-#define MAX_BUF_SIZE				2044
-#define DEF_BUF_SIZE				MAX_BUF_SIZE
-
-static struct spi_device *p_ipc_spi = NULL;
-
-typedef struct spi_protocol_header_rec {
-	unsigned long current_data_size:12;
-	unsigned long more:1;
-	unsigned long rx_error:1;
-	unsigned long packet_id:2;
-	unsigned long reserved:2;
-	unsigned long next_data_size:10;
-	unsigned long RI:1;
-	unsigned long DCD:1;
-	unsigned long RTSCTS:1;
-	unsigned long DSRDTR:1;
-} spi_protocol_header;
 
 struct onedram_reg_mapped {
 	u32 sem;
-	u32 reserved1[7];
+	u32 reserved1[ 7 ];
 	u32 mailbox_AB;  // CP write, AP read
-	u32 reserved2[7];
+	u32 reserved2[ 7 ];
 	u32 mailbox_BA;  // AP write, CP read
-	u32 reserved3[23];
+	u32 reserved3[ 23 ];
 	u32 check_AB;    // can't read
-	u32 reserved4[7];
+	u32 reserved4[ 7 ];
 	u32 check_BA;    // 0: CP read, 1: CP don't read
 };
 
-struct ipc_spi_handler {
+struct ipc_hsi_handler {
 	struct list_head list;
 	void *data;
-	void (*handler)(u32, void *);
+	void ( *handler )( u32, void * );
 };
 
-struct ipc_spi_handler_head {
+struct ipc_hsi_handler_head {
 	struct list_head list;
 	u32 len;
 	spinlock_t lock;
 };
-static struct ipc_spi_handler_head h_list;
+static struct ipc_hsi_handler_head h_list;
 
-static struct resource ipc_spi_resource = {
+static struct resource ipc_hsi_resource = {
 	.name = DRVNAME,
 	.start = 0,
 	.end = -1,
 	.flags = IORESOURCE_MEM,
 };
 
-struct ipc_spi {
+struct ipc_hsi {
 	struct class *class;
 	struct device *dev;
 	struct cdev cdev;
@@ -159,7 +149,7 @@
 	unsigned long size;
 	void __iomem *mmio;
 
-	int irq;
+	int irq, irq_suspend_req;
 
 	struct completion comp;
 	atomic_t ref_sem;
@@ -169,66 +159,72 @@
 
 	struct onedram_reg_mapped *reg;
 };
-struct ipc_spi *ipc_spi;
+struct ipc_hsi *ipc_hsi;
 
-typedef struct ipc_spi_send_modem_bin_workq_data {
-	struct ipc_spi *od;
+struct workqueue_struct* ipc_hsi_wq;
+typedef struct ipc_hsi_send_modem_bin_workq_data {
+	struct ipc_hsi *od;
 	
 	struct work_struct send_modem_w;
-} ipc_spi_send_modem_bin_workq_data_t;
-struct ipc_spi_send_modem_bin_workq_data *ipc_spi_send_modem_work_data;
+} ipc_hsi_send_modem_bin_workq_data_t;
+struct ipc_hsi_send_modem_bin_workq_data *ipc_hsi_send_modem_work_data;
+
+typedef struct ipc_hsi_data_rec {
+	u8 *buf;
+
+	u32 channel;
+	u32 len;
+	u8 more;
+} ipc_hsi_data;
+
 
-static DEFINE_SPINLOCK( ipc_spi_lock );
+static DEFINE_SPINLOCK( ipc_hsi_lock );
 
 static unsigned long hw_tmp; /* for hardware */
-static inline int _read_sem(struct ipc_spi *od);
-static inline void _write_sem(struct ipc_spi *od, int v);
+static inline int _read_sem( struct ipc_hsi *od );
+static inline void _write_sem( struct ipc_hsi *od, int v );
 
 struct completion ril_init;
-static unsigned gpio_ipc_host_wakeup;
-static unsigned gpio_ipc_slave_wakeup;
 static unsigned gpio_suspend_request;
-static unsigned gpio_mrdy;
-static unsigned gpio_srdy;
-struct semaphore srdy_sem;
 struct semaphore transfer_event_sem;
 static int transfer_thread_waiting = 0;
+static int cp_flow_control_stop_transfer = 0;
+static int cp_restart = 0;
 static int loop_back_test = 0;
 
 volatile static void __iomem *p_virtual_buff = 0;
 
 static unsigned long recv_cnt;
 static unsigned long send_cnt;
-static ssize_t show_debug(struct device *d,
-		struct device_attribute *attr, char *buf)
+static ssize_t show_debug( struct device *d, struct device_attribute *attr, char *buf )
 {
 	char *p = buf;
-	struct ipc_spi *od = dev_get_drvdata(d);
+	struct ipc_hsi *od = dev_get_drvdata( d );
 
-	if (!od)
+	if( !od )
 		return 0;
 
-	p += sprintf(p, "Semaphore: %d (%d)\n", _read_sem(od), (char)hw_tmp);
-	p += sprintf(p, "Mailbox: %x\n", od->reg->mailbox_AB);
-	p += sprintf(p, "Reference count: %d\n", atomic_read(&od->ref_sem));
-	p += sprintf(p, "Mailbox send: %lu\n", send_cnt);
-	p += sprintf(p, "Mailbox recv: %lu\n", recv_cnt);
+	p += sprintf( p, "Semaphore: %d (%d)\n", _read_sem( od ), ( char )hw_tmp );
+	p += sprintf( p, "Mailbox: %x\n", od->reg->mailbox_AB );
+	p += sprintf( p, "Reference count: %d\n", atomic_read( &od->ref_sem ) );
+	p += sprintf( p, "Mailbox send: %lu\n", send_cnt );
+	p += sprintf( p, "Mailbox recv: %lu\n", recv_cnt );
 
 	return p - buf;
 }
 
 static DEVICE_ATTR(debug, S_IRUGO, show_debug, NULL);
 
-static struct attribute *ipc_spi_attributes[] = {
+static struct attribute *ipc_hsi_attributes[] = {
 	&dev_attr_debug.attr,
 	NULL
 };
 
-static const struct attribute_group ipc_spi_group = {
-	.attrs = ipc_spi_attributes,
+static const struct attribute_group ipc_hsi_group = {
+	.attrs = ipc_hsi_attributes,
 };
 
-static inline void _write_sem( struct ipc_spi *od, int v )
+static inline void _write_sem( struct ipc_hsi *od, int v )
 {
 	//od->reg->sem = v;
 	od->reg->sem = 1;
@@ -236,16 +232,18 @@
 	hw_tmp = od->reg->sem; /* for hardware */
 }
 
-static inline int _read_sem( struct ipc_spi *od )
+static inline int _read_sem( struct ipc_hsi *od )
 {
 	od->reg->sem = 1;
 	
 	return od->reg->sem;
 }
 
-static inline int _send_cmd( struct ipc_spi *od, u32 cmd )
+extern void kernel_restart( char *cmd );
+static inline int _send_cmd( struct ipc_hsi *od, u32 cmd )
 {
 	u32 tmp_cmd;
+//	char cmd_string[] = "cp_crash";
 	
 	if (!od) {
 		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
@@ -260,6 +258,26 @@
 
 //	dev_dbg( od->dev, "(%d) send %x\n", __LINE__, cmd );
 
+	if( cmd == 0x45674567 ) {
+		dev_dbg( od->dev, "(%d) modem image loaded.\n", __LINE__ );
+		dev_dbg( od->dev, "(%d) start to send modem binary to cp.\n", __LINE__ );
+
+		ipc_hsi_send_modem_work_data->od = od;
+		//schedule_work( &ipc_hsi_send_modem_work_data->send_modem_w );
+		if( !queue_work( ipc_hsi_wq, &ipc_hsi_send_modem_work_data->send_modem_w ) ) { // enqueue work			
+			dev_err( od->dev, "(%d) already exist w-q\n", __LINE__ );		
+		}
+
+		return 0;
+	}
+#if 0
+	else if( cmd == 0xF0F0F0F0 ) {
+		dev_err( od->dev, "(%d) CP RamDump Done. cmd : %x\n", __LINE__, cmd );
+		kernel_restart( cmd_string );
+
+		return 0;
+	}
+#endif
 	if( cmd & MB_VALID ) {
 		if( cmd & MB_COMMAND ) {
 			tmp_cmd = ( cmd & MBC_MASK ) & ~( MB_CMD( 0 ) );
@@ -273,7 +291,7 @@
 					od->reg->mailbox_BA = cmd;
 
 					if( transfer_thread_waiting ) {
-						transfer_thread_waiting = 0;
+						//transfer_thread_waiting = 0;
 						up( &transfer_event_sem );
 					}
 
@@ -291,38 +309,29 @@
 			dev_dbg( od->dev, "(%d) =>send data ( 0x%x )\n", __LINE__, cmd );
 			
 			if( transfer_thread_waiting ) {
-				transfer_thread_waiting = 0;
+				//transfer_thread_waiting = 0;
 				up( &transfer_event_sem );
 			}
 		}
 	}
 	else {
-		if( cmd == 0x45674567 ) {
-			dev_dbg( od->dev, "(%d) modem image loaded.\n", __LINE__ );
-			dev_dbg( od->dev, "(%d) start to send modem binary to cp.\n", __LINE__ );
-
-			ipc_spi_send_modem_work_data->od = od;
-			schedule_work( &ipc_spi_send_modem_work_data->send_modem_w );
-		}
-		else {
-			dev_err( od->dev, "(%d) send invalid cmd : 0x%x\n", __LINE__, cmd );
-		}
+		dev_err( od->dev, "(%d) send invalid cmd : 0x%x\n", __LINE__, cmd );
 	}
 	
 	return 0;
 }
 
-static inline int _recv_cmd( struct ipc_spi *od, u32 *cmd )
+static inline int _recv_cmd( struct ipc_hsi *od, u32 *cmd )
 {
-	if (!cmd)
+	if( !cmd )
 		return -EINVAL;
 
-	if (!od) {
-		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
+	if( !od ) {
+		printk( KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__ );
 		return -EFAULT;
 	}
 
-	if (!od->reg) {
+	if( !od->reg ) {
 		dev_err( od->dev, "(%d) Failed to read cmd, not initialized\n", __LINE__ );
 		
 		return -EFAULT;
@@ -330,28 +339,29 @@
 
 	recv_cnt++;
 	*cmd = od->reg->mailbox_AB;
+	
 	return 0;
 }
 
-static inline int _get_auth( struct ipc_spi *od, u32 cmd )
+static inline int _get_auth( struct ipc_hsi *od, u32 cmd )
 {
 	unsigned long timeleft;
 	int retry = 0;
 
 	/* send cmd every 20m seconds */
-	while (1) {
-		_send_cmd(od, cmd);
+	while( 1 ) {
+		_send_cmd( od, cmd );
 
-		timeleft = wait_for_completion_timeout(&od->comp, HZ/50);
+		timeleft = wait_for_completion_timeout( &od->comp, HZ/50 );
 #if 0		
-		if (timeleft)
+		if( timeleft )
 			break;
 #endif
-		if (_read_sem(od))
+		if( _read_sem( od ) )
 			break;
 
 		retry++;
-		if (retry > 50 ) { /* time out after 1 seconds */
+		if( retry > 50 ) { /* time out after 1 seconds */
 			dev_err( od->dev, "(%d) get authority time out\n", __LINE__ );
 			
 			return -ETIMEDOUT;
@@ -361,16 +371,16 @@
 	return 0;
 }
 
-static int get_auth( struct ipc_spi *od, u32 cmd )
+static int get_auth( struct ipc_hsi *od, u32 cmd )
 {
 	int r;
 
-	if (!od) {
-		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
+	if( !od ) {
+		printk( KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__ );
 		return -EFAULT;
 	}
 
-	if (!od->reg) {
+	if( !od->reg ) {
 		dev_err( od->dev, "(%d) Failed to get authority\n", __LINE__ );
 		
 		return -EFAULT;
@@ -378,11 +388,11 @@
 
 	//atomic_inc( &od->ref_sem );
 
-	if (_read_sem(od))
+	if( _read_sem( od ) )
 		return 0;
 
-	if (cmd)
-		r = _get_auth(od, cmd);
+	if( cmd )
+		r = _get_auth( od, cmd );
 	else
 		r = -EACCES;
 
@@ -392,14 +402,14 @@
 	return r;
 }
 
-static int put_auth( struct ipc_spi *od, int release )
+static int put_auth( struct ipc_hsi *od, int release )
 {
-	if (!od) {
-		printk(KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__);
+	if( !od ) {
+		printk( KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__ );
 		return -EFAULT;
 	}
 
-	if (!od->reg) {
+	if( !od->reg ) {
 		dev_err( od->dev, "(%d) Failed to put authority\n", __LINE__ );
 		
 		return -EFAULT;
@@ -417,14 +427,14 @@
 	return 0;
 }
 
-static int rel_sem( struct ipc_spi *od )
+static int rel_sem( struct ipc_hsi *od )
 {
-	if (!od) {
-		printk(KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__);
+	if( !od ) {
+		printk( KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__ );
 		return -EFAULT;
 	}
 
-	if (!od->reg) {
+	if( !od->reg ) {
 		dev_err( od->dev, "(%d) Failed to put authority\n", __LINE__ );
 		
 		return -EFAULT;
@@ -441,238 +451,254 @@
 	return 0;
 }
 
-int onedram_read_mailbox(u32 *mb)
+int onedram_read_mailbox( u32 *mb )
 {
-	return _recv_cmd( ipc_spi, mb );
+	return _recv_cmd( ipc_hsi, mb );
 }
-EXPORT_SYMBOL(onedram_read_mailbox);
+EXPORT_SYMBOL( onedram_read_mailbox );
 
-int onedram_write_mailbox(u32 mb)
+int onedram_write_mailbox( u32 mb )
 {
-	return _send_cmd( ipc_spi, mb );
+	return _send_cmd( ipc_hsi, mb );
 }
 EXPORT_SYMBOL(onedram_write_mailbox);
 
-void onedram_init_mailbox(void)
+void onedram_init_mailbox( void )
 {
 	int r = 0;
 	/* flush mailbox before registering onedram irq */
-	r = ipc_spi->reg->mailbox_AB;
+	r = ipc_hsi->reg->mailbox_AB;
 
 	/* Set nINT_ONEDRAM_CP to low */
-	ipc_spi->reg->mailbox_BA=0x0;
+	ipc_hsi->reg->mailbox_BA=0x0;
 }
-EXPORT_SYMBOL(onedram_init_mailbox);
+EXPORT_SYMBOL( onedram_init_mailbox );
 
-int onedram_get_auth(u32 cmd)
+int onedram_get_auth( u32 cmd )
 {
-	return get_auth( ipc_spi, cmd );
+	return get_auth( ipc_hsi, cmd );
 }
-EXPORT_SYMBOL(onedram_get_auth);
+EXPORT_SYMBOL( onedram_get_auth );
 
-int onedram_put_auth(int release)
+int onedram_put_auth( int release )
 {
-	return put_auth( ipc_spi, release );
+	return put_auth( ipc_hsi, release );
 }
-EXPORT_SYMBOL(onedram_put_auth);
+EXPORT_SYMBOL( onedram_put_auth );
 
-int onedram_rel_sem(void)
+int onedram_rel_sem( void )
 {
-	return rel_sem( ipc_spi );
+	return rel_sem( ipc_hsi );
 }
-EXPORT_SYMBOL(onedram_rel_sem);
+EXPORT_SYMBOL( onedram_rel_sem );
 
-int onedram_read_sem(void)
+int onedram_read_sem( void )
 {
-	return _read_sem( ipc_spi );
+	return _read_sem( ipc_hsi );
 }
 EXPORT_SYMBOL(onedram_read_sem);
 
-void onedram_get_vbase(void** vbase)
+void onedram_get_vbase( void** vbase )
 {
-	*vbase = (void*)ipc_spi->mmio;
+	*vbase = (void*)ipc_hsi->mmio;
 }
-EXPORT_SYMBOL(onedram_get_vbase);
-
-//static unsigned long long old_clock;
-//static u32 old_mailbox;
+EXPORT_SYMBOL( onedram_get_vbase );
 
-static int ipc_spi_irq_log_flag = 0;
-static irqreturn_t ipc_spi_irq_handler( int irq, void *data ) // SRDY Rising EDGE ISR
+static void ipc_hsi_make_data_interrupt( struct ipc_hsi *od, u32 cmd )
 {
-	struct ipc_spi *od = ( struct ipc_spi * )data;
-	int srdy_pin = 0;
+	struct list_head *l;
+	unsigned long flags;
+	u32 mailbox;
 
-	srdy_pin = gpio_get_value( gpio_srdy );
-	
-	if( ipc_spi_irq_log_flag )
-		dev_dbg( od->dev, "(%d) isr SRDY : %d\n", __LINE__, srdy_pin );
+	mailbox = cmd;
+	dev_err( od->dev, "(%d) <=make data int : 0x%08x\n", __LINE__, mailbox );
+
+	if( h_list.len ) {
+		spin_lock_irqsave( &h_list.lock, flags );
+		list_for_each( l, &h_list.list ) {
+			struct ipc_hsi_handler *h = list_entry( l, struct ipc_hsi_handler, list );
 
-	if( !srdy_pin ) {
-		dev_err( od->dev, "SRDY LOW.\n" );
+			if( h->handler ) h->handler( mailbox, h->data );
+		}
+		spin_unlock_irqrestore( &h_list.lock, flags );
 
-		return IRQ_HANDLED;
+		spin_lock( &ipc_hsi_lock );
+		od->mailbox = mailbox;
+		spin_unlock( &ipc_hsi_lock );
+	} else {
+		od->mailbox = mailbox;
 	}
 
-	up( &srdy_sem ); // signal srdy event
+	dev_err( od->dev, "(%d) <=send data int cmd event\n", __LINE__ );
+	
+	wake_up_interruptible( &od->waitq );
+	kill_fasync( &od->async_queue, SIGIO, POLL_IN );
+}
 
-	if( transfer_thread_waiting ) {
-		transfer_thread_waiting = 0;
+static irqreturn_t ipc_hsi_irq_suspend_req_handler( int irq, void *data ) // suspend request : cp fatal
+{
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-		if( ipc_spi_irq_log_flag )
-			dev_dbg( od->dev, "(%d) signal transfer event.\n", __LINE__ );
-		
-		up( &transfer_event_sem ); // signal transfer event
-	}
+	dev_err( od->dev, "(%d) isr suspend req level : %d\n", __LINE__, gpio_get_value( gpio_suspend_request ) );
+
+	//if( !gpio_get_value( gpio_cp_int ) ) {
+		//make data interrupt cmd
+		//int_cmd = MB_CMD( MBC_ERR_DISPLAY );
+		//ipc_hsi_make_data_interrupt( od, int_cmd );
+
+		//dev_err( od->dev, "(%d) CP FATAL!!!\n", __LINE__ );
+	//}
 
 	return IRQ_HANDLED;
 }
 
+
 #if 0
-static void ipc_spi_vm_close(struct vm_area_struct *vma)
+static void ipc_hsi_vm_close( struct vm_area_struct *vma )
 {
-	struct ipc_spi *od = vma->vm_private_data;
+	struct ipc_hsi *od = vma->vm_private_data;
 	unsigned long offset;
 	unsigned long size;
 
-	put_auth(od, 0);
+	put_auth( od, 0 );
 
-	offset = (vma->vm_pgoff << PAGE_SHIFT) - od->base;
+	offset = ( vma->vm_pgoff << PAGE_SHIFT ) - od->base;
 	size = vma->vm_end - vma->vm_start;
-	dev_dbg(od->dev, "Rel region: 0x%08lx 0x%08lx\n", offset, size);
-	onedram_release_region(offset, size);
+	dev_dbg( od->dev, "Rel region: 0x%08lx 0x%08lx\n", offset, size );
+	
+	onedram_release_region( offset, size );
 }
 #endif
 
-static int ipc_spi_vm_pagefault( struct vm_area_struct *vma, struct vm_fault *vmf )
+static int ipc_hsi_vm_pagefault( struct vm_area_struct *vma, struct vm_fault *vmf )
 {
-	struct ipc_spi *od = vma->vm_private_data;
+	struct ipc_hsi *od = vma->vm_private_data;
 	
-//	dev_dbg( od->dev, "(%d) ipc_spi_vm_pagefault.\n", __LINE__ );
+//	dev_dbg( od->dev, "(%d) ipc_hsi_vm_pagefault.\n", __LINE__ );
 
 	vmf->page = vmalloc_to_page( od->mmio + ( vmf->pgoff << PAGE_SHIFT ) );
 	get_page( vmf->page );
 	
-//	dev_dbg( od->dev, "(%d) ipc_spi_vm_pagefault Done.\n", __LINE__ );
+//	dev_dbg( od->dev, "(%d) ipc_hsi_vm_pagefault Done.\n", __LINE__ );
 	
 	return 0;
 }
 
-static struct vm_operations_struct ipc_spi_vm_ops = {
-	//.close = ipc_spi_vm_close,
-	.fault = ipc_spi_vm_pagefault,
+static struct vm_operations_struct ipc_hsi_vm_ops = {
+	//.close = ipc_hsi_vm_close,
+	.fault = ipc_hsi_vm_pagefault,
 };
 
-static int ipc_spi_open(struct inode *inode, struct file *filp)
+static int ipc_hsi_open( struct inode *inode, struct file *filp )
 {
 	struct cdev *cdev = inode->i_cdev;
-	struct ipc_spi *od = container_of(cdev, struct ipc_spi, cdev);
+	struct ipc_hsi *od = container_of( cdev, struct ipc_hsi, cdev );
 
 	filp->private_data = od;
 	return 0;
 }
 
-static int ipc_spi_release(struct inode *inode, struct file *filp)
+static int ipc_hsi_release( struct inode *inode, struct file *filp )
 {
 	filp->private_data = NULL;
 	return 0;
 }
 
-static unsigned int ipc_spi_poll(struct file *filp, poll_table *wait)
+static unsigned int ipc_hsi_poll( struct file *filp, poll_table *wait )
 {
-	struct ipc_spi *od;
+	struct ipc_hsi *od;
 	u32 data;
 
 	od = filp->private_data;
 
-	poll_wait(filp, &od->waitq, wait);
+	poll_wait( filp, &od->waitq, wait );
 
-	spin_lock_irq( &ipc_spi_lock );
+	spin_lock_irq( &ipc_hsi_lock );
 	data = od->mailbox;
-	spin_unlock_irq( &ipc_spi_lock );
+	spin_unlock_irq( &ipc_hsi_lock );
 
-	if (data)
+	if( data )
 		return POLLIN | POLLRDNORM;
 
 	return 0;
 }
 
-static ssize_t ipc_spi_read(struct file *filp, char __user *buf,
-		size_t count, loff_t *ppos)
+static ssize_t ipc_hsi_read( struct file *filp, char __user *buf, size_t count, loff_t *ppos )
 {
-	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_WAITQUEUE( wait, current );
 	u32 data;
 	ssize_t retval;
-	struct ipc_spi *od;
+	struct ipc_hsi *od;
 
 	od = filp->private_data;
 
-	if (count < sizeof(u32))
+	if( count < sizeof( u32 ) )
 		return -EINVAL;
 
-	add_wait_queue(&od->waitq, &wait);
+	add_wait_queue( &od->waitq, &wait );
 
-	while (1) {
-		set_current_state(TASK_INTERRUPTIBLE);
+	while( 1 ) {
+		set_current_state( TASK_INTERRUPTIBLE );
 
-		spin_lock_irq( &ipc_spi_lock );
+		spin_lock_irq( &ipc_hsi_lock );
 		data = od->mailbox;
 		od->mailbox = 0;
-		spin_unlock_irq( &ipc_spi_lock );
+		spin_unlock_irq( &ipc_hsi_lock );
 
-		if (data)
+		if( data )
 			break;
-		else if (filp->f_flags & O_NONBLOCK) {
+		else if( filp->f_flags & O_NONBLOCK ) {
 			retval = -EAGAIN;
 			goto out;
-		} else if (signal_pending(current)) {
+		}
+		else if( signal_pending( current ) ) {
 			retval = -ERESTARTSYS;
 			goto out;
 		}
 		schedule();
 	}
 
-	retval = put_user(data, (u32 __user *)buf);
-	if (!retval)
-		retval = sizeof(u32);
+	retval = put_user( data, ( u32 __user * )buf );
+	if( !retval )
+		retval = sizeof( u32 );
+	
 out:
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&od->waitq, &wait);
+	__set_current_state( TASK_RUNNING );
+	remove_wait_queue( &od->waitq, &wait );
 
 	return retval;
 }
 
-static ssize_t ipc_spi_write(struct file *filp, const char __user *buf,
-		size_t count, loff_t *ppos)
+static ssize_t ipc_hsi_write( struct file *filp, const char __user *buf, size_t count, loff_t *ppos )
 {
-	struct ipc_spi *od;
+	struct ipc_hsi *od;
 
 	od = filp->private_data;
 
-	if (count) {
+	if( count ) {
 		u32 data;
 
-		if (get_user(data, (u32 __user *)buf))
+		if( get_user( data, ( u32 __user * )buf ) )
 			return -EFAULT;
 
-		_send_cmd(od, data);
+		_send_cmd( od, data );
 	}
 
 	return count;
 }
 
-static int ipc_spi_fasync(int fd, struct file *filp, int on)
+static int ipc_hsi_fasync(int fd, struct file *filp, int on)
 {
-	struct ipc_spi *od;
+	struct ipc_hsi *od;
 
 	od = filp->private_data;
 
-	return fasync_helper(fd, filp, on, &od->async_queue);
+	return fasync_helper( fd, filp, on, &od->async_queue );
 }
 
-static int ipc_spi_mmap( struct file *filp, struct vm_area_struct *vma )
+static int ipc_hsi_mmap( struct file *filp, struct vm_area_struct *vma )
 {
-	struct ipc_spi *od;
+	struct ipc_hsi *od;
 	unsigned long size;
 	unsigned long offset;
 
@@ -686,129 +712,88 @@
 	dev_dbg( od->dev, "(%d) Req region: 0x%08lx 0x%08lx\n", __LINE__, offset, size );
 	
 	vma->vm_flags |= VM_RESERVED;
-	vma->vm_ops = &ipc_spi_vm_ops;
+	vma->vm_ops = &ipc_hsi_vm_ops;
 	vma->vm_private_data = od;
 
-	dev_dbg( od->dev, "(%d) ipc_spi_mmap Done.\n", __LINE__ );
+	dev_dbg( od->dev, "(%d) ipc_hsi_mmap Done.\n", __LINE__ );
 	
 	return 0;
-
-#if 0
-	int r;
-	struct ipc_spi *od;
-	unsigned long size;
-	unsigned long pfn;
-	unsigned long offset;
-	struct resource *res;
-
-	od = filp->private_data;
-	if (!od || !vma)
-		return -EFAULT;
-
-	atomic_inc(&od->ref_sem);
-	if (!_read_sem(od)) {
-		atomic_dec(&od->ref_sem);
-		return -EPERM;
-	}
-
-	size = vma->vm_end - vma->vm_start;
-	offset = vma->vm_pgoff << PAGE_SHIFT;
-	if (size > od->size - PAGE_ALIGN(ONEDRAM_REG_SIZE) - offset)
-		return -EINVAL;
-
-	dev_dbg(od->dev, "Req region: 0x%08lx 0x%08lx\n", offset, size);
-	res = onedram_request_region(offset, size, "mmap");
-	if (!res)
-		return -EBUSY;
-
-	pfn = __phys_to_pfn(od->base + offset);
-	r = remap_pfn_range(vma, vma->vm_start, pfn,
-			size,
-			vma->vm_page_prot);
-	if (r)
-		return -EAGAIN;
-
-	vma->vm_ops = &ipc_spi_vm_ops;
-	vma->vm_private_data = od;
-	return 0;
-#endif
 }
 
-static int ipc_spi_ioctl(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
+static int ipc_hsi_ioctl( struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg )
 {
 	struct cdev *cdev = inode->i_cdev;
-	struct ipc_spi *od = container_of( cdev, struct ipc_spi, cdev );
+	struct ipc_hsi *od = container_of( cdev, struct ipc_hsi, cdev );
 	int r;
 
-	switch (cmd) {
-	case ONEDRAM_GET_AUTH:
-		r = get_auth(od, arg);
-		break;
-	case ONEDRAM_PUT_AUTH:
-		r = put_auth(od, 0);
-		break;
-	case ONEDRAM_REL_SEM:
-		r = rel_sem(od);
-		break;
-	default:
-		r = -ENOIOCTLCMD;
-		break;
+	switch( cmd ) {
+		case ONEDRAM_GET_AUTH :
+			r = get_auth( od, arg );
+			break;
+		case ONEDRAM_PUT_AUTH :
+			r = put_auth( od, 0 );
+			break;
+		case ONEDRAM_REL_SEM:
+			r = rel_sem( od );
+			break;
+		default:
+			r = -ENOIOCTLCMD;
+			break;
 	}
 
 	return r;
 }
 
-static const struct file_operations ipc_spi_fops = {
+static const struct file_operations ipc_hsi_fops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
-	.read = ipc_spi_read,
-	.write = ipc_spi_write,
-	.poll = ipc_spi_poll,
-	.fasync = ipc_spi_fasync,
-	.open = ipc_spi_open,
-	.release = ipc_spi_release,
-	.mmap = ipc_spi_mmap,
-	.ioctl = ipc_spi_ioctl,
+	.read = ipc_hsi_read,
+	.write = ipc_hsi_write,
+	.poll = ipc_hsi_poll,
+	.fasync = ipc_hsi_fasync,
+	.open = ipc_hsi_open,
+	.release = ipc_hsi_release,
+	.mmap = ipc_hsi_mmap,
+	.ioctl = ipc_hsi_ioctl,
 };
 
-static int _register_chrdev( struct ipc_spi *od )
+static int _register_chrdev( struct ipc_hsi *od )
 {
 	int r;
 	dev_t devid;
 
-	od->class = class_create(THIS_MODULE, DRVNAME);
-	if (IS_ERR(od->class)) {
-		r = PTR_ERR(od->class);
+	od->class = class_create( THIS_MODULE, DRVNAME );
+	if( IS_ERR( od->class ) ) {
+		r = PTR_ERR( od->class );
 		od->class = NULL;
 		return r;
 	}
 
-	r = alloc_chrdev_region(&devid, 0, 1, DRVNAME);
-	if (r)
+	r = alloc_chrdev_region( &devid, 0, 1, DRVNAME );
+	if( r )
 		return r;
 
-	cdev_init( &od->cdev, &ipc_spi_fops );
+	cdev_init( &od->cdev, &ipc_hsi_fops );
 
-	r = cdev_add(&od->cdev, devid, 1);
-	if (r) {
-		unregister_chrdev_region(devid, 1);
+	r = cdev_add( &od->cdev, devid, 1 );
+	if( r ) {
+		unregister_chrdev_region( devid, 1 );
 		return r;
 	}
 	od->devid = devid;
 
-	od->dev = device_create(od->class, NULL, od->devid, od, DRVNAME);
-	if (IS_ERR(od->dev)) {
-		r = PTR_ERR(od->dev);
+	od->dev = device_create( od->class, NULL, od->devid, od, DRVNAME );
+	if( IS_ERR( od->dev ) ) {
+		r = PTR_ERR( od->dev );
 		od->dev = NULL;
 		return r;
 	}
-	dev_set_drvdata(od->dev, od);
+	dev_set_drvdata( od->dev, od );
 
 	return 0;
 }
 
-static inline int _request_mem( struct ipc_spi *od, struct platform_device *pdev )
+static inline int _request_mem( struct ipc_hsi *od, struct platform_device *pdev )
 {
 	od->mmio = ( void __iomem * )vmalloc( od->size );
 	if( !od->mmio ) {
@@ -833,147 +818,149 @@
 	od->reg->mailbox_BA = 0;
 	dev_dbg( &pdev->dev, "(%d) force set mailbox to 0 : AB=0x%x, BA=0x%x\n", __LINE__, od->reg->mailbox_AB, od->reg->mailbox_BA );
 	
-	ipc_spi_resource.start = (resource_size_t)od->mmio;
-	ipc_spi_resource.end = (resource_size_t)od->mmio + od->size - 1;
+	ipc_hsi_resource.start = ( resource_size_t )od->mmio;
+	ipc_hsi_resource.end = ( resource_size_t )od->mmio + od->size - 1;
 
 	p_virtual_buff = od->mmio;
 
 	return 0;
 }
 
-static void _release( struct ipc_spi *od )
+static void _release( struct ipc_hsi *od )
 {
-	if (!od)
+	if( !od )
 		return;
 
-	if (od->irq)
-		free_irq(od->irq, od);
+	if( od->irq )
+		free_irq( od->irq, od );
+
+	if( od->irq_suspend_req )
+		free_irq( od->irq_suspend_req, od );
 
-	if (od->group)
-		sysfs_remove_group(&od->dev->kobj, od->group);
+	if( od->group )
+		sysfs_remove_group( &od->dev->kobj, od->group );
 
-	if (od->dev)
-		device_destroy(od->class, od->devid);
+	if( od->dev )
+		device_destroy( od->class, od->devid );
 
-	if (od->devid) {
-		cdev_del(&od->cdev);
-		unregister_chrdev_region(od->devid, 1);
+	if( od->devid ) {
+		cdev_del( &od->cdev );
+		unregister_chrdev_region( od->devid, 1 );
 	}
 
-	if (od->mmio) {
+	if( od->mmio ) {
 		od->reg = NULL;
 		
 		vfree( ( void * )od->mmio );
 		
-		ipc_spi_resource.start = 0;
-		ipc_spi_resource.end = -1;
+		ipc_hsi_resource.start = 0;
+		ipc_hsi_resource.end = -1;
 	}
 
-	if (od->class)
-		class_destroy(od->class);
+	if( od->class )
+		class_destroy( od->class );
 
-	kfree(od);
+	kfree( od );
 }
 
-struct resource* onedram_request_region(resource_size_t start,
-		resource_size_t n, const char *name)
+struct resource* onedram_request_region( resource_size_t start, resource_size_t n, const char *name )
 {
 	struct resource *res;
 
-	start += ipc_spi_resource.start;
-	res = __request_region( &ipc_spi_resource, start, n, name, 0 );
-	if (!res)
+	start += ipc_hsi_resource.start;
+	res = __request_region( &ipc_hsi_resource, start, n, name, 0 );
+	if( !res )
 		return NULL;
 
 	return res;
 }
-EXPORT_SYMBOL(onedram_request_region);
+EXPORT_SYMBOL( onedram_request_region );
 
-void onedram_release_region(resource_size_t start, resource_size_t n)
+void onedram_release_region( resource_size_t start, resource_size_t n )
 {
-	start += ipc_spi_resource.start;
-	__release_region(&ipc_spi_resource, start, n);
+	start += ipc_hsi_resource.start;
+	__release_region( &ipc_hsi_resource, start, n );
 }
-EXPORT_SYMBOL(onedram_release_region);
+EXPORT_SYMBOL( onedram_release_region );
 
-int onedram_register_handler(void (*handler)(u32, void *), void *data)
+int onedram_register_handler( void ( *handler )( u32, void * ), void *data )
 {
 	unsigned long flags;
-	struct ipc_spi_handler *hd;
+	struct ipc_hsi_handler *hd;
 
-	if (!handler)
+	if( !handler )
 		return -EINVAL;
 
-	hd = kzalloc( sizeof( struct ipc_spi_handler ), GFP_KERNEL );
-	if (!hd)
+	hd = kzalloc( sizeof( struct ipc_hsi_handler ), GFP_KERNEL );
+	if( !hd )
 		return -ENOMEM;
 
 	hd->data = data;
 	hd->handler = handler;
 
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_add_tail(&hd->list, &h_list.list);
+	spin_lock_irqsave( &h_list.lock, flags );
+	list_add_tail( &hd->list, &h_list.list );
 	h_list.len++;
-	spin_unlock_irqrestore(&h_list.lock, flags);
+	spin_unlock_irqrestore( &h_list.lock, flags );
 
 	return 0;
 }
-EXPORT_SYMBOL(onedram_register_handler);
+EXPORT_SYMBOL( onedram_register_handler );
 
-int onedram_unregister_handler(void (*handler)(u32, void *))
+int onedram_unregister_handler( void ( *handler )( u32, void * ) )
 {
 	unsigned long flags;
 	struct list_head *l, *tmp;
 
-	if (!handler)
+	if( !handler )
 		return -EINVAL;
 
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_for_each_safe(l, tmp, &h_list.list) {
-		struct ipc_spi_handler *hd = list_entry (l, struct ipc_spi_handler, list );
+	spin_lock_irqsave( &h_list.lock, flags );
+	list_for_each_safe( l, tmp, &h_list.list ) {
+		struct ipc_hsi_handler *hd = list_entry( l, struct ipc_hsi_handler, list );
 
-		if (hd->handler == handler) {
-			list_del(&hd->list);
+		if( hd->handler == handler ) {
+			list_del( &hd->list );
 			h_list.len--;
-			kfree(hd);
+			kfree( hd );
 		}
 	}
-	spin_unlock_irqrestore(&h_list.lock, flags);
+	spin_unlock_irqrestore( &h_list.lock, flags );
 
 	return 0;
 }
-EXPORT_SYMBOL(onedram_unregister_handler);
+EXPORT_SYMBOL( onedram_unregister_handler );
 
-static void _unregister_all_handlers(void)
+static void _unregister_all_handlers( void )
 {
 	unsigned long flags;
 	struct list_head *l, *tmp;
 
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_for_each_safe(l, tmp, &h_list.list) {
-		struct ipc_spi_handler *hd = list_entry( l, struct ipc_spi_handler, list );
+	spin_lock_irqsave( &h_list.lock, flags );
+	list_for_each_safe( l, tmp, &h_list.list ) {
+		struct ipc_hsi_handler *hd = list_entry( l, struct ipc_hsi_handler, list );
 
-		list_del(&hd->list);
+		list_del( &hd->list );
 		h_list.len--;
-		kfree(hd);
+		kfree( hd );
 	}
-	spin_unlock_irqrestore(&h_list.lock, flags);
+	spin_unlock_irqrestore( &h_list.lock, flags );
 }
 
-static void _init_data( struct ipc_spi *od )
+static void _init_data( struct ipc_hsi *od )
 {
-	init_completion(&od->comp);
+	init_completion( &od->comp );
 	atomic_set( &od->ref_sem, 0 );
-	INIT_LIST_HEAD(&h_list.list);
-	spin_lock_init(&h_list.lock);
+	INIT_LIST_HEAD( &h_list.list );
+	spin_lock_init( &h_list.lock );
 	h_list.len = 0;
-	init_waitqueue_head(&od->waitq);
+	init_waitqueue_head( &od->waitq );
 
 	init_completion( &ril_init );
-	sema_init( &srdy_sem, 0 );
 	sema_init( &transfer_event_sem, 0 );
 }
 
+
 #define FMT_OUT		0x0FE000
 #define FMT_IN			0x0FF000
 #define FMT_SZ			0x1000
@@ -986,107 +973,138 @@
 #define RFS_IN			0x400000
 #define RFS_SZ			0x100000
 
-static u32 ipc_spi_get_send_vbuff_command( void )
+static u32 ipc_hsi_get_send_vbuff_command( struct ipc_hsi *od )
 {
 	u32 cmd = 0;
 
 	memcpy( ( void * )&cmd, ( void * )( p_virtual_buff + ONEDRAM_REG_OFFSET + 64 ), sizeof( cmd ) ); // mailbox_BA
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
+//	dev_dbg( od->dev, "(%d) get mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
 	
 	return cmd;
 }
 
-static void ipc_spi_set_send_vbuff_command_clear( void )
+static void ipc_hsi_set_send_vbuff_command_clear( struct ipc_hsi *od )
 {
 	u32 cmd = 0;
 
 	memcpy( ( void * )( p_virtual_buff + ONEDRAM_REG_OFFSET + 64 ), ( void * )&cmd, sizeof( cmd ) ); // mailbox_BA
-//	dev_dbg( &p_ipc_spi->dev, "(%d) clear mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
+//	dev_dbg( od->dev, "(%d) clear mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_format_tx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_format_tx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 16 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 20 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get FMT tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_format_rx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_format_rx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 16 + 8 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 20 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get FMT rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_raw_tx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_raw_tx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 32 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 36 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get RAW tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_raw_rx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_raw_rx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 32 + 8 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 36 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get RAW rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_rfs_tx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_rfs_tx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 48 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 52 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get RFS tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_get_pointer_of_vbuff_rfs_rx( u32 *head, u32 *tail )
+static inline void ipc_hsi_get_pointer_of_vbuff_rfs_rx( struct ipc_hsi *od, u32 *head, u32 *tail )
 {
 	memcpy( ( void * )head, ( void * )( p_virtual_buff + 48 + 8 ), sizeof( *head ) );
 	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 52 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
+//	dev_dbg( od->dev, "(%d) get RFS rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
 }
 
-static inline void ipc_spi_update_tail_of_vbuff_format_tx( u32 u_tail )
+static inline void ipc_hsi_update_tail_of_vbuff_format_tx( struct ipc_hsi *od, u32 u_tail )
 {
 	memcpy( ( void * )( p_virtual_buff + 20 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update FMT tx_tail : %d\n", __LINE__, u_tail );
+//	dev_dbg( od->dev, "(%d) update FMT tx_tail : %d\n", __LINE__, u_tail );
 }
 
-static inline void ipc_spi_update_head_of_vbuff_format_rx( u32 u_head )
+static inline void ipc_hsi_update_head_of_vbuff_format_rx( struct ipc_hsi *od, u32 u_head )
 {
 	memcpy( ( void * )( p_virtual_buff + 20 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update FMT rx_head : %d\n", __LINE__, u_head );
+//	dev_dbg( od->dev, "(%d) update FMT rx_head : %d\n", __LINE__, u_head );
 }
 
-static inline void ipc_spi_update_tail_of_vbuff_raw_tx( u32 u_tail )
+static inline void ipc_hsi_update_tail_of_vbuff_raw_tx( struct ipc_hsi *od, u32 u_tail )
 {
 	memcpy( ( void * )( p_virtual_buff + 36 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RAW tx_tail : %d\n", __LINE__, u_tail );
+//	dev_dbg( od->dev, "(%d) update RAW tx_tail : %d\n", __LINE__, u_tail );
 }
 
-static inline void ipc_spi_update_head_of_vbuff_raw_rx( u32 u_head )
+static inline void ipc_hsi_update_head_of_vbuff_raw_rx( struct ipc_hsi *od, u32 u_head )
 {
 	memcpy( ( void * )( p_virtual_buff + 36 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RAW rx_head : %d\n", __LINE__, u_head );
+//	dev_dbg( od->dev, "(%d) update RAW rx_head : %d\n", __LINE__, u_head );
 }
 
-static inline void ipc_spi_update_tail_of_vbuff_rfs_tx( u32 u_tail )
+static inline void ipc_hsi_update_tail_of_vbuff_rfs_tx( struct ipc_hsi *od, u32 u_tail )
 {
 	memcpy( ( void * )( p_virtual_buff + 52 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RFS tx_tail : %d\n", __LINE__, u_tail );
+//	dev_dbg( od->dev, "(%d) update RFS tx_tail : %d\n", __LINE__, u_tail );
 }
 
-static inline void ipc_spi_update_head_of_vbuff_rfs_rx( u32 u_head )
+static inline void ipc_hsi_update_head_of_vbuff_rfs_rx( struct ipc_hsi *od, u32 u_head )
 {
 	memcpy( ( void * )( p_virtual_buff + 52 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RFS rx_head : %d\n", __LINE__, u_head );
+//	dev_dbg( od->dev, "(%d) update RFS rx_head : %d\n", __LINE__, u_head );
+}
+
+static void ipc_hsi_clear_all_vbuff( struct ipc_hsi *od )
+{
+	u32 head, tail;
+
+	ipc_hsi_get_pointer_of_vbuff_format_tx( od, &head, &tail );
+	ipc_hsi_update_tail_of_vbuff_format_tx( od, head );
+	dev_dbg( od->dev, "(%d) Remove Format TX.\n", __LINE__ );
+	
+	ipc_hsi_get_pointer_of_vbuff_format_rx( od, &head, &tail );
+	ipc_hsi_update_head_of_vbuff_format_rx( od, tail );
+	dev_dbg( od->dev, "(%d) Remove Format RX.\n", __LINE__ );
+
+	ipc_hsi_get_pointer_of_vbuff_raw_tx( od, &head, &tail );
+	ipc_hsi_update_tail_of_vbuff_raw_tx( od, head );
+	dev_dbg( od->dev, "(%d) Remove Raw TX.\n", __LINE__ );
+	
+	ipc_hsi_get_pointer_of_vbuff_raw_rx( od, &head, &tail );
+	ipc_hsi_update_head_of_vbuff_raw_rx( od, tail );
+	dev_dbg( od->dev, "(%d) Remove Raw RX.\n", __LINE__ );
+
+	ipc_hsi_get_pointer_of_vbuff_rfs_tx( od, &head, &tail );
+	ipc_hsi_update_tail_of_vbuff_rfs_tx( od, head );
+	dev_dbg( od->dev, "(%d) Remove Rfs TX.\n", __LINE__ );
+	
+	ipc_hsi_get_pointer_of_vbuff_rfs_rx( od, &head, &tail );
+	ipc_hsi_update_head_of_vbuff_rfs_rx( od, tail );
+	dev_dbg( od->dev, "(%d) Remove Rfs RX.\n", __LINE__ );
+
+	dev_err( od->dev, "(%d) Remove all vbuff.\n", __LINE__ );
 }
 
-static u32 ipc_spi_get_length_vbuff_format_tx( u32 *out_head, u32 *out_tail )
+static u32 ipc_hsi_get_length_vbuff_format_tx( struct ipc_hsi *od, u32 *out_head, u32 *out_tail )
 {
 	u32 len = 0;
 
-	ipc_spi_get_pointer_of_vbuff_format_tx( out_head, out_tail );
+	ipc_hsi_get_pointer_of_vbuff_format_tx( od, out_head, out_tail );
 	
 	if( *out_head >= *out_tail ) {
 		len = *out_head - *out_tail;
@@ -1094,16 +1112,16 @@
 	else {
 		len = FMT_SZ - *out_tail + *out_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT tx_len : %d\n", __LINE__, len );
+//	dev_dbg( od->dev, "(%d) get FMT tx_len : %d\n", __LINE__, len );
 
 	return len;
 }
 
-static u32 ipc_spi_get_length_vbuff_raw_tx( u32 *out_head, u32 *out_tail )
+static u32 ipc_hsi_get_length_vbuff_raw_tx( struct ipc_hsi *od, u32 *out_head, u32 *out_tail )
 {
 	u32 len = 0;
 
-	ipc_spi_get_pointer_of_vbuff_raw_tx( out_head, out_tail );
+	ipc_hsi_get_pointer_of_vbuff_raw_tx( od, out_head, out_tail );
 
 	if( *out_head >= *out_tail ) {
 		len = *out_head - *out_tail;
@@ -1111,16 +1129,22 @@
 	else {
 		len = RAW_SZ - *out_tail + *out_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW tx_len : %d\n", __LINE__, len );
+//	dev_dbg( od->dev, "(%d) get RAW tx_len : %d\n", __LINE__, len );
+
+	if( cp_flow_control_stop_transfer ) {
+		dev_dbg( od->dev, "(%d) ipc_hsi_get_length_vbuff_raw_tx : CP Flow Control.\n", __LINE__ );
+
+		return 0;
+	}
 
 	return len;
 }
 
-static u32 ipc_spi_get_length_vbuff_rfs_tx( u32 *out_head, u32 *out_tail )
+static u32 ipc_hsi_get_length_vbuff_rfs_tx( struct ipc_hsi *od, u32 *out_head, u32 *out_tail )
 {
 	u32 len = 0;
 
-	ipc_spi_get_pointer_of_vbuff_rfs_tx( out_head, out_tail );
+	ipc_hsi_get_pointer_of_vbuff_rfs_tx( od, out_head, out_tail );
 
 	if( *out_head >= *out_tail ) {
 		len = *out_head - *out_tail;
@@ -1128,16 +1152,16 @@
 	else {
 		len = RFS_SZ - *out_tail + *out_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS tx_len : %d\n", __LINE__, len );
+//	dev_dbg( od->dev, "(%d) get RFS tx_len : %d\n", __LINE__, len );
 
 	return len;
 }
 
-static u32 ipc_spi_get_space_vbuff_format_rx( u32 *in_head, u32 *in_tail )
+static u32 ipc_hsi_get_space_vbuff_format_rx( struct ipc_hsi *od, u32 *in_head, u32 *in_tail )
 {
 	u32 space = 0;
 	
-	ipc_spi_get_pointer_of_vbuff_format_rx( in_head, in_tail );
+	ipc_hsi_get_pointer_of_vbuff_format_rx( od, in_head, in_tail );
 
 	//check the memory space remained
 	if( *in_tail <= *in_head ) {
@@ -1146,16 +1170,16 @@
 	else{
 		space = *in_tail - *in_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT rx space : %d\n", __LINE__, space );
+//	dev_dbg( od->dev, "(%d) get FMT rx space : %d\n", __LINE__, space );
 
 	return space;
 }
 
-static u32 ipc_spi_get_space_vbuff_raw_rx( u32 *in_head, u32 *in_tail )
+static u32 ipc_hsi_get_space_vbuff_raw_rx( struct ipc_hsi *od, u32 *in_head, u32 *in_tail )
 {
 	u32 space = 0;
 	
-	ipc_spi_get_pointer_of_vbuff_raw_rx( in_head, in_tail );
+	ipc_hsi_get_pointer_of_vbuff_raw_rx( od, in_head, in_tail );
 
 	//check the memory space remained
 	if( *in_tail <= *in_head ) {
@@ -1164,16 +1188,16 @@
 	else{
 		space = *in_tail - *in_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW rx space : %d\n", __LINE__, space );
+//	dev_dbg( od->dev, "(%d) get RAW rx space : %d\n", __LINE__, space );
 
 	return space;
 }
 
-static u32 ipc_spi_get_space_vbuff_rfs_rx( u32 *in_head, u32 *in_tail )
+static u32 ipc_hsi_get_space_vbuff_rfs_rx( struct ipc_hsi *od, u32 *in_head, u32 *in_tail )
 {
 	u32 space = 0;
 	
-	ipc_spi_get_pointer_of_vbuff_rfs_rx( in_head, in_tail );
+	ipc_hsi_get_pointer_of_vbuff_rfs_rx( od, in_head, in_tail );
 
 	//check the memory space remained
 	if( *in_tail <= *in_head ) {
@@ -1182,49 +1206,54 @@
 	else{
 		space = *in_tail - *in_head;
 	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS rx space : %d\n", __LINE__, space );
+//	dev_dbg( od->dev, "(%d) get RFS rx space : %d\n", __LINE__, space );
 
 	return space;
 }
 
-static int ipc_spi_check_send_data( void )
+static int ipc_hsi_check_send_data( struct ipc_hsi *od )
 {
 	int retval = 0;
 	u32 out_head = 0;
 	u32 out_tail = 0;
 
-	if( ipc_spi_get_send_vbuff_command() ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist CMD data\n", __LINE__ );
+	if( ipc_hsi_get_send_vbuff_command( od ) ) {
+//		dev_dbg( od->dev, "(%d) exist CMD data\n", __LINE__ );
 		retval = 1;
 	}
 
-	ipc_spi_get_pointer_of_vbuff_format_tx( &out_head, &out_tail );
+	ipc_hsi_get_pointer_of_vbuff_format_tx( od, &out_head, &out_tail );
 	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist FMT data\n", __LINE__ );
+//		dev_dbg( od->dev, "(%d) exist FMT data\n", __LINE__ );
 		retval = 1;
 	}
 
-	ipc_spi_get_pointer_of_vbuff_raw_tx( &out_head, &out_tail );
+	ipc_hsi_get_pointer_of_vbuff_raw_tx( od, &out_head, &out_tail );
 	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist RAW data\n", __LINE__ );
-		retval = 1;
+//		dev_dbg( od->dev, "(%d) exist RAW data\n", __LINE__ );
+		if( cp_flow_control_stop_transfer ) {
+			dev_dbg( od->dev, "(%d) ipc_hsi_check_send_data : CP Flow Control.\n", __LINE__ );
+		}
+		else {
+			retval = 1;
+		}
 	}
 
-	ipc_spi_get_pointer_of_vbuff_rfs_tx( &out_head, &out_tail );
+	ipc_hsi_get_pointer_of_vbuff_rfs_tx( od, &out_head, &out_tail );
 	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist RFS data\n", __LINE__ );
+//		dev_dbg( od->dev, "(%d) exist RFS data\n", __LINE__ );
 		retval = 1;
 	}
 
 	if( loop_back_test ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) LOOP checked.\n", __LINE__ );
+//		dev_dbg( od->dev, "(%d) LOOP checked.\n", __LINE__ );
 		retval = 1;
 	}
 
 	return retval;
 }
 
-static void ipc_spi_copy_from_vbuff_format_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
+static void ipc_hsi_copy_from_vbuff_format_tx( struct ipc_hsi *od, void *p_des, u32 offset_vbuff, u32 copy_len )
 {
 	if( ( offset_vbuff + copy_len ) <= FMT_SZ ) {
 		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + FMT_OUT + offset_vbuff ), copy_len );
@@ -1235,7 +1264,7 @@
 	}
 }
 
-static void ipc_spi_copy_from_vbuff_raw_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
+static void ipc_hsi_copy_from_vbuff_raw_tx( struct ipc_hsi *od, void *p_des, u32 offset_vbuff, u32 copy_len )
 {
 	if( ( offset_vbuff + copy_len ) <= RAW_SZ ) {
 		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RAW_OUT + offset_vbuff ), copy_len );
@@ -1246,7 +1275,7 @@
 	}
 }
 
-static void ipc_spi_copy_from_vbuff_rfs_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
+static void ipc_hsi_copy_from_vbuff_rfs_tx( struct ipc_hsi *od, void *p_des, u32 offset_vbuff, u32 copy_len )
 {
 	if( ( offset_vbuff + copy_len ) <= RFS_SZ ) {
 		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RFS_OUT + offset_vbuff ), copy_len );
@@ -1257,1314 +1286,621 @@
 	}
 }
 
-static void ipc_spi_prepare_tx_data( u8 *tx_b )
+static int ipc_hsi_copy_to_vbuff_format_rx( struct ipc_hsi *od, void *data, u16 len )
 {
-	u32 len = 0, tx_b_remail_len = DEF_BUF_SIZE, read_size = 0;
-	spi_protocol_header *tx_header = ( spi_protocol_header * )tx_b;
-	u32 cmd = 0;
-	u8 cmd_8 = 0;
-	u16 mux = 0;
-	u16 p_tx_b = sizeof( spi_protocol_header );
-	u32 p_send_data_h = 0, p_send_data_t = 0;
-	u16 pkt_fmt_len = 0;
-	u32 pkt_len = 0;
-	u8 bof = 0, eof = 0;
-	int i;
-
-	memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-	cmd = ipc_spi_get_send_vbuff_command(); // check mailbox command data
-	if( cmd ) {
-		cmd_8 = cmd & 0xFF;
-		dev_dbg( &p_ipc_spi->dev, "(%d) =>exist CMD cmd_8 : %x\n", __LINE__, cmd_8 );
-		
-		mux = 0x0004;
-		memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) ), ( void * )&mux, sizeof( mux ) );
+	u32 head = 0, tail = 0, new_head = 0, space = 0;
+	int copy_retry_count = 0;
 
-		memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) ), ( void * )&cmd_8, sizeof( cmd_8 ) );
-		ipc_spi_set_send_vbuff_command_clear();
+	dev_dbg( od->dev, "(%d) <=copy data to FMT vbuff, len : %d\n", __LINE__, len );
 
-		tx_header->current_data_size = sizeof( mux ) + sizeof( cmd_8 );
-		tx_header->next_data_size = DEF_BUF_SIZE >> 2;
+COPY_TO_VBUFF_FMT_RETRY :
+	
+	space = ipc_hsi_get_space_vbuff_format_rx( od, &head, &tail );
+	if( space < len ) {
+		dev_err( od->dev, "(%d) FMT vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
 
-		if( ipc_spi_check_send_data() ) {
-			tx_header->more = 1;
-		}
-		else {
-			tx_header->more = 0;
+		copy_retry_count++;
+		if( copy_retry_count > 20 ) {
+			dev_err( od->dev, "(%d) FMT vbuff is full. copy fail.\n", __LINE__ );
+			
+			return -ENOMEM;
 		}
 
+		msleep( 5 );
+		goto COPY_TO_VBUFF_FMT_RETRY;
 	}
-	else { // check format, raw, rfs data
-		len = ipc_spi_get_length_vbuff_format_tx( &p_send_data_h, &p_send_data_t ); // len : vbuff_format_tx length
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare FMT data\n", __LINE__ );
-			
-			mux = 0x0001;
-			read_size = 0;
-			
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) FMT bof : %x\n", __LINE__, bof );
-
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) FMT bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
 
-					return;
-				}
+	if( head + len <= FMT_SZ ) {
+		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, len );
+	}
+	else {
+		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, FMT_SZ - head );
+		memcpy( ( void * )( p_virtual_buff + FMT_IN ), ( void * )( data + ( FMT_SZ - head ) ), len - ( FMT_SZ - head ) );
+	}
 
-				// packet length check
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )&pkt_fmt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_fmt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT packet len : %d\n", __LINE__, pkt_fmt_len );
-				
-				if( ( pkt_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) FMT wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_fmt_len );
-					
-					ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	new_head = ( head + len ) % FMT_SZ;
+	ipc_hsi_update_head_of_vbuff_format_rx( od, new_head );
 
-					return;
-				}
-				else if( ( pkt_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
+	dev_dbg( od->dev, "(%d) <=copy data to FMT vbuff done.\n", __LINE__ );
 
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_fmt_len + sizeof ( bof ) + sizeof ( eof ) );
+	return 0;
+}
 
-#ifdef FORMAT_TX_DUMP
-				printk( "[IPC_SPI => FMT TX :" );
-				for( i = 0 ; i < ( pkt_fmt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // FORMAT_TX_DUMP
+static int ipc_hsi_copy_to_vbuff_raw_rx( struct ipc_hsi *od, void *data, u32 len )
+{
+	u32 head = 0, tail = 0, new_head = 0, space = 0;
+	int copy_retry_count = 0;
 
-				p_tx_b += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
+	dev_dbg( od->dev, "(%d) <=copy data to RAW vbuff, len : %d\n", __LINE__, len );
 
-				p_send_data_t %= FMT_SZ;
-				ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) FMT tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT len : %d\n", __LINE__, len );
-			}
+COPY_TO_VBUFF_RAW_RETRY :
 
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-		}
+	space = ipc_hsi_get_space_vbuff_raw_rx( od, &head, &tail );
+	if( space < len ) {
+		dev_err( od->dev, "(%d) RAW vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
 
-		len = ipc_spi_get_length_vbuff_raw_tx( &p_send_data_h, &p_send_data_t );
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare RAW data\n", __LINE__ );
+		copy_retry_count++;
+		if( copy_retry_count > 20 ) {
+			dev_err( od->dev, "(%d) RAW vbuff is full. copy fail.\n", __LINE__ );
 			
-			mux = 0x0002;
-			read_size = 0;
+			return -ENOMEM;
+		}
 
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) RAW bof : %x\n", __LINE__, bof );
+		msleep( 5 );
+		goto COPY_TO_VBUFF_RAW_RETRY;
+	}
 
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RAW bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	if( head + len <= RAW_SZ ) {
+		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, len );
+	}
+	else {
+		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, RAW_SZ - head );
+		memcpy( ( void * )( p_virtual_buff + RAW_IN ), ( void * )( data + ( RAW_SZ - head ) ), len - ( RAW_SZ - head ) );
+	}
 
-					return;
-				}
+	new_head = ( head + len ) % RAW_SZ;
+	ipc_hsi_update_head_of_vbuff_raw_rx( od, new_head );
 
-				// packet length check
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )&pkt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW packet len : %d\n", __LINE__, pkt_len );
-				
-				if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) RAW wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_len );
-					
-					ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	dev_dbg( od->dev, "(%d) <=copy data to RAW vbuff done.\n", __LINE__ );
 
-					return;
-				}
-				else if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
+	return 0;
+}
 
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_len + sizeof ( bof ) + sizeof ( eof ) );
+static int ipc_hsi_copy_to_vbuff_rfs_rx( struct ipc_hsi *od, void *data, u32 len )
+{
+	u32 head = 0, tail = 0, new_head = 0, space = 0;
+	int copy_retry_count = 0;
 
-#ifdef RAW_TX_DUMP
-				printk( "[IPC_SPI => RAW TX :" );
-				for( i = 0 ; i < ( pkt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // RAW_TX_DUMP
+	dev_dbg( od->dev, "(%d) <=copy data to RFS vbuff, len : %d\n", __LINE__, len );
 
-				p_tx_b += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_len + sizeof ( bof ) + sizeof ( eof );
+COPY_TO_VBUFF_RFS_RETRY :
 
-				p_send_data_t %= RAW_SZ;
-				ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RAW tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW len : %d\n", __LINE__, len );
-			}
+	space = ipc_hsi_get_space_vbuff_rfs_rx( od, &head, &tail );
+	if( space < len ) {
+		dev_err( od->dev, "(%d) RFS vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
 
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
+		copy_retry_count++;
+		if( copy_retry_count > 20 ) {
+			dev_err( od->dev, "(%d) RFS vbuff is full. copy fail.\n", __LINE__ );
+			
+			return -ENOMEM;
 		}
 
-		len = ipc_spi_get_length_vbuff_rfs_tx( &p_send_data_h, &p_send_data_t );
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare RFS data\n", __LINE__ );
-			
-			mux = 0x0003;
-			read_size = 0;
+		msleep( 5 );
+		goto COPY_TO_VBUFF_RFS_RETRY;
+	}
 
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) RFS bof : %x\n", __LINE__, bof );
+	if( head + len <= RFS_SZ ) {
+		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, len );
+	}
+	else {
+		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, RFS_SZ - head );
+		memcpy( ( void * )( p_virtual_buff + RFS_IN ), ( void * )( data + ( RFS_SZ - head ) ), len - ( RFS_SZ - head ) );
+	}
 
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RFS bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	new_head = ( head + len ) % RFS_SZ;
+	ipc_hsi_update_head_of_vbuff_rfs_rx( od, new_head );
 
-					return;
-				}
+	dev_dbg( od->dev, "(%d) <=copy data to RFS vbuff done.\n", __LINE__ );
 
-				// packet length check
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )&pkt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS packet len : %d\n", __LINE__, pkt_len );
-				
-				if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) RFS wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_len );
-					
-					ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	return 0;
+}
 
-					return;
-				}
-				else if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
 
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_len + sizeof ( bof ) + sizeof ( eof ) );
+#define IPC_HSI_TX_BUF_SIZE		( 10 * 1024 )
+#define IPC_HSI_RX_BUF_SIZE		( 266 * 1024 )
+static void ipc_hsi_prepare_tx_data( struct ipc_hsi *od, ipc_hsi_data *tx_data )
+{
+	u32 len = 0;
+	u32 cmd = 0;
+	u8 cmd_8 = 0;
+	u32 p_send_data_h = 0, p_send_data_t = 0;
+	int i;
 
-#ifdef RFS_TX_DUMP
-				printk( "[IPC_SPI => RFS TX :" );
-				for( i = 0 ; i < ( pkt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // RFS_TX_DUMP
+	dev_err( od->dev, "(%d) =>ipc_hsi_prepare_tx_data\n", __LINE__ );
 
-				p_tx_b += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_len + sizeof ( bof ) + sizeof ( eof );
+	tx_data->channel = 0;
+	tx_data->len = 0;
+	tx_data->more = 0;
 
-				p_send_data_t %= RFS_SZ;
-				ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RFS tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS len : %d\n", __LINE__, len );
-
-#ifdef RFS_TX_RX_LENGTH_DUMP
-				printk( "[IPC_SPI => RFS TX : %d]\n", pkt_len );
-#endif // RFS_TX_RX_LENGTH_DUMP
-
-			}
-
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-		}
-	}
-
-//	dev_dbg( &p_ipc_spi->dev, "(%d) tx_data are prepared. \n", __LINE__ );
-//	dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] TX :\n" );
-	dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] TX : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		tx_b[ 0 ], tx_b[ 1 ], tx_b[ 2 ], tx_b[ 3 ], tx_b[ 4 ], tx_b[ 5 ], tx_b[ 6 ], tx_b[ 7 ], tx_b[ 8 ], tx_b[ 9 ], tx_b[ 10 ], tx_b[ 11 ], tx_b[ 12 ], tx_b[ 13 ], tx_b[ 14 ], tx_b[ 15 ], tx_b[ 16 ], tx_b[ 17 ], tx_b[ 18 ], tx_b[ 19 ], 
-		tx_b[ 20 ], tx_b[ 21 ], tx_b[ 22 ], tx_b[ 23 ], tx_b[ 24 ], tx_b[ 25 ], tx_b[ 26 ], tx_b[ 27 ], tx_b[ 28 ], tx_b[ 29 ], tx_b[ 30 ], tx_b[ 31 ], tx_b[ 32 ], tx_b[ 33 ], tx_b[ 34 ], tx_b[ 35 ], tx_b[ 36 ], tx_b[ 37 ], tx_b[ 38 ], tx_b[ 39 ] );
-}
-
-static void ipc_spi_prepare_loopback_tx_data( u8 *tx_b, u8 *rx_b )
-{
-	spi_protocol_header *tx_header = ( spi_protocol_header * )tx_b;
-	u16 mux = 0;
-	u8 bof = 0x7F, eof = 0x7E;
-	u32 pkt_len = 16;
-	u8 test_data[ 10 ] = "0123456789";
-	u8 ch_id = 31, control_id = 0;
-
-	int i;
-	
-	memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
+	cmd = ipc_hsi_get_send_vbuff_command( od );
+	if( cmd ) {
+		cmd_8 = cmd & 0xFF;
+		dev_err( od->dev, "(%d) =>exist CMD tx cmd_8 : %x\n", __LINE__, cmd_8 );
 
-	mux = 0x0002;
-	
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) ), ( void * )&mux, sizeof( mux ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) ), ( void * )&bof, sizeof( bof ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) ), ( void * )&pkt_len, sizeof( pkt_len ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) ),
-		( void * )&ch_id, sizeof( ch_id ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) + sizeof( ch_id ) ),
-		( void * )&control_id, sizeof( control_id ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) 
-		+ sizeof( ch_id ) + sizeof( control_id ) ), ( void * )&test_data, sizeof( test_data ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + pkt_len ), ( void * )&eof, sizeof( eof ) );
+		memcpy( ( void * )tx_data->buf, ( void * )&cmd_8, sizeof( cmd_8 ) );
+		ipc_hsi_set_send_vbuff_command_clear( od );
+		dev_err( od->dev, "(%d) =>copy CMD tx data. cmd_8 : %x\n", __LINE__, cmd_8 );
 
-	tx_header->current_data_size = sizeof( mux ) + sizeof( bof ) + pkt_len + sizeof( eof );
-	tx_header->next_data_size = DEF_BUF_SIZE >> 2;
+		tx_data->channel = 4;
+		tx_data->len = 1;
 
-	printk( "[SPI DUMP] LOOP TX : " );
-	for( i = 0 ; i < 30 ; i++ ) {
-		printk( "%02x ", tx_b[ i ] );
+		goto PREP_TX_DONE;
 	}
-	printk( "\n" );
-}
-
-static void ipc_spi_set_MRDY_pin( int val )
-{
-//	dev_dbg( &p_ipc_spi->dev, "(%d) set MRDY %d\n", __LINE__, val );
 	
-	gpio_set_value( gpio_mrdy, val );
-}
-
-static int ipc_spi_tx_rx_sync( u8 *tx_d, u8 *rx_d, unsigned len )
-{
-	struct spi_transfer t;
-	struct spi_message msg;
-	
-	memset( &t, 0, sizeof t );
-	
-	t.len = len;
-
-	t.tx_buf = tx_d;
-	t.rx_buf = rx_d;
-
-	t.cs_change = 0;
-	t.bits_per_word = 32;
-	t.speed_hz = 24000000;
-
-	spi_message_init( &msg );
-	spi_message_add_tail( &t, &msg );
-
-	return spi_sync( p_ipc_spi, &msg );
-}
+	len = ipc_hsi_get_length_vbuff_format_tx( od, &p_send_data_h, &p_send_data_t );
+	if( len ) {
+		dev_err( od->dev, "(%d) =>exist FMT tx data\n", __LINE__ );
 
-static void ipc_spi_swap_data_htn( u8 *data, int len )
-{
-	int i;
+		if( len > IPC_HSI_TX_BUF_SIZE ) {
+			dev_err( od->dev, "(%d) =>FMT tx data len is over. len : %d\n", __LINE__, len );
 
-	for( i = 0 ; i < len ; i += 4 ) {
-		*( u32 * )( data + i ) = htonl( *( u32 * )( data + i ) );
-	}
-}
+			ipc_hsi_update_tail_of_vbuff_format_tx( od, p_send_data_h );
+			dev_err( od->dev, "(%d) =>discard FMT tx data.\n", __LINE__ );
 
-static void ipc_spi_swap_data_nth( u8 *data, int len )
-{
-	int i;
+			tx_data->channel = 0;
+			tx_data->len = 0;
 
-	for( i = 0 ; i < len ; i += 4 ) {
-		*( u32 * )( data + i ) = ntohl( *( u32 * )( data + i ) );
-	}
-}
+			goto PREP_TX_DONE;
+		}
 
-static int ipc_spi_copy_to_vbuff_format_rx( void *data, u16 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
-	u32 int_cmd = 0;
+		ipc_hsi_copy_from_vbuff_format_tx( od, ( void * )tx_data->buf, p_send_data_t, len );
+		dev_err( od->dev, "(%d) =>copy FMT tx data. len : %d\n", __LINE__, len );
+		
+		p_send_data_t += len;
+		p_send_data_t %= FMT_SZ;
+		ipc_hsi_update_tail_of_vbuff_format_tx( od, p_send_data_t );
+		dev_err( od->dev, "(%d) =>update FMT tx data in pointer. in : %d\n", __LINE__, p_send_data_t );
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to FMT vbuff, len : %d\n", __LINE__, len );
+		tx_data->channel = 1;
+		tx_data->len = len;
 
-COPY_TO_VBUFF_FMT_RETRY :
-	
-	space = ipc_spi_get_space_vbuff_format_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) FMT vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
-
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) FMT vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
+#ifdef FORMAT_TX_DUMP
+		printk( "[IPC_SPI => FMT TX :" );
+		for( i = 0; i < tx_data->len; i++ ) {
+			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
+		printk( "]\n" );
+#endif // FORMAT_TX_DUMP
 
-		msleep( 5 );
-		goto COPY_TO_VBUFF_FMT_RETRY;
+		goto PREP_TX_DONE;
 	}
 
-	if( head + len <= FMT_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, len );
-	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, FMT_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + FMT_IN ), ( void * )( data + ( FMT_SZ - head ) ), len - ( FMT_SZ - head ) );
-	}
-
-	new_head = ( head + len ) % FMT_SZ;
-	ipc_spi_update_head_of_vbuff_format_rx( new_head );
+	len = ipc_hsi_get_length_vbuff_raw_tx( od, &p_send_data_h, &p_send_data_t );
+	if( len ) {
+		dev_err( od->dev, "(%d) =>exist RAW tx data\n", __LINE__ );
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to FMT vbuff done.\n", __LINE__ );
+		if( len > IPC_HSI_TX_BUF_SIZE ) {
+			dev_err( od->dev, "(%d) =>RAW tx data len is over. len : %d\n", __LINE__, len );
 
-	return 0;
-}
+			ipc_hsi_update_tail_of_vbuff_raw_tx( od, p_send_data_h );
+			dev_err( od->dev, "(%d) =>discard RAW tx data.\n", __LINE__ );
 
-static int ipc_spi_copy_to_vbuff_raw_rx( void *data, u32 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
+			tx_data->channel = 0;
+			tx_data->len = 0;
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RAW vbuff, len : %d\n", __LINE__, len );
+			goto PREP_TX_DONE;
+		}
 
-COPY_TO_VBUFF_RAW_RETRY :
+		ipc_hsi_copy_from_vbuff_raw_tx( od, ( void * )tx_data->buf, p_send_data_t, len );
+		dev_err( od->dev, "(%d) =>copy RAW tx data. len : %d\n", __LINE__, len );
+		
+		p_send_data_t += len;
+		p_send_data_t %= RAW_SZ;
+		ipc_hsi_update_tail_of_vbuff_raw_tx( od, p_send_data_t );
+		dev_err( od->dev, "(%d) =>update RAW tx data in pointer. in : %d\n", __LINE__, p_send_data_t );
 
-	space = ipc_spi_get_space_vbuff_raw_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) RAW vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
+		tx_data->channel = 2;
+		tx_data->len = len;
 
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) RAW vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
+#ifdef RAW_TX_DUMP
+		printk( "[IPC_SPI => RAW TX :" );
+		for( i = 0; i < tx_data->len; i++ ) {
+			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
+		printk( "]\n" );
+#endif // RAW_TX_DUMP
 
-		msleep( 5 );
-		goto COPY_TO_VBUFF_RAW_RETRY;
-	}
+#ifdef RAW_TX_RX_LENGTH_DUMP
+		printk( "[IPC_SPI => RAW TX : %d]\n", tx_data->len );
+#endif // RAW_TX_RX_LENGTH_DUMP
 
-	if( head + len <= RAW_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, len );
-	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, RAW_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + RAW_IN ), ( void * )( data + ( RAW_SZ - head ) ), len - ( RAW_SZ - head ) );
+		goto PREP_TX_DONE;
 	}
 
-	new_head = ( head + len ) % RAW_SZ;
-	ipc_spi_update_head_of_vbuff_raw_rx( new_head );
+	len = ipc_hsi_get_length_vbuff_rfs_tx( od, &p_send_data_h, &p_send_data_t );
+	if( len ) {
+		dev_err( od->dev, "(%d) =>exist RFS tx data\n", __LINE__ );
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RAW vbuff done.\n", __LINE__ );
+		if( len > IPC_HSI_TX_BUF_SIZE ) {
+			dev_err( od->dev, "(%d) =>RFS tx data len is over. len : %d\n", __LINE__, len );
 
-	return 0;
-}
+			ipc_hsi_update_tail_of_vbuff_rfs_tx( od, p_send_data_h );
+			dev_err( od->dev, "(%d) =>discard RFS tx data.\n", __LINE__ );
 
-static int ipc_spi_copy_to_vbuff_rfs_rx( void *data, u32 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
+			tx_data->channel = 0;
+			tx_data->len = 0;
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RFS vbuff, len : %d\n", __LINE__, len );
+			goto PREP_TX_DONE;
+		}
 
-COPY_TO_VBUFF_RFS_RETRY :
+		ipc_hsi_copy_from_vbuff_rfs_tx( od, ( void * )tx_data->buf, p_send_data_t, len );
+		dev_err( od->dev, "(%d) =>copy RFS tx data. len : %d\n", __LINE__, len );
+		
+		p_send_data_t += len;
+		p_send_data_t %= RFS_SZ;
+		ipc_hsi_update_tail_of_vbuff_rfs_tx( od, p_send_data_t );
+		dev_err( od->dev, "(%d) =>update RFS tx data in pointer. in : %d\n", __LINE__, p_send_data_t );
 
-	space = ipc_spi_get_space_vbuff_rfs_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) RFS vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
+		tx_data->channel = 3;
+		tx_data->len = len;
 
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) RFS vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
+#ifdef RFS_TX_DUMP
+		printk( "[IPC_SPI => RFS TX :" );
+		for( i = 0; i < tx_data->len; i++ ) {
+			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
+		printk( "]\n" );
+#endif // RFS_TX_DUMP
 
-		msleep( 5 );
-		goto COPY_TO_VBUFF_RFS_RETRY;
-	}
+#ifdef RFS_TX_RX_LENGTH_DUMP
+		printk( "[IPC_SPI => RFS TX : %d]\n", tx_data->len );
+#endif // RFS_TX_RX_LENGTH_DUMP
 
-	if( head + len <= RFS_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, len );
+		goto PREP_TX_DONE;
 	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, RFS_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + RFS_IN ), ( void * )( data + ( RFS_SZ - head ) ), len - ( RFS_SZ - head ) );
-	}
-
-	new_head = ( head + len ) % RFS_SZ;
-	ipc_spi_update_head_of_vbuff_rfs_rx( new_head );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RFS vbuff done.\n", __LINE__ );
-
-	return 0;
-}
 
-static void ipc_spi_make_data_interrupt( u32 cmd,  struct ipc_spi *od )
-{
-	struct list_head *l;
-	unsigned long flags;
-	u32 mailbox;
-
-	mailbox = cmd;
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=make data int : 0x%08x\n", __LINE__, mailbox );
-
-	if( h_list.len ) {
-		spin_lock_irqsave( &h_list.lock, flags );
-		list_for_each( l, &h_list.list ) {
-			struct ipc_spi_handler *h = list_entry( l, struct ipc_spi_handler, list );
-
-			if( h->handler ) h->handler( mailbox, h->data );
-		}
-		spin_unlock_irqrestore( &h_list.lock, flags );
+PREP_TX_DONE :
 
-		spin_lock( &ipc_spi_lock );
-		od->mailbox = mailbox;
-		spin_unlock( &ipc_spi_lock );
-	} else {
-		od->mailbox = mailbox;
+#ifdef ALL_TX_DUMP
+	printk( "[IPC_SPI => ALL TX :" );
+	for( i = 0; i < tx_data->len; i++ ) {
+		printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 	}
+	printk( "]\n" );
+#endif // ALL_TX_DUMP
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=send data int cmd event\n", __LINE__ );
+	dev_err( od->dev, "(%d) =>ipc_hsi_prepare_tx_data done. ch : %d, len : %d\n", __LINE__, tx_data->channel, tx_data->len );
 	
-	wake_up_interruptible( &od->waitq );
-	kill_fasync( &od->async_queue, SIGIO, POLL_IN );
 }
 
-static int rx_prev_data_saved = 0;
-static u16 rx_prev_data_mux = 0;
-static u32 rx_prev_data_size = 0;
-static u32 rx_prev_data_remain = 0;
+static void ipc_hsi_prepare_loopback_tx_data( struct ipc_hsi *od, u8 *tx_b )
+{
+}
 
-static void ipc_spi_rx_process( u8 *rx_b,  u8 *rx_save_b, struct ipc_spi *od )
+static void ipc_hsi_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
 {
 	int retval = 0;
-	spi_protocol_header *rx_header = ( spi_protocol_header * )rx_b;
-	u32 total_size = 0, read_size = 0;
-	u16 packet_fmt_len = 0;
-	u32 packet_len = 0;
-	u8 bof = 0, eof = 0;
-	u16 mux = 0;
-	u16 p_read = 4;
+	u32 read_size = 0;
 	u32 int_cmd = 0;
+	u16 cmd_16 = 0;
 	int i;
 
-//	dev_dbg( &p_ipc_spi->dev, "(%d) rx process, more : %d, CTS : %d, current size : %d, next size : %d\n", __LINE__, rx_header->more, rx_header->RTSCTS, rx_header->current_data_size, rx_header->next_data_size );
-
-	total_size = rx_header->current_data_size;
+	dev_err( od->dev, "(%d) <=ipc_hsi_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
 
-	while( total_size > read_size ) {
-		int_cmd = 0;
-
-		if( !rx_prev_data_saved ) {
-			// check bof : 0x7F
-			memcpy( ( void * )&bof, ( void * )( rx_b + p_read + sizeof( mux ) ), sizeof( bof ) );
-//			dev_dbg( &p_ipc_spi->dev, "(%d) rx process, bof : %x\n", __LINE__, bof );
-			if( bof != 0x7F ) {
-				dev_err( &p_ipc_spi->dev, "(%d) rx process, bof error : %x\n", __LINE__, bof );
-
-//				printk( "[IPC_SPI <= RX :" );
-//				for( i = 0 ; i < DEF_BUF_SIZE + 4 ; i++ ) {
-//					printk( " %02x", *( ( u8 * )( rx_b + i ) ) );
-//				}
-//				printk( "]\n" );
-				
-				break;
-			}
-		}
-
-		if( !rx_prev_data_saved ) {
-			// read mux
-			memcpy( ( void * )&mux, ( void * )( rx_b + p_read ), sizeof( mux ) );
-//			dev_dbg( &p_ipc_spi->dev, "(%d) rx process, mux : 0x%04x\n", __LINE__, mux );
-			if( mux > 0x4 || mux < 0x0) {
-				dev_err( &p_ipc_spi->dev, "(%d) rx process, mux error : %x\n", __LINE__, mux );
-				break;
-			}
-		}
-		else {
-			mux = rx_prev_data_mux;
+	if( !rx_data->channel || ( rx_data->channel > 4 ) ) {
+		dev_err( od->dev, "(%d) <=Wrong channel : %d\n", __LINE__, rx_data->channel );
+		return;
+	}
+	dev_err( od->dev, "(%d) <=channel : %d\n", __LINE__, rx_data->channel );
 
-			dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, prev_mux : %d\n", __LINE__, mux );
-		}
+	if( rx_data->len > IPC_HSI_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=Wrong len : %d\n", __LINE__, rx_data->len );
+		return;
+	}
+	dev_err( od->dev, "(%d) <=len : %d\n", __LINE__, rx_data->len );
+	
+	while( rx_data->len > read_size ) {
 
-		switch( mux ) {
+		switch( rx_data->channel ) {
 			case 0x0001 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got FMT : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, FMT saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0001;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, FMT size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, FMT bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, FMT eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_format_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet FMT read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef FORMAT_RX_DUMP
-					printk( "[IPC_SPI <= FMT RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // FORMAT_RX_DUMP
-
-					rx_prev_data_saved = 0;
+				dev_err( od->dev, "(%d) <=rx process, got FMT rx data.\n", __LINE__ );
+				
+				retval = ipc_hsi_copy_to_vbuff_format_rx( od, ( void * )rx_data->buf, rx_data->len );
+				if( retval < 0 ) {
+					dev_err( od->dev, "(%d) <=rx process, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
+					return;
 				}
 				else {
-					// read packet len
-					memcpy( ( void * )&packet_fmt_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_fmt_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, FMT pkt len : %d\n", __LINE__, packet_fmt_len );
-//					if( packet_fmt_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, FMT pkt len error : %d\n", __LINE__, packet_fmt_len );
-//						return;
-//					}
-
-					if( ( packet_fmt_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, FMT packet_fmt_len : %d, remain : %d\n", __LINE__, packet_fmt_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0001;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_fmt_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, FMT size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
+					dev_err( od->dev, "(%d) <=rx process, FMT read Done. len : %d\n", __LINE__, rx_data->len );
+				}
 
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_format_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_fmt_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-//						dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet FMT read Done.\n", __LINE__ );
-					}
+				read_size += rx_data->len;
+				dev_err( od->dev, "(%d) <=rx process, FMT update read_size : %d\n", __LINE__, read_size );
 
 #ifdef FORMAT_RX_DUMP
-					printk( "[IPC_SPI <= FMT RX :" );
-					for( i = 0 ; i < ( packet_fmt_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
-#endif // FORMAT_RX_DUMP
-
-					p_read += packet_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, FMT read size : %d, \n", __LINE__, read_size );
+				printk( "[IPC_SPI <= FMT RX :" );
+				for( i = 0; i < rx_data->len; i++ ) {
+					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
 				}
+				printk( "]\n" );
+#endif // FORMAT_RX_DUMP
 
-				// make data interrupt cmd
 				int_cmd = MB_DATA( MBD_SEND_FMT );
-				ipc_spi_make_data_interrupt( int_cmd, od );
+				ipc_hsi_make_data_interrupt( od, int_cmd );
+				dev_err( od->dev, "(%d) <=rx process, FMT send event : 0x%x\n", __LINE__, int_cmd );
 				break;
 
 			case 0x0002 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got RAW : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, RAW saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0002;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, RAW size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RAW bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RAW eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_raw_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet RAW read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef RAW_RX_DUMP
-					printk( "[IPC_SPI <= RAW RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RAW_RX_DUMP
-
-					rx_prev_data_saved = 0;
+				dev_err( od->dev, "(%d) <=rx process, got RAW rx data.\n", __LINE__ );
+				
+				retval = ipc_hsi_copy_to_vbuff_raw_rx( od, ( void * )rx_data->buf, rx_data->len );
+				if( retval < 0 ) {
+					dev_err( od->dev, "(%d) <=rx process, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
+					return;
 				}
 				else {
-					// read packet len
-					memcpy( ( void * )&packet_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, RAW pkt len : %d\n", __LINE__, packet_len );
-//					if( packet_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, RAW pkt len error : %d\n", __LINE__, packet_len );
-//						return;
-//					}
-
-					if( ( packet_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, RAW packet_len : %d, remain : %d\n", __LINE__, packet_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0002;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, RAW size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
+					dev_err( od->dev, "(%d) <=rx process, RAW read Done. len : %d\n", __LINE__, rx_data->len );
+				}
 
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_raw_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-//						dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet RAW read Done.\n", __LINE__ );
-					}
+				read_size += rx_data->len;
+				dev_err( od->dev, "(%d) <=rx process, RAW update read_size : %d\n", __LINE__, read_size );
 
 #ifdef RAW_RX_DUMP
-					printk( "[IPC_SPI <= RAW RX :" );
-					for( i = 0 ; i < ( packet_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
+				printk( "[IPC_SPI <= RAW RX :" );
+				for( i = 0; i < rx_data->len; i++ ) {
+					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+				}
+				printk( "]\n" );
 #endif // RAW_RX_DUMP
 
-					p_read += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, RAW read size : %d\n", __LINE__, read_size );
-				}
+#ifdef RAW_TX_RX_LENGTH_DUMP
+				printk( "[IPC_SPI <= RAW RX : %d]\n", rx_data->len );
+#endif // RAW_TX_RX_LENGTH_DUMP
 
-				// make data interrupt cmd
 				int_cmd = MB_DATA( MBD_SEND_RAW );
-				ipc_spi_make_data_interrupt( int_cmd, od );
+				ipc_hsi_make_data_interrupt( od, int_cmd );
+				dev_err( od->dev, "(%d) <=rx process, RAW send event : 0x%x\n", __LINE__, int_cmd );
 				break;
 
 			case 0x0003 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got RFS : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, RFS saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0003;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, RFS size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RFS bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RFS eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_rfs_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet RFS read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef RFS_RX_DUMP
-					printk( "[IPC_SPI <= RFS RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RFS_RX_DUMP
-
-#ifdef RFS_TX_RX_LENGTH_DUMP
-					printk( "[IPC_SPI <= RFS RX : %d]\n", rx_prev_data_size + rx_prev_data_remain );
-#endif // RFS_TX_RX_LENGTH_DUMP
-
-					rx_prev_data_saved = 0;
+				dev_err( od->dev, "(%d) <=rx process, got RFS rx data.\n", __LINE__ );
+				
+				retval = ipc_hsi_copy_to_vbuff_rfs_rx( od, ( void * )rx_data->buf, rx_data->len );
+				if( retval < 0 ) {
+					dev_err( od->dev, "(%d) <=rx process, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
+					return;
 				}
 				else {
-					// read packet len
-					memcpy( ( void * )&packet_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, RFS pkt len : %d\n", __LINE__, packet_len );
-//					if( packet_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, RFS pkt len error : %d\n", __LINE__, packet_len );
-//						return;
-//					}
-
-					if( ( packet_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, RFS packet_len : %d, remain : %d\n", __LINE__, packet_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0003;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, RFS size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
+					dev_err( od->dev, "(%d) <=rx process, RFS read Done. len : %d\n", __LINE__, rx_data->len );
+				}
 
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_rfs_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-	//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet RFS read Done.\n", __LINE__ );
-					}
+				read_size += rx_data->len;
+				dev_err( od->dev, "(%d) <=rx process, RFS update read_size : %d\n", __LINE__, read_size );
 
 #ifdef RFS_RX_DUMP
-					printk( "[IPC_SPI <= RFS RX :" );
-					for( i = 0 ; i < ( packet_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
+				printk( "[IPC_SPI <= RFS RX :" );
+				for( i = 0; i < rx_data->len; i++ ) {
+					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+				}
+				printk( "]\n" );
 #endif // RFS_RX_DUMP
 
-					p_read += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-	//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, RFS read size : %d\n", __LINE__, read_size );
-
 #ifdef RFS_TX_RX_LENGTH_DUMP
-					printk( "[IPC_SPI <= RFS RX : %d]\n", packet_len );
+				printk( "[IPC_SPI <= RFS RX : %d]\n", rx_data->len );
 #endif // RFS_TX_RX_LENGTH_DUMP
 
-				}
-
-				// make data interrupt cmd
 				int_cmd = MB_DATA( MBD_SEND_RFS );
-				ipc_spi_make_data_interrupt( int_cmd, od );
+				ipc_hsi_make_data_interrupt( od, int_cmd );
+				dev_err( od->dev, "(%d) <=rx process, RFS send event : 0x%x\n", __LINE__, int_cmd );
 				break;
 
 			case 0x0004 :
-				dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, got command : %x\n", __LINE__, mux );
+				dev_err( od->dev, "(%d) <=rx process, got CMD rx data.\n", __LINE__ );
+
+				memcpy( ( void * )&cmd_16, ( void * )rx_data->buf, sizeof( cmd_16 ) );
+				dev_err( od->dev, "(%d) <=rx process, CMD read Done. cmd : 0x%x, len : %d\n", __LINE__, cmd_16, rx_data->len );
+
+				if( ( cmd_16 & 0xF ) == 0xA ) { // ONEDRAM_CMD_SUSPEND_REQ
+					printk( "[ipc_spi] Got ONEDRAM_CMD_SUSPEND_REQ\n" );
+					cp_flow_control_stop_transfer = 1;
+				}
+				else if( ( cmd_16 & 0xF ) == 0xB ) { // ONEDRAM_CMD_RESUME_REQ
+					printk( "[ipc_spi] Got ONEDRAM_CMD_RESUME_REQ\n" );
+					cp_flow_control_stop_transfer = 0;
+				}
+
+				read_size += rx_data->len;
+				dev_err( od->dev, "(%d) <=rx process, CMD update read_size : %d\n", __LINE__, read_size );
+				
 				break;
 
 			default :
 				break;
 		}
 
-		if( total_size < read_size ) {
-			dev_err( &p_ipc_spi->dev, "(%d) rx process, read error.\n", __LINE__ );
-		}
-
-//		dev_dbg( &p_ipc_spi->dev, "(%d) rx process, LOOP ==== total : %d, read : %d, p_read : %d\n", __LINE__, total_size, read_size, p_read );
+		dev_err( od->dev, "(%d) ===== rx process loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
 	}
 }
 
-static int ipc_spi_thread( void *data )
+int hsi_start_protocol( void );
+int write_hsi( int channel, u32 *data, int length );
+int read_hsi( u8 *data, u32 *ch, u32 *length );
+static int ipc_hsi_tx_thread( void *data )
 {
-	struct ipc_spi *od = ( struct ipc_spi * )data;
-	
 	int retval = 0;
-	u8 *tx_buf = NULL;
-	spi_protocol_header *tx_header = NULL;
-	u8 *rx_buf = NULL;
-	spi_protocol_header *rx_header = NULL;
-	int skip_SRDY_chk = 0;
-	int clear_tx_buf = 0;
-	u8 *rx_save_buf = NULL;
-
-	daemonize( "ipc_spi_thread" );
-
-	printk( "[%s] ipc_spi_thread start.\n", __func__ );
-
-	wait_for_completion( &ril_init );
-	printk( "[%s] ril_init completed.\n", __func__ );
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-	if( !p_ipc_spi ) {
-		printk( "[%s] p_ipc_spi is NULL.\n", __func__ );
+	ipc_hsi_data *tx_data = NULL;
+	
+	daemonize( "ipc_hsi_tx_thread" );
 
-		retval = -ENODEV;
-		goto exit;
-	}
+	printk( "(%d) ipc_hsi_tx_thread start.\n", __LINE__ );
 
 	if( !p_virtual_buff ) {
-		dev_err( &p_ipc_spi->dev, "[%s] p_virtual_buff is NULL.\n", __func__);
+		dev_err( od->dev, "(%d) p_virtual_buff is NULL.\n", __LINE__);
 
 		retval = -ENODEV;
 		goto exit;
 	}
 
-	tx_buf = kmalloc( DEF_BUF_SIZE + 4, GFP_ATOMIC );
-	if( !tx_buf ) {
-		dev_err( &p_ipc_spi->dev, "[%s] tx_buf kmalloc fail.", __func__ );
-
+	tx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !tx_data ) {
+		dev_err( od->dev, "(%d) tx_data kmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
-	tx_header = ( spi_protocol_header * )tx_buf;
-
-	rx_buf = kmalloc( DEF_BUF_SIZE + 4, GFP_ATOMIC );
-	if( !rx_buf  ) {
-		dev_err( &p_ipc_spi->dev, "[%s] rx_buf  kmalloc fail.", __func__ );
+	memset( ( void * )tx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) tx_data kmalloc done.\n", __LINE__ );
 
+	tx_data->buf = kmalloc( IPC_HSI_TX_BUF_SIZE, GFP_ATOMIC );
+	if( !tx_data->buf ) {
+		dev_err( od->dev, "(%d) tx_data->buf vmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
-	rx_header = ( spi_protocol_header * )rx_buf;
+	memset( ( void * )tx_data->buf, 0, IPC_HSI_TX_BUF_SIZE );
+	dev_err( od->dev, "(%d) tx_data->buf vmalloc done.\n", __LINE__ );
 
-	rx_save_buf = kmalloc( DEF_BUF_SIZE * 3, GFP_ATOMIC );
-	if( !rx_save_buf  ) {
-		dev_err( &p_ipc_spi->dev, "[%s] rx_save_buf  kmalloc fail.", __func__ );
+SILENT_RESET :
 
-		retval = -ENOMEM;
-		goto exit;
-	}
-	memset( ( void * )rx_save_buf, 0, DEF_BUF_SIZE * 3 );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) wait 2 sec... srdy : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	msleep( 2000 );
-	
-	while( gpio_get_value( gpio_srdy ) );
-	dev_dbg( &p_ipc_spi->dev, "(%d) cp booting... Done.\n", __LINE__ );
+	printk( "[%s] wait ril_init complete.\n", __func__ );
+	wait_for_completion( &ril_init );
+	printk( "[%s] ril_init completed.\n", __func__ );
 
-	dev_dbg( &p_ipc_spi->dev, "(%d) wait 1 sec...\n", __LINE__ );
-	msleep( 1000 );
+	cp_restart = 0;
 
-	printk( "[IPC_SPI] Start IPC Communication. MRDY : %d, SRDY : %d\n", gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
-	sema_init( &srdy_sem, 0 );
+	dev_err( od->dev, "(%d) wait 2 sec...\n", __LINE__ );
+	msleep( 2000 );
+	dev_err( od->dev, "(%d) Start TX Thread.\n", __LINE__ );
 
-	ipc_spi_irq_log_flag = 1;
+	sema_init( &transfer_event_sem, 0 );
 	
 	while( 1 ) {
 
-		if( !ipc_spi_check_send_data() ) { // no send data
-			if( down_trylock( &srdy_sem ) ) { // no srdy sem
-				dev_dbg( &p_ipc_spi->dev, "(%d) no data and no sem, wait tx-srdy event.\n", __LINE__ );
-				
-				transfer_thread_waiting = 1;
+		if( !ipc_hsi_check_send_data( od ) ) {
+			transfer_thread_waiting = 1;
 
-				skip_SRDY_chk = 0;
+			dev_err( od->dev, "(%d) no data and no sem, wait tx event.\n", __LINE__ );
 
-				down( &transfer_event_sem ); // wait event( tx or srdy )
-				dev_dbg( &p_ipc_spi->dev, "(%d) got tx-srdy event.\n", __LINE__ );
-			}
-			else {
-				dev_dbg( &p_ipc_spi->dev, "(%d) srdy_sem already exist\n", __LINE__ );
+			down( &transfer_event_sem );
+			transfer_thread_waiting = 0;
 
-				skip_SRDY_chk = 1;
-				clear_tx_buf = 1;
-			}
+			dev_err( od->dev, "(%d) got tx event.\n", __LINE__ );
 		}
 		else {
-			dev_dbg( &p_ipc_spi->dev, "(%d) send data exist\n", __LINE__ );
+			dev_err( od->dev, "(%d) send data exist\n", __LINE__ );
 		}
 
-		// HERE : Got tx data event or Got SRDY isr event
-		if( gpio_get_value( gpio_mrdy ) ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) MRDY HIGH!!!\n", __LINE__ );
-			
-			ipc_spi_set_MRDY_pin( 0 );
+		if( cp_restart ) {
+			printk( "[IPC_HSI] (%d)CP Restart.\n", __LINE__ );					
+			goto SILENT_RESET;
 		}
-		ipc_spi_set_MRDY_pin( 1 ); // set MRDY High
-		
-		do {
 
-			if( clear_tx_buf ) {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) tx data clear.\n", __LINE__ );
-				
-				memset( ( void * )tx_buf, 0, DEF_BUF_SIZE + 4 );
-
-				clear_tx_buf = 0;
-			}
-			else {
-				ipc_spi_prepare_tx_data( tx_buf );
-			}
+		ipc_hsi_prepare_tx_data( od, tx_data );
 
-			if( loop_back_test ) {
-				ipc_spi_prepare_loopback_tx_data( tx_buf, rx_buf );
-
-				loop_back_test = 0;
-			}
-
-			if( !skip_SRDY_chk ) {
-RETRY_WAIT_SEM :
-				
-				dev_dbg( &p_ipc_spi->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-				
-				//down( &srdy_sem ); // wait SRDY set High
-				if( down_timeout( &srdy_sem, 2 * HZ ) ) {
-					dev_err( &p_ipc_spi->dev, "(%d) SRDY TimeOUT!!! MRDY : %d, SRDY : %d\n", __LINE__, gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
-			
-					ipc_spi_set_MRDY_pin( 0 );
-					mdelay( 10 );
-					ipc_spi_set_MRDY_pin( 1 );
+		// call write func
+		dev_err( od->dev, "(%d) start write_hsi. len : %d\n", __LINE__, tx_data->len );
+		retval = write_hsi( tx_data->channel, ( u32 * )tx_data->buf, tx_data->len );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) start write_hsi error : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) start write_hsi Done : %d\n", __LINE__, retval );
 
-					dev_err( &p_ipc_spi->dev, "(%d) SRDY TimeOUT Reset!!! MRDY : %d, SRDY : %d\n", __LINE__, gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
+		dev_err( od->dev, "(%d) ===== tx loop =====\n", __LINE__ );
 
-					if( !gpio_get_value( gpio_srdy ) )
-						goto RETRY_WAIT_SEM;
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) got SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-			}
-			else {
-				dev_dbg( &p_ipc_spi->dev, "(%d) skip wait SRDY.\n", __LINE__ );
-				
-				skip_SRDY_chk = 0;
-			}
-
-//			dev_dbg( &p_ipc_spi->dev, "(%d) clear rx buf.\n", __LINE__ );
-//			memset( ( void * )rx_buf, 0, DEF_BUF_SIZE + 4 );
+	}
 
-//			if( !gpio_get_value( gpio_srdy ) ) {
-//				dev_err( &p_ipc_spi->dev, "(%d) SRDY gpio is Low.\n", __LINE__ );
-//			}
-			
-			// tx, rx Transmit
-//			dev_dbg( &p_ipc_spi->dev, "(%d) transmit start.\n", __LINE__ );
+exit :
+	printk( "(%d) thread stop.\n", __LINE__ );
 
-			ipc_spi_swap_data_htn( tx_buf, DEF_BUF_SIZE + 4 );    //host to network
-            
+	return retval;
+}
 
-			retval = ipc_spi_tx_rx_sync( tx_buf, rx_buf, DEF_BUF_SIZE + 4 );
-			if( retval != 0 ) {
-				dev_err( &p_ipc_spi->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
-			}
-			else {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) transmit Done.\n", __LINE__ );
-			}
+static int ipc_hsi_rx_thread( void *data )
+{
+	int retval = 0;
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-			ipc_spi_swap_data_nth( rx_buf, DEF_BUF_SIZE + 4 );    //network to host
-			*( u32 * )tx_header = ntohl( *( u32 * )tx_header );
+	ipc_hsi_data *rx_data = NULL;
+	
+	daemonize( "ipc_hsi_rx_thread" );
 
-//			dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] RX :\n" );
-			dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] RX : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-				rx_buf[ 0 ], rx_buf[ 1 ], rx_buf[ 2 ], rx_buf[ 3 ], rx_buf[ 4 ], rx_buf[ 5 ], rx_buf[ 6 ], rx_buf[ 7 ], rx_buf[ 8 ], rx_buf[ 9 ], rx_buf[ 10 ], rx_buf[ 11 ], rx_buf[ 12 ], rx_buf[ 13 ], rx_buf[ 14 ], rx_buf[ 15 ], rx_buf[ 16 ], rx_buf[ 17 ], rx_buf[ 18 ], rx_buf[ 19 ], 
-				rx_buf[ 20 ], rx_buf[ 21 ], rx_buf[ 22 ], rx_buf[ 23 ], rx_buf[ 24 ], rx_buf[ 25 ], rx_buf[ 26 ], rx_buf[ 27 ], rx_buf[ 28 ], rx_buf[ 29 ], rx_buf[ 30 ], rx_buf[ 31 ], rx_buf[ 32 ], rx_buf[ 33 ], rx_buf[ 34 ], rx_buf[ 35 ], rx_buf[ 36 ], rx_buf[ 37 ], rx_buf[ 38 ], rx_buf[ 39 ] );
+	printk( "(%d) ipc_hsi_rx_thread start.\n", __LINE__ );
 
-			if( *( u32 * )rx_header != 0x00000000 && *( u32 * )rx_header != 0xFFFFFFFF ) { // valid spi header
-//				dev_dbg( &p_ipc_spi->dev, "(%d) got valid rx data.\n", __LINE__ );
-				
-				// RX process
-				ipc_spi_rx_process( rx_buf, rx_save_buf, od );
-				
-				if( rx_header->RTSCTS ) { // modem is not available.
-					dev_err( &p_ipc_spi->dev, "(%d) rx CTS set.\n", __LINE__ );
-					
-					clear_tx_buf = 1;
-				}
-
-				//if( tx_header->RTSCTS ) { // master is not available.
-				//	dev_dbg( &p_ipc_spi->dev, "(%d) tx RTS set.\n", __LINE__ );
-				//}
-			}
-			else {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) got invalid rx data.\n", __LINE__ );
-				
-				rx_header->RTSCTS = 0;
-				rx_header->more = 0;
-			}
+	if( !p_virtual_buff ) {
+		dev_err( od->dev, "(%d) p_virtual_buff is NULL.\n", __LINE__);
 
-			dev_dbg( &p_ipc_spi->dev, "(%d) check more, CTS : %d, rx more : %d, tx more : %d\n", __LINE__, rx_header->RTSCTS, rx_header->more, tx_header->more );
-		}while( rx_header->RTSCTS || rx_header->more || tx_header->more );
+		retval = -ENODEV;
+		goto exit;
+	}
 
-		ipc_spi_set_MRDY_pin( 0 ); // clear MRDY Low
+	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !rx_data ) {
+		dev_err( od->dev, "(%d) rx_data kmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) rx_data kmalloc done.\n", __LINE__ );
 
-//		dev_dbg( &p_ipc_spi->dev, "(%d) LOOP Done ============================\n", __LINE__ );
+	rx_data->buf = kmalloc( IPC_HSI_RX_BUF_SIZE, GFP_ATOMIC );
+	if( !rx_data->buf ) {
+		dev_err( od->dev, "(%d) rx_data->buf vmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
 	}
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) rx_data->buf vmalloc done.\n", __LINE__ );
 
-exit :
-	printk( "(%d) thread stop.\n", __LINE__ );
+SILENT_RESET :
 
-	return retval;
-}
+	printk( "[%s] wait ril_init complete.\n", __func__ );
+	wait_for_completion( &ril_init );
+	printk( "[%s] ril_init completed.\n", __func__ );
 
-struct ipc_spi_send_modem_bin_header {
-	u16 sot;
-	u16 type;
-	u16 length;
-};
+	cp_restart = 0;
 
-struct ipc_spi_send_modem_bin_footer {
-	u16 crc;
-	u16 eot;
-};
+	dev_err( od->dev, "(%d) wait 2 sec...\n", __LINE__ );
+	msleep( 2000 );
+	dev_err( od->dev, "(%d) Start RX Thread.\n", __LINE__ );
+	
+	while( 1 ) {
 
+		if( cp_restart ) {
+			printk( "[IPC_HSI] (%d)CP Restart.\n", __LINE__ );						
+			goto SILENT_RESET;
+		}
 
-static u16 ipc_spi_send_modem_bin_make_crc( u8 *buf )
-{
-	u16 crc = 0;
-	int i;
-	struct ipc_spi_send_modem_bin_header *header = ( struct ipc_spi_send_modem_bin_header * )( buf + 4 );
+		do {
+			rx_data->channel = 0;
+			rx_data->len = 0;
+			rx_data->more = 0;
+			
+			// call read func
+			dev_err( od->dev, "(%d) read_hsi start\n", __LINE__ );
+			retval = read_hsi( ( u8 * )rx_data->buf, ( u32 * )&rx_data->channel, ( u32 * )&rx_data->len );
+			if( retval < rx_data->len ) {
+				dev_err( od->dev, "(%d) read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
+			}
+			dev_err( od->dev, "(%d) read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 
-	crc += header->type;
-	crc += header->length;
+			ipc_hsi_rx_process( od, rx_data );
 
-	buf += 4;
-	buf += sizeof( struct ipc_spi_send_modem_bin_header );
-	for( i = 0 ; i < header->length ; i++ )
-		crc += *buf++;
+			dev_err( od->dev, "(%d) check rx more : %d\n", __LINE__, rx_data->more );
+		} while( rx_data->more );
 
-	return crc;
-}
+		dev_err( od->dev, "(%d) ===== rx loop =====\n", __LINE__ );
 
-#define EBL_PACKET_SIZE	4096//4096//3088//2064
-static int ipc_spi_send_modem_bin_execute_cmd( struct ipc_spi *od, u16 type, u32 len, void *data )
-{
-	int retval = 0;
-	u8 *tx_b = NULL;
-	u8 *rx_b = NULL;
-	spi_protocol_header *tx_spi_header = NULL;
-	spi_protocol_header *rx_spi_header = NULL;
-	struct ipc_spi_send_modem_bin_header *tx_header = NULL;
-	struct ipc_spi_send_modem_bin_footer *tx_footer = NULL;
-	struct ipc_spi_send_modem_bin_header *rx_header = NULL;
-	struct ipc_spi_send_modem_bin_footer *rx_footer = NULL;
-
-	tx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
-	if( !tx_b ) {
-		dev_err( od->dev, "(%d) tx_b kmalloc fail.", __LINE__ );
-		return -ENOMEM;
-	}
-	tx_spi_header = ( spi_protocol_header * )tx_b;
-	tx_header = ( struct ipc_spi_send_modem_bin_header * )( tx_b + 4 );
-	memset( tx_b, 0, EBL_PACKET_SIZE);
-	
-	rx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
-	if( !rx_b ) {
-		dev_err( od->dev, "(%d) rx_b kmalloc fail.", __LINE__ );
-		return -ENOMEM;
-	}
-	rx_spi_header = ( spi_protocol_header * )rx_b;
-	rx_header = ( struct ipc_spi_send_modem_bin_header * )( rx_b + 4 );
-	memset( rx_b, 0, EBL_PACKET_SIZE);
-//	dev_dbg( od->dev, "(%d) tx_b, rx_b kmalloc Done.\n", __LINE__ );
-
-	ipc_spi_set_MRDY_pin( 1 );
-//	dev_dbg( od->dev, "(%d) set MRDY.\n", __LINE__ );
-
-	tx_spi_header->next_data_size = ( EBL_PACKET_SIZE - 4 ) >> 2;
-	tx_spi_header->current_data_size = sizeof( struct ipc_spi_send_modem_bin_header ) + len + sizeof( struct ipc_spi_send_modem_bin_footer );
-
-	tx_header->sot = 0x0002;
-	tx_header->type = type;
-	tx_header->length = len;
-
-//	dev_dbg( od->dev, "(%d) len : %d\n", __LINE__, len );
-	memcpy( ( void * )( tx_b + sizeof( struct ipc_spi_send_modem_bin_header ) + 4 ), data, len );
-
-	tx_footer = ( struct ipc_spi_send_modem_bin_footer * )( tx_b + 4 + sizeof( struct ipc_spi_send_modem_bin_header ) + len );
-
-	tx_footer->crc = ipc_spi_send_modem_bin_make_crc( tx_b );
-//	dev_dbg( od->dev, "(%d) tx crc : %d\n", __LINE__, tx_footer->crc );
-
-	tx_footer->eot = 0x0003;
-/*
-	dev_dbg( od->dev, "[SPI DUMP] tx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		tx_b[ 0 ], tx_b[ 1 ], tx_b[ 2 ], tx_b[ 3 ], tx_b[ 4 ], 
-		tx_b[ 5 ], tx_b[ 6 ], tx_b[ 7 ], tx_b[ 8 ], tx_b[ 9 ], 
-		tx_b[ 10 ], tx_b[ 11 ], tx_b[ 12 ], tx_b[ 13 ], tx_b[ 14 ], 
-		tx_b[ 15 ], tx_b[ 16 ], tx_b[ 17 ], tx_b[ 18 ], tx_b[ 19 ],
-		tx_b[ EBL_PACKET_SIZE - 10 ], tx_b[ EBL_PACKET_SIZE - 9 ], tx_b[ EBL_PACKET_SIZE - 8 ], tx_b[ EBL_PACKET_SIZE - 7 ], tx_b[ EBL_PACKET_SIZE - 6 ],
-		tx_b[ EBL_PACKET_SIZE - 5 ], tx_b[ EBL_PACKET_SIZE - 4 ], tx_b[ EBL_PACKET_SIZE - 3 ], tx_b[ EBL_PACKET_SIZE - 2 ], tx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-	ipc_spi_swap_data_htn( tx_b, EBL_PACKET_SIZE );
-	
-//	dev_dbg( od->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	down( &srdy_sem );
-
-	retval = ipc_spi_tx_rx_sync( tx_b, rx_b, EBL_PACKET_SIZE );
-	if( retval != 0 ) {
-		dev_err( od->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
 	}
-	else {
-//		dev_dbg( od->dev, "(%d) transmit Done.\n", __LINE__ );
-	}
-	
-	//ipc_spi_swap_data_nth( rx_b, EBL_PACKET_SIZE );
-/*
-	dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-		rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-		rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-		rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-		rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-		rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-
-	if( type == 0x0208 ) // ReqForceHwReset
-		return 0;
 
-	memset( tx_b, 0, EBL_PACKET_SIZE);
-	memset( rx_b, 0, EBL_PACKET_SIZE);
-	
-//	dev_dbg( od->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	down( &srdy_sem );
-	
-	retval = ipc_spi_tx_rx_sync( tx_b, rx_b, EBL_PACKET_SIZE );
-	if( retval != 0 ) {
-		dev_err( od->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
-	}
-	else {
-//		dev_dbg( od->dev, "(%d) transmit Done.\n", __LINE__ );
-	}
-	
-	ipc_spi_swap_data_nth( rx_b, EBL_PACKET_SIZE );
-/*
-	dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-		rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-		rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-		rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-		rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-		rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-	if( rx_header->type != type ) {
-		dev_err( od->dev, "(%d) execute cmd ack error : 0x%x(0x%x)\n", __LINE__, rx_header->type, type );
-
-		dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-			rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-			rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-			rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-			rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-			rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-			rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-		
-		retval = -1;
-	}
-	else {
-//		dev_dbg( od->dev, "(%d) execute cmd ack Done.\n", __LINE__ );
-	}
+exit :
+	printk( "(%d) thread stop.\n", __LINE__ );
 
-	ipc_spi_set_MRDY_pin( 0 );
-	
 	return retval;
 }
 
+
 enum image_type {
 	MODEM_PSI,
 	MODEM_EBL,
@@ -2590,216 +1926,127 @@
 #define MAIN_OFFSET_VM	0
 #define NV_OFFSET_VM		0xD80000
 
-#define SPI_SEND_BLOCK_SIZE		4080//4080//3072//2048
-
-static int ipc_spi_send_modem_bin_xmit_img( struct ipc_spi *od, enum image_type type, unsigned int *address )
-{
-	int retval = 0;
-	struct image_buf img;
-	unsigned int data_size;
-	unsigned int send_size = 0;
-	unsigned int rest_size = 0;
-	unsigned char *ptr;
-	int i;
-
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img type : %d.\n", __LINE__, type );
-	switch( type ) {
-		case MODEM_MAIN:
-			img.buf = ( unsigned char * )( p_virtual_buff + MAIN_OFFSET_VM );
-			img.length = MAIN_LEN;
-			dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img save MAIN to img.\n", __LINE__ );
-				
-			break;
-			
-		case MODEM_NV:
-			img.buf = ( unsigned char * )( p_virtual_buff + NV_OFFSET_VM );
-			img.length = NV_LEN;
-			dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img save NV to img.\n", __LINE__ );
-			
-			break;
-			
-		default:
-			dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img wrong : %d.", __LINE__, type );
-			return -1;
-	}
-
-	//Command : ReqFlashSetAddress( 0x0802 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0802, sizeof( unsigned int ), address );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		return -1;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
-
-	dev_dbg( od->dev, "(%d) Start send img. size : %d\n", __LINE__, img.length );
-	ptr = img.buf;
-	data_size = SPI_SEND_BLOCK_SIZE;
-	rest_size = img.length;
-
-	for( i = 0 ; send_size < img.length ; i++ ) {
-		if( rest_size < SPI_SEND_BLOCK_SIZE )
-			data_size = rest_size;
-
-		//Command : ReqFlashWriteBlock( 0x0804 )
-		retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0804, data_size, ptr );
-		if( retval < 0 ) {
-			dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-			return -1;
-		}
+#define SPI_SEND_BLOCK_SIZE		3072//4080//3072//2048
 
-		send_size += data_size;
-		rest_size -= data_size;
-		ptr += data_size;
+#define EBL_PACKET_SIZE	3088//4096//3088//2064
+#define EBL_RX_PACKET_SIZE	80
 
-		if( !( i % 100 ) )
-			dev_dbg( od->dev, "(%d) [%d] 0x%x size done, rest size: 0x%x\n", __LINE__, i, send_size, rest_size );
-	}
-
-	return retval;
-}
-
-static void ipc_spi_send_modem_bin( struct work_struct *send_modem_w )
+static void ipc_hsi_send_modem_bin( struct work_struct *send_modem_w )
 {
 	int retval = 0;
 	u32 int_cmd = 0xABCDABCD;
 	u32 int_cmd_fail = 0xDCBADCBA;
-	struct ipc_spi_send_modem_bin_workq_data *smw 
-		= container_of( send_modem_w, struct ipc_spi_send_modem_bin_workq_data, send_modem_w );
-	struct ipc_spi *od = smw->od;
-
-	unsigned int modem_addr = 0x60300000;//0x60300000;0x61580000;0x61600000
-	unsigned int nvm_static_fix_addr = 0x60e80000;//0x60e80000;0x61F80000;0x61E80000
-	unsigned int nvm_static_cal_addr = 0x60f00000;//0x60f00000;0x61F00000;0x61F00000
-	unsigned int nvm_dynamic_addr = 0x60f80000;//0x60f80000;0x61E80000;0x61F80000
-	unsigned int nvm_addr = 0x60C00000;//0x60b80000;//0x60C00000;
-	unsigned short sec_end = 0x0000;
-	unsigned int force_hw_reset = 0x00111001;
+	struct ipc_hsi_send_modem_bin_workq_data *smw 
+		= container_of( send_modem_w, struct ipc_hsi_send_modem_bin_workq_data, send_modem_w );
+	struct ipc_hsi *od = smw->od;
+
+//	unsigned int modem_addr = 0x61500000;//0x60300000;0x61580000;0x61600000;0x61500000
+//	unsigned int nvm_static_fix_addr = 0x60e80000;//0x60e80000;0x61F80000;0x61E80000
+//	unsigned int nvm_static_cal_addr = 0x60f00000;//0x60f00000;0x61F00000;0x61F00000
+//	unsigned int nvm_dynamic_addr = 0x60f80000;//0x60f80000;0x61E80000;0x61F80000
+//	unsigned int nvm_addr = 0x61E00000;//0x60b80000;//0x60C00000;0x61E00000
+//	unsigned short sec_end = 0x0000;
+//	unsigned int force_hw_reset = 0x00111001;
 	
-	u8 *sec_start = NULL;
-
 	dev_dbg( od->dev, "[SPI DUMP] mb : [%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
 		*( u8 * )( p_virtual_buff ), *( u8 * )( p_virtual_buff + 1 ), *( u8 * )( p_virtual_buff + 2 ), *( u8 * )( p_virtual_buff + 3 ), *( u8 * )( p_virtual_buff + 4 ), 
 		 *( u8 * )( p_virtual_buff + 5 ),  *( u8 * )( p_virtual_buff + 6 ),  *( u8 * )( p_virtual_buff + 7 ),  *( u8 * )( p_virtual_buff + 8 ),  *( u8 * )( p_virtual_buff + 9 ), 
 		*( u8 * )( p_virtual_buff + 10 ),  *( u8 * )( p_virtual_buff + 11 ),  *( u8 * )( p_virtual_buff + 12 ),  *( u8 * )( p_virtual_buff + 13 ),  *( u8 * )( p_virtual_buff + 14 ), 
 		*( u8 * )( p_virtual_buff + 15 ),  *( u8 * )( p_virtual_buff + 16 ),  *( u8 * )( p_virtual_buff + 17 ),  *( u8 * )( p_virtual_buff + 18 ),  *( u8 * )( p_virtual_buff + 19 ) );
 
-	//Command : ReqSecStart( 0x0204 )
-	sec_start = kmalloc( 2048, GFP_ATOMIC );
-	if( !sec_start ) {
-		dev_err( od->dev, "(%d) sec_start kmalloc fail.", __LINE__ );
-		goto err;
-	}
-	memset( sec_start, 0, 2048);
+// TODO Flashless Boot
 
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0204, 2048, ( void * )sec_start );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
+	// make data interrupt cmd for success
+	ipc_hsi_make_data_interrupt( od, int_cmd );
 
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_MAIN, &modem_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_MAIN Done.\n", __LINE__ );
+	return;
 
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_addr Done.\n", __LINE__ );
+err :
+	// make data interrupt cmd for fail
+	ipc_hsi_make_data_interrupt( od, int_cmd_fail );
+}
 
-/*
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_static_cal_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_static_cal_addr Done.\n", __LINE__ );
+#if 0
+extern void ( *onedram_cp_force_crash ) ( void );
+static void ipc_hsi_cp_force_crash( void )
+{
+	u32 int_cmd = 0;
+	
+	printk( "[ipc_hsi_cp_force_crash]\n" );
 
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_dynamic_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_dynamic_addr Done.\n", __LINE__ );
-*/
+	if( ipc_hsi ) {
+// Silent Reset
+#if 0
+		// make data interrupt cmd
+		int_cmd = MB_CMD( MBC_ERR_DISPLAY );
+		
+		ipc_hsi->reg->mailbox_BA = int_cmd;
 
-	//Command : ReqSecEnd( 0x0205 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0205, sizeof( unsigned short ), &sec_end );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd; ReqSecEnd Done.\n", __LINE__ );
+		if( transfer_thread_waiting ) {
+			//transfer_thread_waiting = 0;
+			up( &transfer_event_sem );
+		}
 
-	//Command : ReqForceHwReset( 0x0208 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0208, sizeof( unsigned int ), &force_hw_reset );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
+		printk( "Send CP Fatal command.\n" );
+#endif
 	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd; ReqForceHwReset Done.\n", __LINE__ );
-
-	kfree( sec_start );
-
-	ipc_spi_set_MRDY_pin( 0 );
+	else {
+		printk( "error ipc_hsi null.\n" );
+	}
+	
+}
+#endif
 
-	// make data interrupt cmd
-	ipc_spi_make_data_interrupt( int_cmd, od );
+void  ipc_hsi_restart_hsi( void )
+{
+	printk( "Phone Restart HSI Init.\n" );
 
-	return;
+	cp_restart = 1;
 
-err :
-	// make data interrupt cmd
-	ipc_spi_make_data_interrupt( int_cmd_fail, od );
+	ipc_hsi_clear_all_vbuff( ipc_hsi );
+	init_completion( &ril_init );
 }
+EXPORT_SYMBOL( ipc_hsi_restart_hsi );
 
-static int __devinit ipc_spi_platform_probe( struct platform_device *pdev )
+static int __devinit ipc_hsi_platform_probe( struct platform_device *pdev )
 {
 	int r;
-	int irq;
-	struct ipc_spi *od = NULL;
+	int irq_suspend_req;
+	struct ipc_hsi *od = NULL;
 	struct ipc_hsi_platform_data *pdata;
 	struct resource *res;
 
-	printk("[%s]\n",__func__);
+	printk( "[%s]\n",__func__ );
+	
 	pdata = pdev->dev.platform_data;
-	if (!pdata || !pdata->cfg_gpio) {
-		dev_err(&pdev->dev, "No platform data\n");
+	if( !pdata || !pdata->cfg_gpio ) {
+		dev_err( &pdev->dev, "No platform data\n" );
 		r = -EINVAL;
 		goto err;
 	}
 
-	gpio_ipc_host_wakeup= pdata->gpio_ipc_host_wakeup;
-	gpio_ipc_slave_wakeup= pdata->gpio_ipc_slave_wakeup;
 	gpio_suspend_request= pdata->gpio_suspend_request;
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_host_wakeup : %d\n", __LINE__, gpio_get_value(gpio_ipc_host_wakeup) );
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_slave_wakeup : %d\n", __LINE__, gpio_get_value(gpio_ipc_slave_wakeup) );
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_suspend_request : %d\n", __LINE__, gpio_get_value(gpio_suspend_request) );
+	dev_err( &pdev->dev, "(%d) gpio_ipc_suspend_request : %d\n", __LINE__, gpio_get_value( gpio_suspend_request ) );
 
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	res = platform_get_resource( pdev, IORESOURCE_IRQ, 0 ); // suspend request : cp fatal
 	if (!res) {
 		dev_err( &pdev->dev, "(%d) failed to get irq number\n", __LINE__ );
 		
 		r = -EINVAL;
 		goto err;
 	}
-	irq = res->start;
+	irq_suspend_req = res->start;
 
-	od = kzalloc( sizeof( struct ipc_spi ), GFP_KERNEL );
+	od = kzalloc( sizeof( struct ipc_hsi ), GFP_KERNEL );
 	if (!od) {
 		dev_err( &pdev->dev, "(%d) failed to allocate device\n", __LINE__ );
 		
 		r = -ENOMEM;
 		goto err;
 	}
-	ipc_spi = od;
+	ipc_hsi = od;
 	
-	dev_dbg( &pdev->dev, "(%d) IpcSpi dev: %p\n", __LINE__, od );
+	dev_dbg( &pdev->dev, "(%d) IpcHsi dev: %p\n", __LINE__, od );
 
 	od->base = 0;
 	od->size = 0x1000000; // 16M
@@ -2810,120 +2057,141 @@
 	/* init mailbox state before registering irq handler */
 	onedram_init_mailbox();
 
-	_init_data(od);
+	_init_data( od );
 
 	pdata->cfg_gpio();
 
-	r = request_irq( irq, ipc_spi_irq_handler, IRQF_TRIGGER_RISING, "IpcSpi", od );
-	if (r) {
-		dev_err( &pdev->dev, "(%d) Failed to allocate an interrupt: %d\n", __LINE__, irq );
-		
-		goto err;
-	}
-	od->irq = irq;
-
 	// Init work structure
-	ipc_spi_send_modem_work_data = kmalloc( sizeof( struct ipc_spi_send_modem_bin_workq_data ), GFP_ATOMIC );
-	if( !ipc_spi_send_modem_work_data ) {
+	ipc_hsi_send_modem_work_data = kmalloc( sizeof( struct ipc_hsi_send_modem_bin_workq_data ), GFP_ATOMIC );
+	if( !ipc_hsi_send_modem_work_data ) {
 		dev_err( &pdev->dev, "(%d) memory alloc fail\n", __LINE__ );
 
 		r = -ENOMEM;
 		goto err;
 	}
-	INIT_WORK( &ipc_spi_send_modem_work_data->send_modem_w, ipc_spi_send_modem_bin );
+	INIT_WORK( &ipc_hsi_send_modem_work_data->send_modem_w, ipc_hsi_send_modem_bin );
 
-	r = _register_chrdev(od);
-	if (r) {
+	r = _register_chrdev( od );
+	if( r ) {
 		dev_err( &pdev->dev, "(%d) Failed to register chrdev\n", __LINE__ );
-		
 		goto err;
 	}
 
-	r = sysfs_create_group(&od->dev->kobj, &ipc_spi_group);
-	if (r) {
+	r = sysfs_create_group( &od->dev->kobj, &ipc_hsi_group );
+	if( r ) {
 		dev_err( &pdev->dev, "(%d) Failed to create sysfs files\n", __LINE__ );
+		goto err;
+	}
+	od->group = &ipc_hsi_group;
+
+	platform_set_drvdata( pdev, od );
+
+	r = request_irq( irq_suspend_req, ipc_hsi_irq_suspend_req_handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, "CPSusReq", od );
+	if( r ) {
+		dev_err( &pdev->dev, "(%d) Failed to allocate an interrupt: %d\n", __LINE__, irq_suspend_req );
 		
 		goto err;
 	}
-	od->group = &ipc_spi_group;
+	od->irq_suspend_req = irq_suspend_req;
 
-	platform_set_drvdata(pdev, od);
+	r = kernel_thread( ipc_hsi_tx_thread, ( void * )od, 0 );
+	if( r < 0 ) {
+		dev_err( &pdev->dev, "kernel_thread() failed : %d\n", r );
+		
+		goto err;
+	}
 
-	r = kernel_thread( ipc_spi_thread, ( void * )od, 0 );
+	r = kernel_thread( ipc_hsi_rx_thread, ( void * )od, 0 );
 	if( r < 0 ) {
 		dev_err( &pdev->dev, "kernel_thread() failed : %d\n", r );
 		
 		goto err;
 	}
 
-	dev_info( &pdev->dev, "(%d) platform probe Done.\n", __LINE__ );
+//	onedram_cp_force_crash = ipc_hsi_cp_force_crash;
+
+	hsi_start_protocol();
+	dev_err( &pdev->dev, "(%d) hsi_start_protocol Done.\n", __LINE__ );
+
+	dev_err( &pdev->dev, "(%d) platform probe Done.\n", __LINE__ );
 
 	return 0;
 
 err:
-	_release(od);
+	_release( od );
+	
 	return r;
 }
 
-static int __devexit ipc_spi_platform_remove( struct platform_device *pdev )
+static int __devexit ipc_hsi_platform_remove( struct platform_device *pdev )
 {
-	struct ipc_spi *od = platform_get_drvdata( pdev );
+	struct ipc_hsi *od = platform_get_drvdata( pdev );
 
 	/* TODO: need onedram_resource clean? */
 	_unregister_all_handlers();
-	platform_set_drvdata(pdev, NULL);
-	ipc_spi = NULL;
-	_release(od);
+	platform_set_drvdata( pdev, NULL );
+	ipc_hsi = NULL;
+	_release( od );
 
 	// Free work queue data
-	kfree( ipc_spi_send_modem_work_data );
+	kfree( ipc_hsi_send_modem_work_data );
 
 	return 0;
 }
 
 #ifdef CONFIG_PM
-static int ipc_spi_platform_suspend( struct platform_device *pdev, pm_message_t state )
+static int ipc_hsi_platform_suspend( struct platform_device *pdev, pm_message_t state )
 {
 //	struct onedram *od = platform_get_drvdata(pdev);
 
 	return 0;
 }
 
-static int ipc_spi_platform_resume( struct platform_device *pdev )
+static int ipc_hsi_platform_resume( struct platform_device *pdev )
 {
 //	struct onedram *od = platform_get_drvdata(pdev);
 
 	return 0;
 }
 #else
-#  define ipc_spi_platform_suspend NULL
-#  define ipc_spi_platform_resume NULL
+#  define ipc_hsi_platform_suspend NULL
+#  define ipc_hsi_platform_resume NULL
 #endif
 
-static struct platform_driver ipc_spi_platform_driver = {
-	.probe = ipc_spi_platform_probe,
-	.remove = __devexit_p( ipc_spi_platform_remove ),
-	.suspend = ipc_spi_platform_suspend,
-	.resume = ipc_spi_platform_resume,
+static struct platform_driver ipc_hsi_platform_driver = {
+	.probe = ipc_hsi_platform_probe,
+	.remove = __devexit_p( ipc_hsi_platform_remove ),
+	.suspend = ipc_hsi_platform_suspend,
+	.resume = ipc_hsi_platform_resume,
 	.driver = {
 		.name = DRVNAME,
 	},
 };
 
-static int __init ipc_spi_init( void )
+static int __init ipc_hsi_init( void )
 {
 	int retval = 0;
 	
 	printk("[%s]\n",__func__);
 
-	retval = platform_driver_register( &ipc_spi_platform_driver );
+	retval = platform_driver_register( &ipc_hsi_platform_driver );
 	if( retval < 0 ) {
 		printk( "[%s] platform_driver_register ERROR : %d\n", __func__, retval );
 
 		goto exit;
 	}
 
-	printk( "[%s](%d) init Done - 1011260100.\n", __func__, __LINE__ );
+	// creat work queue thread
+	ipc_hsi_wq = create_singlethread_workqueue( "ipc_hsi_wq" );
+	//ipc_hsi_wq = create_workqueue( "ipc_hsi_wq" );
+	if( !ipc_hsi_wq ) {
+		printk( "[%s] get workqueue thread fail\n", __func__ );
+
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	printk( "[%s](%d) init Done.\n", __func__, __LINE__ );
 
 	return 0;
 
@@ -2931,16 +2199,20 @@
 	return retval;
 }
 
-static void __exit ipc_spi_exit( void )
+static void __exit ipc_hsi_exit( void )
 {
 	printk( "[%s]\n", __func__ );
 	
-	platform_driver_unregister( &ipc_spi_platform_driver );
+	platform_driver_unregister( &ipc_hsi_platform_driver );
+
+	if( ipc_hsi_wq ) {
+		destroy_workqueue( ipc_hsi_wq );
+	}
 }
 
-module_init( ipc_spi_init );
-module_exit( ipc_spi_exit );
+module_init( ipc_hsi_init );
+module_exit( ipc_hsi_exit );
 
 MODULE_LICENSE( "GPL" );
 MODULE_AUTHOR( "Wonhee Seo <wonhee48.seo@samsung.com>" );
-MODULE_DESCRIPTION( "IpcSpi driver" );
+MODULE_DESCRIPTION( "IpcHsi driver" );
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/mipi_hsi/Kconfig Kernel/drivers/phone_svn/mipi_hsi/Kconfig
--- Kernel-org/drivers/phone_svn/mipi_hsi/Kconfig	2011-01-24 14:36:07.830272200 +0530
+++ Kernel/drivers/phone_svn/mipi_hsi/Kconfig	1970-01-01 05:30:00.000000000 +0530
@@ -1,18 +0,0 @@
-#
-# OneDRAM configuration
-#
-config DPRAM_BUILT_IN
-	tristate "onedram driver built-in"
-
-	---help---
-	  By default, n
-
-	  When in doubt, say N.
-
-config SVNET_WHITELIST
-	bool "svnet uses whitelist via onedram"
-	default n
-	---help---
-	  By default, n
-
-	  When in doubt, say N.
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/mipi_hsi/Makefile Kernel/drivers/phone_svn/mipi_hsi/Makefile
--- Kernel-org/drivers/phone_svn/mipi_hsi/Makefile	2011-01-24 14:36:07.830272200 +0530
+++ Kernel/drivers/phone_svn/mipi_hsi/Makefile	1970-01-01 05:30:00.000000000 +0530
@@ -1,2 +0,0 @@
-obj-$(CONFIG_PHONE_MIPI_HSI)	+= mipi_hsi.o
-
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/mipi_hsi/mipi_hsi.c Kernel/drivers/phone_svn/mipi_hsi/mipi_hsi.c
--- Kernel-org/drivers/phone_svn/mipi_hsi/mipi_hsi.c	2011-01-24 14:36:07.830272200 +0530
+++ Kernel/drivers/phone_svn/mipi_hsi/mipi_hsi.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,3019 +0,0 @@
-/**
- * Samsung Virtual Network driver using IpcSpi device
- *
- * Copyright (C) 2010 Samsung Electronics. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#define DEBUG
-
-//#define FORMAT_TX_DUMP
-//#define RAW_TX_DUMP
-//#define RFS_TX_DUMP
-//#define FORMAT_RX_DUMP
-//#define RAW_RX_DUMP
-//#define RFS_RX_DUMP
-//#define RFS_TX_RX_LENGTH_DUMP
-
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-
-#include <linux/mm.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/phone_svn/mipi_hsi.h>
-#include <linux/spinlock.h>
-#include <linux/ioport.h>
-#include <asm/io.h>
-#include <linux/wait.h>
-#include <linux/fs.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-
-#include <linux/vmalloc.h>
-#include <linux/spi/spi.h>
-#include <linux/gpio.h>
-#include <linux/delay.h>
-#include <linux/in.h>
-#include <linux/hsi_driver_if.h>
-
-
-// test
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/miscdevice.h>
-#include <linux/file.h>
-#include <linux/mm.h>
-#include <linux/ioctl.h>
-#include <linux/mm.h>
-// test
-
-
-
-
-#define DRVNAME "onedram"
-
-#define ONEDRAM_REG_OFFSET	0xFFF800
-#define ONEDRAM_REG_SIZE		0x800
-
-#define MB_VALID					0x0080
-#define MB_COMMAND				0x0040
-
-#define MB_CMD( x )					( MB_VALID | MB_COMMAND | x )
-#define MB_DATA( x )				( MB_VALID | x )
-
-#define MBD_SEND_FMT			0x0002
-#define MBD_SEND_RAW			0x0001
-#define MBD_SEND_RFS				0x0100
-#define MBD_REQ_ACK_FMT		0x0020
-#define MBD_REQ_ACK_RAW		0x0010
-#define MBD_REQ_ACK_RFS		0x0400
-#define MBD_RES_ACK_FMT		0x0008
-#define MBD_RES_ACK_RAW		0x0004
-#define MBD_RES_ACK_RFS			0x0200
-
-enum {
-	MBC_NONE = 0,
-	MBC_INIT_START,				// 0x0001
-	MBC_INIT_END,				// 0x0002
-	MBC_REQ_ACTIVE,			// 0x0003
-	MBC_RES_ACTIVE,			// 0x0004
-	MBC_TIME_SYNC,				// 0x0005
-	MBC_POWER_OFF,			// 0x0006
-	MBC_RESET,					// 0x0007
-	MBC_PHONE_START,			// 0x0008
-	MBC_ERR_DISPLAY,			// 0x0009
-	MBC_POWER_SAVE,			// 0x000A
-	MBC_NV_REBUILD,			// 0x000B
-	MBC_EMER_DOWN,			// 0x000C
-	MBC_REQ_SEM,				// 0x000D
-	MBC_RES_SEM,				// 0x000E
-	MBC_MAX						// 0x000F
-};
-#define MBC_MASK					0xFF
-
-#define MAX_BUF_SIZE				2044
-#define DEF_BUF_SIZE				MAX_BUF_SIZE
-
-static struct spi_device *p_ipc_spi = NULL;
-
-typedef struct spi_protocol_header_rec {
-	unsigned long current_data_size:12;
-	unsigned long more:1;
-	unsigned long rx_error:1;
-	unsigned long packet_id:2;
-	unsigned long reserved:2;
-	unsigned long next_data_size:10;
-	unsigned long RI:1;
-	unsigned long DCD:1;
-	unsigned long RTSCTS:1;
-	unsigned long DSRDTR:1;
-} spi_protocol_header;
-
-struct onedram_reg_mapped {
-	u32 sem;
-	u32 reserved1[7];
-	u32 mailbox_AB;  // CP write, AP read
-	u32 reserved2[7];
-	u32 mailbox_BA;  // AP write, CP read
-	u32 reserved3[23];
-	u32 check_AB;    // can't read
-	u32 reserved4[7];
-	u32 check_BA;    // 0: CP read, 1: CP don't read
-};
-
-struct ipc_spi_handler {
-	struct list_head list;
-	void *data;
-	void (*handler)(u32, void *);
-};
-
-struct ipc_spi_handler_head {
-	struct list_head list;
-	u32 len;
-	spinlock_t lock;
-};
-static struct ipc_spi_handler_head h_list;
-
-static struct resource ipc_spi_resource = {
-	.name = DRVNAME,
-	.start = 0,
-	.end = -1,
-	.flags = IORESOURCE_MEM,
-};
-
-struct ipc_spi {
-	struct class *class;
-	struct device *dev;
-	struct cdev cdev;
-	dev_t devid;
-
-	wait_queue_head_t waitq;
-	struct fasync_struct *async_queue;
-	u32 mailbox;
-
-	unsigned long base;
-	unsigned long size;
-	void __iomem *mmio;
-
-	int irq;
-
-	struct completion comp;
-	atomic_t ref_sem;
-	unsigned long flags;
-
-	const struct attribute_group *group;
-
-	struct onedram_reg_mapped *reg;
-};
-struct ipc_spi *ipc_spi;
-
-typedef struct ipc_spi_send_modem_bin_workq_data {
-	struct ipc_spi *od;
-	
-	struct work_struct send_modem_w;
-} ipc_spi_send_modem_bin_workq_data_t;
-struct ipc_spi_send_modem_bin_workq_data *ipc_spi_send_modem_work_data;
-
-static DEFINE_SPINLOCK( ipc_spi_lock );
-
-static unsigned long hw_tmp; /* for hardware */
-static inline int _read_sem(struct ipc_spi *od);
-static inline void _write_sem(struct ipc_spi *od, int v);
-
-struct completion ril_init;
-static unsigned gpio_ipc_host_wakeup;
-static unsigned gpio_ipc_slave_wakeup;
-static unsigned gpio_suspend_request;
-
-static unsigned gpio_mrdy;
-static unsigned gpio_srdy;
-
-struct semaphore srdy_sem;
-struct semaphore transfer_event_sem;
-static int transfer_thread_waiting = 0;
-static int loop_back_test = 0;
-
-volatile static void __iomem *p_virtual_buff = 0;
-
-static unsigned long recv_cnt;
-static unsigned long send_cnt;
-static ssize_t show_debug(struct device *d,
-		struct device_attribute *attr, char *buf)
-{
-	char *p = buf;
-	struct ipc_spi *od = dev_get_drvdata(d);
-
-	if (!od)
-		return 0;
-
-	p += sprintf(p, "Semaphore: %d (%d)\n", _read_sem(od), (char)hw_tmp);
-	p += sprintf(p, "Mailbox: %x\n", od->reg->mailbox_AB);
-	p += sprintf(p, "Reference count: %d\n", atomic_read(&od->ref_sem));
-	p += sprintf(p, "Mailbox send: %lu\n", send_cnt);
-	p += sprintf(p, "Mailbox recv: %lu\n", recv_cnt);
-
-	return p - buf;
-}
-
-static DEVICE_ATTR(debug, S_IRUGO, show_debug, NULL);
-
-static struct attribute *ipc_spi_attributes[] = {
-	&dev_attr_debug.attr,
-	NULL
-};
-
-static const struct attribute_group ipc_spi_group = {
-	.attrs = ipc_spi_attributes,
-};
-
-static inline void _write_sem( struct ipc_spi *od, int v )
-{
-	//od->reg->sem = v;
-	od->reg->sem = 1;
-	
-	hw_tmp = od->reg->sem; /* for hardware */
-}
-
-static inline int _read_sem( struct ipc_spi *od )
-{
-	od->reg->sem = 1;
-	
-	return od->reg->sem;
-}
-
-static inline int _send_cmd( struct ipc_spi *od, u32 cmd )
-{
-	u32 tmp_cmd;
-	
-	if (!od) {
-		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
-		return -EFAULT;
-	}
-
-	if (!od->reg) {
-		dev_err( od->dev, "(%d) Failed to send cmd, not initialized\n", __LINE__ );
-		
-		return -EFAULT;
-	}
-
-//	dev_dbg( od->dev, "(%d) send %x\n", __LINE__, cmd );
-
-	if( cmd & MB_VALID ) {
-		if( cmd & MB_COMMAND ) {
-			tmp_cmd = ( cmd & MBC_MASK ) & ~( MB_CMD( 0 ) );
-//			dev_dbg( od->dev, "(%d) command : %x\n", __LINE__, tmp_cmd );
-
-			switch( tmp_cmd ) {
-				case MBC_INIT_END : // 0x0002
-					dev_info( od->dev, "(%d) send ril init cmd : %x\n", __LINE__, cmd );
-					
-					send_cnt++;
-					od->reg->mailbox_BA = cmd;
-
-					if( transfer_thread_waiting ) {
-						transfer_thread_waiting = 0;
-						up( &transfer_event_sem );
-					}
-
-					complete_all( &ril_init );
-					
-					break;
-					
-				default :
-//					dev_dbg( od->dev, "(%d) ignore command ( 0x%x )\n", __LINE__, tmp_cmd );
-					
-					break;
-			}
-		}
-		else {
-			dev_dbg( od->dev, "(%d) =>send data ( 0x%x )\n", __LINE__, cmd );
-			
-			if( transfer_thread_waiting ) {
-				transfer_thread_waiting = 0;
-				up( &transfer_event_sem );
-			}
-		}
-	}
-	else {
-		if( cmd == 0x45674567 ) {
-			dev_dbg( od->dev, "(%d) modem image loaded.\n", __LINE__ );
-			dev_dbg( od->dev, "(%d) start to send modem binary to cp.\n", __LINE__ );
-
-			ipc_spi_send_modem_work_data->od = od;
-			schedule_work( &ipc_spi_send_modem_work_data->send_modem_w );
-		}
-		else {
-			dev_err( od->dev, "(%d) send invalid cmd : 0x%x\n", __LINE__, cmd );
-		}
-	}
-	
-	return 0;
-}
-
-static inline int _recv_cmd( struct ipc_spi *od, u32 *cmd )
-{
-	if (!cmd)
-		return -EINVAL;
-
-	if (!od) {
-		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
-		return -EFAULT;
-	}
-
-	if (!od->reg) {
-		dev_err( od->dev, "(%d) Failed to read cmd, not initialized\n", __LINE__ );
-		
-		return -EFAULT;
-	}
-
-	recv_cnt++;
-	*cmd = od->reg->mailbox_AB;
-	return 0;
-}
-
-static inline int _get_auth( struct ipc_spi *od, u32 cmd )
-{
-	unsigned long timeleft;
-	int retry = 0;
-
-	/* send cmd every 20m seconds */
-	while (1) {
-		_send_cmd(od, cmd);
-
-		timeleft = wait_for_completion_timeout(&od->comp, HZ/50);
-#if 0		
-		if (timeleft)
-			break;
-#endif
-		if (_read_sem(od))
-			break;
-
-		retry++;
-		if (retry > 50 ) { /* time out after 1 seconds */
-			dev_err( od->dev, "(%d) get authority time out\n", __LINE__ );
-			
-			return -ETIMEDOUT;
-		}
-	}
-
-	return 0;
-}
-
-static int get_auth( struct ipc_spi *od, u32 cmd )
-{
-	int r;
-
-	if (!od) {
-		printk(KERN_ERR "[%s]ipcspi: Dev is NULL, but try to access\n",__func__);
-		return -EFAULT;
-	}
-
-	if (!od->reg) {
-		dev_err( od->dev, "(%d) Failed to get authority\n", __LINE__ );
-		
-		return -EFAULT;
-	}
-
-	//atomic_inc( &od->ref_sem );
-
-	if (_read_sem(od))
-		return 0;
-
-	if (cmd)
-		r = _get_auth(od, cmd);
-	else
-		r = -EACCES;
-
-	//if( r < 0 )
-	//	atomic_dec( &od->ref_sem );
-
-	return r;
-}
-
-static int put_auth( struct ipc_spi *od, int release )
-{
-	if (!od) {
-		printk(KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__);
-		return -EFAULT;
-	}
-
-	if (!od->reg) {
-		dev_err( od->dev, "(%d) Failed to put authority\n", __LINE__ );
-		
-		return -EFAULT;
-	}
-
-	//if( release )
-	//	set_bit( 0, &od->flags );
-
-	//if( atomic_dec_and_test( &od->ref_sem ) && test_and_clear_bit( 0, &od->flags ) ) {
-		//INIT_COMPLETION( od->comp );
-		//_write_sem( od, 0 );
-		//dev_dbg( od->dev, "rel_sem: %d\n", _read_sem( od ) );
-	//}
-
-	return 0;
-}
-
-static int rel_sem( struct ipc_spi *od )
-{
-	if (!od) {
-		printk(KERN_ERR "[%s]onedram: Dev is NULL, but try to access\n",__func__);
-		return -EFAULT;
-	}
-
-	if (!od->reg) {
-		dev_err( od->dev, "(%d) Failed to put authority\n", __LINE__ );
-		
-		return -EFAULT;
-	}
-
-	//if( atomic_read( &od->ref_sem ) )
-	//	return -EBUSY;
-
-	//INIT_COMPLETION( od->comp );
-	//clear_bit( 0, &od->flags );
-	//_write_sem( od, 0 );
-	//dev_dbg( od->dev, "rel_sem: %d\n", _read_sem( od ) );
-	
-	return 0;
-}
-
-int onedram_read_mailbox(u32 *mb)
-{
-	return _recv_cmd( ipc_spi, mb );
-}
-EXPORT_SYMBOL(onedram_read_mailbox);
-
-int onedram_write_mailbox(u32 mb)
-{
-	return _send_cmd( ipc_spi, mb );
-}
-EXPORT_SYMBOL(onedram_write_mailbox);
-
-void onedram_init_mailbox(void)
-{
-	int r = 0;
-	/* flush mailbox before registering onedram irq */
-	r = ipc_spi->reg->mailbox_AB;
-
-	/* Set nINT_ONEDRAM_CP to low */
-	ipc_spi->reg->mailbox_BA=0x0;
-}
-EXPORT_SYMBOL(onedram_init_mailbox);
-
-int onedram_get_auth(u32 cmd)
-{
-	return get_auth( ipc_spi, cmd );
-}
-EXPORT_SYMBOL(onedram_get_auth);
-
-int onedram_put_auth(int release)
-{
-	return put_auth( ipc_spi, release );
-}
-EXPORT_SYMBOL(onedram_put_auth);
-
-int onedram_rel_sem(void)
-{
-	return rel_sem( ipc_spi );
-}
-EXPORT_SYMBOL(onedram_rel_sem);
-
-int onedram_read_sem(void)
-{
-	return _read_sem( ipc_spi );
-}
-EXPORT_SYMBOL(onedram_read_sem);
-
-void onedram_get_vbase(void** vbase)
-{
-	*vbase = (void*)ipc_spi->mmio;
-}
-EXPORT_SYMBOL(onedram_get_vbase);
-
-//static unsigned long long old_clock;
-//static u32 old_mailbox;
-
-static int ipc_spi_irq_log_flag = 0;
-static irqreturn_t ipc_spi_irq_handler( int irq, void *data ) // SRDY Rising EDGE ISR
-{
-
-	struct ipc_spi *od = ( struct ipc_spi * )data;
-	int srdy_pin = 0;
-
-	srdy_pin = gpio_get_value( gpio_srdy );
-	
-	if( ipc_spi_irq_log_flag )
-		dev_dbg( od->dev, "(%d) isr SRDY : %d\n", __LINE__, srdy_pin );
-
-	if( !srdy_pin ) {
-		dev_err( od->dev, "SRDY LOW.\n" );
-
-		return IRQ_HANDLED;
-	}
-
-	up( &srdy_sem ); // signal srdy event
-
-	if( transfer_thread_waiting ) {
-		transfer_thread_waiting = 0;
-
-		if( ipc_spi_irq_log_flag )
-			dev_dbg( od->dev, "(%d) signal transfer event.\n", __LINE__ );
-		
-		up( &transfer_event_sem ); // signal transfer event
-	}
-
-	return IRQ_HANDLED;
-}
-
-#if 0
-static void ipc_spi_vm_close(struct vm_area_struct *vma)
-{
-	struct ipc_spi *od = vma->vm_private_data;
-	unsigned long offset;
-	unsigned long size;
-
-	put_auth(od, 0);
-
-	offset = (vma->vm_pgoff << PAGE_SHIFT) - od->base;
-	size = vma->vm_end - vma->vm_start;
-	dev_dbg(od->dev, "Rel region: 0x%08lx 0x%08lx\n", offset, size);
-	onedram_release_region(offset, size);
-}
-#endif
-
-static int ipc_spi_vm_pagefault( struct vm_area_struct *vma, struct vm_fault *vmf )
-{
-	struct ipc_spi *od = vma->vm_private_data;
-	
-//	dev_dbg( od->dev, "(%d) ipc_spi_vm_pagefault.\n", __LINE__ );
-
-	vmf->page = vmalloc_to_page( od->mmio + ( vmf->pgoff << PAGE_SHIFT ) );
-	get_page( vmf->page );
-	
-//	dev_dbg( od->dev, "(%d) ipc_spi_vm_pagefault Done.\n", __LINE__ );
-	
-	return 0;
-}
-
-static struct vm_operations_struct ipc_spi_vm_ops = {
-	//.close = ipc_spi_vm_close,
-	.fault = ipc_spi_vm_pagefault,
-};
-
-static int ipc_spi_open(struct inode *inode, struct file *filp)
-{
-	struct cdev *cdev = inode->i_cdev;
-	struct ipc_spi *od = container_of(cdev, struct ipc_spi, cdev);
-
-	filp->private_data = od;
-	return 0;
-}
-
-static int ipc_spi_release(struct inode *inode, struct file *filp)
-{
-	filp->private_data = NULL;
-	return 0;
-}
-
-static unsigned int ipc_spi_poll(struct file *filp, poll_table *wait)
-{
-	struct ipc_spi *od;
-	u32 data;
-
-	od = filp->private_data;
-
-	poll_wait(filp, &od->waitq, wait);
-
-	spin_lock_irq( &ipc_spi_lock );
-	data = od->mailbox;
-	spin_unlock_irq( &ipc_spi_lock );
-
-	if (data)
-		return POLLIN | POLLRDNORM;
-
-	return 0;
-}
-
-static ssize_t ipc_spi_read(struct file *filp, char __user *buf,
-		size_t count, loff_t *ppos)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	u32 data;
-	ssize_t retval;
-	struct ipc_spi *od;
-
-	od = filp->private_data;
-
-	if (count < sizeof(u32))
-		return -EINVAL;
-
-	add_wait_queue(&od->waitq, &wait);
-
-	while (1) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		spin_lock_irq( &ipc_spi_lock );
-		data = od->mailbox;
-		od->mailbox = 0;
-		spin_unlock_irq( &ipc_spi_lock );
-
-		if (data)
-			break;
-		else if (filp->f_flags & O_NONBLOCK) {
-			retval = -EAGAIN;
-			goto out;
-		} else if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			goto out;
-		}
-		schedule();
-	}
-
-	retval = put_user(data, (u32 __user *)buf);
-	if (!retval)
-		retval = sizeof(u32);
-out:
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&od->waitq, &wait);
-
-	return retval;
-}
-
-static ssize_t ipc_spi_write(struct file *filp, const char __user *buf,
-		size_t count, loff_t *ppos)
-{
-	struct ipc_spi *od;
-
-	od = filp->private_data;
-
-	if (count) {
-		u32 data;
-
-		if (get_user(data, (u32 __user *)buf))
-			return -EFAULT;
-
-		_send_cmd(od, data);
-	}
-
-	return count;
-}
-
-static int ipc_spi_fasync(int fd, struct file *filp, int on)
-{
-	struct ipc_spi *od;
-
-	od = filp->private_data;
-
-	return fasync_helper(fd, filp, on, &od->async_queue);
-}
-
-static int ipc_spi_mmap( struct file *filp, struct vm_area_struct *vma )
-{
-	struct ipc_spi *od;
-	unsigned long size;
-	unsigned long offset;
-
-	od = filp->private_data;
-	if( !od || !vma )
-		return -EFAULT;
-
-	size = vma->vm_end - vma->vm_start;
-	offset = vma->vm_pgoff << PAGE_SHIFT;
-
-	dev_dbg( od->dev, "(%d) Req region: 0x%08lx 0x%08lx\n", __LINE__, offset, size );
-	
-	vma->vm_flags |= VM_RESERVED;
-	vma->vm_ops = &ipc_spi_vm_ops;
-	vma->vm_private_data = od;
-
-	dev_dbg( od->dev, "(%d) ipc_spi_mmap Done.\n", __LINE__ );
-	
-	return 0;
-
-#if 0
-	int r;
-	struct ipc_spi *od;
-	unsigned long size;
-	unsigned long pfn;
-	unsigned long offset;
-	struct resource *res;
-
-	od = filp->private_data;
-	if (!od || !vma)
-		return -EFAULT;
-
-	atomic_inc(&od->ref_sem);
-	if (!_read_sem(od)) {
-		atomic_dec(&od->ref_sem);
-		return -EPERM;
-	}
-
-	size = vma->vm_end - vma->vm_start;
-	offset = vma->vm_pgoff << PAGE_SHIFT;
-	if (size > od->size - PAGE_ALIGN(ONEDRAM_REG_SIZE) - offset)
-		return -EINVAL;
-
-	dev_dbg(od->dev, "Req region: 0x%08lx 0x%08lx\n", offset, size);
-	res = onedram_request_region(offset, size, "mmap");
-	if (!res)
-		return -EBUSY;
-
-	pfn = __phys_to_pfn(od->base + offset);
-	r = remap_pfn_range(vma, vma->vm_start, pfn,
-			size,
-			vma->vm_page_prot);
-	if (r)
-		return -EAGAIN;
-
-	vma->vm_ops = &ipc_spi_vm_ops;
-	vma->vm_private_data = od;
-	return 0;
-#endif
-}
-
-static int ipc_spi_ioctl(struct inode *inode, struct file *filp,
-		unsigned int cmd, unsigned long arg)
-{
-	struct cdev *cdev = inode->i_cdev;
-	struct ipc_spi *od = container_of( cdev, struct ipc_spi, cdev );
-	int r;
-
-	switch (cmd) {
-	case ONEDRAM_GET_AUTH:
-		r = get_auth(od, arg);
-		break;
-	case ONEDRAM_PUT_AUTH:
-		r = put_auth(od, 0);
-		break;
-	case ONEDRAM_REL_SEM:
-		r = rel_sem(od);
-		break;
-	default:
-		r = -ENOIOCTLCMD;
-		break;
-	}
-
-	return r;
-}
-
-static const struct file_operations ipc_spi_fops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.read = ipc_spi_read,
-	.write = ipc_spi_write,
-	.poll = ipc_spi_poll,
-	.fasync = ipc_spi_fasync,
-	.open = ipc_spi_open,
-	.release = ipc_spi_release,
-	.mmap = ipc_spi_mmap,
-	.ioctl = ipc_spi_ioctl,
-};
-
-static int _register_chrdev( struct ipc_spi *od )
-{
-	int r;
-	dev_t devid;
-
-	od->class = class_create(THIS_MODULE, DRVNAME);
-	if (IS_ERR(od->class)) {
-		r = PTR_ERR(od->class);
-		od->class = NULL;
-		return r;
-	}
-
-	r = alloc_chrdev_region(&devid, 0, 1, DRVNAME);
-	if (r)
-		return r;
-
-	cdev_init( &od->cdev, &ipc_spi_fops );
-
-	r = cdev_add(&od->cdev, devid, 1);
-	if (r) {
-		unregister_chrdev_region(devid, 1);
-		return r;
-	}
-	od->devid = devid;
-
-	printk("[mipi_hsi_probe]: (%d) - debug\n", __LINE__);	//remove
-	od->dev = device_create(od->class, NULL, od->devid, od, DRVNAME);
-	printk("[mipi_hsi_probe]: (%d) - debug\n", __LINE__);	//remove
-	if (IS_ERR(od->dev)) {
-		r = PTR_ERR(od->dev);
-		od->dev = NULL;
-		return r;
-	}
-	printk("[mipi_hsi_probe]: (%d) - debug\n", __LINE__);	//remove
-	dev_set_drvdata(od->dev, od);
-	printk("[mipi_hsi_probe]: (%d) - debug\n", __LINE__);	//remove
-
-	return 0;
-}
-
-static inline int _request_mem( struct ipc_spi *od, struct platform_device *pdev )
-{
-	od->mmio = ( void __iomem * )vmalloc( od->size );
-	if( !od->mmio ) {
-		dev_err( &pdev->dev, "(%d) Failed to vmalloc size : %lu\n", __LINE__, od->size );
-		
-		return -EBUSY;
-	}
-	else {
-		dev_dbg( &pdev->dev, "(%d) vmalloc Done. mmio : 0x%08x\n", __LINE__, ( u32 )od->mmio );
-	}
-
-	memset( ( void * )od->mmio, 0, od->size );
-
-	od->reg = (struct onedram_reg_mapped *)(
-			(char *)od->mmio + ONEDRAM_REG_OFFSET);
-	dev_dbg( &pdev->dev, "(%d) Onedram semaphore: %d\n", __LINE__, _read_sem( od ) );
-
-	od->reg->sem = 1;
-	dev_dbg( &pdev->dev, "(%d) force set sem to 1 : %d\n", __LINE__, od->reg->sem );
-
-	od->reg->mailbox_AB = 0x000000C8; // Only for Latona2
-	od->reg->mailbox_BA = 0;
-	dev_dbg( &pdev->dev, "(%d) force set mailbox to 0 : AB=0x%x, BA=0x%x\n", __LINE__, od->reg->mailbox_AB, od->reg->mailbox_BA );
-	
-	ipc_spi_resource.start = (resource_size_t)od->mmio;
-	ipc_spi_resource.end = (resource_size_t)od->mmio + od->size - 1;
-
-	p_virtual_buff = od->mmio;
-
-	return 0;
-}
-
-static void _release( struct ipc_spi *od )
-{
-	if (!od)
-		return;
-
-	if (od->irq)
-		free_irq(od->irq, od);
-
-	if (od->group)
-		sysfs_remove_group(&od->dev->kobj, od->group);
-
-	if (od->dev)
-		device_destroy(od->class, od->devid);
-
-	if (od->devid) {
-		cdev_del(&od->cdev);
-		unregister_chrdev_region(od->devid, 1);
-	}
-
-	if (od->mmio) {
-		od->reg = NULL;
-		
-		vfree( ( void * )od->mmio );
-		
-		ipc_spi_resource.start = 0;
-		ipc_spi_resource.end = -1;
-	}
-
-	if (od->class)
-		class_destroy(od->class);
-
-	kfree(od);
-}
-
-struct resource* onedram_request_region(resource_size_t start,
-		resource_size_t n, const char *name)
-{
-	struct resource *res;
-
-	start += ipc_spi_resource.start;
-	res = __request_region( &ipc_spi_resource, start, n, name, 0 );
-	if (!res)
-		return NULL;
-
-	return res;
-}
-EXPORT_SYMBOL(onedram_request_region);
-
-void onedram_release_region(resource_size_t start, resource_size_t n)
-{
-	start += ipc_spi_resource.start;
-	__release_region(&ipc_spi_resource, start, n);
-}
-EXPORT_SYMBOL(onedram_release_region);
-
-int onedram_register_handler(void (*handler)(u32, void *), void *data)
-{
-	unsigned long flags;
-	struct ipc_spi_handler *hd;
-
-	if (!handler)
-		return -EINVAL;
-
-	hd = kzalloc( sizeof( struct ipc_spi_handler ), GFP_KERNEL );
-	if (!hd)
-		return -ENOMEM;
-
-	hd->data = data;
-	hd->handler = handler;
-
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_add_tail(&hd->list, &h_list.list);
-	h_list.len++;
-	spin_unlock_irqrestore(&h_list.lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(onedram_register_handler);
-
-int onedram_unregister_handler(void (*handler)(u32, void *))
-{
-	unsigned long flags;
-	struct list_head *l, *tmp;
-
-	if (!handler)
-		return -EINVAL;
-
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_for_each_safe(l, tmp, &h_list.list) {
-		struct ipc_spi_handler *hd = list_entry (l, struct ipc_spi_handler, list );
-
-		if (hd->handler == handler) {
-			list_del(&hd->list);
-			h_list.len--;
-			kfree(hd);
-		}
-	}
-	spin_unlock_irqrestore(&h_list.lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(onedram_unregister_handler);
-
-static void _unregister_all_handlers(void)
-{
-	unsigned long flags;
-	struct list_head *l, *tmp;
-
-	spin_lock_irqsave(&h_list.lock, flags);
-	list_for_each_safe(l, tmp, &h_list.list) {
-		struct ipc_spi_handler *hd = list_entry( l, struct ipc_spi_handler, list );
-
-		list_del(&hd->list);
-		h_list.len--;
-		kfree(hd);
-	}
-	spin_unlock_irqrestore(&h_list.lock, flags);
-}
-
-static void _init_data( struct ipc_spi *od )
-{
-	init_completion(&od->comp);
-	atomic_set( &od->ref_sem, 0 );
-	INIT_LIST_HEAD(&h_list.list);
-	spin_lock_init(&h_list.lock);
-	h_list.len = 0;
-	init_waitqueue_head(&od->waitq);
-
-	init_completion( &ril_init );
-	sema_init( &srdy_sem, 0 );
-	sema_init( &transfer_event_sem, 0 );
-}
-
-#define FMT_OUT		0x0FE000
-#define FMT_IN			0x0FF000
-#define FMT_SZ			0x1000
-
-#define RAW_OUT		0x100000
-#define RAW_IN			0x200000
-#define RAW_SZ			0x100000
-
-#define RFS_OUT		0x300000
-#define RFS_IN			0x400000
-#define RFS_SZ			0x100000
-
-static u32 ipc_spi_get_send_vbuff_command( void )
-{
-	u32 cmd = 0;
-
-	memcpy( ( void * )&cmd, ( void * )( p_virtual_buff + ONEDRAM_REG_OFFSET + 64 ), sizeof( cmd ) ); // mailbox_BA
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
-	
-	return cmd;
-}
-
-static void ipc_spi_set_send_vbuff_command_clear( void )
-{
-	u32 cmd = 0;
-
-	memcpy( ( void * )( p_virtual_buff + ONEDRAM_REG_OFFSET + 64 ), ( void * )&cmd, sizeof( cmd ) ); // mailbox_BA
-//	dev_dbg( &p_ipc_spi->dev, "(%d) clear mailbox_BA cmd : 0x%x\n", __LINE__, cmd );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_format_tx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 16 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 20 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_format_rx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 16 + 8 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 20 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_raw_tx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 32 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 36 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_raw_rx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 32 + 8 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 36 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_rfs_tx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 48 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 52 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS tx_head : %d, tx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_get_pointer_of_vbuff_rfs_rx( u32 *head, u32 *tail )
-{
-	memcpy( ( void * )head, ( void * )( p_virtual_buff + 48 + 8 ), sizeof( *head ) );
-	memcpy( ( void * )tail, ( void * )( p_virtual_buff + 52 + 8 ), sizeof( *tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS rx_head : %d, rx_tail : %d\n", __LINE__, *head, *tail );
-}
-
-static inline void ipc_spi_update_tail_of_vbuff_format_tx( u32 u_tail )
-{
-	memcpy( ( void * )( p_virtual_buff + 20 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update FMT tx_tail : %d\n", __LINE__, u_tail );
-}
-
-static inline void ipc_spi_update_head_of_vbuff_format_rx( u32 u_head )
-{
-	memcpy( ( void * )( p_virtual_buff + 20 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update FMT rx_head : %d\n", __LINE__, u_head );
-}
-
-static inline void ipc_spi_update_tail_of_vbuff_raw_tx( u32 u_tail )
-{
-	memcpy( ( void * )( p_virtual_buff + 36 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RAW tx_tail : %d\n", __LINE__, u_tail );
-}
-
-static inline void ipc_spi_update_head_of_vbuff_raw_rx( u32 u_head )
-{
-	memcpy( ( void * )( p_virtual_buff + 36 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RAW rx_head : %d\n", __LINE__, u_head );
-}
-
-static inline void ipc_spi_update_tail_of_vbuff_rfs_tx( u32 u_tail )
-{
-	memcpy( ( void * )( p_virtual_buff + 52 ), ( void * )&u_tail, sizeof( u_tail ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RFS tx_tail : %d\n", __LINE__, u_tail );
-}
-
-static inline void ipc_spi_update_head_of_vbuff_rfs_rx( u32 u_head )
-{
-	memcpy( ( void * )( p_virtual_buff + 52 + 4 ), ( void * )&u_head, sizeof( u_head ) );
-//	dev_dbg( &p_ipc_spi->dev, "(%d) update RFS rx_head : %d\n", __LINE__, u_head );
-}
-
-static u32 ipc_spi_get_length_vbuff_format_tx( u32 *out_head, u32 *out_tail )
-{
-	u32 len = 0;
-
-	ipc_spi_get_pointer_of_vbuff_format_tx( out_head, out_tail );
-	
-	if( *out_head >= *out_tail ) {
-		len = *out_head - *out_tail;
-	}
-	else {
-		len = FMT_SZ - *out_tail + *out_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT tx_len : %d\n", __LINE__, len );
-
-	return len;
-}
-
-static u32 ipc_spi_get_length_vbuff_raw_tx( u32 *out_head, u32 *out_tail )
-{
-	u32 len = 0;
-
-	ipc_spi_get_pointer_of_vbuff_raw_tx( out_head, out_tail );
-
-	if( *out_head >= *out_tail ) {
-		len = *out_head - *out_tail;
-	}
-	else {
-		len = RAW_SZ - *out_tail + *out_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW tx_len : %d\n", __LINE__, len );
-
-	return len;
-}
-
-static u32 ipc_spi_get_length_vbuff_rfs_tx( u32 *out_head, u32 *out_tail )
-{
-	u32 len = 0;
-
-	ipc_spi_get_pointer_of_vbuff_rfs_tx( out_head, out_tail );
-
-	if( *out_head >= *out_tail ) {
-		len = *out_head - *out_tail;
-	}
-	else {
-		len = RFS_SZ - *out_tail + *out_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS tx_len : %d\n", __LINE__, len );
-
-	return len;
-}
-
-static u32 ipc_spi_get_space_vbuff_format_rx( u32 *in_head, u32 *in_tail )
-{
-	u32 space = 0;
-	
-	ipc_spi_get_pointer_of_vbuff_format_rx( in_head, in_tail );
-
-	//check the memory space remained
-	if( *in_tail <= *in_head ) {
-		space = FMT_SZ - *in_head + *in_tail;
-	}
-	else{
-		space = *in_tail - *in_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get FMT rx space : %d\n", __LINE__, space );
-
-	return space;
-}
-
-static u32 ipc_spi_get_space_vbuff_raw_rx( u32 *in_head, u32 *in_tail )
-{
-	u32 space = 0;
-	
-	ipc_spi_get_pointer_of_vbuff_raw_rx( in_head, in_tail );
-
-	//check the memory space remained
-	if( *in_tail <= *in_head ) {
-		space = RAW_SZ - *in_head + *in_tail;
-	}
-	else{
-		space = *in_tail - *in_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RAW rx space : %d\n", __LINE__, space );
-
-	return space;
-}
-
-static u32 ipc_spi_get_space_vbuff_rfs_rx( u32 *in_head, u32 *in_tail )
-{
-	u32 space = 0;
-	
-	ipc_spi_get_pointer_of_vbuff_rfs_rx( in_head, in_tail );
-
-	//check the memory space remained
-	if( *in_tail <= *in_head ) {
-		space = RFS_SZ - *in_head + *in_tail;
-	}
-	else{
-		space = *in_tail - *in_head;
-	}
-//	dev_dbg( &p_ipc_spi->dev, "(%d) get RFS rx space : %d\n", __LINE__, space );
-
-	return space;
-}
-
-static int ipc_spi_check_send_data( void )
-{
-	int retval = 0;
-	u32 out_head = 0;
-	u32 out_tail = 0;
-
-	if( ipc_spi_get_send_vbuff_command() ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist CMD data\n", __LINE__ );
-		retval = 1;
-	}
-
-	ipc_spi_get_pointer_of_vbuff_format_tx( &out_head, &out_tail );
-	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist FMT data\n", __LINE__ );
-		retval = 1;
-	}
-
-	ipc_spi_get_pointer_of_vbuff_raw_tx( &out_head, &out_tail );
-	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist RAW data\n", __LINE__ );
-		retval = 1;
-	}
-
-	ipc_spi_get_pointer_of_vbuff_rfs_tx( &out_head, &out_tail );
-	if( out_head != out_tail ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) exist RFS data\n", __LINE__ );
-		retval = 1;
-	}
-
-	if( loop_back_test ) {
-//		dev_dbg( &p_ipc_spi->dev, "(%d) LOOP checked.\n", __LINE__ );
-		retval = 1;
-	}
-
-	return retval;
-}
-
-static void ipc_spi_copy_from_vbuff_format_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
-{
-	if( ( offset_vbuff + copy_len ) <= FMT_SZ ) {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + FMT_OUT + offset_vbuff ), copy_len );
-	}
-	else {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + FMT_OUT + offset_vbuff ), FMT_SZ - offset_vbuff );
-		memcpy( ( void * )( p_des + ( FMT_SZ - offset_vbuff ) ), ( void * )( p_virtual_buff + FMT_OUT ), copy_len -( FMT_SZ - offset_vbuff ) );
-	}
-}
-
-static void ipc_spi_copy_from_vbuff_raw_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
-{
-	if( ( offset_vbuff + copy_len ) <= RAW_SZ ) {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RAW_OUT + offset_vbuff ), copy_len );
-	}
-	else {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RAW_OUT + offset_vbuff ), RAW_SZ - offset_vbuff );
-		memcpy( ( void * )( p_des + ( RAW_SZ - offset_vbuff ) ), ( void * )( p_virtual_buff + RAW_OUT ), copy_len -( RAW_SZ - offset_vbuff ) );
-	}
-}
-
-static void ipc_spi_copy_from_vbuff_rfs_tx( void *p_des, u32 offset_vbuff, u32 copy_len )
-{
-	if( ( offset_vbuff + copy_len ) <= RFS_SZ ) {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RFS_OUT + offset_vbuff ), copy_len );
-	}
-	else {
-		memcpy( ( void * )p_des, ( void * )( p_virtual_buff + RFS_OUT + offset_vbuff ), RFS_SZ - offset_vbuff );
-		memcpy( ( void * )( p_des + ( RFS_SZ - offset_vbuff ) ), ( void * )( p_virtual_buff + RFS_OUT ), copy_len -( RFS_SZ - offset_vbuff ) );
-	}
-}
-
-static void ipc_spi_prepare_tx_data( u8 *tx_b )
-{
-	u32 len = 0, tx_b_remail_len = DEF_BUF_SIZE, read_size = 0;
-	spi_protocol_header *tx_header = ( spi_protocol_header * )tx_b;
-	u32 cmd = 0;
-	u8 cmd_8 = 0;
-	u16 mux = 0;
-	u16 p_tx_b = sizeof( spi_protocol_header );
-	u32 p_send_data_h = 0, p_send_data_t = 0;
-	u16 pkt_fmt_len = 0;
-	u32 pkt_len = 0;
-	u8 bof = 0, eof = 0;
-	int i;
-
-	memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-	cmd = ipc_spi_get_send_vbuff_command(); // check mailbox command data
-	if( cmd ) {
-		cmd_8 = cmd & 0xFF;
-		dev_dbg( &p_ipc_spi->dev, "(%d) =>exist CMD cmd_8 : %x\n", __LINE__, cmd_8 );
-		
-		mux = 0x0004;
-		memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) ), ( void * )&mux, sizeof( mux ) );
-
-		memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) ), ( void * )&cmd_8, sizeof( cmd_8 ) );
-		ipc_spi_set_send_vbuff_command_clear();
-
-		tx_header->current_data_size = sizeof( mux ) + sizeof( cmd_8 );
-		tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-
-		if( ipc_spi_check_send_data() ) {
-			tx_header->more = 1;
-		}
-		else {
-			tx_header->more = 0;
-		}
-
-	}
-	else { // check format, raw, rfs data
-		len = ipc_spi_get_length_vbuff_format_tx( &p_send_data_h, &p_send_data_t ); // len : vbuff_format_tx length
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare FMT data\n", __LINE__ );
-			
-			mux = 0x0001;
-			read_size = 0;
-			
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) FMT bof : %x\n", __LINE__, bof );
-
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) FMT bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-
-				// packet length check
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )&pkt_fmt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_fmt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT packet len : %d\n", __LINE__, pkt_fmt_len );
-				
-				if( ( pkt_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) FMT wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_fmt_len );
-					
-					ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-				else if( ( pkt_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
-
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_format_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_fmt_len + sizeof ( bof ) + sizeof ( eof ) );
-
-#ifdef FORMAT_TX_DUMP
-				printk( "[IPC_SPI => FMT TX :" );
-				for( i = 0 ; i < ( pkt_fmt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // FORMAT_TX_DUMP
-
-				p_tx_b += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-
-				p_send_data_t %= FMT_SZ;
-				ipc_spi_update_tail_of_vbuff_format_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_fmt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) FMT tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>FMT len : %d\n", __LINE__, len );
-			}
-
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-		}
-
-		len = ipc_spi_get_length_vbuff_raw_tx( &p_send_data_h, &p_send_data_t );
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare RAW data\n", __LINE__ );
-			
-			mux = 0x0002;
-			read_size = 0;
-
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) RAW bof : %x\n", __LINE__, bof );
-
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RAW bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-
-				// packet length check
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )&pkt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW packet len : %d\n", __LINE__, pkt_len );
-				
-				if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) RAW wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_len );
-					
-					ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-				else if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
-
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_raw_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_len + sizeof ( bof ) + sizeof ( eof ) );
-
-#ifdef RAW_TX_DUMP
-				printk( "[IPC_SPI => RAW TX :" );
-				for( i = 0 ; i < ( pkt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // RAW_TX_DUMP
-
-				p_tx_b += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_len + sizeof ( bof ) + sizeof ( eof );
-
-				p_send_data_t %= RAW_SZ;
-				ipc_spi_update_tail_of_vbuff_raw_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RAW tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RAW len : %d\n", __LINE__, len );
-			}
-
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-		}
-
-		len = ipc_spi_get_length_vbuff_rfs_tx( &p_send_data_h, &p_send_data_t );
-		if( len ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) =>prepare RFS data\n", __LINE__ );
-			
-			mux = 0x0003;
-			read_size = 0;
-
-			while( len > read_size ) { // till len is zero
-				// bof : 0x7F check
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )&bof, p_send_data_t, sizeof( bof ) );
-//				dev_dbg( &p_ipc_spi->dev, "(%d) RFS bof : %x\n", __LINE__, bof );
-
-				if( bof != 0x7F ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RFS bof error, remove invalid data. bof : %x\n", __LINE__, bof );
-					
-					ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-
-				// packet length check
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )&pkt_len, p_send_data_t + sizeof ( bof ), sizeof( pkt_len ) );
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS packet len : %d\n", __LINE__, pkt_len );
-				
-				if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > DEF_BUF_SIZE ){
-					dev_err( &p_ipc_spi->dev, "(%d) RFS wrong packet len, remove invalid data. packet len : %x\n", __LINE__, pkt_len );
-					
-					ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_h ); // remove invalid data
-					memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-					return;
-				}
-				else if( ( pkt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux ) ) > tx_b_remail_len ) {
-					dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS tx more set\n", __LINE__ );
-					
-					tx_header->more = 1;
-					
-					break;
-				}
-
-				// make spi tx packet ( 1 packet : vbuff -> tx_b )
-				memcpy( ( void * )( tx_b + p_tx_b ), ( void * )&mux, sizeof( mux ) );
-				p_tx_b += sizeof( mux );
-				tx_b_remail_len -= sizeof( mux );
-				
-				ipc_spi_copy_from_vbuff_rfs_tx( ( void * )( tx_b + p_tx_b ), p_send_data_t, pkt_len + sizeof ( bof ) + sizeof ( eof ) );
-
-#ifdef RFS_TX_DUMP
-				printk( "[IPC_SPI => RFS TX :" );
-				for( i = 0 ; i < ( pkt_len + sizeof ( bof ) + sizeof ( eof ) ) ; i++ ) {
-					printk( " %02x", *( ( u8 * )( tx_b + p_tx_b + i ) ) );
-				}
-				printk( "]\n" );
-#endif // RFS_TX_DUMP
-
-				p_tx_b += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				p_send_data_t += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				tx_b_remail_len -= pkt_len + sizeof ( bof ) + sizeof ( eof );
-
-				p_send_data_t %= RFS_SZ;
-				ipc_spi_update_tail_of_vbuff_rfs_tx( p_send_data_t ); // in-pointer update
-				
-				read_size += pkt_len + sizeof ( bof ) + sizeof ( eof );
-				if( len < read_size ) {
-					dev_err( &p_ipc_spi->dev, "(%d) RFS tx read error len : %d, read_size : %d\n", __LINE__, len, read_size );
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) =>RFS len : %d\n", __LINE__, len );
-
-#ifdef RFS_TX_RX_LENGTH_DUMP
-				printk( "[IPC_SPI => RFS TX : %d]\n", pkt_len );
-#endif // RFS_TX_RX_LENGTH_DUMP
-
-			}
-
-			tx_header->current_data_size = DEF_BUF_SIZE - tx_b_remail_len;
-			tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-		}
-	}
-
-//	dev_dbg( &p_ipc_spi->dev, "(%d) tx_data are prepared. \n", __LINE__ );
-//	dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] TX :\n" );
-	dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] TX : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		tx_b[ 0 ], tx_b[ 1 ], tx_b[ 2 ], tx_b[ 3 ], tx_b[ 4 ], tx_b[ 5 ], tx_b[ 6 ], tx_b[ 7 ], tx_b[ 8 ], tx_b[ 9 ], tx_b[ 10 ], tx_b[ 11 ], tx_b[ 12 ], tx_b[ 13 ], tx_b[ 14 ], tx_b[ 15 ], tx_b[ 16 ], tx_b[ 17 ], tx_b[ 18 ], tx_b[ 19 ], 
-		tx_b[ 20 ], tx_b[ 21 ], tx_b[ 22 ], tx_b[ 23 ], tx_b[ 24 ], tx_b[ 25 ], tx_b[ 26 ], tx_b[ 27 ], tx_b[ 28 ], tx_b[ 29 ], tx_b[ 30 ], tx_b[ 31 ], tx_b[ 32 ], tx_b[ 33 ], tx_b[ 34 ], tx_b[ 35 ], tx_b[ 36 ], tx_b[ 37 ], tx_b[ 38 ], tx_b[ 39 ] );
-}
-
-static void ipc_spi_prepare_loopback_tx_data( u8 *tx_b, u8 *rx_b )
-{
-	spi_protocol_header *tx_header = ( spi_protocol_header * )tx_b;
-	u16 mux = 0;
-	u8 bof = 0x7F, eof = 0x7E;
-	u32 pkt_len = 16;
-	u8 test_data[ 10 ] = "0123456789";
-	u8 ch_id = 31, control_id = 0;
-
-	int i;
-	
-	memset( ( void * )tx_b, 0, DEF_BUF_SIZE + 4 );
-
-	mux = 0x0002;
-	
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) ), ( void * )&mux, sizeof( mux ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) ), ( void * )&bof, sizeof( bof ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) ), ( void * )&pkt_len, sizeof( pkt_len ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) ),
-		( void * )&ch_id, sizeof( ch_id ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) + sizeof( ch_id ) ),
-		( void * )&control_id, sizeof( control_id ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + sizeof( pkt_len ) 
-		+ sizeof( ch_id ) + sizeof( control_id ) ), ( void * )&test_data, sizeof( test_data ) );
-	memcpy( ( void * )( tx_b + sizeof( spi_protocol_header ) + sizeof( mux ) + sizeof( bof ) + pkt_len ), ( void * )&eof, sizeof( eof ) );
-
-	tx_header->current_data_size = sizeof( mux ) + sizeof( bof ) + pkt_len + sizeof( eof );
-	tx_header->next_data_size = DEF_BUF_SIZE >> 2;
-
-	printk( "[SPI DUMP] LOOP TX : " );
-	for( i = 0 ; i < 30 ; i++ ) {
-		printk( "%02x ", tx_b[ i ] );
-	}
-	printk( "\n" );
-}
-
-static void ipc_spi_set_MRDY_pin( int val )
-{
-//	dev_dbg( &p_ipc_spi->dev, "(%d) set MRDY %d\n", __LINE__, val );
-	
-	gpio_set_value( gpio_mrdy, val );
-}
-
-static int ipc_spi_tx_rx_sync( u8 *tx_d, u8 *rx_d, unsigned len )
-{
-	struct spi_transfer t;
-	struct spi_message msg;
-	
-	memset( &t, 0, sizeof t );
-	
-	t.len = len;
-
-	t.tx_buf = tx_d;
-	t.rx_buf = rx_d;
-
-	t.cs_change = 0;
-	t.bits_per_word = 32;
-	t.speed_hz = 24000000;
-
-	spi_message_init( &msg );
-	spi_message_add_tail( &t, &msg );
-
-	return spi_sync( p_ipc_spi, &msg );
-}
-
-static void ipc_spi_swap_data_htn( u8 *data, int len )
-{
-	int i;
-
-	for( i = 0 ; i < len ; i += 4 ) {
-		*( u32 * )( data + i ) = htonl( *( u32 * )( data + i ) );
-	}
-}
-
-static void ipc_spi_swap_data_nth( u8 *data, int len )
-{
-	int i;
-
-	for( i = 0 ; i < len ; i += 4 ) {
-		*( u32 * )( data + i ) = ntohl( *( u32 * )( data + i ) );
-	}
-}
-
-static int ipc_spi_copy_to_vbuff_format_rx( void *data, u16 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
-	u32 int_cmd = 0;
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to FMT vbuff, len : %d\n", __LINE__, len );
-
-COPY_TO_VBUFF_FMT_RETRY :
-	
-	space = ipc_spi_get_space_vbuff_format_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) FMT vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
-
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) FMT vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
-		}
-
-		msleep( 5 );
-		goto COPY_TO_VBUFF_FMT_RETRY;
-	}
-
-	if( head + len <= FMT_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, len );
-	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + FMT_IN + head ), data, FMT_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + FMT_IN ), ( void * )( data + ( FMT_SZ - head ) ), len - ( FMT_SZ - head ) );
-	}
-
-	new_head = ( head + len ) % FMT_SZ;
-	ipc_spi_update_head_of_vbuff_format_rx( new_head );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to FMT vbuff done.\n", __LINE__ );
-
-	return 0;
-}
-
-static int ipc_spi_copy_to_vbuff_raw_rx( void *data, u32 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RAW vbuff, len : %d\n", __LINE__, len );
-
-COPY_TO_VBUFF_RAW_RETRY :
-
-	space = ipc_spi_get_space_vbuff_raw_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) RAW vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
-
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) RAW vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
-		}
-
-		msleep( 5 );
-		goto COPY_TO_VBUFF_RAW_RETRY;
-	}
-
-	if( head + len <= RAW_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, len );
-	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + RAW_IN + head ), data, RAW_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + RAW_IN ), ( void * )( data + ( RAW_SZ - head ) ), len - ( RAW_SZ - head ) );
-	}
-
-	new_head = ( head + len ) % RAW_SZ;
-	ipc_spi_update_head_of_vbuff_raw_rx( new_head );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RAW vbuff done.\n", __LINE__ );
-
-	return 0;
-}
-
-static int ipc_spi_copy_to_vbuff_rfs_rx( void *data, u32 len )
-{
-	u32 head = 0, tail = 0, new_head = 0, space = 0;
-	int copy_retry_count = 0;
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RFS vbuff, len : %d\n", __LINE__, len );
-
-COPY_TO_VBUFF_RFS_RETRY :
-
-	space = ipc_spi_get_space_vbuff_rfs_rx( &head, &tail );
-	if( space < len ) {
-		dev_err( &p_ipc_spi->dev, "(%d) RFS vbuff is full, space : %d, len : %d\n", __LINE__, space, len );
-
-		copy_retry_count++;
-		if( copy_retry_count > 20 ) {
-			dev_err( &p_ipc_spi->dev, "(%d) RFS vbuff is full. copy fail.\n", __LINE__ );
-			
-			return -ENOMEM;
-		}
-
-		msleep( 5 );
-		goto COPY_TO_VBUFF_RFS_RETRY;
-	}
-
-	if( head + len <= RFS_SZ ) {
-		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, len );
-	}
-	else {
-		memcpy( ( void * )( p_virtual_buff + RFS_IN + head ), data, RFS_SZ - head );
-		memcpy( ( void * )( p_virtual_buff + RFS_IN ), ( void * )( data + ( RFS_SZ - head ) ), len - ( RFS_SZ - head ) );
-	}
-
-	new_head = ( head + len ) % RFS_SZ;
-	ipc_spi_update_head_of_vbuff_rfs_rx( new_head );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=copy data to RFS vbuff done.\n", __LINE__ );
-
-	return 0;
-}
-
-static void ipc_spi_make_data_interrupt( u32 cmd,  struct ipc_spi *od )
-{
-	struct list_head *l;
-	unsigned long flags;
-	u32 mailbox;
-
-	mailbox = cmd;
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=make data int : 0x%08x\n", __LINE__, mailbox );
-
-	if( h_list.len ) {
-		spin_lock_irqsave( &h_list.lock, flags );
-		list_for_each( l, &h_list.list ) {
-			struct ipc_spi_handler *h = list_entry( l, struct ipc_spi_handler, list );
-
-			if( h->handler ) h->handler( mailbox, h->data );
-		}
-		spin_unlock_irqrestore( &h_list.lock, flags );
-
-		spin_lock( &ipc_spi_lock );
-		od->mailbox = mailbox;
-		spin_unlock( &ipc_spi_lock );
-	} else {
-		od->mailbox = mailbox;
-	}
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) <=send data int cmd event\n", __LINE__ );
-	
-	wake_up_interruptible( &od->waitq );
-	kill_fasync( &od->async_queue, SIGIO, POLL_IN );
-}
-
-static int rx_prev_data_saved = 0;
-static u16 rx_prev_data_mux = 0;
-static u32 rx_prev_data_size = 0;
-static u32 rx_prev_data_remain = 0;
-
-static void ipc_spi_rx_process( u8 *rx_b,  u8 *rx_save_b, struct ipc_spi *od )
-{
-	int retval = 0;
-	spi_protocol_header *rx_header = ( spi_protocol_header * )rx_b;
-	u32 total_size = 0, read_size = 0;
-	u16 packet_fmt_len = 0;
-	u32 packet_len = 0;
-	u8 bof = 0, eof = 0;
-	u16 mux = 0;
-	u16 p_read = 4;
-	u32 int_cmd = 0;
-	int i;
-
-//	dev_dbg( &p_ipc_spi->dev, "(%d) rx process, more : %d, CTS : %d, current size : %d, next size : %d\n", __LINE__, rx_header->more, rx_header->RTSCTS, rx_header->current_data_size, rx_header->next_data_size );
-
-	total_size = rx_header->current_data_size;
-
-	while( total_size > read_size ) {
-		int_cmd = 0;
-
-		if( !rx_prev_data_saved ) {
-			// check bof : 0x7F
-			memcpy( ( void * )&bof, ( void * )( rx_b + p_read + sizeof( mux ) ), sizeof( bof ) );
-//			dev_dbg( &p_ipc_spi->dev, "(%d) rx process, bof : %x\n", __LINE__, bof );
-			if( bof != 0x7F ) {
-				dev_err( &p_ipc_spi->dev, "(%d) rx process, bof error : %x\n", __LINE__, bof );
-
-//				printk( "[IPC_SPI <= RX :" );
-//				for( i = 0 ; i < DEF_BUF_SIZE + 4 ; i++ ) {
-//					printk( " %02x", *( ( u8 * )( rx_b + i ) ) );
-//				}
-//				printk( "]\n" );
-				
-				break;
-			}
-		}
-
-		if( !rx_prev_data_saved ) {
-			// read mux
-			memcpy( ( void * )&mux, ( void * )( rx_b + p_read ), sizeof( mux ) );
-//			dev_dbg( &p_ipc_spi->dev, "(%d) rx process, mux : 0x%04x\n", __LINE__, mux );
-			if( mux > 0x4 || mux < 0x0) {
-				dev_err( &p_ipc_spi->dev, "(%d) rx process, mux error : %x\n", __LINE__, mux );
-				break;
-			}
-		}
-		else {
-			mux = rx_prev_data_mux;
-
-			dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, prev_mux : %d\n", __LINE__, mux );
-		}
-
-		switch( mux ) {
-			case 0x0001 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got FMT : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, FMT saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0001;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, FMT size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, FMT bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, FMT eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_format_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet FMT read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef FORMAT_RX_DUMP
-					printk( "[IPC_SPI <= FMT RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // FORMAT_RX_DUMP
-
-					rx_prev_data_saved = 0;
-				}
-				else {
-					// read packet len
-					memcpy( ( void * )&packet_fmt_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_fmt_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, FMT pkt len : %d\n", __LINE__, packet_fmt_len );
-//					if( packet_fmt_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, FMT pkt len error : %d\n", __LINE__, packet_fmt_len );
-//						return;
-//					}
-
-					if( ( packet_fmt_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, FMT packet_fmt_len : %d, remain : %d\n", __LINE__, packet_fmt_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0001;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_fmt_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, FMT size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_format_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_fmt_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-//						dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet FMT read Done.\n", __LINE__ );
-					}
-
-#ifdef FORMAT_RX_DUMP
-					printk( "[IPC_SPI <= FMT RX :" );
-					for( i = 0 ; i < ( packet_fmt_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
-#endif // FORMAT_RX_DUMP
-
-					p_read += packet_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_fmt_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, FMT read size : %d, \n", __LINE__, read_size );
-				}
-
-				// make data interrupt cmd
-				int_cmd = MB_DATA( MBD_SEND_FMT );
-				ipc_spi_make_data_interrupt( int_cmd, od );
-				break;
-
-			case 0x0002 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got RAW : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, RAW saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0002;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, RAW size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RAW bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RAW eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_raw_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet RAW read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef RAW_RX_DUMP
-					printk( "[IPC_SPI <= RAW RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RAW_RX_DUMP
-
-					rx_prev_data_saved = 0;
-				}
-				else {
-					// read packet len
-					memcpy( ( void * )&packet_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, RAW pkt len : %d\n", __LINE__, packet_len );
-//					if( packet_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, RAW pkt len error : %d\n", __LINE__, packet_len );
-//						return;
-//					}
-
-					if( ( packet_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, RAW packet_len : %d, remain : %d\n", __LINE__, packet_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0002;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, RAW size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_raw_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-//						dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet RAW read Done.\n", __LINE__ );
-					}
-
-#ifdef RAW_RX_DUMP
-					printk( "[IPC_SPI <= RAW RX :" );
-					for( i = 0 ; i < ( packet_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RAW_RX_DUMP
-
-					p_read += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, RAW read size : %d\n", __LINE__, read_size );
-				}
-
-				// make data interrupt cmd
-				int_cmd = MB_DATA( MBD_SEND_RAW );
-				ipc_spi_make_data_interrupt( int_cmd, od );
-				break;
-
-			case 0x0003 :
-//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, got RFS : %x\n", __LINE__, mux );
-
-				if( rx_prev_data_saved ) {
-					if( rx_prev_data_remain > DEF_BUF_SIZE ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data, RFS saved : %d, remain : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_mux = 0x0003;
-
-						memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), DEF_BUF_SIZE );
-						rx_prev_data_size += DEF_BUF_SIZE;
-						rx_prev_data_remain -= DEF_BUF_SIZE;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx 2nd prev data save, RFS size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-					
-					memcpy( ( void * )( rx_save_b + rx_prev_data_size ), ( void * )( rx_b + 4 ), rx_prev_data_remain );
-					p_read += rx_prev_data_remain;
-					read_size += rx_prev_data_remain;
-
-					if( *rx_save_b != 0x7F ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RFS bof error : %x\n", __LINE__, *rx_save_b );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					if( *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) != 0x7E ) {
-						dev_err( &p_ipc_spi->dev, "(%d) <=rx prev, RFS eof error : %x\n", __LINE__, *( u8 * )( rx_save_b + rx_prev_data_size + rx_prev_data_remain - 1 ) );
-
-						rx_prev_data_saved = 0;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_rfs_rx( ( void * )rx_save_b, rx_prev_data_size + rx_prev_data_remain );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx prev data, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-						dev_dbg( &p_ipc_spi->dev, "(%d) rx prev data, <= one packet RFS read Done. size : %d, total_size : %d, read_size : %d, p_read : %d\n", __LINE__, 
-							rx_prev_data_size + rx_prev_data_remain, total_size, read_size, p_read );
-					}
-
-#ifdef RFS_RX_DUMP
-					printk( "[IPC_SPI <= RFS RX :" );
-					for( i = 0 ; i < ( rx_prev_data_size + rx_prev_data_remain ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_save_b + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RFS_RX_DUMP
-
-#ifdef RFS_TX_RX_LENGTH_DUMP
-					printk( "[IPC_SPI <= RFS RX : %d]\n", rx_prev_data_size + rx_prev_data_remain );
-#endif // RFS_TX_RX_LENGTH_DUMP
-
-					rx_prev_data_saved = 0;
-				}
-				else {
-					// read packet len
-					memcpy( ( void * )&packet_len, ( void * )( rx_b + p_read + sizeof( mux ) + sizeof( bof ) ), sizeof( packet_len ) );
-					dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, RFS pkt len : %d\n", __LINE__, packet_len );
-//					if( packet_len > DEF_BUF_SIZE ) {
-//						dev_err( &p_ipc_spi->dev, "(%d) rx process, RFS pkt len error : %d\n", __LINE__, packet_len );
-//						return;
-//					}
-
-					if( ( packet_len + sizeof( mux ) + sizeof( bof ) + sizeof( eof ) ) > ( total_size - read_size ) ) {
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data, RFS packet_len : %d, remain : %d\n", __LINE__, packet_len, total_size - read_size );
-
-						rx_prev_data_mux = 0x0003;
-
-						memcpy( ( void * )rx_save_b, ( void * )( rx_b + p_read + sizeof( mux ) ), total_size - read_size - sizeof( mux ) );
-						rx_prev_data_size = total_size - read_size - sizeof( mux );
-						rx_prev_data_remain = packet_len + sizeof( bof ) + sizeof( eof ) - rx_prev_data_size;
-						dev_dbg( &p_ipc_spi->dev, "(%d) <=rx prev data save, RFS size : %d, remain size : %d\n", __LINE__, rx_prev_data_size, rx_prev_data_remain );
-
-						rx_prev_data_saved = 1;
-
-						return;
-					}
-
-					// copy to v_buff
-					retval = ipc_spi_copy_to_vbuff_rfs_rx( ( void * )( rx_b + p_read + sizeof( mux ) ), packet_len + sizeof( bof ) + sizeof( eof ) );
-					if( retval < 0 ) {
-						dev_err( &p_ipc_spi->dev, "(%d) rx process, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
-						return;
-					}
-					else {
-	//					dev_dbg( &p_ipc_spi->dev, "(%d) rx process, one packet RFS read Done.\n", __LINE__ );
-					}
-
-#ifdef RFS_RX_DUMP
-					printk( "[IPC_SPI <= RFS RX :" );
-					for( i = 0 ; i < ( packet_len + sizeof( bof ) + sizeof( eof ) ) ; i++ ) {
-						printk( " %02x", *( ( u8 * )( rx_b + p_read + sizeof( mux ) + i ) ) );
-					}
-					printk( "]\n" );
-#endif // RFS_RX_DUMP
-
-					p_read += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-					read_size += packet_len + sizeof( bof ) + sizeof( eof ) + sizeof( mux );
-	//				dev_dbg( &p_ipc_spi->dev, "(%d) rx process, RFS read size : %d\n", __LINE__, read_size );
-
-#ifdef RFS_TX_RX_LENGTH_DUMP
-					printk( "[IPC_SPI <= RFS RX : %d]\n", packet_len );
-#endif // RFS_TX_RX_LENGTH_DUMP
-
-				}
-
-				// make data interrupt cmd
-				int_cmd = MB_DATA( MBD_SEND_RFS );
-				ipc_spi_make_data_interrupt( int_cmd, od );
-				break;
-
-			case 0x0004 :
-				dev_dbg( &p_ipc_spi->dev, "(%d) <=rx process, got command : %x\n", __LINE__, mux );
-				break;
-
-			default :
-				break;
-		}
-
-		if( total_size < read_size ) {
-			dev_err( &p_ipc_spi->dev, "(%d) rx process, read error.\n", __LINE__ );
-		}
-
-//		dev_dbg( &p_ipc_spi->dev, "(%d) rx process, LOOP ==== total : %d, read : %d, p_read : %d\n", __LINE__, total_size, read_size, p_read );
-	}
-}
-
-static int ipc_spi_thread( void *data )
-{
-	struct ipc_spi *od = ( struct ipc_spi * )data;
-	
-	int retval = 0;
-	u8 *tx_buf = NULL;
-	spi_protocol_header *tx_header = NULL;
-	u8 *rx_buf = NULL;
-	spi_protocol_header *rx_header = NULL;
-	int skip_SRDY_chk = 0;
-	int clear_tx_buf = 0;
-	u8 *rx_save_buf = NULL;
-
-	daemonize( "ipc_spi_thread" );
-
-	printk( "[%s] ipc_spi_thread start.\n", __func__ );
-
-	wait_for_completion( &ril_init );
-	printk( "[%s] ril_init completed.\n", __func__ );
-
-	if( !p_ipc_spi ) {
-		printk( "[%s] p_ipc_spi is NULL.\n", __func__ );
-
-		retval = -ENODEV;
-		goto exit;
-	}
-
-	if( !p_virtual_buff ) {
-		dev_err( &p_ipc_spi->dev, "[%s] p_virtual_buff is NULL.\n", __func__);
-
-		retval = -ENODEV;
-		goto exit;
-	}
-
-	tx_buf = kmalloc( DEF_BUF_SIZE + 4, GFP_ATOMIC );
-	if( !tx_buf ) {
-		dev_err( &p_ipc_spi->dev, "[%s] tx_buf kmalloc fail.", __func__ );
-
-		retval = -ENOMEM;
-		goto exit;
-	}
-	tx_header = ( spi_protocol_header * )tx_buf;
-
-	rx_buf = kmalloc( DEF_BUF_SIZE + 4, GFP_ATOMIC );
-	if( !rx_buf  ) {
-		dev_err( &p_ipc_spi->dev, "[%s] rx_buf  kmalloc fail.", __func__ );
-
-		retval = -ENOMEM;
-		goto exit;
-	}
-	rx_header = ( spi_protocol_header * )rx_buf;
-
-	rx_save_buf = kmalloc( DEF_BUF_SIZE * 3, GFP_ATOMIC );
-	if( !rx_save_buf  ) {
-		dev_err( &p_ipc_spi->dev, "[%s] rx_save_buf  kmalloc fail.", __func__ );
-
-		retval = -ENOMEM;
-		goto exit;
-	}
-	memset( ( void * )rx_save_buf, 0, DEF_BUF_SIZE * 3 );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) wait 2 sec... srdy : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	msleep( 2000 );
-	
-	while( gpio_get_value( gpio_srdy ) );
-	dev_dbg( &p_ipc_spi->dev, "(%d) cp booting... Done.\n", __LINE__ );
-
-	dev_dbg( &p_ipc_spi->dev, "(%d) wait 1 sec...\n", __LINE__ );
-	msleep( 1000 );
-
-	printk( "[IPC_SPI] Start IPC Communication. MRDY : %d, SRDY : %d\n", gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
-	sema_init( &srdy_sem, 0 );
-
-	ipc_spi_irq_log_flag = 1;
-	
-	while( 1 ) {
-
-		if( !ipc_spi_check_send_data() ) { // no send data
-			if( down_trylock( &srdy_sem ) ) { // no srdy sem
-				dev_dbg( &p_ipc_spi->dev, "(%d) no data and no sem, wait tx-srdy event.\n", __LINE__ );
-				
-				transfer_thread_waiting = 1;
-
-				skip_SRDY_chk = 0;
-
-				down( &transfer_event_sem ); // wait event( tx or srdy )
-				dev_dbg( &p_ipc_spi->dev, "(%d) got tx-srdy event.\n", __LINE__ );
-			}
-			else {
-				dev_dbg( &p_ipc_spi->dev, "(%d) srdy_sem already exist\n", __LINE__ );
-
-				skip_SRDY_chk = 1;
-				clear_tx_buf = 1;
-			}
-		}
-		else {
-			dev_dbg( &p_ipc_spi->dev, "(%d) send data exist\n", __LINE__ );
-		}
-
-		// HERE : Got tx data event or Got SRDY isr event
-		if( gpio_get_value( gpio_mrdy ) ) {
-			dev_dbg( &p_ipc_spi->dev, "(%d) MRDY HIGH!!!\n", __LINE__ );
-			
-			ipc_spi_set_MRDY_pin( 0 );
-		}
-		ipc_spi_set_MRDY_pin( 1 ); // set MRDY High
-		
-		do {
-
-			if( clear_tx_buf ) {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) tx data clear.\n", __LINE__ );
-				
-				memset( ( void * )tx_buf, 0, DEF_BUF_SIZE + 4 );
-
-				clear_tx_buf = 0;
-			}
-			else {
-				ipc_spi_prepare_tx_data( tx_buf );
-			}
-
-			if( loop_back_test ) {
-				ipc_spi_prepare_loopback_tx_data( tx_buf, rx_buf );
-
-				loop_back_test = 0;
-			}
-
-			if( !skip_SRDY_chk ) {
-RETRY_WAIT_SEM :
-				
-				dev_dbg( &p_ipc_spi->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-				
-				//down( &srdy_sem ); // wait SRDY set High
-				if( down_timeout( &srdy_sem, 2 * HZ ) ) {
-					dev_err( &p_ipc_spi->dev, "(%d) SRDY TimeOUT!!! MRDY : %d, SRDY : %d\n", __LINE__, gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
-			
-					ipc_spi_set_MRDY_pin( 0 );
-					mdelay( 10 );
-					ipc_spi_set_MRDY_pin( 1 );
-
-					dev_err( &p_ipc_spi->dev, "(%d) SRDY TimeOUT Reset!!! MRDY : %d, SRDY : %d\n", __LINE__, gpio_get_value( gpio_mrdy ), gpio_get_value( gpio_srdy ) );
-
-					if( !gpio_get_value( gpio_srdy ) )
-						goto RETRY_WAIT_SEM;
-				}
-				dev_dbg( &p_ipc_spi->dev, "(%d) got SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-			}
-			else {
-				dev_dbg( &p_ipc_spi->dev, "(%d) skip wait SRDY.\n", __LINE__ );
-				
-				skip_SRDY_chk = 0;
-			}
-
-//			dev_dbg( &p_ipc_spi->dev, "(%d) clear rx buf.\n", __LINE__ );
-//			memset( ( void * )rx_buf, 0, DEF_BUF_SIZE + 4 );
-
-//			if( !gpio_get_value( gpio_srdy ) ) {
-//				dev_err( &p_ipc_spi->dev, "(%d) SRDY gpio is Low.\n", __LINE__ );
-//			}
-			
-			// tx, rx Transmit
-//			dev_dbg( &p_ipc_spi->dev, "(%d) transmit start.\n", __LINE__ );
-
-			ipc_spi_swap_data_htn( tx_buf, DEF_BUF_SIZE + 4 );    //host to network
-            
-
-			retval = ipc_spi_tx_rx_sync( tx_buf, rx_buf, DEF_BUF_SIZE + 4 );
-			if( retval != 0 ) {
-				dev_err( &p_ipc_spi->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
-			}
-			else {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) transmit Done.\n", __LINE__ );
-			}
-
-			ipc_spi_swap_data_nth( rx_buf, DEF_BUF_SIZE + 4 );    //network to host
-			*( u32 * )tx_header = ntohl( *( u32 * )tx_header );
-
-//			dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] RX :\n" );
-			dev_dbg( &p_ipc_spi->dev, "[SPI DUMP] RX : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-				rx_buf[ 0 ], rx_buf[ 1 ], rx_buf[ 2 ], rx_buf[ 3 ], rx_buf[ 4 ], rx_buf[ 5 ], rx_buf[ 6 ], rx_buf[ 7 ], rx_buf[ 8 ], rx_buf[ 9 ], rx_buf[ 10 ], rx_buf[ 11 ], rx_buf[ 12 ], rx_buf[ 13 ], rx_buf[ 14 ], rx_buf[ 15 ], rx_buf[ 16 ], rx_buf[ 17 ], rx_buf[ 18 ], rx_buf[ 19 ], 
-				rx_buf[ 20 ], rx_buf[ 21 ], rx_buf[ 22 ], rx_buf[ 23 ], rx_buf[ 24 ], rx_buf[ 25 ], rx_buf[ 26 ], rx_buf[ 27 ], rx_buf[ 28 ], rx_buf[ 29 ], rx_buf[ 30 ], rx_buf[ 31 ], rx_buf[ 32 ], rx_buf[ 33 ], rx_buf[ 34 ], rx_buf[ 35 ], rx_buf[ 36 ], rx_buf[ 37 ], rx_buf[ 38 ], rx_buf[ 39 ] );
-
-			if( *( u32 * )rx_header != 0x00000000 && *( u32 * )rx_header != 0xFFFFFFFF ) { // valid spi header
-//				dev_dbg( &p_ipc_spi->dev, "(%d) got valid rx data.\n", __LINE__ );
-				
-				// RX process
-				ipc_spi_rx_process( rx_buf, rx_save_buf, od );
-				
-				if( rx_header->RTSCTS ) { // modem is not available.
-					dev_err( &p_ipc_spi->dev, "(%d) rx CTS set.\n", __LINE__ );
-					
-					clear_tx_buf = 1;
-				}
-
-				//if( tx_header->RTSCTS ) { // master is not available.
-				//	dev_dbg( &p_ipc_spi->dev, "(%d) tx RTS set.\n", __LINE__ );
-				//}
-			}
-			else {
-//				dev_dbg( &p_ipc_spi->dev, "(%d) got invalid rx data.\n", __LINE__ );
-				
-				rx_header->RTSCTS = 0;
-				rx_header->more = 0;
-			}
-
-			dev_dbg( &p_ipc_spi->dev, "(%d) check more, CTS : %d, rx more : %d, tx more : %d\n", __LINE__, rx_header->RTSCTS, rx_header->more, tx_header->more );
-		}while( rx_header->RTSCTS || rx_header->more || tx_header->more );
-
-		ipc_spi_set_MRDY_pin( 0 ); // clear MRDY Low
-
-//		dev_dbg( &p_ipc_spi->dev, "(%d) LOOP Done ============================\n", __LINE__ );
-	}
-
-exit :
-	printk( "(%d) thread stop.\n", __LINE__ );
-
-	return retval;
-}
-
-struct ipc_spi_send_modem_bin_header {
-	u16 sot;
-	u16 type;
-	u16 length;
-};
-
-struct ipc_spi_send_modem_bin_footer {
-	u16 crc;
-	u16 eot;
-};
-
-
-static u16 ipc_spi_send_modem_bin_make_crc( u8 *buf )
-{
-	u16 crc = 0;
-	int i;
-	struct ipc_spi_send_modem_bin_header *header = ( struct ipc_spi_send_modem_bin_header * )( buf + 4 );
-
-	crc += header->type;
-	crc += header->length;
-
-	buf += 4;
-	buf += sizeof( struct ipc_spi_send_modem_bin_header );
-	for( i = 0 ; i < header->length ; i++ )
-		crc += *buf++;
-
-	return crc;
-}
-
-#define EBL_PACKET_SIZE	4096//4096//3088//2064
-static int ipc_spi_send_modem_bin_execute_cmd( struct ipc_spi *od, u16 type, u32 len, void *data )
-{
-	int retval = 0;
-	u8 *tx_b = NULL;
-	u8 *rx_b = NULL;
-	spi_protocol_header *tx_spi_header = NULL;
-	spi_protocol_header *rx_spi_header = NULL;
-	struct ipc_spi_send_modem_bin_header *tx_header = NULL;
-	struct ipc_spi_send_modem_bin_footer *tx_footer = NULL;
-	struct ipc_spi_send_modem_bin_header *rx_header = NULL;
-	struct ipc_spi_send_modem_bin_footer *rx_footer = NULL;
-
-	tx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
-	if( !tx_b ) {
-		dev_err( od->dev, "(%d) tx_b kmalloc fail.", __LINE__ );
-		return -ENOMEM;
-	}
-	tx_spi_header = ( spi_protocol_header * )tx_b;
-	tx_header = ( struct ipc_spi_send_modem_bin_header * )( tx_b + 4 );
-	memset( tx_b, 0, EBL_PACKET_SIZE);
-	
-	rx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
-	if( !rx_b ) {
-		dev_err( od->dev, "(%d) rx_b kmalloc fail.", __LINE__ );
-		return -ENOMEM;
-	}
-	rx_spi_header = ( spi_protocol_header * )rx_b;
-	rx_header = ( struct ipc_spi_send_modem_bin_header * )( rx_b + 4 );
-	memset( rx_b, 0, EBL_PACKET_SIZE);
-//	dev_dbg( od->dev, "(%d) tx_b, rx_b kmalloc Done.\n", __LINE__ );
-
-	ipc_spi_set_MRDY_pin( 1 );
-//	dev_dbg( od->dev, "(%d) set MRDY.\n", __LINE__ );
-
-	tx_spi_header->next_data_size = ( EBL_PACKET_SIZE - 4 ) >> 2;
-	tx_spi_header->current_data_size = sizeof( struct ipc_spi_send_modem_bin_header ) + len + sizeof( struct ipc_spi_send_modem_bin_footer );
-
-	tx_header->sot = 0x0002;
-	tx_header->type = type;
-	tx_header->length = len;
-
-//	dev_dbg( od->dev, "(%d) len : %d\n", __LINE__, len );
-	memcpy( ( void * )( tx_b + sizeof( struct ipc_spi_send_modem_bin_header ) + 4 ), data, len );
-
-	tx_footer = ( struct ipc_spi_send_modem_bin_footer * )( tx_b + 4 + sizeof( struct ipc_spi_send_modem_bin_header ) + len );
-
-	tx_footer->crc = ipc_spi_send_modem_bin_make_crc( tx_b );
-//	dev_dbg( od->dev, "(%d) tx crc : %d\n", __LINE__, tx_footer->crc );
-
-	tx_footer->eot = 0x0003;
-/*
-	dev_dbg( od->dev, "[SPI DUMP] tx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		tx_b[ 0 ], tx_b[ 1 ], tx_b[ 2 ], tx_b[ 3 ], tx_b[ 4 ], 
-		tx_b[ 5 ], tx_b[ 6 ], tx_b[ 7 ], tx_b[ 8 ], tx_b[ 9 ], 
-		tx_b[ 10 ], tx_b[ 11 ], tx_b[ 12 ], tx_b[ 13 ], tx_b[ 14 ], 
-		tx_b[ 15 ], tx_b[ 16 ], tx_b[ 17 ], tx_b[ 18 ], tx_b[ 19 ],
-		tx_b[ EBL_PACKET_SIZE - 10 ], tx_b[ EBL_PACKET_SIZE - 9 ], tx_b[ EBL_PACKET_SIZE - 8 ], tx_b[ EBL_PACKET_SIZE - 7 ], tx_b[ EBL_PACKET_SIZE - 6 ],
-		tx_b[ EBL_PACKET_SIZE - 5 ], tx_b[ EBL_PACKET_SIZE - 4 ], tx_b[ EBL_PACKET_SIZE - 3 ], tx_b[ EBL_PACKET_SIZE - 2 ], tx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-	ipc_spi_swap_data_htn( tx_b, EBL_PACKET_SIZE );
-	
-//	dev_dbg( od->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	down( &srdy_sem );
-
-	retval = ipc_spi_tx_rx_sync( tx_b, rx_b, EBL_PACKET_SIZE );
-	if( retval != 0 ) {
-		dev_err( od->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
-	}
-	else {
-//		dev_dbg( od->dev, "(%d) transmit Done.\n", __LINE__ );
-	}
-	
-	//ipc_spi_swap_data_nth( rx_b, EBL_PACKET_SIZE );
-/*
-	dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-		rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-		rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-		rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-		rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-		rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-
-	if( type == 0x0208 ) // ReqForceHwReset
-		return 0;
-
-	memset( tx_b, 0, EBL_PACKET_SIZE);
-	memset( rx_b, 0, EBL_PACKET_SIZE);
-	
-//	dev_dbg( od->dev, "(%d) wait SRDY : %d\n", __LINE__, gpio_get_value( gpio_srdy ) );
-	down( &srdy_sem );
-	
-	retval = ipc_spi_tx_rx_sync( tx_b, rx_b, EBL_PACKET_SIZE );
-	if( retval != 0 ) {
-		dev_err( od->dev, "(%d) spi sync error : %d\n", __LINE__, retval );
-	}
-	else {
-//		dev_dbg( od->dev, "(%d) transmit Done.\n", __LINE__ );
-	}
-	
-	ipc_spi_swap_data_nth( rx_b, EBL_PACKET_SIZE );
-/*
-	dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-		rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-		rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-		rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-		rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-		rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-*/
-	if( rx_header->type != type ) {
-		dev_err( od->dev, "(%d) execute cmd ack error : 0x%x(0x%x)\n", __LINE__, rx_header->type, type );
-
-		dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-			rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
-			rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
-			rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
-			rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
-			rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
-			rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
-		
-		retval = -1;
-	}
-	else {
-//		dev_dbg( od->dev, "(%d) execute cmd ack Done.\n", __LINE__ );
-	}
-
-	ipc_spi_set_MRDY_pin( 0 );
-	
-	return retval;
-}
-
-enum image_type {
-	MODEM_PSI,
-	MODEM_EBL,
-	MODEM_MAIN,
-	MODEM_NV,
-};
-
-struct image_buf {
-	unsigned int length;
-	unsigned char *buf;
-};
-
-#define PSI_OFFSET			0
-#define EBL_OFFSET		0x10000
-#define MAIN_OFFSET		0x28000
-#define NV_OFFSET			0xA00000
-
-#define PSI_LEN				( EBL_OFFSET - PSI_OFFSET - 1 ) // 0xF058
-#define EBL_LEN			( MAIN_OFFSET - EBL_OFFSET ) // 0x13F98
-#define MAIN_LEN			( NV_OFFSET - MAIN_OFFSET ) // 0x84B04D
-#define NV_LEN				( 2 * 1024 * 1024 )
-
-#define MAIN_OFFSET_VM	0
-#define NV_OFFSET_VM		0xD80000
-
-#define SPI_SEND_BLOCK_SIZE		4080//4080//3072//2048
-
-static int ipc_spi_send_modem_bin_xmit_img( struct ipc_spi *od, enum image_type type, unsigned int *address )
-{
-	int retval = 0;
-	struct image_buf img;
-	unsigned int data_size;
-	unsigned int send_size = 0;
-	unsigned int rest_size = 0;
-	unsigned char *ptr;
-	int i;
-
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img type : %d.\n", __LINE__, type );
-	switch( type ) {
-		case MODEM_MAIN:
-			img.buf = ( unsigned char * )( p_virtual_buff + MAIN_OFFSET_VM );
-			img.length = MAIN_LEN;
-			dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img save MAIN to img.\n", __LINE__ );
-				
-			break;
-			
-		case MODEM_NV:
-			img.buf = ( unsigned char * )( p_virtual_buff + NV_OFFSET_VM );
-			img.length = NV_LEN;
-			dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img save NV to img.\n", __LINE__ );
-			
-			break;
-			
-		default:
-			dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img wrong : %d.", __LINE__, type );
-			return -1;
-	}
-
-	//Command : ReqFlashSetAddress( 0x0802 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0802, sizeof( unsigned int ), address );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		return -1;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
-
-	dev_dbg( od->dev, "(%d) Start send img. size : %d\n", __LINE__, img.length );
-	ptr = img.buf;
-	data_size = SPI_SEND_BLOCK_SIZE;
-	rest_size = img.length;
-
-	for( i = 0 ; send_size < img.length ; i++ ) {
-		if( rest_size < SPI_SEND_BLOCK_SIZE )
-			data_size = rest_size;
-
-		//Command : ReqFlashWriteBlock( 0x0804 )
-		retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0804, data_size, ptr );
-		if( retval < 0 ) {
-			dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-			return -1;
-		}
-
-		send_size += data_size;
-		rest_size -= data_size;
-		ptr += data_size;
-
-		if( !( i % 100 ) )
-			dev_dbg( od->dev, "(%d) [%d] 0x%x size done, rest size: 0x%x\n", __LINE__, i, send_size, rest_size );
-	}
-
-	return retval;
-}
-
-static void ipc_spi_send_modem_bin( struct work_struct *send_modem_w )
-{
-	int retval = 0;
-	u32 int_cmd = 0xABCDABCD;
-	u32 int_cmd_fail = 0xDCBADCBA;
-	struct ipc_spi_send_modem_bin_workq_data *smw 
-		= container_of( send_modem_w, struct ipc_spi_send_modem_bin_workq_data, send_modem_w );
-	struct ipc_spi *od = smw->od;
-
-	unsigned int modem_addr = 0x60300000;//0x60300000;0x61580000;0x61600000
-	unsigned int nvm_static_fix_addr = 0x60e80000;//0x60e80000;0x61F80000;0x61E80000
-	unsigned int nvm_static_cal_addr = 0x60f00000;//0x60f00000;0x61F00000;0x61F00000
-	unsigned int nvm_dynamic_addr = 0x60f80000;//0x60f80000;0x61E80000;0x61F80000
-	unsigned int nvm_addr = 0x60C00000;//0x60b80000;//0x60C00000;
-	unsigned short sec_end = 0x0000;
-	unsigned int force_hw_reset = 0x00111001;
-	
-	u8 *sec_start = NULL;
-
-	dev_dbg( od->dev, "[SPI DUMP] mb : [%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		*( u8 * )( p_virtual_buff ), *( u8 * )( p_virtual_buff + 1 ), *( u8 * )( p_virtual_buff + 2 ), *( u8 * )( p_virtual_buff + 3 ), *( u8 * )( p_virtual_buff + 4 ), 
-		 *( u8 * )( p_virtual_buff + 5 ),  *( u8 * )( p_virtual_buff + 6 ),  *( u8 * )( p_virtual_buff + 7 ),  *( u8 * )( p_virtual_buff + 8 ),  *( u8 * )( p_virtual_buff + 9 ), 
-		*( u8 * )( p_virtual_buff + 10 ),  *( u8 * )( p_virtual_buff + 11 ),  *( u8 * )( p_virtual_buff + 12 ),  *( u8 * )( p_virtual_buff + 13 ),  *( u8 * )( p_virtual_buff + 14 ), 
-		*( u8 * )( p_virtual_buff + 15 ),  *( u8 * )( p_virtual_buff + 16 ),  *( u8 * )( p_virtual_buff + 17 ),  *( u8 * )( p_virtual_buff + 18 ),  *( u8 * )( p_virtual_buff + 19 ) );
-
-	//Command : ReqSecStart( 0x0204 )
-	sec_start = kmalloc( 2048, GFP_ATOMIC );
-	if( !sec_start ) {
-		dev_err( od->dev, "(%d) sec_start kmalloc fail.", __LINE__ );
-		goto err;
-	}
-	memset( sec_start, 0, 2048);
-
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0204, 2048, ( void * )sec_start );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
-
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_MAIN, &modem_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_MAIN Done.\n", __LINE__ );
-
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_addr Done.\n", __LINE__ );
-
-/*
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_static_cal_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_static_cal_addr Done.\n", __LINE__ );
-
-	retval = ipc_spi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_dynamic_addr );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_xmit_img MODEM_NV:nvm_dynamic_addr Done.\n", __LINE__ );
-*/
-
-	//Command : ReqSecEnd( 0x0205 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0205, sizeof( unsigned short ), &sec_end );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd; ReqSecEnd Done.\n", __LINE__ );
-
-	//Command : ReqForceHwReset( 0x0208 )
-	retval = ipc_spi_send_modem_bin_execute_cmd( od, 0x0208, sizeof( unsigned int ), &force_hw_reset );
-	if( retval < 0 ) {
-		dev_err( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
-		goto err;
-	}
-	dev_dbg( od->dev, "(%d) ipc_spi_send_modem_bin_execute_cmd; ReqForceHwReset Done.\n", __LINE__ );
-
-	kfree( sec_start );
-
-	ipc_spi_set_MRDY_pin( 0 );
-
-	// make data interrupt cmd
-	ipc_spi_make_data_interrupt( int_cmd, od );
-
-	return;
-
-err :
-	// make data interrupt cmd
-	ipc_spi_make_data_interrupt( int_cmd_fail, od );
-}
-
-static int __devinit ipc_spi_platform_probe( struct platform_device *pdev )
-{
-	int r;
-	int irq;
-	struct ipc_spi *od = NULL;
-	struct mipi_hsi_platform_data *pdata;
-	struct resource *res;
-
-	printk("[%s]\n",__func__);
-	pdata = pdev->dev.platform_data;
-	if (!pdata || !pdata->cfg_gpio) {
-		dev_err(&pdev->dev, "No platform data\n");
-		r = -EINVAL;
-		goto err;
-	}
-
-	gpio_ipc_host_wakeup= pdata->gpio_ipc_host_wakeup;
-	gpio_ipc_slave_wakeup= pdata->gpio_ipc_slave_wakeup;
-	gpio_suspend_request= pdata->gpio_suspend_request;
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_host_wakeup : %d\n", __LINE__, gpio_get_value(gpio_ipc_host_wakeup) );
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_slave_wakeup : %d\n", __LINE__, gpio_get_value(gpio_ipc_slave_wakeup) );
-	dev_dbg( &pdev->dev, "(%d) gpio_ipc_suspend_request : %d\n", __LINE__, gpio_get_value(gpio_suspend_request) );
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res) {
-		dev_err( &pdev->dev, "(%d) failed to get irq number\n", __LINE__ );
-		
-		r = -EINVAL;
-		goto err;
-	}
-	irq = res->start;
-
-	od = kzalloc( sizeof( struct ipc_spi ), GFP_KERNEL );
-	if (!od) {
-		dev_err( &pdev->dev, "(%d) failed to allocate device\n", __LINE__ );
-		
-		r = -ENOMEM;
-		goto err;
-	}
-	ipc_spi = od;
-	
-	dev_dbg( &pdev->dev, "(%d) IpcSpi dev: %p\n", __LINE__, od );
-
-	od->base = 0;
-	od->size = 0x1000000; // 16M
-	r = _request_mem(od, pdev);
-	if (r)
-		goto err;
-
-	/* init mailbox state before registering irq handler */
-	onedram_init_mailbox();
-
-	_init_data(od);
-
-	pdata->cfg_gpio();
-
-	r = request_irq( irq, ipc_spi_irq_handler, IRQF_TRIGGER_RISING, "IpcSpi", od );
-	if (r) {
-		dev_err( &pdev->dev, "(%d) Failed to allocate an interrupt: %d\n", __LINE__, irq );
-		
-		goto err;
-	}
-	od->irq = irq;
-
-	// Init work structure
-	ipc_spi_send_modem_work_data = kmalloc( sizeof( struct ipc_spi_send_modem_bin_workq_data ), GFP_ATOMIC );
-	if( !ipc_spi_send_modem_work_data ) {
-		dev_err( &pdev->dev, "(%d) memory alloc fail\n", __LINE__ );
-
-		r = -ENOMEM;
-		goto err;
-	}
-	INIT_WORK( &ipc_spi_send_modem_work_data->send_modem_w, ipc_spi_send_modem_bin );
-
-	r = _register_chrdev(od);
-	printk("[mipi_hsi_probe]: (%d) - debug\n", __LINE__);	//remove
-	if (r) {
-		dev_err( &pdev->dev, "(%d) Failed to register chrdev\n", __LINE__ );
-		
-		goto err;
-	}
-
-	r = sysfs_create_group(&od->dev->kobj, &ipc_spi_group);
-	if (r) {
-		dev_err( &pdev->dev, "(%d) Failed to create sysfs files\n", __LINE__ );
-		
-		goto err;
-	}
-	od->group = &ipc_spi_group;
-
-	platform_set_drvdata(pdev, od);
-
-
-	r = kernel_thread( ipc_spi_thread, ( void * )od, 0 );
-	if( r < 0 ) {
-		dev_err( &pdev->dev, "kernel_thread() failed : %d\n", r );
-		
-		goto err;
-	}
-
-	dev_info( &pdev->dev, "(%d) platform probe Done.\n", __LINE__ );
-
-	printk("[%s Done...]\n",__func__);
-
-	return 0;
-
-err:
-	_release(od);
-	return r;
-}
-
-static int __devexit ipc_spi_platform_remove( struct platform_device *pdev )
-{
-	struct ipc_spi *od = platform_get_drvdata( pdev );
-
-	/* TODO: need onedram_resource clean? */
-	_unregister_all_handlers();
-	platform_set_drvdata(pdev, NULL);
-	ipc_spi = NULL;
-	_release(od);
-
-	// Free work queue data
-	kfree( ipc_spi_send_modem_work_data );
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ipc_spi_platform_suspend( struct platform_device *pdev, pm_message_t state )
-{
-//	struct onedram *od = platform_get_drvdata(pdev);
-
-	return 0;
-}
-
-static int ipc_spi_platform_resume( struct platform_device *pdev )
-{
-//	struct onedram *od = platform_get_drvdata(pdev);
-
-	return 0;
-}
-#else
-#  define ipc_spi_platform_suspend NULL
-#  define ipc_spi_platform_resume NULL
-#endif
-
-/*
-static int ipc_spi_probe( struct spi_device *spi )
-{
-	int retval = 0;
-
-	p_ipc_spi = spi;
-	p_ipc_spi->mode = SPI_MODE_1;
-	p_ipc_spi->bits_per_word = 32;
-
-	retval = spi_setup( p_ipc_spi );
-	if( retval != 0 ) {
-		printk( "[%s] spi_setup ERROR : %d\n", __func__, retval );
-
-		return retval;
-	}
-
-	dev_info( &p_ipc_spi->dev, "(%d) spi probe Done.\n", __LINE__ );
-
-	return retval;
-}
-
-static int ipc_spi_remove( struct spi_device *spi )
-{
-	return 0;
-}
-*/
-
-static struct platform_driver ipc_spi_platform_driver = {
-	.probe = ipc_spi_platform_probe,
-	.remove = __devexit_p( ipc_spi_platform_remove ),
-	.suspend = ipc_spi_platform_suspend,
-	.resume = ipc_spi_platform_resume,
-	.driver = {
-		.name = DRVNAME,
-	},
-};
-
-/*
-static struct spi_driver ipc_spi_driver = {
-	.probe = ipc_spi_probe,
-	.remove = __devexit_p( ipc_spi_remove ),
-	.driver = {
-		.name = "ipc_spi",
-		.bus = &spi_bus_type,
-		.owner = THIS_MODULE,
-	},
-};
-*/
-
-static int __init ipc_spi_init( void )
-{
-	int retval = 0;
-	
-	printk("[%s]\n",__func__);
-
-	retval = platform_driver_register( &ipc_spi_platform_driver );
-	if( retval < 0 ) {
-		printk( "[%s] platform_driver_register ERROR : %d\n", __func__, retval );
-
-		goto exit;
-	}
-/*
-	retval = spi_register_driver( &ipc_spi_driver );
-	if( retval < 0 ) {
-		printk( "[%s] spi_register_driver ERROR : %d\n", __func__, retval );
-
-		goto exit;
-	}
-*/
-	printk( "[%s](%d) init Done - 1011260100.\n", __func__, __LINE__ );
-
-	return 0;
-
-exit :
-	return retval;
-}
-
-static void __exit ipc_spi_exit( void )
-{
-	printk( "[%s]\n", __func__ );
-	
-//	spi_unregister_driver( &ipc_spi_driver );
-	platform_driver_unregister( &ipc_spi_platform_driver );
-}
-
-module_init( ipc_spi_init );
-module_exit( ipc_spi_exit );
-
-MODULE_LICENSE( "GPL" );
-MODULE_AUTHOR( "Wonhee Seo <wonhee48.seo@samsung.com>" );
-MODULE_DESCRIPTION( "IpcSpi driver" );
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/modemctl/modemctl.c Kernel/drivers/phone_svn/modemctl/modemctl.c
--- Kernel-org/drivers/phone_svn/modemctl/modemctl.c	2011-01-24 14:36:07.830272200 +0530
+++ Kernel/drivers/phone_svn/modemctl/modemctl.c	2011-01-20 23:57:16.060273085 +0530
@@ -43,8 +43,6 @@
 #endif
 
 
-
-
 #define DRVNAME "modemctl"
 
 //#define SIM_DEBOUNCE_TIME_HZ	(HZ)
@@ -72,10 +70,7 @@
 	unsigned gpio_phone_active;
 	unsigned gpio_pda_active;
 	unsigned gpio_cp_reset;
-//	unsigned gpio_con_cp_sel;
 	unsigned gpio_reset_req_n;
-	unsigned gpio_active_state;
-//	unsigned gpio_suspend_request;
 
 //	unsigned gpio_flm_sel;
 //	unsigned gpio_con_cp_sel;
@@ -108,6 +103,9 @@
 };
 #endif
 
+static int check_phone_restart = 0;
+extern void ipc_hsi_restart_hsi( void );
+
 #ifdef CONFIG_HAS_WAKELOCK
 static inline void _wake_lock_init(struct modemctl *mc)
 {
@@ -192,8 +190,7 @@
 
 static void infinion_on(struct modemctl *mc)
 {
-//6260 on:
-	dev_dbg(mc->dev, "%s\n", __func__);
+	dev_err(mc->dev, "%s\n", __func__);
 	if (!mc->gpio_cp_reset || !mc->gpio_phone_on || !mc->gpio_reset_req_n){
 		printk( "[%s]: gpio_cp_reset = %d\n",__func__, gpio_get_value(mc->gpio_cp_reset) );
 		printk( "[%s]: gpio_phone_on = %d\n",__func__, gpio_get_value(mc->gpio_phone_on) );
@@ -202,66 +199,31 @@
 		return;
 	}
 	
-	gpio_set_value(mc->gpio_active_state, 1);
-	printk( "[%s]: gpio_active_state = %d\n",__func__, gpio_get_value(mc->gpio_active_state) );
 	gpio_set_value(mc->gpio_pda_active, 0);
-	printk( "[%s]: gpio_pda_active = %d\n",__func__, gpio_get_value(mc->gpio_pda_active) );
 	msleep(100);
 
 	gpio_set_value(mc->gpio_cp_reset, 1);
-	printk( "[%s]: gpio_cp_reset = %d\n",__func__, gpio_get_value(mc->gpio_cp_reset) );
 	udelay(160);
 	gpio_set_value(mc->gpio_reset_req_n, 1);
-	printk( "[%s]: gpio_reset_req_n = %d\n",__func__, gpio_get_value(mc->gpio_reset_req_n) );
 	msleep(100);
 
 	gpio_set_value(mc->gpio_phone_on, 1);
-	printk( "[%s]: gpio_phone_on = %d\n",__func__, gpio_get_value(mc->gpio_phone_on) );
-
-	gpio_set_value(mc->gpio_pda_active, 1);
-	printk( "[%s]: gpio_pda_active = %d\n",__func__, gpio_get_value(mc->gpio_pda_active) );
-	
-
-
-#if 0 //6160
-	dev_dbg(mc->dev, "%s\n", __func__);
-	if(!mc->gpio_cp_reset )
-		return;
 	gpio_set_value(mc->gpio_pda_active, 1);
-	msleep(100);
-	gpio_set_value(mc->gpio_cp_reset, 1);
-	msleep(300);
-
-//	if(!mc->gpio_sim_ndetect)
-//		return;
-#endif
 }
 
 static void infinion_off(struct modemctl *mc)
 {
-	dev_dbg(mc->dev, "%s\n", __func__);
+	dev_err(mc->dev, "%s\n", __func__);
 	if (!mc->gpio_cp_reset || !mc->gpio_phone_on)
 		return;
 
 	gpio_set_value(mc->gpio_phone_on, 0);
-	printk( "[%s]: gpio_phone_on = %d\n",__func__, gpio_get_value(mc->gpio_phone_on) );
-	gpio_set_value(mc->gpio_cp_reset, 0);
-	printk( "[%s]: gpio_cp_reset = %d\n",__func__, gpio_get_value(mc->gpio_cp_reset) );
-
-#if 0
-	dev_dbg(mc->dev, "%s\n", __func__);
-	if(!mc->gpio_cp_reset )
-		return;
-
 	gpio_set_value(mc->gpio_cp_reset, 0);
-#endif
 }
 
 static void infinion_reset(struct modemctl *mc)
 {
-
-//6260 on:
-	dev_dbg(mc->dev, "%s\n", __func__);
+	dev_err(mc->dev, "%s\n", __func__);
 	if (!mc->gpio_cp_reset || !mc->gpio_reset_req_n)
 		return;
 
@@ -273,57 +235,49 @@
 	gpio_set_value(mc->gpio_cp_reset, 1);
 	udelay(160);
 	gpio_set_value(mc->gpio_reset_req_n, 1);
-
-#if 0	//6160
-	dev_dbg(mc->dev, "%s\n", __func__);
-	if(!mc->gpio_cp_reset )
-		return;
-
-
-	/* To Do :
-	 * hard_reset(RESET_PMU_N) and soft_reset(RESET_REQ_N)
-	 * should be divided later.
-	 * soft_reset is used for CORE_DUMP
-	 */
-	gpio_set_value(mc->gpio_cp_reset, 0);
-	msleep(500);
-	gpio_set_value(mc->gpio_cp_reset, 1);
-	msleep(300);
-#endif
 }
 
 static void infinion_boot_on(struct modemctl *mc)
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 
-//	if(mc->gpio_flm_sel)
-//		gpio_set_value(mc->gpio_flm_sel, 0);
-//6260 on:
-//	if(mc->gpio_con_cp_sel)
-//		gpio_set_value(mc->gpio_con_cp_sel, 0);
+#if 0
+	if(mc->gpio_flm_sel)
+		gpio_set_value(mc->gpio_flm_sel, 0);
+
+	if(mc->gpio_con_cp_sel)
+		gpio_set_value(mc->gpio_con_cp_sel, 0);
+#endif
 }
 
 static void infinion_boot_off(struct modemctl *mc)
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 
-//	if(mc->gpio_flm_sel)
-//		gpio_set_value(mc->gpio_flm_sel, 1);
-
-//6260 on:
+#if 0
+	if(mc->gpio_flm_sel)
+		gpio_set_value(mc->gpio_flm_sel, 1);
 
-//	if(mc->gpio_con_cp_sel)
-//		gpio_set_value(mc->gpio_con_cp_sel, 1);
+	if(mc->gpio_con_cp_sel)
+		gpio_set_value(mc->gpio_con_cp_sel, 1);
+#endif
 }
 
 static int modem_on(struct modemctl *mc)
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 	if(!mc->ops || !mc->ops->modem_on) {
-		// 
 		return -ENXIO;
 	}
 
+	if( check_phone_restart ) {
+		dev_dbg( mc->dev, "%s: Phone Restart SPI Init.\n", __func__ );
+		ipc_hsi_restart_hsi();
+	}
+	else {
+		check_phone_restart = 1;
+	}
+
 	mc->ops->modem_on(mc);
 
 	return 0;
@@ -333,7 +287,6 @@
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 	if(!mc->ops || !mc->ops->modem_off) {
-		// 
 		return -ENXIO;
 	}
 
@@ -346,7 +299,6 @@
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 	if(!mc->ops || !mc->ops->modem_reset) {
-		// 
 		return -ENXIO;
 	}
 
@@ -359,7 +311,6 @@
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 	if(!mc->ops || !mc->ops->modem_boot_on) {
-		// 
 		return -ENXIO;
 	}
 
@@ -372,7 +323,6 @@
 {
 	dev_dbg(mc->dev, "%s\n", __func__);
 	if(!mc->ops || !mc->ops->modem_boot_off) {
-		// 
 		return -ENXIO;
 	}
 
@@ -409,22 +359,18 @@
 
 static int modem_get_active(struct modemctl *mc)
 {
-	dev_dbg(mc->dev, "%s\n", __func__);
+	dev_err(mc->dev, "%s\n", __func__);
 	if(!mc->gpio_phone_active || !mc->gpio_cp_reset)
 		return -ENXIO;
 
-	dev_dbg(mc->dev, "cp %d phone %d\n",
+	dev_err(mc->dev, "cp %d phone %d\n",
 			gpio_get_value(mc->gpio_cp_reset),
 			gpio_get_value(mc->gpio_phone_active));
 
- 	printk(mc->dev, "[mipi_hsi_test]: cp %d phone %d\n", gpio_get_value(mc->gpio_cp_reset), gpio_get_value(mc->gpio_phone_active));
-
-	//if(gpio_get_value(mc->gpio_cp_reset))
-		//return !!gpio_get_value(mc->gpio_phone_active);
-
-	return gpio_get_value( mc->gpio_phone_active );
+	if(gpio_get_value(mc->gpio_cp_reset))
+		return !!gpio_get_value(mc->gpio_phone_active);
 
-	//return 0;
+	return 0;
 }
 
 static ssize_t show_control(struct device *d,
@@ -519,22 +465,15 @@
 
 	p += sprintf(p, "GPIO ---- \n");
 
-//	if(mc->gpio_phone_on)
-//		p += sprintf(p, "\t%3d %d : phone on\n", mc->gpio_phone_on,
-//				gpio_get_value(mc->gpio_phone_on));
-	if(mc->gpio_reset_req_n)
-		p += sprintf(p, "\t%3d %d : reset_req_n\n", mc->gpio_reset_req_n,
-				gpio_get_value(mc->gpio_reset_req_n));
 	if(mc->gpio_phone_on)
 		p += sprintf(p, "\t%3d %d : phone on\n", mc->gpio_phone_on,
 				gpio_get_value(mc->gpio_phone_on));
+	if(mc->gpio_reset_req_n)
+		p += sprintf(p, "\t%3d %d : reset_req_n\n", mc->gpio_reset_req_n,
+				gpio_get_value(mc->gpio_reset_req_n));
 	if(mc->gpio_cp_reset)
 		p += sprintf(p, "\t%3d %d : CP reset\n", mc->gpio_cp_reset,
 				gpio_get_value(mc->gpio_cp_reset));
-
-//	if(mc->gpio_suspend_request)
-//		p += sprintf(p, "\t%3d %d : suspend_request\n", mc->gpio_suspend_request,
-//				gpio_get_value(mc->gpio_suspend_request));
 	if(mc->gpio_pda_active)
 		p += sprintf(p, "\t%3d %d : pda active\n", mc->gpio_pda_active,
 				gpio_get_value(mc->gpio_pda_active));
@@ -579,9 +518,7 @@
 		return;
 	}
 
-	dev_info(mc->dev, "PHONE ACTIVE: %d\n", r);
-	printk(mc->dev, "PHONE ACTIVE: %d\n", r);
-
+	dev_err(mc->dev, "PHONE ACTIVE: %d\n", r);
 
 	if (r) {
 //		if (mc->sim_change_reset == SIM_LEVEL_CHANGED) {
@@ -596,7 +533,7 @@
 		kobject_uevent(&mc->dev->kobj, KOBJ_ONLINE);
 	}
 	else
-		kobject_uevent(&mc->dev->kobj, KOBJ_OFFLINE);
+		;//kobject_uevent(&mc->dev->kobj, KOBJ_OFFLINE);
 }
 
 static irqreturn_t modemctl_irq_handler(int irq, void *dev_id)
@@ -724,7 +661,6 @@
 
 static int __devinit modemctl_probe(struct platform_device *pdev)
 {
-
 	struct modemctl *mc = NULL;
 	struct modemctl_platform_data *pdata;
 	struct resource *res;
@@ -734,7 +670,6 @@
 	printk("[%s]\n",__func__);
 
 	pdata = pdev->dev.platform_data;
-
 	if(!pdata || !pdata->cfg_gpio) {
 		dev_err(&pdev->dev, "No platform data\n");
 		r = -EINVAL;
@@ -743,23 +678,23 @@
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if(!res)  {
-		dev_err(&pdev->dev, " ( %d ) failed to get irq number\n", __LINE__ );
+		dev_err(&pdev->dev, "failed to get irq number\n");
 		r = -EINVAL;
 		goto err;
 	}
 	irq_phone_active = res->start;
-/*	
+	
+#if 0
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
 	if(!res)  {
-		dev_err(&pdev->dev, " ( %d ) failed to get irq number\n", __LINE__ );
+		dev_err(&pdev->dev, "failed to get irq number\n");
 		r = -EINVAL;
 		goto err;
 	}
-//	irq_sim_ndetect = res->start;
-*/
+	irq_sim_ndetect = res->start;
+#endif
 
 	mc = kzalloc(sizeof(struct modemctl), GFP_KERNEL);
-
 	if(!mc) {
 		dev_err(&pdev->dev, "failed to allocate device\n");
 		r = -ENOMEM;
@@ -769,14 +704,12 @@
 	mc->gpio_reset_req_n = pdata->gpio_reset_req_n;
 	mc->gpio_phone_on = pdata->gpio_phone_on;
 	mc->gpio_cp_reset = pdata->gpio_cp_reset;
-//	mc->gpio_suspend_request = pdata->gpio_suspend_request;
 	mc->gpio_pda_active = pdata->gpio_pda_active;
 	mc->gpio_phone_active = pdata->gpio_phone_active;
 
 	dev_dbg( &pdev->dev, "reset_req_n : %d\n", mc->gpio_reset_req_n );
 	dev_dbg( &pdev->dev, "phone on : %d\n", mc->gpio_phone_on );
 	dev_dbg( &pdev->dev, "cp_rst : %d\n", mc->gpio_cp_reset );
-//	dev_dbg( &pdev->dev, "suspend_request : %d\n", mc->gpio_suspend_request );
 	dev_dbg( &pdev->dev, "pda_active : %d\n", mc->gpio_pda_active );
 	dev_dbg( &pdev->dev, "phone_active : %d\n", mc->gpio_phone_active );
 	
@@ -789,10 +722,8 @@
 		dev_err(&pdev->dev, "can't find operations: %s\n", pdata->name);
 		goto err;
 	}
-	
 
 	mc->class = class_create(THIS_MODULE, "modemctl");
-
 	if(IS_ERR(mc->class)) {
 		dev_err(&pdev->dev, "failed to create sysfs class\n");
 		r = PTR_ERR(mc->class);
@@ -802,49 +733,33 @@
 
 	pdata->cfg_gpio();
 
-
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	mc->dev = device_create(mc->class, &pdev->dev, MKDEV(0, 0), NULL, "%s", pdata->name);
-
-
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
-
 	if(IS_ERR(mc->dev)) {
 		dev_err(&pdev->dev, "failed to create device\n");
 		r = PTR_ERR(mc->dev);
 		goto err;
 	}
-#if 1 //test
 	dev_set_drvdata(mc->dev, mc);
 
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
-
 	r = sysfs_create_group(&mc->dev->kobj, &modemctl_group);
-
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	if(r) {
 		dev_err(&pdev->dev, "failed to create sysfs files\n");
 		goto err;
 	}
 	mc->group = &modemctl_group;
 
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	INIT_WORK(&mc->work, mc_work);
 
-
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	r = request_irq(irq_phone_active, modemctl_irq_handler,
 			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 			"phone_active", mc);
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	if(r) {
 		dev_err(&pdev->dev, "failed to allocate an interrupt(%d)\n",
 				irq_phone_active);
 		goto err;
 	}
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	mc->irq_phone_active = irq_phone_active;
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
+
 #if 0
 	setup_timer(&mc->sim_irq_debounce_timer, (void*)sim_irq_debounce_timer_func,(unsigned long)mc);
 
@@ -859,22 +774,17 @@
 	mc->irq_sim_ndetect= irq_sim_ndetect;
 #endif
 
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	_wake_lock_init(mc);
 
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
 	platform_set_drvdata(pdev, mc);
-	printk("[modemctl_probe]: (%d) - debug\n", __LINE__);	//remove
-	
+
 	dev_dbg( &pdev->dev, "modemctl_probe Done.\n" );
-	printk( "[ modemctl_probe Done. ]\n"  );
 
 	return 0;
-#endif //test
+
 err:
 	_free_all(mc);
 	return r;
-
 }
 
 static int __devexit modemctl_remove(struct platform_device *pdev)
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/storage/storage.c Kernel/drivers/phone_svn/storage/storage.c
--- Kernel-org/drivers/phone_svn/storage/storage.c	2011-01-24 14:36:07.830272200 +0530
+++ Kernel/drivers/phone_svn/storage/storage.c	2011-01-20 23:57:16.070275264 +0530
@@ -18,6 +18,10 @@
 #define STORAGE_IOCTL_CMD   0x98
 #define STORAGE_READ_DGS    _IOR(STORAGE_IOCTL_CMD, 0x1, char)
 
+#define STORAGE_FACTORY_TEST_FORCE_SLEEP    _IOR(STORAGE_IOCTL_CMD, 0x5, char)
+
+extern unsigned int factory_test_force_sleep;
+
 extern unsigned int HWREV;
 
 int storage_open(struct inode *inode, struct file *filp)
@@ -33,10 +37,9 @@
 {
 	int dgs_block_offset = 2047;
 
-#ifdef CONFIG_TARGET_LOCALE_KOR
-	if (HWREV >= 12) /* uses 8G OneNAND*/
-		dgs_block_offset = 4095;
-#endif
+	/* uses 8G OneNAND*/
+	//dgs_block_offset = 4095;
+
 	printk("Storage Device ioctl -> cmd : %08X, arg : %08X \n", cmd, arg);
 	switch (cmd) {
 		case STORAGE_READ_DGS:
@@ -81,6 +84,10 @@
 				return copy_to_user((char *) arg, (char *) aDGSBuf, sizeof (aDGSBuf));
 		}
 
+		case STORAGE_FACTORY_TEST_FORCE_SLEEP:
+			factory_test_force_sleep = 1;
+			return 0;
+
 		default:
 			break;
 	}
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/phone_svn/svnet/sipc4.c Kernel/drivers/phone_svn/svnet/sipc4.c
--- Kernel-org/drivers/phone_svn/svnet/sipc4.c	2011-01-24 14:36:07.840269699 +0530
+++ Kernel/drivers/phone_svn/svnet/sipc4.c	2011-01-20 23:57:16.080268643 +0530
@@ -38,8 +38,7 @@
 #include <linux/phonet.h>
 #include <net/phonet/phonet.h>
 
-#include <linux/phone_svn/mipi_hsi.h>
-#include <linux/phone_svn/ipc_spi.h>
+#include <linux/phone_svn/ipc_hsi.h>
 
 #if defined(CONFIG_KERNEL_DEBUG_SEC)
 #include <linux/kernel_sec_common.h>
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/sensors/compass/yas530.c Kernel/drivers/sensors/compass/yas530.c
--- Kernel-org/drivers/sensors/compass/yas530.c	2011-01-24 14:38:37.680273724 +0530
+++ Kernel/drivers/sensors/compass/yas530.c	2011-01-20 23:57:22.967770263 +0530
@@ -2515,6 +2515,7 @@
 geomagnetic_enable(struct geomagnetic_data *data)
 {
     if (!atomic_cmpxchg(&data->enable, 0, 1)) {
+	printk("YAS530 CVS calling schedule_delayed_work\n");
         schedule_delayed_work(&data->work, 0);
     }
 
@@ -2852,9 +2853,9 @@
 
 #endif /* DEBUG */
 
-static DEVICE_ATTR(poll_delay, S_IRUGO|S_IWUSR|S_IWGRP,
+static DEVICE_ATTR(poll_delay, S_IRUGO|S_IWUGO,
         geomagnetic_delay_show, geomagnetic_delay_store);
-static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUGO,
         geomagnetic_enable_show, geomagnetic_enable_store);
 static DEVICE_ATTR(filter_enable, S_IRUGO|S_IWUSR|S_IWGRP,
         geomagnetic_filter_enable_show, geomagnetic_filter_enable_store);
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/sensors/compass/yas530.h Kernel/drivers/sensors/compass/yas530.h
--- Kernel-org/drivers/sensors/compass/yas530.h	2011-01-24 14:38:37.680273724 +0530
+++ Kernel/drivers/sensors/compass/yas530.h	2011-01-20 23:57:22.967770263 +0530
@@ -85,7 +85,7 @@
 /* -------------------------------------------------------------------------- */
 
 /* Debugging */
-#define DEBUG                               (1)
+#define DEBUG                               (0)
 
 #if DEBUG
 #ifdef __LINUX_KERNEL_DRIVER__
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/hsi_protocol.c Kernel/drivers/staging/omap_hsi/hsi_protocol.c
--- Kernel-org/drivers/staging/omap_hsi/hsi_protocol.c	1970-01-01 05:30:00.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol.c	2011-01-24 11:07:43.827779913 +0530
@@ -0,0 +1,346 @@
+/*
+ * File - hsi_protocol.c
+ *
+ * Implements HSI protocol for Infineon Modem.
+ *
+ * Copyright (C) 2011 Samsung Electronics.
+ * 
+ * Author: Rupesh Gujare <rupesh.g@samsung.com>
+ *  
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* #define DEBUG */
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/io.h>
+
+#include "hsi-protocol-if.h" 
+#include <linux/hsi_driver_if.h>
+
+#define DRIVER_VERSION  "1.0"
+
+char test_data[10]="abcdefghij";
+
+dev_t hsi_protocol_dev;
+
+struct protocol_queue {
+        struct list_head list;
+        u32 *data;
+        unsigned int count;
+};
+
+struct hsi_protocol {
+        unsigned int opened;
+        int poll_event;
+        struct list_head rx_queue;
+        struct list_head tx_queue;
+        spinlock_t lock;        /* Serialize access to driver data and API */
+        struct fasync_struct *async_queue;
+        wait_queue_head_t rx_wait;
+        wait_queue_head_t tx_wait;
+        wait_queue_head_t poll_wait;
+};
+
+static struct hsi_protocol hsi_protocol_data[HSI_MAX_CHANNELS];
+
+void if_notify(int ch, struct hsi_event *ev)
+{
+        struct protocol_queue *entry;
+
+        pr_debug("%s, ev = {0x%x, 0x%p, %u}\n", __func__, ev->event, ev->data,
+                 ev->count);
+        printk("%s, ev = {0x%x, 0x%p, %u} ch{%d} \n", __func__, ev->event, ev->data,
+                 ev->count, ch);
+
+        spin_lock(&hsi_protocol_data[ch].lock);
+
+//Not Required
+/*        if (!hsi_protocol_data[ch].opened) {
+                pr_debug("%s, device not opened\n!", __func__);
+                printk("%s, device not opened\n!", __func__);
+                spin_unlock(&hsi_protocol_data[ch].lock);
+                return;
+        }*/
+
+        switch (HSI_EV_TYPE(ev->event)) {
+        case HSI_EV_IN:
+                entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+                if (!entry) {
+                        pr_err("HSI-CHAR: entry allocation failed.\n");
+                        spin_unlock(&hsi_protocol_data[ch].lock);
+                        return;
+                }
+                entry->data = ev->data;
+                entry->count = ev->count;
+                list_add_tail(&entry->list, &hsi_protocol_data[ch].rx_queue);
+                spin_unlock(&hsi_protocol_data[ch].lock);
+                pr_debug("%s, HSI_EV_IN\n", __func__);
+                wake_up_interruptible(&hsi_protocol_data[ch].rx_wait);
+                break;
+        case HSI_EV_OUT:
+                entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+                if (!entry) {
+                        pr_err("HSI-CHAR: entry allocation failed.\n");
+                        spin_unlock(&hsi_protocol_data[ch].lock);
+                        return;
+                }
+                entry->data = ev->data;
+                entry->count = ev->count;
+                hsi_protocol_data[ch].poll_event |= (POLLOUT | POLLWRNORM);
+                list_add_tail(&entry->list, &hsi_protocol_data[ch].tx_queue);
+		spin_unlock(&hsi_protocol_data[ch].lock);
+                pr_debug("%s, HSI_EV_OUT\n", __func__);
+                printk("%s, HSI_EV_OUT\n", __func__);
+                wake_up_interruptible(&hsi_protocol_data[ch].tx_wait);
+                break;
+        case HSI_EV_EXCEP:
+                hsi_protocol_data[ch].poll_event |= POLLPRI;
+                spin_unlock(&hsi_protocol_data[ch].lock);
+                pr_debug("%s, HSI_EV_EXCEP\n", __func__);
+                wake_up_interruptible(&hsi_protocol_data[ch].poll_wait);
+                break;
+        case HSI_EV_AVAIL:
+                hsi_protocol_data[ch].poll_event |= (POLLIN | POLLRDNORM);
+                spin_unlock(&hsi_protocol_data[ch].lock);
+                pr_debug("%s, HSI_EV_AVAIL\n", __func__);
+                wake_up_interruptible(&hsi_protocol_data[ch].poll_wait);
+                break;
+        default:
+                spin_unlock(&hsi_protocol_data[ch].lock);
+                break;
+        }
+}
+
+int hsi_proto_read(int ch, u32 *buffer, int count)
+{
+        DECLARE_WAITQUEUE(wait, current);
+	u32 *data;
+        unsigned int data_len = 0;
+        struct protocol_queue *entry;
+        int ret, recv_data = 0;
+
+
+        /*printk(KERN_DEBUG "%s, count = %d\n", __func__, count); */
+
+/*        if (count > MAX_HSI_IPC_BUFFER) 
+                count = MAX_HSI_IPC_BUFFER;
+
+        data = kmalloc(count, GFP_ATOMIC);*/
+
+
+        ret = if_hsi_read(ch, buffer, count);
+        if (ret < 0) {
+                pr_err("Can not submit read. READ Error \n");
+		goto out2;
+        }
+
+        spin_lock_bh(&hsi_protocol_data[ch].lock);
+        add_wait_queue(&hsi_protocol_data[ch].rx_wait, &wait);
+        spin_unlock_bh(&hsi_protocol_data[ch].lock);
+
+        for (;;) {
+                data = NULL;
+                data_len = 0;
+
+                set_current_state(TASK_INTERRUPTIBLE);
+
+                spin_lock_bh(&hsi_protocol_data[ch].lock);
+                if (!list_empty(&hsi_protocol_data[ch].rx_queue)) {
+                        entry = list_entry(hsi_protocol_data[ch].rx_queue.next,
+                                           struct protocol_queue, list);
+                        data = entry->data;
+                        data_len = entry->count;
+                        list_del(&entry->list);
+                        kfree(entry);
+                } 
+                spin_unlock_bh(&hsi_protocol_data[ch].lock);
+
+                pr_debug("%s, data = 0x%p, data_len = %d\n",
+                         __func__, data, data_len);
+
+                if (data_len) {
+                        pr_debug("%s, RX finished\n", __func__);
+                        spin_lock_bh(&hsi_protocol_data[ch].lock);
+                        hsi_protocol_data[ch].poll_event &= ~(POLLIN | POLLRDNORM);
+                        spin_unlock_bh(&hsi_protocol_data[ch].lock);
+                        if_hsi_poll(ch);
+			//memcpy(buffer, data, count); 
+			recv_data += data_len;
+			//buffer += data_len;
+			//if ((recv_data == count) || (recv_data => MAX_HSI_IPC_BUFFER))
+                        	break;
+                } else if (signal_pending(current)) {
+                        pr_debug("%s, ERESTARTSYS\n", __func__);
+                        recv_data = -EAGAIN;
+                        if_hsi_cancel_read(ch);
+                        /* goto out; */
+                        break;
+                }
+
+                /*printk(KERN_DEBUG "%s, going to sleep...\n", __func__); */
+                schedule();
+                /*printk(KERN_DEBUG "%s, woke up\n", __func__); */
+        }
+
+//out:
+        __set_current_state(TASK_RUNNING);
+        remove_wait_queue(&hsi_protocol_data[ch].rx_wait, &wait);
+
+out2:	
+	/*To Do- Set bit if data to be received is 
+	* greater than 512K Bytes and return to IPC call
+	*/
+
+        /*printk(KERN_DEBUG "%s, ret = %d\n", __func__, ret); */
+        return recv_data;
+}
+
+int hsi_proto_write(int ch, u32 *buffer, int length)
+{
+
+	DECLARE_WAITQUEUE(wait, current);
+	u32 *data;
+	unsigned int data_len = 0, ret = -1;
+	struct protocol_queue *entry;
+
+	printk("%s\n",__func__);
+        ret = if_hsi_write(ch, buffer, length);
+        if (ret < 0) {
+		pr_err("HSI Write ERROR %s \n", __func__);
+                goto out2;
+        }else
+		printk("if_hsi_write() returned successfuly\n");
+	spin_lock_bh(&hsi_protocol_data[ch].lock);
+        hsi_protocol_data[ch].poll_event &= ~(POLLOUT | POLLWRNORM);
+        add_wait_queue(&hsi_protocol_data[ch].tx_wait, &wait);
+        spin_unlock_bh(&hsi_protocol_data[ch].lock);
+
+	printk("Added task to waitqueue, sleeping\n");
+	for (;;) {
+                data = NULL;
+                data_len = 0;
+
+                set_current_state(TASK_INTERRUPTIBLE);
+		printk("Inside for loop\n");
+                spin_lock_bh(&hsi_protocol_data[ch].lock);
+                if (!list_empty(&hsi_protocol_data[ch].tx_queue)) {
+                        entry = list_entry(hsi_protocol_data[ch].tx_queue.next,
+                                           struct protocol_queue, list);
+                        data = entry->data;
+                        data_len = entry->count;
+                        list_del(&entry->list);
+                        kfree(entry);
+			printk("data_len = %d\n",data_len);
+                }
+                spin_unlock_bh(&hsi_protocol_data[ch].lock);
+
+                if (data_len) {
+                        pr_debug("%s, TX finished\n", __func__);
+                        printk("%s, TX finished\n", __func__);
+                        ret = data_len;
+                        break;
+                } else if (signal_pending(current)) {
+                        pr_debug("%s, ERESTARTSYS\n", __func__);
+                        ret = -ERESTARTSYS;
+                        goto out;
+                }
+
+                printk("%s, going to sleep...\n", __func__); 
+                schedule();
+                printk("%s, woke up\n", __func__); 
+        }
+
+out:
+        __set_current_state(TASK_RUNNING);
+        remove_wait_queue(&hsi_protocol_data[ch].tx_wait, &wait);
+
+out2:
+        /*printk(KERN_DEBUG "%s, ret = %d\n", __func__, ret); */
+        return ret;
+}
+//EXPORT_SYMBOL(hsi_proto_write);
+
+#define OMAP4_PAD_CAM_GLOBALRESET_USBB1_ULPITLL_CLK		0x4A1000C0 // ???, MIPI_HSI_TX_WAKE
+#define OMAP4_PAD_USBB1_ULPITLL_STP_USBB1_ULPITLL_DIR		0x4A1000C4 // MIPI_HSI_TX_DATA, MIPI_HSI_TX_FLG
+#define OMAP4_PAD_USBB1_ULPITLL_NXT_USBB1_ULPITLL_DAT0		0x4A1000C8 // MIPI_HSI_TX_RDY, MIPI_HSI_RX_WAKE
+#define OMAP4_PAD_USBB1_ULPITLL_DAT1_USBB1_ULPITLL_DAT2		0x4A1000CC // MIPI_HSI_RX_DATA, MIPI_HSI_RX_FLG
+#define OMAP4_PAD_USBB1_ULPITLL_DAT3_USBB1_ULPITLL_DAT4	0x4A1000D0 // MIPI_HSI_RX_RDY, ???
+
+static void hsi_mux_setting( void )
+{
+	u32 reg_val;
+
+	reg_val = omap_readl( OMAP4_PAD_CAM_GLOBALRESET_USBB1_ULPITLL_CLK );
+	reg_val &= 0x0000FFFF;
+	reg_val |= 0x01010000;
+	omap_writel( reg_val, OMAP4_PAD_CAM_GLOBALRESET_USBB1_ULPITLL_CLK );
+
+	reg_val = 0x01010101;
+	omap_writel( reg_val, OMAP4_PAD_USBB1_ULPITLL_STP_USBB1_ULPITLL_DIR );
+
+	reg_val = 0x00010001;
+	omap_writel( reg_val, OMAP4_PAD_USBB1_ULPITLL_NXT_USBB1_ULPITLL_DAT0 );
+
+	reg_val = 0x00010001;
+	omap_writel( reg_val, OMAP4_PAD_USBB1_ULPITLL_DAT1_USBB1_ULPITLL_DAT2 );
+
+	reg_val = omap_readl( OMAP4_PAD_USBB1_ULPITLL_DAT3_USBB1_ULPITLL_DAT4 );
+	reg_val &= 0xFFFF0000;
+	reg_val |= 0x00000101;
+	omap_writel( reg_val, OMAP4_PAD_USBB1_ULPITLL_DAT3_USBB1_ULPITLL_DAT4 );
+}
+
+static int __init hsi_protocol_init(void)
+{
+	int i,ret = 0;
+
+	   pr_info("HSI Infineon Protocol driver version " DRIVER_VERSION "\n");
+
+        for (i = 0; i < HSI_MAX_CHANNELS; i++) {
+                init_waitqueue_head(&hsi_protocol_data[i].rx_wait);
+                init_waitqueue_head(&hsi_protocol_data[i].tx_wait);
+                init_waitqueue_head(&hsi_protocol_data[i].poll_wait);
+                spin_lock_init(&hsi_protocol_data[i].lock);
+                hsi_protocol_data[i].opened = 0;
+                INIT_LIST_HEAD(&hsi_protocol_data[i].rx_queue);
+                INIT_LIST_HEAD(&hsi_protocol_data[i].tx_queue);
+        }
+
+	hsi_mux_setting();
+	printk( "hsi_protocol_init : hsi_mux_setting Done.\n" );
+
+	ret = if_hsi_init();
+
+	return ret;
+}
+
+
+static void __exit hsi_protocol_exit(void)
+{
+	if_hsi_exit();
+}
+
+
+MODULE_AUTHOR("Rupesh Gujare <rupesh.g@samsung.com> / Samsung Electronics");
+MODULE_DESCRIPTION("HSI Protocol for Infineon Modem");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(hsi_protocol_init);
+module_exit(hsi_protocol_exit);
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/hsi_protocol_cmd.c Kernel/drivers/staging/omap_hsi/hsi_protocol_cmd.c
--- Kernel-org/drivers/staging/omap_hsi/hsi_protocol_cmd.c	1970-01-01 05:30:00.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol_cmd.c	2011-01-24 11:07:43.837780835 +0530
@@ -0,0 +1,377 @@
+/* 
+ *
+ * Copyright (C) 2011 Samsung Electrnoics. All rights reserved.
+ * 
+ *
+ * Author: Rupesh Gujare <rupesh.g@samsung.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+#include <linux/hsi_driver_if.h>
+#include "hsi-protocol-if.h"
+
+extern struct if_hsi_iface hsi_protocol_iface;
+extern wait_queue_head_t ipc_read_wait, ipc_write_wait;
+int if_hsi_openchannel(struct if_hsi_channel *channel);
+int if_hsi_closechannel(struct if_hsi_channel *channel);
+
+extern u32 avlb_ch, avlb_length;
+extern u32 actual_write;
+
+/*Decode command from received PDU on channle 0*/
+int hsi_decode_cmd( u32 *cmd_data, u32 *cmd, u32 *ch, u32 *param)
+{
+	int ret = 0;
+	u32 data = *cmd_data;
+	u8 lrc_cal, lrc_act;
+	u8 val1, val2, val3;	
+
+	*cmd = ((data & 0xF0000000) >> 28);
+	
+	switch (*cmd){
+	case	HSI_LL_MSG_BREAK:
+		pr_err("Command MSG_BREAK Received.\n");
+		break;
+	
+	case	HSI_LL_MSG_OPEN_CONN:
+		*ch = ((data & 0x0F000000) >> 24);
+		*param   = ((data & 0x00FFFF00) >> 8 );
+		/*Check LRC*/
+		val1 = ((data & 0xFF000000) >> 24);
+		val2 = ((data & 0x00FF0000) >> 16);
+		val3 = ((data & 0x0000FF00) >>  8);
+		lrc_act = (data & 0x000000FF);
+		lrc_cal = val1 ^ val2 ^ val3;
+	       	if(lrc_cal != lrc_act)
+        	ret = -1;
+		break;
+
+	case HSI_LL_MSG_CONN_READY:
+	case HSI_LL_MSG_CONN_CLOSED:
+	case HSI_LL_MSG_CANCEL_CONN:
+	case HSI_LL_MSG_NAK:
+		*ch = ((data & 0x0F000000) >> 24);
+		break;
+
+	case HSI_LL_MSG_ACK:
+		*ch = ((data & 0x0F000000) >> 24);
+		*param = (data & 0x00FFFFFF);
+		printk("ACK Received ch=%d, param=%d\n",*ch, *param);
+		break;
+	
+	case HSI_LL_MSG_CONF_RATE:
+		*ch = ((data & 0x0F000000) >> 24);
+		*param   = ((data & 0x0F000000) >> 24);
+		break;
+
+	case HSI_LL_MSG_OPEN_CONN_OCTET:
+		*ch = ((data & 0x0F000000) >> 24);
+		*param   = (data & 0x00FFFFFF);
+		break;
+
+	case HSI_LL_MSG_ECHO:
+	case HSI_LL_MSG_INFO_REQ:
+	case HSI_LL_MSG_INFO:
+	case HSI_LL_MSG_CONFIGURE:
+	case HSI_LL_MSG_ALLOCATE_CH:
+	case HSI_LL_MSG_RELEASE_CH:
+	case HSI_LL_MSG_INVALID:
+		*cmd = HSI_LL_MSG_INVALID;
+		*ch  = HSI_LL_INVALID_CHANNEL;
+		ret = -1;
+		break;
+	}
+	return ret;
+}
+
+int protocol_create_cmd(int cmd_type, unsigned int channel, void* arg)
+{
+unsigned int command = 0;
+  int ret = 0;
+
+  switch(cmd_type)
+  {
+    case HSI_LL_MSG_BREAK:
+     {
+       command = 0;
+     }
+     break;
+
+    case HSI_LL_MSG_OPEN_CONN:
+     {
+       unsigned int size = *(unsigned int*)arg;
+       unsigned int lcr  = 0;
+
+/*       if(size > 4)
+         size = (size & 0x3) ? ((size >> 2) + 1):(size >> 2);
+       else
+         size = 1;*/
+
+       command = ((HSI_LL_MSG_OPEN_CONN & 0x0000000F) << 28) |
+                 ((channel              & 0x000000FF) << 24) |
+                 ((size                 & 0x0000FFFF) << 8);
+
+       lcr = ((command & 0xFF000000) >> 24) ^
+             ((command & 0x00FF0000) >> 16) ^
+             ((command & 0x0000FF00) >>  8);
+
+       command = command | (lcr & 0x000000FF);
+     }
+     break;
+
+    case HSI_LL_MSG_CONN_READY:
+     {
+       command = ((HSI_LL_MSG_CONN_READY & 0x0000000F) << 28) |
+                 ((channel               & 0x000000FF) << 24);
+     }
+     break;
+
+    case HSI_LL_MSG_CONN_CLOSED:
+     {
+       command = ((HSI_LL_MSG_CONN_CLOSED & 0x0000000F) << 28) |
+                 ((channel                & 0x000000FF) << 24);
+     }
+	break;
+
+    case HSI_LL_MSG_CANCEL_CONN:
+     {
+       unsigned int role = *(unsigned int*)arg;
+
+       command = ((HSI_LL_MSG_CANCEL_CONN & 0x0000000F) << 28) |
+                 ((channel                & 0x000000FF) << 24) |
+                 ((role                   & 0x000000FF) << 16);
+     }
+     break;
+
+    case HSI_LL_MSG_ACK:
+     {
+       unsigned int echo_params = *(unsigned int*)arg;
+
+       command = ((HSI_LL_MSG_ACK & 0x0000000F) << 28) |
+                 ((channel        & 0x000000FF) << 24) |
+                 ((echo_params    & 0x00FFFFFF));
+     }
+     break;
+
+    case HSI_LL_MSG_NAK:
+     {
+       command = ((HSI_LL_MSG_NAK & 0x0000000F) << 28) |
+                 ((channel        & 0x000000FF) << 24);
+     }
+     break;
+
+    case HSI_LL_MSG_CONF_RATE:
+     {
+       unsigned int baud_rate = *(unsigned int*)arg;
+
+       command = ((HSI_LL_MSG_CONF_RATE & 0x0000000F) << 28) |
+                 ((channel              & 0x000000FF) << 24) |
+                 ((baud_rate            & 0x00FFFFFF));
+     }
+     break;
+
+    case HSI_LL_MSG_OPEN_CONN_OCTET:
+     {
+       unsigned int size = *(unsigned int*)arg;
+
+	command = ((HSI_LL_MSG_OPEN_CONN_OCTET & 0x0000000F) << 28) |
+                 ((channel                    & 0x000000FF) << 24) |
+                 ((size                       & 0x00FFFFFF));
+
+     }
+     break;
+
+    case HSI_LL_MSG_ECHO:
+    case HSI_LL_MSG_INFO_REQ:
+    case HSI_LL_MSG_INFO:
+    case HSI_LL_MSG_CONFIGURE:
+    case HSI_LL_MSG_ALLOCATE_CH:
+    case HSI_LL_MSG_RELEASE_CH:
+    case HSI_LL_MSG_INVALID:
+      ret = -1;
+     break;
+  }
+	return command;
+}
+
+int set_tx_config(struct if_hsi_channel *ch, u32 mode, u32 max_channels)
+{
+	 struct hst_ctx tx_config;
+	int ret;
+
+	hsi_ioctl(ch->dev, HSI_IOCTL_GET_TX, &tx_config);
+	tx_config.mode = mode;
+	tx_config.channels = max_channels;
+	ret = hsi_ioctl(ch->dev, HSI_IOCTL_SET_TX, &tx_config);
+	return ret;
+}
+
+int hsi_protocol_send_command(u32 cmd, u32 channel, u32 param)
+{
+	u32 cmd_array[4] = {0, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC}, ret = -1;
+
+	cmd_array[0] = protocol_create_cmd(cmd, channel, &param);
+	ret = hsi_proto_write(0, &cmd_array, 16 );
+	if(ret < 0){
+		printk("Command Write failed %s()\n", __func__);
+		return -1;
+	}else
+		return 0;
+}
+
+
+void rx_stm(u32 cmd, u32 ch, u32 param)
+{
+	struct if_hsi_channel *channel;
+	u32 size = 0, ret;
+	channel = &hsi_protocol_iface.channels[ch]; 
+
+	switch(cmd){
+	case HSI_LL_MSG_OPEN_CONN:
+		printk("ERROR... OPEN_CONN Not supported. Should use OPEN_CONN_OCTECT instead.\n");
+		break;
+	
+	case HSI_LL_MSG_ECHO:
+		printk("ERROR... HSI_LL_MSG_ECHO not supported.\n"); 
+		break;
+
+	case HSI_LL_MSG_CONN_CLOSED:
+		switch(channel->tx_state){
+		case HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED:
+			channel->tx_state = HSI_LL_TX_STATE_IDLE;
+			printk("Received CONN_CLOSED\n");
+			if_hsi_closechannel(channel);
+			break;
+
+		default:
+			printk("Wrong STATE for CONN_CLOSED\n");
+		}
+		break;
+	
+	case HSI_LL_MSG_CANCEL_CONN:
+		printk("Received CANCEL_CONN\n");
+		break;
+
+	case HSI_LL_MSG_ACK:
+		switch(channel->tx_state){
+		struct hst_ctx tx_config;
+		
+		case HSI_LL_TX_STATE_WAIT_FOR_ACK:
+		case HSI_LL_TX_STATE_SEND_OPEN_CONN:
+			printk("ACK received %s()\n",__func__);
+			ret = if_hsi_openchannel(channel);
+			if (ret != 0)
+				pr_err("Unable to open channel %d after ACK for data transfer\n", channel->channel_id);	
+			/*Set Tx Config*/
+			hsi_ioctl(channel->dev, HSI_IOCTL_GET_TX, &tx_config);
+			tx_config.mode = 2;
+			tx_config.channels = HSI_MAX_CHANNELS;
+			ret = hsi_ioctl(channel->dev, HSI_IOCTL_SET_TX, &tx_config);
+			if ( ret == 0)
+				printk ("SET_TX Successful %s()\n",__func__);
+			
+			channel->tx_state = HSI_LL_TX_STATE_TX;
+			size = param;
+			if ((size > 16) && (size % 4))
+				size += (4 - (size % 4));
+			else if (size < 16)
+				size = 16;
+			printk("Writing %d bytes data on channel %d, tx_buf = %x,  in %s()\n", size, ch, channel->tx_buf, __func__);
+			ret = hsi_proto_write(ch, channel->tx_buf, size);
+			channel->tx_state = HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED;
+			actual_write = ret;
+			wake_up_interruptible (&ipc_write_wait);
+			break;
+
+		case HSI_LL_TX_STATE_CLOSED:/* ACK as response to CANCEL_CONN */
+			if(channel->rx_state == HSI_LL_RX_STATE_WAIT_FOR_CANCEL_CONN_ACK)
+			 channel->rx_state = HSI_LL_RX_STATE_CLOSED;
+			break;
+
+		case HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK: /* ACK as response to CONF_RATE */
+			//TODO: SET CONF RATE
+			pr_debug("ACK Received for CONF_RATE\n");
+			break;
+
+		default:
+			pr_err("ACK Received for Unknown state\n");
+		}
+		break;
+
+	case HSI_LL_MSG_NAK:
+		switch(channel->tx_state){
+		case HSI_LL_TX_STATE_WAIT_FOR_ACK:
+			channel->tx_state = HSI_LL_TX_STATE_NACK;
+			break;
+
+		 case HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK: /* NAK as response to CONF_RATE */
+		 channel->tx_state = HSI_LL_TX_STATE_IDLE;
+		break;
+
+		default:
+			pr_err("ERROR - Received NAK in invalid state\n");
+		}
+		break;
+
+	case HSI_LL_MSG_CONF_RATE:
+		//TODO: Set Conf Rate
+		pr_debug("CONF_RATE Received\n");
+		break;
+
+	case HSI_LL_MSG_OPEN_CONN_OCTET:
+		switch(channel->rx_state){
+			case HSI_LL_RX_STATE_CLOSED:
+				printk("OPEN_CONN_OCTET in %s()\n",__func__);
+				channel->rx_state = HSI_LL_RX_STATE_TO_ACK;
+				ret = if_hsi_openchannel(channel);
+				if ( ret < 0){
+					printk("%s() Channel Open failed\n",__func__);
+					hsi_protocol_send_command(HSI_LL_MSG_NAK, ch, param);
+					channel->rx_state = HSI_LL_RX_STATE_CLOSED;
+					break;
+				}else{
+					printk("%s() Channel Open Successful\n",__func__);
+					set_tx_config(channel, 2, HSI_MAX_CHANNELS);
+					hsi_protocol_send_command(HSI_LL_MSG_ACK, ch, param);
+				}
+				channel->rx_state = HSI_LL_RX_STATE_SEND_ACK;
+				channel->rx_state = HSI_LL_RX_STATE_RX;
+				avlb_ch = ch;
+				avlb_length = param; 
+				printk("Waking up IPC read\n");
+				wake_up_interruptible (&ipc_read_wait);
+				//Open channel Set RX config & Read Data & close channel 
+				//hsi_protocol_send_command(HSI_LL_MSG_CONN_CLOSED, ch, param);
+				//channel->HSI_LL_RX_STATE_IDLE;
+				break;
+			case HSI_LL_RX_STATE_BLOCKED:
+				//TODO
+				break;
+			default:
+				pr_err("OPEN_CONN_OCTET in invalid state\n");
+		}
+		break;	
+	
+	default:
+		pr_err("Invalid Command encountered in rx_state()\n");
+	}
+
+}
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/hsi_protocol_if.c Kernel/drivers/staging/omap_hsi/hsi_protocol_if.c
--- Kernel-org/drivers/staging/omap_hsi/hsi_protocol_if.c	1970-01-01 05:30:00.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol_if.c	2011-01-24 11:07:43.847780500 +0530
@@ -0,0 +1,725 @@
+/*
+ * File -  hsi_protocol_if.c
+ *
+ * Implements HSI protocol for Infineon Modem.
+ *
+ * Copyright (C) 2011 Samsung Electronics.
+ *
+ * Author: Rupesh Gujare <rupesh.g@samsung.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <asm/mach-types.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/ktime.h>
+#include <linux/bitmap.h>
+#include <linux/poll.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/hsi_driver_if.h>
+#include "hsi-protocol-if.h" 
+
+#define DEBUG	1
+
+#define HSI_CHANNEL_STATE_UNAVAIL       (1 << 0)
+#define HSI_CHANNEL_STATE_READING       (1 << 1)
+#define HSI_CHANNEL_STATE_WRITING       (1 << 2)
+
+#define MAX_HSI_IPC_BUFFER		512*1024
+
+
+
+
+
+struct if_hsi_iface hsi_protocol_iface;
+
+u32 avlb_ch, avlb_length = 0;
+u32 actual_write;
+wait_queue_head_t ipc_read_wait, ipc_write_wait;
+
+static void if_hsi_protocol_port_event(struct hsi_device *dev, unsigned int event,
+                              void *arg);
+static int __devinit hsi_protocol_probe(struct hsi_device *dev);
+static int __devexit hsi_protocol_remove(struct hsi_device *dev);
+
+static struct hsi_device_driver if_hsi_protocol_driver = {
+	.ctrl_mask = ANY_HSI_CONTROLLER,
+	.probe = hsi_protocol_probe,
+	.remove = __devexit_p(hsi_protocol_remove),
+	.driver = {
+	.name = "hsi_protocol"
+	},
+};
+
+
+
+static int if_hsi_read_on(int ch, u32 *data, unsigned int count)
+{
+        struct if_hsi_channel *channel;
+        int ret;
+
+        channel = &hsi_protocol_iface.channels[ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+
+        spin_lock(&channel->lock);
+        if (channel->state & HSI_CHANNEL_STATE_READING) {
+                pr_err("Read still pending on channel %d\n", ch);
+                spin_unlock(&channel->lock);
+                return -EBUSY;
+        }
+        channel->state |= HSI_CHANNEL_STATE_READING;
+        channel->rx_data = data;
+        channel->rx_count = count;
+        spin_unlock(&channel->lock);
+
+        ret = hsi_read(channel->dev, data, count / 4);
+        dev_dbg(&channel->dev->device, "%s, ch = %d, ret = %d\n", __func__, ch,
+                ret);
+
+        return ret;
+}
+
+static void if_hsi_proto_read_done(struct hsi_device *dev, unsigned int size)
+{
+	struct if_hsi_channel *channel;
+        struct hsi_event ev;
+
+	printk("if_hsi_proto_read_done() is called for ch-> %d\n",dev->n_ch);
+        channel = &hsi_protocol_iface.channels[dev->n_ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, dev->n_ch);
+        spin_lock(&channel->lock);
+        channel->state &= ~HSI_CHANNEL_STATE_READING;
+        ev.event = HSI_EV_IN;
+        ev.data = channel->rx_data;
+        ev.count = 4 * size;
+        spin_unlock(&channel->lock);
+        if_notify(dev->n_ch, &ev);
+}
+
+int if_hsi_read(int ch, u32 *data, unsigned int count)
+{
+        int ret = 0;
+        struct if_hsi_channel *channel;
+        channel = &hsi_protocol_iface.channels[ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+        ret = if_hsi_read_on(ch, data, count);
+        return ret;
+}
+
+int if_hsi_poll(int ch)
+{
+        struct if_hsi_channel *channel;
+        int ret = 0;
+        channel = &hsi_protocol_iface.channels[ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+        ret = hsi_poll(channel->dev);
+        return ret;
+}
+
+static int if_hsi_write_on(int ch, u32 *address, unsigned int count)
+{
+        struct if_hsi_channel *channel;
+        int ret;
+	
+        channel = &hsi_protocol_iface.channels[ch];
+	printk("In Funcion - %s acquiring channel->lock\n",__func__);
+
+        spin_lock(&channel->lock);
+	printk("In Funcion - %s\n Acquired channel->lock\n",__func__);
+        if (channel->state & HSI_CHANNEL_STATE_WRITING) {
+                pr_err("Write still pending on channel %d\n", ch);
+                printk("Write still pending on channel %d\n", ch);
+                spin_unlock(&channel->lock);
+                return -EBUSY;
+        }
+
+        channel->tx_data = address;
+        channel->tx_count = count;
+        channel->state |= HSI_CHANNEL_STATE_WRITING;
+        spin_unlock(&channel->lock);
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+	printk("hsi_write() Starting ...\n");
+        ret = hsi_write(channel->dev, address, count / 4);
+	printk("hsi_write() returned %d, %s()\n", ret, __func__);
+        return ret;
+}
+
+
+static void if_hsi_proto_write_done(struct hsi_device *dev, unsigned int size)
+{
+	struct if_hsi_channel *channel;
+        struct hsi_event ev;
+
+	printk("if_hsi_proto_write_done() is called for ch-> %d\n",dev->n_ch);
+        channel = &hsi_protocol_iface.channels[dev->n_ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, dev->n_ch);
+
+        spin_lock(&channel->lock);
+        channel->state &= ~HSI_CHANNEL_STATE_WRITING;
+        ev.event = HSI_EV_OUT;
+        ev.data = channel->tx_data;
+        ev.count = 4 * size;
+        spin_unlock(&channel->lock);
+        if_notify(dev->n_ch, &ev);
+
+}
+
+int if_hsi_write(int ch, u32 *data, unsigned int count)
+{
+        int ret = 0;
+        struct if_hsi_channel *channel;
+        channel = &hsi_protocol_iface.channels[ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+        ret = if_hsi_write_on(ch, data, count);
+        return ret;
+}
+
+void if_hsi_cancel_read(int ch)
+{
+        struct if_hsi_channel *channel;
+        channel = &hsi_protocol_iface.channels[ch];
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
+        if (channel->state & HSI_CHANNEL_STATE_READING)
+                hsi_read_cancel(channel->dev);
+        spin_lock(&channel->lock);
+        channel->state &= ~HSI_CHANNEL_STATE_READING;
+        spin_unlock(&channel->lock);
+}
+
+void if_hsi_set_wakeline(int ch, unsigned int state)
+{
+        struct if_hsi_channel *channel;
+        channel = &hsi_protocol_iface.channels[ch];
+        hsi_ioctl(channel->dev,
+                  state ? HSI_IOCTL_ACWAKE_UP : HSI_IOCTL_ACWAKE_DOWN, NULL);
+}
+
+
+static void if_hsi_protocol_port_event(struct hsi_device *dev, unsigned int event,
+                              void *arg)
+{
+	struct hsi_event ev;
+        int i;
+
+        ev.event = HSI_EV_EXCEP;
+        ev.data = (u32 *) 0;
+        ev.count = 0;
+
+
+	switch (event) {
+	case HSI_EVENT_BREAK_DETECTED:
+		pr_debug("%s, HWBREAK detected\n", __func__);
+                ev.data = (u32 *) HSI_HWBREAK;
+                for (i = 0; i < HSI_MAX_CHANNELS; i++) {
+                        if (hsi_protocol_iface.channels[i].opened)
+                                if_notify(i, &ev);
+                }
+		break;
+	case HSI_EVENT_HSR_DATAAVAILABLE:
+		i = (int)arg;
+                pr_debug("%s, HSI_EVENT_HSR_DATAAVAILABLE channel = %d\n",
+                         __func__, i);
+                ev.event = HSI_EV_AVAIL;
+                if (hsi_protocol_iface.channels[i].opened)
+                        if_notify(i, &ev);
+		break;
+	case HSI_EVENT_CAWAKE_UP:
+		pr_debug("%s, CAWAKE up\n", __func__);
+		break;
+	case HSI_EVENT_CAWAKE_DOWN:
+		pr_debug("%s, CAWAKE down\n", __func__);
+		break;
+	case HSI_EVENT_ERROR:
+		pr_debug("%s, HSI ERROR occured\n", __func__);
+		break;
+	default:
+		pr_warning("%s, Unknown event(%d)\n", __func__, event);
+		break;
+	}
+}
+
+int if_hsi_openchannel(struct if_hsi_channel *channel)
+{
+        int ret = 0;
+
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__,
+                channel->channel_id);
+        spin_lock(&channel->lock);
+
+        if (channel->state == HSI_CHANNEL_STATE_UNAVAIL){
+                ret = -ENODEV;
+		goto leave;		
+	}
+
+        if (channel->opened) {
+                ret = -EBUSY;
+                goto leave;
+        }
+
+        if (!channel->dev) {
+                pr_err("Channel %d is not ready??\n", channel->channel_id);
+                ret = -ENODEV;
+                goto leave;
+        }
+        spin_unlock(&channel->lock);
+
+        ret = hsi_open(channel->dev);
+        spin_lock(&channel->lock);
+        if (ret < 0) {
+                pr_err("Could not open channel %d\n", channel->channel_id);
+                goto leave;
+        }
+
+        channel->opened = 1;
+	channel->tx_state = HSI_LL_TX_STATE_IDLE;
+	channel->rx_state = HSI_LL_RX_STATE_IDLE;
+	printk("setting channel->opened=1 for channel %d\n", channel->dev->n_ch);
+leave:
+        spin_unlock(&channel->lock);
+        return ret;
+}
+
+int if_hsi_closechannel(struct if_hsi_channel *channel)
+{
+        int ret = 0;
+
+        dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__,
+                channel->channel_id);
+        spin_lock(&channel->lock);
+
+        if (!channel->opened)
+                goto leave;
+
+        if (!channel->dev) {
+                pr_err("Channel %d is not ready??\n", channel->channel_id);
+                ret = -ENODEV;
+                goto leave;
+        }
+
+        /* Stop any pending read/write */
+        if (channel->state & HSI_CHANNEL_STATE_READING) {
+                channel->state &= ~HSI_CHANNEL_STATE_READING;
+        	spin_unlock(&channel->lock);
+                hsi_read_cancel(channel->dev);
+        	spin_lock(&channel->lock);
+        }
+        if (channel->state & HSI_CHANNEL_STATE_WRITING) {
+                channel->state &= ~HSI_CHANNEL_STATE_WRITING;
+
+        	spin_unlock(&channel->lock);
+                hsi_write_cancel(channel->dev);
+        }else
+        	spin_unlock(&channel->lock);
+        	
+	hsi_close(channel->dev);
+
+       	spin_lock(&channel->lock);
+        channel->opened = 0;
+	channel->tx_state = HSI_LL_TX_STATE_CLOSED;
+	channel->rx_state = HSI_LL_RX_STATE_CLOSED;
+leave:
+        spin_unlock(&channel->lock);
+        return ret;
+}
+
+
+/* Read Thread
+* Should be responsible for handling commands
+* Should wait on port events - waitqueue
+* 
+*/
+static int hsi_read_thrd(void *data)
+{
+	u32 cmd_data[4], cmd, channel, param ;
+	int ret;
+
+	printk("Inside read thread\n");
+	while(1){
+		/*Call hsi_proto_read*/
+		/*Read 16 bytes due to Modem limitation*/
+		hsi_proto_read(0,&cmd_data, (4 * 4));
+		printk("hsi_proto_read returned\n");
+
+		/*Decode Command*/
+		ret = hsi_decode_cmd(&cmd_data[0], &cmd, &channel, &param);
+		if(ret != 0){
+			pr_err("Can not decode command\n");
+			}else{
+				printk("cmd is %x\n",cmd);
+				/*Rx State Machine*/
+				rx_stm(cmd, channel, param);
+			}
+		}		
+	return 0;
+}
+
+
+int hsi_start_protocol(void)
+{
+	struct hst_ctx tx_config;
+	struct hsr_ctx rx_config;
+	int ret = 0;
+
+	printk("In function  %s()\n",__func__);	
+	/*Open channel 0 */
+	ret = if_hsi_openchannel(&hsi_protocol_iface.channels[0]);
+	if (ret < 0){
+		pr_err("Can not Open channel 0. Can not start HSI protocol \n");
+		goto err;
+	}else
+		printk("if_hsi_openchannel() returned %d\n", ret);
+
+	/*Set Rx Config*/
+	hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_GET_RX, &rx_config);
+	rx_config.mode = 2;
+	rx_config.channels = HSI_MAX_CHANNELS;
+	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_RX, &rx_config);
+	if ( ret == 0)
+		printk ("SET_RX Successful\n");
+	
+	/*Set Tx Config*/
+	hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_GET_TX, &tx_config);
+	tx_config.mode = 2;
+	tx_config.channels = HSI_MAX_CHANNELS;
+	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_TX, &tx_config);
+	if ( ret == 0)
+		printk ("SET_TX Successful\n");
+	
+	/* Making ACWAKE HIGH here as clocks are disabled otherwise*/
+	//hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
+	
+	/*Create read thread*/
+	//read_thread = kthread_run(hsi_read_thrd, NULL, "hsi_read_thread");
+err: 
+	return ret;
+}
+EXPORT_SYMBOL(hsi_start_protocol);
+
+int __devexit hsi_protocol_remove(struct hsi_device *dev)
+{
+	struct if_hsi_channel *channel;
+        unsigned long *address;
+        int port, ret;
+
+        //dev_dbg(&dev->device, "%s, port = %d, ch = %d\n", __func__, dev->n_p,
+          //      dev->n_ch);
+
+        for (port = 0; port < HSI_MAX_PORTS; port++) {
+                if (if_hsi_protocol_driver.ch_mask[port])
+                        break;
+        }
+
+        address = &if_hsi_protocol_driver.ch_mask[port];
+
+        spin_lock_bh(&hsi_protocol_iface.lock);
+        if (test_bit(dev->n_ch, address) && (dev->n_p == port)) {
+                hsi_set_read_cb(dev, NULL);
+                hsi_set_write_cb(dev, NULL);
+		hsi_set_port_event_cb(dev, NULL);
+                channel = &hsi_protocol_iface.channels[dev->n_ch];
+                channel->dev = NULL;
+                channel->state = HSI_CHANNEL_STATE_UNAVAIL;
+                ret = 0;
+        }
+        spin_unlock_bh(&hsi_protocol_iface.lock);
+
+	return ret;
+}
+
+int __devinit hsi_protocol_probe(struct hsi_device *dev)
+{
+	struct if_hsi_channel *channel;
+	unsigned long *address;
+	int port;
+
+	printk("Inside Function %s\n", __func__);
+	for (port = 0; port < HSI_MAX_PORTS; port++) {
+                if (if_hsi_protocol_driver.ch_mask[port])
+                        break;
+        }
+	
+	address = &if_hsi_protocol_driver.ch_mask[port];
+
+	spin_lock_bh(&hsi_protocol_iface.lock);
+	if (test_bit(dev->n_ch, address) && (dev->n_p == port)) {
+		printk("Regestering callback functions\n");
+		hsi_set_read_cb(dev, if_hsi_proto_read_done);
+		hsi_set_write_cb(dev, if_hsi_proto_write_done);
+		hsi_set_port_event_cb(dev, if_hsi_protocol_port_event);
+		channel = &hsi_protocol_iface.channels[dev->n_ch];
+		channel->dev = dev;
+		channel->state = 0;
+		channel->rx_state = HSI_LL_RX_STATE_CLOSED;
+		channel->tx_state = HSI_LL_TX_STATE_CLOSED;
+		channel->rx_buf = NULL;
+		channel->tx_buf = NULL;
+		hsi_protocol_iface.init_chan_map ^= (1 << dev->n_ch);
+	}
+	spin_unlock_bh(&hsi_protocol_iface.lock);
+
+	//hsi_start_protocol();	
+/*	printk("Starting write_hsi() function\n");	
+	port = write_hsi(0, data, 4);
+	printk("write_hsi returned %d\n",port);	*/
+	return 0;
+	
+}
+
+
+int __init if_hsi_init(void)
+{
+	struct if_hsi_channel *channel;
+	int i, ret;
+		
+	for (i = 0; i < HSI_MAX_PORTS; i++)
+                if_hsi_protocol_driver.ch_mask[i] = 0;
+	
+	for (i = 0; i < HSI_MAX_CHANNELS; i++) {
+                channel = &hsi_protocol_iface.channels[i];
+                channel->dev = NULL;
+                channel->opened = 0;
+                channel->state = HSI_CHANNEL_STATE_UNAVAIL;
+                channel->channel_id = i;
+                spin_lock_init(&channel->lock);
+        }
+
+	/*Initialize waitqueue for IPC read*/
+	init_waitqueue_head(&ipc_read_wait);
+	init_waitqueue_head(&ipc_write_wait);
+	
+	/*Select All Channels of PORT-1.*/
+	if_hsi_protocol_driver.ch_mask[0] = CHANNEL_MASK; 
+
+	ret = hsi_register_driver(&if_hsi_protocol_driver);
+	if (ret)
+		pr_err("Error while registering HSI driver %d", ret);
+
+	return ret;
+}
+
+int __devexit if_hsi_exit(void)
+{
+	struct if_hsi_channel *channel;
+        unsigned long *address;
+        int i, port;
+
+        pr_debug("%s\n", __func__);
+
+        for (port = 0; port < HSI_MAX_PORTS; port++) {
+                if (if_hsi_protocol_driver.ch_mask[port])
+                        break;
+        }
+
+        address = &if_hsi_protocol_driver.ch_mask[port];
+
+        for (i = 0; i < HSI_MAX_CHANNELS; i++) {
+                channel = &hsi_protocol_iface.channels[i];
+                if (channel->opened) {
+                        if_hsi_set_wakeline(i, HSI_IOCTL_ACWAKE_DOWN);
+                        if_hsi_closechannel(channel);
+                }
+        }
+
+	hsi_unregister_driver(&if_hsi_protocol_driver);
+	return 0;
+
+}
+
+int write_hsi_direct( u32 *data, int length )
+{
+	int retval = 0;
+	struct hst_ctx tx_config;
+
+	printk( "write_hsi_direct : len : %d\n", length );
+
+	hsi_ioctl( hsi_protocol_iface.channels[ 0 ].dev, HSI_IOCTL_GET_TX, &tx_config );
+	tx_config.mode = 2;
+	tx_config.channels = 1;
+	tx_config.divisor = 47;
+	retval = hsi_ioctl( hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_TX, &tx_config);
+	if ( retval < 0 ) {
+		printk( "write_hsi_direct : SET_TX Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "write_hsi_direct : SET_TX Successful\n" );
+
+	retval = hsi_ioctl( hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL );
+	if( retval < 0 ) {
+		printk("write_hsi_direct : ACWAKE High Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "write_hsi_direct : ACWAKE High\n" );
+
+	if( ( length > 16 ) || ( length % 4 ) ) {
+		length += ( 4 - ( length % 4 ) );
+	}
+	else if( length < 16 ) {
+		length = 16;
+	}
+	printk( "write_hsi_direct : new len : %d\n", length );
+	
+	retval = hsi_proto_write( 0, data, length );
+	if( retval < 0 ) {
+		printk( "write_hsi_direct : hsi_proto_write Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "write_hsi_direct : Write returned %d\n", retval );
+
+	return retval;
+}
+EXPORT_SYMBOL( write_hsi_direct );
+
+int read_hsi_direct( u32 *data, int length )
+{
+	int retval = 0;
+	struct hsr_ctx rx_config;
+
+	printk( "read_hsi_direct : len : %d\n", length );
+
+	hsi_ioctl( hsi_protocol_iface.channels[ 0 ].dev, HSI_IOCTL_GET_RX, &rx_config );
+	rx_config.mode = 2;
+	rx_config.channels = 1;
+	rx_config.divisor = 47;
+	retval = hsi_ioctl( hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_RX, &rx_config);
+	if( retval < 0 ) {
+		printk( "read_hsi_direct : SET_RX Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "read_hsi_direct : SET_RX Successful\n" );
+
+	retval = hsi_ioctl( hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL );
+	if( retval < 0 ) {
+		printk("read_hsi_direct : ACWAKE High Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "read_hsi_direct : ACWAKE High\n" );
+
+	if( ( length > 16 ) || ( length % 4 ) ) {
+		length += ( 4 - ( length % 4 ) );
+	}
+	else if( length < 16 ) {
+		length = 16;
+	}
+	printk( "read_hsi_direct : new len : %d\n", length );
+	
+	retval = hsi_proto_read( 0, data, length );
+	if( retval < 0 ) {
+		printk( "read_hsi_direct : hsi_proto_read Fail : %d\n", retval );
+		return retval;
+	}
+	printk( "read_hsi_direct : Read returned %d\n", retval );
+
+	return retval;
+}
+EXPORT_SYMBOL( read_hsi_direct );
+
+u32 initialization = 0;
+
+/*write data to channel*/
+int write_hsi(u32 ch, u32 *data, int length)
+{
+	int ret;	
+	u32 cmd[4] = {0, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC};
+	struct if_hsi_channel *channel;
+	struct task_struct *read_thread;
+
+	channel = &hsi_protocol_iface.channels[ch];
+	channel->tx_buf = data;	
+	actual_write = 0;
+
+	cmd[0] = protocol_create_cmd(HSI_LL_MSG_OPEN_CONN_OCTET, ch, (void *)&length);
+	printk("data ptr is %x\n", data); 
+
+	if (initialization == 0){
+		/* ACWAKE ->HIGH */
+		ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
+		if(ret == 0)
+			printk("ACWAKE pulled high in %s()\n",__func__);
+
+		/*Creating read thread*/
+		read_thread = kthread_run(hsi_read_thrd, NULL, "hsi_read_thread");
+	
+		initialization++;
+	}
+
+	channel->tx_state = HSI_LL_TX_STATE_WAIT_FOR_ACK;
+	
+	//send_cmd(cmd, channel, data)
+	ret = hsi_proto_write(0, &cmd, 4*4);
+	printk("Write returned %d\n", ret); 	
+
+	wait_event_interruptible(ipc_write_wait, actual_write != 0);
+
+	return	actual_write;
+
+
+/*	printk("%s() Opening channel %d\n", __func__, channel);
+	ret = if_hsi_openchannel(&hsi_protocol_iface.channels[channel]);
+	if (ret < 0){
+		pr_err("Can not Open channel 0. Can not start HSI protocol \n");
+		//Close Channel
+		if_hsi_closechannel(&hsi_protocol_iface.channels[channel]);
+		return -1;
+
+	}else{
+	//Send Data
+	printk("Channel Open successful. ret = %d, func-%s\n", ret, __func__);
+	ret = hsi_proto_write(channel, data, length);
+	//Close Channel
+	if_hsi_closechannel(&hsi_protocol_iface.channels[channel]);*/
+}
+EXPORT_SYMBOL(write_hsi);
+
+
+int read_hsi(u8 *data, u32 *ch, u32 *length)
+{
+	int ret, size, tmp;
+	struct if_hsi_channel *channel;
+
+	printk("In read_hsi() function, Sleeping ...\n");
+	wait_event_interruptible(ipc_read_wait,(avlb_length != 0));
+	printk("In read_hsi() function, Waking Up ...\n");
+
+	channel = &hsi_protocol_iface.channels[avlb_ch];	
+	
+	size = avlb_length;
+	if ((size > 16) && (size % 4))
+		size += (4 - (size % 4));
+	else if (size < 16)
+		size = 16;
+	ret = hsi_proto_read(avlb_ch, data, size);
+	if( ret < 0)
+		printk("Read in IPC failed, %s()\n",__func__);
+	
+	printk("%s() read returned %d, actual_length = %d, ch-> %d\n",__func__, ret,avlb_length, avlb_ch);
+	tmp = if_hsi_closechannel(channel);
+	printk("%s() closed channel, sending CONN_CLOSED. ret = %d\n",__func__, tmp);
+	tmp = hsi_protocol_send_command(HSI_LL_MSG_CONN_CLOSED, avlb_ch, 0);
+	printk("%s() Sending CONN_CLOSED Finished. ret = %d\n",__func__, tmp);
+	
+	*ch = avlb_ch;
+	*length = avlb_length;
+	avlb_length = 0;
+	
+	printk("%s() RETURNING TO IPC with ret = %d\n",__func__, ret);
+	return ret;
+
+}
+EXPORT_SYMBOL(read_hsi);
+
+
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/hsi-protocol-if.h Kernel/drivers/staging/omap_hsi/hsi-protocol-if.h
--- Kernel-org/drivers/staging/omap_hsi/hsi-protocol-if.h	1970-01-01 05:30:00.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi-protocol-if.h	2011-01-20 23:57:27.891516854 +0530
@@ -0,0 +1,173 @@
+/*
+ * hsi-if.h
+ *
+ * Part of the HSI character driver, private headers.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Author: Andras Domokos <andras.domokos@nokia.com>
+ * Author: Sebastien JAN <s-jan@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _HSI_IF_H
+#define _HSI_IF_H
+
+#define HSI_EV_MASK		(0xffff << 0)
+#define HSI_EV_TYPE_MASK	(0x0f << 16)
+#define HSI_EV_IN		(0x01 << 16)
+#define HSI_EV_OUT		(0x02 << 16)
+#define HSI_EV_EXCEP		(0x03 << 16)
+#define HSI_EV_AVAIL		(0x04 << 16)
+#define HSI_EV_TYPE(event)	((event) & HSI_EV_TYPE_MASK)
+
+#define HSI_HWBREAK		1
+#define HSI_ERROR		2
+
+#define HSI_MAX_CHANNELS	16 
+#define CHANNEL_MASK		0xFF
+#define HSI_LL_INVALID_CHANNEL	0xFF
+
+struct hsi_event {
+	unsigned int event;
+	u32 *data;
+	unsigned int count;
+};
+
+struct if_hsi_channel {
+        struct hsi_device *dev;
+        unsigned int channel_id;
+        u32 *tx_data;
+        unsigned int tx_count;
+        u32 *rx_data;
+        unsigned int rx_count;
+        unsigned int opened;
+        unsigned int state;
+	u32 *tx_buf;
+	u32 *rx_buf;
+	unsigned int tx_state;
+	unsigned int rx_state;
+        spinlock_t lock; /* Serializes access to channel data */
+};
+
+struct if_hsi_iface {
+	struct if_hsi_channel channels[HSI_MAX_CHANNELS];
+        //int bootstrap;
+        unsigned long init_chan_map;
+        spinlock_t lock; /* Serializes access to HSI functional interface */
+};
+
+enum {
+  HSI_LL_MSG_BREAK           = 0x00,
+  HSI_LL_MSG_ECHO            = 0x01,
+  HSI_LL_MSG_INFO_REQ        = 0x02,
+  HSI_LL_MSG_INFO            = 0x03,
+  HSI_LL_MSG_CONFIGURE       = 0x04,
+  HSI_LL_MSG_ALLOCATE_CH     = 0x05,
+  HSI_LL_MSG_RELEASE_CH      = 0x06,
+  HSI_LL_MSG_OPEN_CONN       = 0x07,
+  HSI_LL_MSG_CONN_READY      = 0x08,
+  HSI_LL_MSG_CONN_CLOSED     = 0x09,
+  HSI_LL_MSG_CANCEL_CONN     = 0x0A,
+  HSI_LL_MSG_ACK             = 0x0B,
+  HSI_LL_MSG_NAK             = 0x0C,
+  HSI_LL_MSG_CONF_RATE       = 0x0D,
+  HSI_LL_MSG_OPEN_CONN_OCTET = 0x0E,
+  HSI_LL_MSG_INVALID         = 0xFF,
+};
+
+enum
+{
+  HSI_LL_TX_STATE_UNDEF,
+  HSI_LL_TX_STATE_CLOSED,
+  HSI_LL_TX_STATE_IDLE,
+  HSI_LL_TX_STATE_POWER_DOWN,
+  HSI_LL_TX_STATE_ERROR,
+  HSI_LL_TX_STATE_SEND_OPEN_CONN,
+  HSI_LL_TX_STATE_WAIT_FOR_ACK,
+  HSI_LL_TX_STATE_NACK,
+  HSI_LL_TX_STATE_WAIT_FOR_CONN_READY,
+  HSI_LL_TX_STATE_SEND_CONF_RATE,
+  HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK,
+  HSI_LL_TX_STATE_TX,
+  HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED,
+  HSI_LL_TX_STATE_TO_OPEN_CONN,
+  HSI_LL_TX_STATE_TO_ACK,
+  HSI_LL_TX_STATE_TO_READY,
+  HSI_LL_TX_STATE_TO_CONF,
+  HSI_LL_TX_STATE_TO_CONF_ACK,
+  HSI_LL_TX_STATE_TO_TX,
+  HSI_LL_TX_STATE_TO_CLOSE,
+  HSI_LL_TX_STATE_SEND_BREAK,
+};
+
+enum {
+  HSI_LL_RX_STATE_UNDEF,
+  HSI_LL_RX_STATE_CLOSED,
+  HSI_LL_RX_STATE_IDLE,
+  HSI_LL_RX_STATE_POWER_DOWN,
+  HSI_LL_RX_STATE_ERROR,
+  HSI_LL_RX_STATE_BLOCKED,
+  HSI_LL_RX_STATE_SEND_ACK,
+  HSI_LL_RX_STATE_SEND_NACK,
+  HSI_LL_RX_STATE_SEND_CONN_READY,
+  HSI_LL_RX_STATE_RX,
+  HSI_LL_RX_STATE_SEND_CONN_CLOSED,
+  HSI_LL_RX_STATE_SEND_CONN_CANCEL,
+  HSI_LL_RX_STATE_WAIT_FOR_CANCEL_CONN_ACK,
+  HSI_LL_RX_STATE_SEND_CONF_ACK,
+  HSI_LL_RX_STATE_SEND_CONF_NACK,
+  HSI_LL_RX_STATE_TO_RX,
+  HSI_LL_RX_STATE_TO_ACK,
+  HSI_LL_RX_STATE_TO_NACK,
+  HSI_LL_RX_STATE_TO_CONN_READY,
+  HSI_LL_RX_STATE_TO_CONN_CLOSED,
+  HSI_LL_RX_STATE_TO_CONN_CANCEL,
+  HSI_LL_RX_STATE_TO_CONN_CANCEL_ACK,
+  HSI_LL_RX_STATE_TO_CONF_ACK,
+  HSI_LL_RX_STATE_SEND_BREAK,
+};
+
+
+int if_hsi_init(void);
+int if_hsi_exit(void);
+
+int if_hsi_start(int ch);
+void if_hsi_stop(int ch);
+
+void if_hsi_send_break(int ch);
+void if_hsi_flush_rx(int ch);
+void if_hsi_flush_tx(int ch);
+void if_hsi_bootstrap(int ch);
+void if_hsi_set_wakeline(int ch, unsigned int state);
+void if_hsi_get_wakeline(int ch, unsigned int *state);
+
+//int if_hsi_set_rx(int ch, struct hsi_rx_config *cfg);
+//void if_hsi_get_rx(int ch, struct hsi_rx_config *cfg);
+//int if_hsi_set_tx(int ch, struct hsi_tx_config *cfg);
+//void if_hsi_get_tx(int ch, struct hsi_tx_config *cfg);
+
+int if_hsi_read(int ch, u32 *data, unsigned int count);
+int if_hsi_poll(int ch);
+int if_hsi_write(int ch, u32 *data, unsigned int count);
+
+void if_hsi_cancel_read(int ch);
+void if_hsi_cancel_write(int ch);
+
+void if_notify(int ch, struct hsi_event *ev);
+int hsi_proto_read(int ch, u32 *buffer, int count);
+int hsi_proto_write(int ch, u32 *buffer, int length);
+int hsi_decode_cmd( u32 *data, u32 *cmd, u32 *ch, u32 *param);
+int protocol_create_cmd(int cmd_type, unsigned int channel, void *arg);
+int hsi_protocol_send_command(u32 cmd, u32 channel, u32 param);
+void rx_stm(u32 cmd, u32 ch, u32 param);
+//int hsi_start_protocol(void);
+#endif /* _HSI_IF_H */
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/Kconfig Kernel/drivers/staging/omap_hsi/Kconfig
--- Kernel-org/drivers/staging/omap_hsi/Kconfig	2010-12-31 16:25:39.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/Kconfig	2011-01-20 23:57:27.881516910 +0530
@@ -56,3 +56,10 @@
 	  If you say Y here, you will enable the OMAP HSI character driver.
 	  This driver provides a simple character device interface for
 	  serial communication over the HSI bus.
+
+config OMAP_HSI_PROTOCOL
+        tristate "HSI Protocol driver for Infineon Modem"
+        depends on OMAP_HSI
+        ---help---
+          If you say Y here, you will enable the HSI Protocol driver.
+          This driver supports HSI protocol for Infineon Modem.
diff -urN -x patches -x .git -x .gitignore -x modules.builtin -x .mailmap -x .pc Kernel-org/drivers/staging/omap_hsi/Makefile Kernel/drivers/staging/omap_hsi/Makefile
--- Kernel-org/drivers/staging/omap_hsi/Makefile	2010-12-31 16:25:39.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/Makefile	2011-01-20 23:57:27.881516910 +0530
@@ -13,5 +13,9 @@
 
 hsi_char-objs	:=	hsi-char.o hsi-if.o
 
+hsi-protocol-objs    := hsi_protocol.o hsi_protocol_if.o \
+                        hsi_protocol_cmd.o
+
 obj-$(CONFIG_OMAP_HSI)		+= omap_hsi.o
-obj-$(CONFIG_OMAP_HSI_CHAR)	+= hsi_char.o
\ No newline at end of file
+obj-$(CONFIG_OMAP_HSI_CHAR)	+= hsi_char.o
+obj-$(CONFIG_OMAP_HSI_PROTOCOL) += hsi-protocol.o
