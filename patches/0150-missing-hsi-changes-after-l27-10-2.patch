diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/mach-omap2/board-4430sdp.c Kernel/arch/arm/mach-omap2/board-4430sdp.c
--- Kernel-orig/arch/arm/mach-omap2/board-4430sdp.c	2011-02-07 09:37:28.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/board-4430sdp.c	2011-02-09 13:07:22.887773152 +0530
@@ -1269,6 +1269,13 @@
 	 */
 	omap_mux_enable_wakeup("sys_nirq1");
 	omap_mux_enable_wakeup("sys_nirq2");
+
+	/*
+	 * Enable IO daisy for HSI CAWAKE line, to be able to
+	 * wakeup from interrupts from Modem.
+	 * Needed only in Device OFF mode.
+	 */
+	omap_mux_enable_wakeup("usbb1_ulpitll_clk.hsi1_cawake");
 }
 
 static struct omap_volt_pmic_info omap_pmic_core = {
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/mach-omap2/omap_hsi.c Kernel/arch/arm/mach-omap2/omap_hsi.c
--- Kernel-orig/arch/arm/mach-omap2/omap_hsi.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/omap_hsi.c	2011-02-09 13:07:22.887773152 +0530
@@ -34,154 +34,97 @@
 #define OMAP_HSI_HWMOD_NAME  "hsi"
 #define OMAP_HSI_HWMOD_CLASSNAME  "hsi"
 
-#define	hsi_inl(p)	inl((unsigned long) p)
-#define	hsi_outl(v, p)	outl(v, (unsigned long) p)
-
-#ifdef HSI_CONTEXT_SAVE_RESTORE
-static void hsi_set_mode(struct platform_device *pdev, u32 mode)
-{
-	struct hsi_platform_data *pdata = pdev->dev.platform_data;
-	void __iomem *base = OMAP2_IO_ADDRESS(pdev->resource[0].start);
-	int port;
-
-	for (port = 1; port <= pdata->num_ports; port++) {
-		/* FIXME - to update: need read/modify/write or something else:
-		 * this register now also contains flow and wake ctrl
-		 */
-		hsi_outl(mode, base + HSI_HST_MODE_REG(port));
-		hsi_outl(mode, base + HSI_HSR_MODE_REG(port));
-	}
-}
-
-static void hsi_save_mode(struct platform_device *pdev)
-{
-	struct hsi_platform_data *pdata = pdev->dev.platform_data;
-	void __iomem *base = OMAP2_IO_ADDRESS(pdev->resource[0].start);
-	struct port_ctx *p;
-	int port;
-
-	for (port = 1; port <= pdata->num_ports; port++) {
-		p = &pdata->ctx.pctx[port - 1];
-		p->hst.mode = hsi_inl(base + HSI_HST_MODE_REG(port));
-		p->hsr.mode = hsi_inl(base + HSI_HSR_MODE_REG(port));
-	}
-}
-
-static void hsi_restore_mode(struct platform_device *pdev)
-{
-	struct hsi_platform_data *pdata = pdev->dev.platform_data;
-	void __iomem *base = OMAP2_IO_ADDRESS(pdev->resource[0].start);
-	struct port_ctx *p;
-	int port;
-
-	for (port = 1; port <= pdata->num_ports; port++) {
-		p = &pdata->ctx.pctx[port - 1];
-		hsi_outl(p->hst.mode, base + HSI_HST_MODE_REG(port));
-		hsi_outl(p->hsr.mode, base + HSI_HSR_MODE_REG(port));
-	}
-}
-#endif /* HSI_CONTEXT_SAVE_RESTORE */
-
-#ifdef HSI_CONTEXT_SAVE_RESTORE
-static void hsi_save_ctx(struct platform_device *pdev)
-{
-	struct hsi_platform_data *pdata = pdev->dev.platform_data;
-	void __iomem *base = OMAP2_IO_ADDRESS(pdev->resource[0].start);
-	struct port_ctx *p;
-	int port;
-
-	pdata->ctx.loss_count = omap_pm_get_dev_context_loss_count(&pdev->dev);
-	pdata->ctx.sysconfig = hsi_inl(base + HSI_SYS_SYSCONFIG_REG);
-	pdata->ctx.gdd_gcr = hsi_inl(base + HSI_GDD_GCR_REG);
-	for (port = 1; port <= pdata->num_ports; port++) {
-		p = &pdata->ctx.pctx[port - 1];
-		p->sys_mpu_enable[0] = hsi_inl(base +
-					       HSI_SYS_MPU_ENABLE_REG(port, 0));
-		p->sys_mpu_enable[1] = hsi_inl(base +
-					       HSI_SYS_MPU_U_ENABLE_REG(port,
-									0));
-		p->hst.frame_size = hsi_inl(base + HSI_HST_FRAMESIZE_REG(port));
-		p->hst.divisor = hsi_inl(base + HSI_HST_DIVISOR_REG(port));
-		p->hst.channels = hsi_inl(base + HSI_HST_CHANNELS_REG(port));
-		p->hst.arb_mode = hsi_inl(base + HSI_HST_ARBMODE_REG(port));
-		p->hsr.frame_size = hsi_inl(base + HSI_HSR_FRAMESIZE_REG(port));
-/*FIXME - check this register*/
-		p->hsr.timeout = hsi_inl(base + HSI_HSR_COUNTERS_REG(port));
-		p->hsr.channels = hsi_inl(base + HSI_HSR_CHANNELS_REG(port));
-	}
-}
-
-static void hsi_restore_ctx(struct platform_device *pdev)
-{
-	struct hsi_platform_data *pdata = pdev->dev.platform_data;
-	void __iomem *base = OMAP2_IO_ADDRESS(pdev->resource[0].start);
-	struct port_ctx *p;
-	int port;
-	int loss_count;
-
-	loss_count = omap_pm_get_dev_context_loss_count(&pdev->dev);
-
-	if (loss_count == pdata->ctx.loss_count)
-		return;
-
-	hsi_outl(pdata->ctx.sysconfig, base + HSI_SYS_SYSCONFIG_REG);
-	hsi_outl(pdata->ctx.gdd_gcr, base + HSI_GDD_GCR_REG);
-	for (port = 1; port <= pdata->num_ports; port++) {
-		p = &pdata->ctx.pctx[port - 1];
-		hsi_outl(p->sys_mpu_enable[0], base +
-			 HSI_SYS_MPU_ENABLE_REG(port, 0));
-		hsi_outl(p->sys_mpu_enable[1], base +
-			 HSI_SYS_MPU_U_ENABLE_REG(port, 0));
-		hsi_outl(p->hst.frame_size, base + HSI_HST_FRAMESIZE_REG(port));
-		hsi_outl(p->hst.divisor, base + HSI_HST_DIVISOR_REG(port));
-		hsi_outl(p->hst.channels, base + HSI_HST_CHANNELS_REG(port));
-		hsi_outl(p->hst.arb_mode, base + HSI_HST_ARBMODE_REG(port));
-		hsi_outl(p->hsr.frame_size, base + HSI_HSR_FRAMESIZE_REG(port));
-/* FIXME - check this register */
-		hsi_outl(p->hsr.timeout, base + HSI_HSR_COUNTERS_REG(port));
-		hsi_outl(p->hsr.channels, base + HSI_HSR_CHANNELS_REG(port));
-	}
-}
-#endif /* HSI_CONTEXT_SAVE_RESTORE */
 
 /*
  * NOTE: We abuse a little bit the struct port_ctx to use it also for
  * initialization.
  */
+
+
 static struct port_ctx hsi_port_ctx[] = {
 	[0] = {
 	       .hst.mode = HSI_MODE_FRAME,
 	       .hst.flow = HSI_FLOW_SYNCHRONIZED,
 	       .hst.frame_size = HSI_FRAMESIZE_DEFAULT,
-	       .hst.divisor = 1,
+	       .hst.divisor = HSI_DIVISOR_DEFAULT,
 	       .hst.channels = HSI_CHANNELS_DEFAULT,
 	       .hst.arb_mode = HSI_ARBMODE_ROUNDROBIN,
 	       .hsr.mode = HSI_MODE_FRAME,
 	       .hsr.flow = HSI_FLOW_SYNCHRONIZED,
 	       .hsr.frame_size = HSI_FRAMESIZE_DEFAULT,
 	       .hsr.channels = HSI_CHANNELS_DEFAULT,
-	       .hsr.divisor = 1,
-	       .hsr.timeout = HSI_COUNTERS_FT_DEFAULT |
-	       HSI_COUNTERS_TB_DEFAULT | HSI_COUNTERS_FB_DEFAULT,
+	       .hsr.divisor = HSI_DIVISOR_DEFAULT,
+	       .hsr.counters = HSI_COUNTERS_FT_DEFAULT |
+			       HSI_COUNTERS_TB_DEFAULT |
+			       HSI_COUNTERS_FB_DEFAULT,
 	       },
 };
 
+static struct ctrl_ctx hsi_ctx = {
+		.sysconfig = 0,
+		.gdd_gcr = 0,
+		.dll = 0,
+		.pctx = hsi_port_ctx,
+};
+
 static struct hsi_platform_data omap_hsi_platform_data = {
 	.num_ports = ARRAY_SIZE(hsi_port_ctx),
 	.hsi_gdd_chan_count = HSI_HSI_DMA_CHANNEL_MAX,
-	.ctx.pctx = hsi_port_ctx,
+	.default_hsi_fclk = HSI_DEFAULT_FCLK,
+	.ctx = &hsi_ctx,
 	.device_enable = omap_device_enable,
 	.device_idle = omap_device_idle,
 	.device_shutdown = omap_device_shutdown,
 };
 
+/**
+* hsi_idle_hwmod - This function is a used to workaround the omap_hwmod layer
+*			which might sleep when omap_hwmod_idle() is called,
+*			and thus cannot be called from atomic context.
+*
+* @od - reference to the hsi omap_device.
+*
+* Note : a "normal" .deactivate_func shall be omap_device_idle_hwmods()
+*/
+static int hsi_idle_hwmod(struct omap_device *od)
+{
+	/* HSI omap_device only contain one od->hwmods[0], so no need to */
+	/* loop for all hwmods */
+	if (irqs_disabled())
+		_omap_hwmod_idle(od->hwmods[0]);
+	else
+		omap_hwmod_idle(od->hwmods[0]);
+	return 0;
+}
+
+/**
+* hsi_enable_hwmod - This function is a used to workaround the omap_hwmod layer
+*			which might sleep when omap_hwmod_enable() is called,
+*			and thus cannot be called from atomic context.
+*
+* @od - reference to the hsi omap_device.
+*
+* Note : a "normal" .activate_func shall be omap_device_enable_hwmods()
+*/
+static int hsi_enable_hwmod(struct omap_device *od)
+{
+	/* HSI omap_device only contain one od->hwmods[0], so no need to */
+	/* loop for all hwmods */
+	if (irqs_disabled())
+		_omap_hwmod_enable(od->hwmods[0]);
+	else
+		omap_hwmod_enable(od->hwmods[0]);
+	return 0;
+}
+
+
 /* HSI_TODO : This requires some fine tuning & completion of
  * activate/deactivate latency values
  */
 static struct omap_device_pm_latency omap_hsi_latency[] = {
 	[0] = {
-	       .deactivate_func = omap_device_idle_hwmods,
-	       .activate_func = omap_device_enable_hwmods,
+	       .deactivate_func = hsi_idle_hwmod,
+	       .activate_func = hsi_enable_hwmod,
 	       .flags = OMAP_DEVICE_LATENCY_AUTO_ADJUST,
 	       },
 };
@@ -201,7 +144,7 @@
 	od = omap_device_build(OMAP_HSI_PLATFORM_DEVICE_DRIVER_NAME, 0, oh,
 			       pdata, sizeof(*pdata), omap_hsi_latency,
 			       ARRAY_SIZE(omap_hsi_latency), false);
-	WARN(IS_ERR(od), "Cant build omap_device for %s:%s.\n",
+	WARN(IS_ERR(od), "Can't build omap_device for %s:%s.\n",
 	     OMAP_HSI_PLATFORM_DEVICE_DRIVER_NAME, oh->name);
 
 	pr_info("HSI: device registered\n");
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/mach-omap2/omap_hwmod_44xx_data.c Kernel/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
--- Kernel-orig/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2011-02-09 13:07:22.927767551 +0530
@@ -2223,9 +2223,9 @@
 
 /* hsi */
 static struct omap_hwmod_irq_info omap44xx_hsi_irqs[] = {
-	{ .name = "mpu_p1", .irq = 67 + OMAP44XX_IRQ_GIC_START },
-	{ .name = "mpu_p2", .irq = 68 + OMAP44XX_IRQ_GIC_START },
-	{ .name = "mpu_dma", .irq = 71 + OMAP44XX_IRQ_GIC_START },
+	{ .name = "hsi_p1_mpu", .irq = 67 + OMAP44XX_IRQ_GIC_START },
+	{ .name = "hsi_p2_mpu", .irq = 68 + OMAP44XX_IRQ_GIC_START },
+	{ .name = "hsi_dma_mpu", .irq = 71 + OMAP44XX_IRQ_GIC_START },
 };
 
 /* hsi master ports */
@@ -2262,6 +2262,7 @@
 	.mpu_irqs	= omap44xx_hsi_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_hsi_irqs),
 	.main_clk	= "hsi_fck",
+	.vdd_name	= "core",
 	.prcm = {
 		.omap4 = {
 			.clkctrl_reg = OMAP4430_CM_L3INIT_HSI_CLKCTRL,
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/mach-omap2/opp44xx_data.c Kernel/arch/arm/mach-omap2/opp44xx_data.c
--- Kernel-orig/arch/arm/mach-omap2/opp44xx_data.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/arch/arm/mach-omap2/opp44xx_data.c	2011-02-09 13:07:22.937768264 +0530
@@ -35,7 +35,7 @@
 static struct clk *dpll_mpu_clk, *iva_clk, *dsp_clk, *l3_clk, *core_m2_clk;
 static struct clk *core_m3_clk, *core_m6_clk, *core_m7_clk;
 static struct clk *per_m3_clk, *per_m6_clk;
-static struct clk *abe_clk, *sgx_clk, *fdif_clk;
+static struct clk *abe_clk, *sgx_clk, *fdif_clk, *hsi_clk;
 
 /*
  * Separate OPP table is needed for pre ES2.1 chips as emif cannot be scaled.
@@ -87,6 +87,10 @@
 	OMAP_OPP_DEF("gpu", true, 153600000, 930000),
 	/* SGX OPP2 - OPP100 */
 	OMAP_OPP_DEF("gpu", true, 307200000, 1100000),
+	/* HSI OPP1 - OPP50 */
+	OMAP_OPP_DEF("hsi", true, 96000000, 930000),
+	/* HSI OPP2 - OPP100 */
+	OMAP_OPP_DEF("hsi", true, 192000000, 1100000),
 };
 
 static struct omap_opp_def __initdata omap44xx_opp_def_list[] = {
@@ -142,6 +146,10 @@
 	OMAP_OPP_DEF("gpu", true, 153600000, 930000),
 	/* SGX OPP2 - OPP100 */
 	OMAP_OPP_DEF("gpu", true, 307200000, 1100000),
+	/* HSI OPP1 - OPP50 */
+	OMAP_OPP_DEF("hsi", true, 96000000, 930000),
+	/* HSI OPP2 - OPP100 */
+	OMAP_OPP_DEF("hsi", true, 192000000, 1100000),
 };
 
 #define	L3_OPP50_RATE			100000000
@@ -309,6 +317,16 @@
 	return fdif_clk->rate ;
 }
 
+static int omap4_hsi_set_rate(struct device *dev, unsigned long rate)
+{
+	return clk_set_rate(hsi_clk, rate);
+}
+
+static unsigned long omap4_hsi_get_rate(struct device *dev)
+{
+	return hsi_clk->rate ;
+}
+
 struct device *find_dev_ptr(char *name)
 {
 
@@ -368,6 +386,7 @@
 	per_m6_clk = clk_get(NULL, "dpll_per_m6x2_ck");
 	abe_clk = clk_get(NULL, "abe_clk");
 	fdif_clk = clk_get(NULL, "fdif_fck");
+	hsi_clk = clk_get(NULL, "hsi_fck");
 
 	/* Set SGX parent to PER DPLL */
 	clk_set_parent(gpu_fclk, sgx_clk);
@@ -426,5 +445,10 @@
 		opp_populate_rate_fns(dev, omap4_fdif_set_rate,
 				omap4_fdif_get_rate);
 
+	dev = find_dev_ptr("hsi");
+	if (dev)
+		opp_populate_rate_fns(dev, omap4_hsi_set_rate,
+				omap4_hsi_get_rate);
+
 	return 0;
 }
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/plat-omap/include/mach/omap_hsi.h Kernel/arch/arm/plat-omap/include/mach/omap_hsi.h
--- Kernel-orig/arch/arm/plat-omap/include/mach/omap_hsi.h	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/arch/arm/plat-omap/include/mach/omap_hsi.h	2011-02-09 13:07:23.017935300 +0530
@@ -28,6 +28,11 @@
 #ifndef __OMAP_HSI_H__
 #define __OMAP_HSI_H__
 
+/* Set the HSI Functional Clock to 96MHz.
+ * This is to ensure HSI will function even at OPP50. */
+#define HSI_DEFAULT_FCLK		96000000	/* 96 MHz */
+
+
 #define HSI_PORT_OFFSET			0x1000
 
 /*
@@ -208,6 +213,7 @@
 
 /* Additional registers for HSI */
 #define	HSI_HST_FIFO_COUNT			16
+#define	HSI_HST_FIFO_SIZE			8
 #define HSI_HST_MAPPING_FIFO_REG(fifo)		(HSI_HST_BASE(1) + 0x0100 +\
 						(fifo * 4))
 #define HSI_MAPPING_ENABLE		1
@@ -277,11 +283,12 @@
 
 /* Additional registers for HSI */
 #define	HSI_HSR_FIFO_COUNT		16
+#define	HSI_HSR_FIFO_SIZE		8
 #define HSI_HSR_MAPPING_FIFO_REG(fifo)	(HSI_HSR_BASE(1) + 0x0100 +\
 					(fifo * 4))
 #define HSI_HSR_MAPPING_WORDS_MASK	(0xf << 10)
 
-#define HSI_HSR_DLL_REG(port)		(HSI_HSR_BASE(port) + 0x0144)
+#define HSI_HSR_DLL_REG			(HSI_HSR_BASE(1) + 0x0144)
 #define HSI_HSR_DLL_COCHRE		1
 #define HSI_HSR_DLL_COCHGR		(1 << 4)
 #define HSI_HSR_DLL_INCO_MASK		0x0003ff00
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/arch/arm/plat-omap/opp.c Kernel/arch/arm/plat-omap/opp.c
--- Kernel-orig/arch/arm/plat-omap/opp.c	2010-12-10 15:11:19.000000000 +0530
+++ Kernel/arch/arm/plat-omap/opp.c	2011-02-09 13:07:23.087873799 +0530
@@ -408,7 +408,7 @@
 	}
 
 	if (!dev_opp->get_rate) {
-		dev_err(dev, "%s: No set_rate API for scaling opp\n",
+		dev_err(dev, "%s: No get_rate API for scaling opp\n",
 			__func__);
 		return 0;
 	}
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/phone_svn/ipc_hsi/ipc_hsi.c Kernel/drivers/phone_svn/ipc_hsi/ipc_hsi.c
--- Kernel-orig/drivers/phone_svn/ipc_hsi/ipc_hsi.c	2011-02-16 11:29:38.472107047 +0530
+++ Kernel/drivers/phone_svn/ipc_hsi/ipc_hsi.c	2011-02-14 12:44:05.489612902 +0530
@@ -18,20 +18,22 @@
  * 02110-1301 USA
  */
 
-#define DEBUG
+//#define DEBUG
 
-#define FORMAT_TX_DUMP
-#define RAW_TX_DUMP
-#define RFS_TX_DUMP
-#define ALL_TX_DUMP
-
-#define FORMAT_RX_DUMP
-#define RAW_RX_DUMP
-#define RFS_RX_DUMP
-#define ALL_RX_DUMP
+//#define FORMAT_TX_DUMP
+//#define RAW_TX_DUMP
+//#define RFS_TX_DUMP
+//#define ALL_TX_DUMP
+
+//#define FORMAT_RX_DUMP
+//#define RAW_RX_DUMP
+//#define RFS_RX_DUMP
+//#define ALL_RX_DUMP
 
-#define RAW_TX_RX_LENGTH_DUMP
-#define RFS_TX_RX_LENGTH_DUMP
+//#define RAW_TX_RX_LENGTH_DUMP
+//#define RFS_TX_RX_LENGTH_DUMP
+
+//#define LOOP_BACK_TEST
 
 
 #include <linux/init.h>
@@ -59,6 +61,7 @@
 #include <linux/workqueue.h>
 
 #include <linux/hsi_driver_if.h>
+#include <linux/kthread.h>
 
 
 #define DRVNAME "onedram"
@@ -178,6 +181,15 @@
 } ipc_hsi_data;
 
 
+extern int hsi_start_protocol( void );
+extern int write_hsi( int channel, u32 *data, int length );
+extern int read_hsi( u8 *data, u32 ch, u32 *length );
+extern int write_hsi_direct( u32 *data, int length );
+extern int read_hsi_direct( u32 *data, int length );
+extern int hsi_start_protocol_single( void );
+extern int hsi_reconfigure_protocol( void );
+
+
 static DEFINE_SPINLOCK( ipc_hsi_lock );
 
 static unsigned long hw_tmp; /* for hardware */
@@ -190,7 +202,6 @@
 static int transfer_thread_waiting = 0;
 static int cp_flow_control_stop_transfer = 0;
 static int cp_restart = 0;
-static int loop_back_test = 0;
 
 volatile static void __iomem *p_virtual_buff = 0;
 
@@ -511,7 +522,7 @@
 	u32 mailbox;
 
 	mailbox = cmd;
-	dev_err( od->dev, "(%d) <=make data int : 0x%08x\n", __LINE__, mailbox );
+	dev_dbg( od->dev, "(%d) <=make data int : 0x%08x\n", __LINE__, mailbox );
 
 	if( h_list.len ) {
 		spin_lock_irqsave( &h_list.lock, flags );
@@ -529,7 +540,7 @@
 		od->mailbox = mailbox;
 	}
 
-	dev_err( od->dev, "(%d) <=send data int cmd event\n", __LINE__ );
+	dev_dbg( od->dev, "(%d) <=send data int cmd event\n", __LINE__ );
 	
 	wake_up_interruptible( &od->waitq );
 	kill_fasync( &od->async_queue, SIGIO, POLL_IN );
@@ -961,17 +972,17 @@
 }
 
 
-#define FMT_OUT		0x0FE000
-#define FMT_IN			0x0FF000
-#define FMT_SZ			0x1000
-
-#define RAW_OUT		0x100000
-#define RAW_IN			0x200000
-#define RAW_SZ			0x100000
-
-#define RFS_OUT		0x300000
-#define RFS_IN			0x400000
-#define RFS_SZ			0x100000
+#define FMT_OUT	0x0FE000
+#define FMT_IN		0x10E000
+#define FMT_SZ		0x10000   /* 65536 bytes */
+
+#define RAW_OUT	0x11E000
+#define RAW_IN		0x21E000
+#define RAW_SZ		0x100000 /* 1 MB */
+
+#define RFS_OUT	0x31E000
+#define RFS_IN		0x41E000
+#define RFS_SZ		0x100000 /* 1 MB */
 
 static u32 ipc_hsi_get_send_vbuff_command( struct ipc_hsi *od )
 {
@@ -1245,11 +1256,6 @@
 		retval = 1;
 	}
 
-	if( loop_back_test ) {
-//		dev_dbg( od->dev, "(%d) LOOP checked.\n", __LINE__ );
-		retval = 1;
-	}
-
 	return retval;
 }
 
@@ -1408,7 +1414,12 @@
 
 
 #define IPC_HSI_TX_BUF_SIZE		( 10 * 1024 )
-#define IPC_HSI_RX_BUF_SIZE		( 266 * 1024 )
+#define IPC_HSI_FMT_RX_BUF_SIZE		( 10 * 1024 )
+#define IPC_HSI_RAW_RX_BUF_SIZE		( 10 * 1024 )
+#define IPC_HSI_RFS_RX_BUF_SIZE		( 266 * 1024 )
+#define IPC_HSI_CMD_RX_BUF_SIZE		( 1 * 1024 )
+#define IPC_HSI_LOOPBACK_RX_BUF_SIZE		( 10 * 1024 )
+
 static void ipc_hsi_prepare_tx_data( struct ipc_hsi *od, ipc_hsi_data *tx_data )
 {
 	u32 len = 0;
@@ -1417,8 +1428,9 @@
 	u32 p_send_data_h = 0, p_send_data_t = 0;
 	int i;
 
-	dev_err( od->dev, "(%d) =>ipc_hsi_prepare_tx_data\n", __LINE__ );
+	dev_dbg( od->dev, "(%d) =>ipc_hsi_prepare_tx_data\n", __LINE__ );
 
+	i = 0;
 	tx_data->channel = 0;
 	tx_data->len = 0;
 	tx_data->more = 0;
@@ -1440,13 +1452,13 @@
 	
 	len = ipc_hsi_get_length_vbuff_format_tx( od, &p_send_data_h, &p_send_data_t );
 	if( len ) {
-		dev_err( od->dev, "(%d) =>exist FMT tx data\n", __LINE__ );
+		dev_dbg( od->dev, "(%d) =>exist FMT tx data. len : %d, in : %d, out : %d\n", __LINE__, len, p_send_data_t, p_send_data_h );
 
 		if( len > IPC_HSI_TX_BUF_SIZE ) {
-			dev_err( od->dev, "(%d) =>FMT tx data len is over. len : %d\n", __LINE__, len );
+			dev_dbg( od->dev, "(%d) =>FMT tx data len is over. len : %d\n", __LINE__, len );
 
 			ipc_hsi_update_tail_of_vbuff_format_tx( od, p_send_data_h );
-			dev_err( od->dev, "(%d) =>discard FMT tx data.\n", __LINE__ );
+			dev_dbg( od->dev, "(%d) =>discard FMT tx data.\n", __LINE__ );
 
 			tx_data->channel = 0;
 			tx_data->len = 0;
@@ -1455,19 +1467,19 @@
 		}
 
 		ipc_hsi_copy_from_vbuff_format_tx( od, ( void * )tx_data->buf, p_send_data_t, len );
-		dev_err( od->dev, "(%d) =>copy FMT tx data. len : %d\n", __LINE__, len );
+		dev_dbg( od->dev, "(%d) =>copy FMT tx data. len : %d\n", __LINE__, len );
 		
 		p_send_data_t += len;
 		p_send_data_t %= FMT_SZ;
 		ipc_hsi_update_tail_of_vbuff_format_tx( od, p_send_data_t );
-		dev_err( od->dev, "(%d) =>update FMT tx data in pointer. in : %d\n", __LINE__, p_send_data_t );
+		dev_dbg( od->dev, "(%d) =>update FMT tx data in pointer. in : %d, out : %d\n", __LINE__, p_send_data_t, p_send_data_h );
 
 		tx_data->channel = 1;
 		tx_data->len = len;
 
 #ifdef FORMAT_TX_DUMP
 		printk( "[IPC_SPI => FMT TX :" );
-		for( i = 0; i < tx_data->len; i++ ) {
+		for( i = 0; i < ( ( tx_data->len > 20 )? 20 : tx_data->len ); i++ ) {
 			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
 		printk( "]\n" );
@@ -1478,7 +1490,7 @@
 
 	len = ipc_hsi_get_length_vbuff_raw_tx( od, &p_send_data_h, &p_send_data_t );
 	if( len ) {
-		dev_err( od->dev, "(%d) =>exist RAW tx data\n", __LINE__ );
+		dev_dbg( od->dev, "(%d) =>exist RAW tx data\n", __LINE__ );
 
 		if( len > IPC_HSI_TX_BUF_SIZE ) {
 			dev_err( od->dev, "(%d) =>RAW tx data len is over. len : %d\n", __LINE__, len );
@@ -1505,7 +1517,7 @@
 
 #ifdef RAW_TX_DUMP
 		printk( "[IPC_SPI => RAW TX :" );
-		for( i = 0; i < tx_data->len; i++ ) {
+		for( i = 0; i < ( ( tx_data->len > 20 )? 20 : tx_data->len ); i++ ) {
 			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
 		printk( "]\n" );
@@ -1520,7 +1532,7 @@
 
 	len = ipc_hsi_get_length_vbuff_rfs_tx( od, &p_send_data_h, &p_send_data_t );
 	if( len ) {
-		dev_err( od->dev, "(%d) =>exist RFS tx data\n", __LINE__ );
+		dev_dbg( od->dev, "(%d) =>exist RFS tx data\n", __LINE__ );
 
 		if( len > IPC_HSI_TX_BUF_SIZE ) {
 			dev_err( od->dev, "(%d) =>RFS tx data len is over. len : %d\n", __LINE__, len );
@@ -1547,7 +1559,7 @@
 
 #ifdef RFS_TX_DUMP
 		printk( "[IPC_SPI => RFS TX :" );
-		for( i = 0; i < tx_data->len; i++ ) {
+		for( i = 0; i < ( ( tx_data->len > 20 )? 20 : tx_data->len ); i++ ) {
 			printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 		}
 		printk( "]\n" );
@@ -1564,272 +1576,418 @@
 
 #ifdef ALL_TX_DUMP
 	printk( "[IPC_SPI => ALL TX :" );
-	for( i = 0; i < tx_data->len; i++ ) {
+	for( i = 0; i < ( ( tx_data->len > 20 )? 20 : tx_data->len ); i++ ) {
 		printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
 	}
 	printk( "]\n" );
 #endif // ALL_TX_DUMP
 
-	dev_err( od->dev, "(%d) =>ipc_hsi_prepare_tx_data done. ch : %d, len : %d\n", __LINE__, tx_data->channel, tx_data->len );
+	dev_dbg( od->dev, "(%d) =>ipc_hsi_prepare_tx_data done. ch : %d, len : %d\n", __LINE__, tx_data->channel, tx_data->len );
 	
 }
 
-static void ipc_hsi_prepare_loopback_tx_data( struct ipc_hsi *od, u8 *tx_b )
+#ifdef LOOP_BACK_TEST
+static void ipc_hsi_prepare_loopback_tx_data( struct ipc_hsi *od, ipc_hsi_data *tx_data )
 {
+//	int i;
+	
+	dev_dbg( od->dev, "(%d) =>ipc_hsi_prepare_loopback_tx_data\n", __LINE__ );
+
+	tx_data->channel = 2;
+	tx_data->len = 1550;
+	tx_data->more = 0;
+
+	tx_data->buf[ 0 ] = 0x7F;
+	*( u32 * )( tx_data->buf + 1 ) = tx_data->len - 2;
+	tx_data->buf[ 5 ] = 0;
+	tx_data->buf[ tx_data->len - 1 ] = 0x7E;
+
+//	printk( "[IPC_SPI => LOOP TX :" );
+//	for( i = 0; i < 5; i++ ) {
+//		printk( " %02x", *( ( u8 * )( tx_data->buf + i ) ) );
+//	}
+//	printk( "]\n" );
+
+	dev_dbg( od->dev, "(%d) =>ipc_hsi_prepare_loopback_tx_data done. ch : %d, len : %d\n", __LINE__, tx_data->channel, tx_data->len );
 }
+#endif // LOOP_BACK_TEST
 
-static void ipc_hsi_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
+static void ipc_hsi_fmt_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
 {
 	int retval = 0;
 	u32 read_size = 0;
 	u32 int_cmd = 0;
-	u16 cmd_16 = 0;
 	int i;
 
-	dev_err( od->dev, "(%d) <=ipc_hsi_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+	dev_dbg( od->dev, "(%d) <=ipc_hsi_fmt_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+
+	i = 0;
 
-	if( !rx_data->channel || ( rx_data->channel > 4 ) ) {
-		dev_err( od->dev, "(%d) <=Wrong channel : %d\n", __LINE__, rx_data->channel );
+	if( rx_data->channel != 1 ) {
+		dev_err( od->dev, "(%d) <=FMT Wrong channel : %d\n", __LINE__, rx_data->channel );
 		return;
 	}
-	dev_err( od->dev, "(%d) <=channel : %d\n", __LINE__, rx_data->channel );
+	dev_dbg( od->dev, "(%d) <=FMT channel : %d\n", __LINE__, rx_data->channel );
 
-	if( rx_data->len > IPC_HSI_RX_BUF_SIZE ) {
-		dev_err( od->dev, "(%d) <=Wrong len : %d\n", __LINE__, rx_data->len );
+	if( rx_data->len > IPC_HSI_FMT_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=FMT Wrong len : %d\n", __LINE__, rx_data->len );
 		return;
 	}
-	dev_err( od->dev, "(%d) <=len : %d\n", __LINE__, rx_data->len );
+	dev_dbg( od->dev, "(%d) <=FMT len : %d\n", __LINE__, rx_data->len );
 	
 	while( rx_data->len > read_size ) {
+		dev_dbg( od->dev, "(%d) <=rx process, got FMT rx data.\n", __LINE__ );
+		
+		retval = ipc_hsi_copy_to_vbuff_format_rx( od, ( void * )rx_data->buf, rx_data->len );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) <=rx process, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
+			return;
+		}
+		else {
+			dev_dbg( od->dev, "(%d) <=rx process, FMT read Done. len : %d\n", __LINE__, rx_data->len );
+		}
 
-		switch( rx_data->channel ) {
-			case 0x0001 :
-				dev_err( od->dev, "(%d) <=rx process, got FMT rx data.\n", __LINE__ );
-				
-				retval = ipc_hsi_copy_to_vbuff_format_rx( od, ( void * )rx_data->buf, rx_data->len );
-				if( retval < 0 ) {
-					dev_err( od->dev, "(%d) <=rx process, cp -> ap FMT memory FULL!!!.\n", __LINE__ );
-					return;
-				}
-				else {
-					dev_err( od->dev, "(%d) <=rx process, FMT read Done. len : %d\n", __LINE__, rx_data->len );
-				}
-
-				read_size += rx_data->len;
-				dev_err( od->dev, "(%d) <=rx process, FMT update read_size : %d\n", __LINE__, read_size );
+		read_size += rx_data->len;
+		dev_dbg( od->dev, "(%d) <=rx process, FMT update read_size : %d\n", __LINE__, read_size );
 
 #ifdef FORMAT_RX_DUMP
-				printk( "[IPC_SPI <= FMT RX :" );
-				for( i = 0; i < rx_data->len; i++ ) {
-					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
-				}
-				printk( "]\n" );
+		printk( "[IPC_SPI <= FMT RX :" );
+		for( i = 0; i < ( ( rx_data->len > 20 )? 20 : rx_data->len ); i++ ) {
+			printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+		}
+		printk( "]\n" );
 #endif // FORMAT_RX_DUMP
 
-				int_cmd = MB_DATA( MBD_SEND_FMT );
-				ipc_hsi_make_data_interrupt( od, int_cmd );
-				dev_err( od->dev, "(%d) <=rx process, FMT send event : 0x%x\n", __LINE__, int_cmd );
-				break;
+		int_cmd = MB_DATA( MBD_SEND_FMT );
+		ipc_hsi_make_data_interrupt( od, int_cmd );
+		dev_dbg( od->dev, "(%d) <=rx process, FMT send event : 0x%x\n", __LINE__, int_cmd );
 
-			case 0x0002 :
-				dev_err( od->dev, "(%d) <=rx process, got RAW rx data.\n", __LINE__ );
-				
-				retval = ipc_hsi_copy_to_vbuff_raw_rx( od, ( void * )rx_data->buf, rx_data->len );
-				if( retval < 0 ) {
-					dev_err( od->dev, "(%d) <=rx process, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
-					return;
-				}
-				else {
-					dev_err( od->dev, "(%d) <=rx process, RAW read Done. len : %d\n", __LINE__, rx_data->len );
-				}
+		dev_dbg( od->dev, "(%d) ===== rx process FMT loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
+	}
+}
+
+static void ipc_hsi_raw_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
+{
+	int retval = 0;
+	u32 read_size = 0;
+	u32 int_cmd = 0;
+	int i;
 
-				read_size += rx_data->len;
-				dev_err( od->dev, "(%d) <=rx process, RAW update read_size : %d\n", __LINE__, read_size );
+	dev_dbg( od->dev, "(%d) <=ipc_hsi_raw_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+
+	 i =0;
+
+	if( rx_data->channel != 2 ) {
+		dev_err( od->dev, "(%d) <=RAW Wrong channel : %d\n", __LINE__, rx_data->channel );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=RAW channel : %d\n", __LINE__, rx_data->channel );
+
+	if( rx_data->len > IPC_HSI_RAW_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=RAW Wrong len : %d\n", __LINE__, rx_data->len );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=RAW len : %d\n", __LINE__, rx_data->len );
+	
+	while( rx_data->len > read_size ) {
+		dev_dbg( od->dev, "(%d) <=rx process, got RAW rx data.\n", __LINE__ );
+		
+		retval = ipc_hsi_copy_to_vbuff_raw_rx( od, ( void * )rx_data->buf, rx_data->len );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) <=rx process, cp -> ap RAW memory FULL!!!.\n", __LINE__ );
+			return;
+		}
+		else {
+			dev_dbg( od->dev, "(%d) <=rx process, RAW read Done. len : %d\n", __LINE__, rx_data->len );
+		}
+
+		read_size += rx_data->len;
+		dev_dbg( od->dev, "(%d) <=rx process, RAW update read_size : %d\n", __LINE__, read_size );
 
 #ifdef RAW_RX_DUMP
-				printk( "[IPC_SPI <= RAW RX :" );
-				for( i = 0; i < rx_data->len; i++ ) {
-					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
-				}
-				printk( "]\n" );
+		printk( "[IPC_SPI <= RAW RX :" );
+		for( i = 0; i < ( ( rx_data->len > 20 )? 20 : rx_data->len ); i++ ) {
+			printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+		}
+		printk( "]\n" );
 #endif // RAW_RX_DUMP
 
 #ifdef RAW_TX_RX_LENGTH_DUMP
-				printk( "[IPC_SPI <= RAW RX : %d]\n", rx_data->len );
+		printk( "[IPC_SPI <= RAW RX : %d]\n", rx_data->len );
 #endif // RAW_TX_RX_LENGTH_DUMP
 
-				int_cmd = MB_DATA( MBD_SEND_RAW );
-				ipc_hsi_make_data_interrupt( od, int_cmd );
-				dev_err( od->dev, "(%d) <=rx process, RAW send event : 0x%x\n", __LINE__, int_cmd );
-				break;
+		int_cmd = MB_DATA( MBD_SEND_RAW );
+		ipc_hsi_make_data_interrupt( od, int_cmd );
+		dev_dbg( od->dev, "(%d) <=rx process, RAW send event : 0x%x\n", __LINE__, int_cmd );
 
-			case 0x0003 :
-				dev_err( od->dev, "(%d) <=rx process, got RFS rx data.\n", __LINE__ );
-				
-				retval = ipc_hsi_copy_to_vbuff_rfs_rx( od, ( void * )rx_data->buf, rx_data->len );
-				if( retval < 0 ) {
-					dev_err( od->dev, "(%d) <=rx process, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
-					return;
-				}
-				else {
-					dev_err( od->dev, "(%d) <=rx process, RFS read Done. len : %d\n", __LINE__, rx_data->len );
-				}
+		dev_dbg( od->dev, "(%d) ===== rx process RAW loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
+	}
+}
+
+static void ipc_hsi_rfs_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
+{
+	int retval = 0;
+	u32 read_size = 0;
+	u32 int_cmd = 0;
+	int i;
+
+	dev_dbg( od->dev, "(%d) <=ipc_hsi_rfs_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+
+	i = 0;
+
+	if( rx_data->channel != 3 ) {
+		dev_err( od->dev, "(%d) <=RFS Wrong channel : %d\n", __LINE__, rx_data->channel );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=RFS channel : %d\n", __LINE__, rx_data->channel );
+
+	if( rx_data->len > IPC_HSI_RFS_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=RFS Wrong len : %d\n", __LINE__, rx_data->len );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=RFS len : %d\n", __LINE__, rx_data->len );
+	
+	while( rx_data->len > read_size ) {
+		dev_dbg( od->dev, "(%d) <=rx process, got RFS rx data.\n", __LINE__ );
+		
+		retval = ipc_hsi_copy_to_vbuff_rfs_rx( od, ( void * )rx_data->buf, rx_data->len );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) <=rx process, cp -> ap RFS memory FULL!!!.\n", __LINE__ );
+			return;
+		}
+		else {
+			dev_dbg( od->dev, "(%d) <=rx process, RFS read Done. len : %d\n", __LINE__, rx_data->len );
+		}
 
-				read_size += rx_data->len;
-				dev_err( od->dev, "(%d) <=rx process, RFS update read_size : %d\n", __LINE__, read_size );
+		read_size += rx_data->len;
+		dev_dbg( od->dev, "(%d) <=rx process, RFS update read_size : %d\n", __LINE__, read_size );
 
 #ifdef RFS_RX_DUMP
-				printk( "[IPC_SPI <= RFS RX :" );
-				for( i = 0; i < rx_data->len; i++ ) {
-					printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
-				}
-				printk( "]\n" );
+		printk( "[IPC_SPI <= RFS RX :" );
+		for( i = 0; i < ( ( rx_data->len > 20 )? 20 : rx_data->len ); i++ ) {
+			printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+		}
+		printk( "]\n" );
 #endif // RFS_RX_DUMP
 
 #ifdef RFS_TX_RX_LENGTH_DUMP
-				printk( "[IPC_SPI <= RFS RX : %d]\n", rx_data->len );
+		printk( "[IPC_SPI <= RFS RX : %d]\n", rx_data->len );
 #endif // RFS_TX_RX_LENGTH_DUMP
 
-				int_cmd = MB_DATA( MBD_SEND_RFS );
-				ipc_hsi_make_data_interrupt( od, int_cmd );
-				dev_err( od->dev, "(%d) <=rx process, RFS send event : 0x%x\n", __LINE__, int_cmd );
-				break;
-
-			case 0x0004 :
-				dev_err( od->dev, "(%d) <=rx process, got CMD rx data.\n", __LINE__ );
-
-				memcpy( ( void * )&cmd_16, ( void * )rx_data->buf, sizeof( cmd_16 ) );
-				dev_err( od->dev, "(%d) <=rx process, CMD read Done. cmd : 0x%x, len : %d\n", __LINE__, cmd_16, rx_data->len );
-
-				if( ( cmd_16 & 0xF ) == 0xA ) { // ONEDRAM_CMD_SUSPEND_REQ
-					printk( "[ipc_spi] Got ONEDRAM_CMD_SUSPEND_REQ\n" );
-					cp_flow_control_stop_transfer = 1;
-				}
-				else if( ( cmd_16 & 0xF ) == 0xB ) { // ONEDRAM_CMD_RESUME_REQ
-					printk( "[ipc_spi] Got ONEDRAM_CMD_RESUME_REQ\n" );
-					cp_flow_control_stop_transfer = 0;
-				}
+		int_cmd = MB_DATA( MBD_SEND_RFS );
+		ipc_hsi_make_data_interrupt( od, int_cmd );
+		dev_dbg( od->dev, "(%d) <=rx process, RFS send event : 0x%x\n", __LINE__, int_cmd );
 
-				read_size += rx_data->len;
-				dev_err( od->dev, "(%d) <=rx process, CMD update read_size : %d\n", __LINE__, read_size );
-				
-				break;
+		dev_dbg( od->dev, "(%d) ===== rx process RFS loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
+	}
+}
+
+static void ipc_hsi_cmd_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
+{
+	u32 read_size = 0;
+	u16 cmd_16 = 0;
+
+	dev_err( od->dev, "(%d) <=ipc_hsi_cmd_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+
+	if(!rx_data->channel != 4 ) {
+		dev_err( od->dev, "(%d) <=CMD Wrong channel : %d\n", __LINE__, rx_data->channel );
+		return;
+	}
+	dev_err( od->dev, "(%d) <=CMD channel : %d\n", __LINE__, rx_data->channel );
+
+	if( rx_data->len > IPC_HSI_CMD_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=CMD Wrong len : %d\n", __LINE__, rx_data->len );
+		return;
+	}
+	dev_err( od->dev, "(%d) <=CMD len : %d\n", __LINE__, rx_data->len );
+	
+	while( rx_data->len > read_size ) {
+		dev_err( od->dev, "(%d) <=rx process, got CMD rx data.\n", __LINE__ );
+
+		memcpy( ( void * )&cmd_16, ( void * )rx_data->buf, sizeof( cmd_16 ) );
+		dev_err( od->dev, "(%d) <=rx process, CMD read Done. cmd : 0x%x, len : %d\n", __LINE__, cmd_16, rx_data->len );
 
-			default :
-				break;
+		if( ( cmd_16 & 0xF ) == 0xA ) { // ONEDRAM_CMD_SUSPEND_REQ
+			printk( "[ipc_spi] Got ONEDRAM_CMD_SUSPEND_REQ\n" );
+			cp_flow_control_stop_transfer = 1;
 		}
+		else if( ( cmd_16 & 0xF ) == 0xB ) { // ONEDRAM_CMD_RESUME_REQ
+			printk( "[ipc_spi] Got ONEDRAM_CMD_RESUME_REQ\n" );
+			cp_flow_control_stop_transfer = 0;
+		}
+
+		read_size += rx_data->len;
+		dev_err( od->dev, "(%d) <=rx process, CMD update read_size : %d\n", __LINE__, read_size );
 
-		dev_err( od->dev, "(%d) ===== rx process loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
+		dev_err( od->dev, "(%d) ===== rx process CMD loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
 	}
 }
 
-int hsi_start_protocol( void );
-int write_hsi( int channel, u32 *data, int length );
-int read_hsi( u8 *data, u32 *ch, u32 *length );
-static int ipc_hsi_tx_thread( void *data )
+#ifdef LOOP_BACK_TEST
+static void ipc_hsi_loopback_rx_process( struct ipc_hsi *od, ipc_hsi_data *rx_data )
+{
+	u32 read_size = 0;
+//	int i;
+
+	dev_dbg( od->dev, "(%d) <=ipc_hsi_loopback_rx_process. channel : %d, len : %d\n", __LINE__, rx_data->channel, rx_data->len );
+
+	if( rx_data->channel != 2 ) {
+		dev_err( od->dev, "(%d) <=LOOP Wrong channel : %d\n", __LINE__, rx_data->channel );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=LOOP channel : %d\n", __LINE__, rx_data->channel );
+
+	if( rx_data->len > IPC_HSI_LOOPBACK_RX_BUF_SIZE ) {
+		dev_err( od->dev, "(%d) <=LOOP Wrong len : %d\n", __LINE__, rx_data->len );
+		return;
+	}
+	dev_dbg( od->dev, "(%d) <=LOOP len : %d\n", __LINE__, rx_data->len );
+	
+	while( rx_data->len > read_size ) {
+
+//		printk( "[IPC_SPI => LOOP RX :" );
+//		for( i = 0; i < 5; i++ ) {
+//			printk( " %02x", *( ( u8 * )( rx_data->buf + i ) ) );
+//		}
+//		printk( "]\n" );
+
+		read_size += rx_data->len;
+		dev_dbg( od->dev, "(%d) <=rx process, LOOPBACK update read_size : %d\n", __LINE__, read_size );
+
+		dev_dbg( od->dev, "(%d) ===== rx process LOOPBACK loop. total_len : %d, read_size : %d\n", __LINE__, rx_data->len, read_size );
+	}
+}
+#endif // LOOP_BACK_TEST
+
+static int ipc_hsi_fmt_rx_thread( void *data )
 {
 	int retval = 0;
 	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-	ipc_hsi_data *tx_data = NULL;
-	
-	daemonize( "ipc_hsi_tx_thread" );
+	ipc_hsi_data *rx_data = NULL;
 
-	printk( "(%d) ipc_hsi_tx_thread start.\n", __LINE__ );
+	printk( "(%d) ipc_hsi_fmt_rx_thread : start.\n", __LINE__ );
 
 	if( !p_virtual_buff ) {
-		dev_err( od->dev, "(%d) p_virtual_buff is NULL.\n", __LINE__);
+		dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : p_virtual_buff is NULL.\n", __LINE__);
 
 		retval = -ENODEV;
 		goto exit;
 	}
 
-	tx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
-	if( !tx_data ) {
-		dev_err( od->dev, "(%d) tx_data kmalloc fail.", __LINE__ );
+	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !rx_data ) {
+		dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : rx_data kmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
-	memset( ( void * )tx_data, 0, sizeof( ipc_hsi_data ) );
-	dev_err( od->dev, "(%d) tx_data kmalloc done.\n", __LINE__ );
+	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : rx_data kmalloc done.\n", __LINE__ );
 
-	tx_data->buf = kmalloc( IPC_HSI_TX_BUF_SIZE, GFP_ATOMIC );
-	if( !tx_data->buf ) {
-		dev_err( od->dev, "(%d) tx_data->buf vmalloc fail.", __LINE__ );
+	rx_data->buf = kmalloc( IPC_HSI_FMT_RX_BUF_SIZE, GFP_ATOMIC );
+	if( !rx_data->buf ) {
+		dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : rx_data->buf vmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
-	memset( ( void * )tx_data->buf, 0, IPC_HSI_TX_BUF_SIZE );
-	dev_err( od->dev, "(%d) tx_data->buf vmalloc done.\n", __LINE__ );
-
-SILENT_RESET :
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_FMT_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : rx_data->buf vmalloc done.\n", __LINE__ );
+	
+	while( 1 ) {
+		rx_data->channel = 1;
+		rx_data->len = 0;
+		rx_data->more = 0;
+		
+		dev_dbg( od->dev, "(%d) ipc_hsi_fmt_rx_thread : read_hsi start\n", __LINE__ );
+		retval = read_hsi( ( u8 * )rx_data->buf, rx_data->channel, ( u32 * )&rx_data->len );
+		if( retval < rx_data->len ) {
+			dev_err( od->dev, "(%d) ipc_hsi_fmt_rx_thread : read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
+		}
+		else
+			dev_dbg( od->dev, "(%d) ipc_hsi_fmt_rx_thread : read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 
-	printk( "[%s] wait ril_init complete.\n", __func__ );
-	wait_for_completion( &ril_init );
-	printk( "[%s] ril_init completed.\n", __func__ );
+		ipc_hsi_fmt_rx_process( od, rx_data );
 
-	cp_restart = 0;
+		dev_dbg( od->dev, "(%d) ipc_hsi_fmt_rx_thread : check rx more : %d\n", __LINE__, rx_data->more );
+		dev_dbg( od->dev, "(%d) ===== ipc_hsi_fmt_rx_thread rx loop =====\n", __LINE__ );
+	}
 
-	dev_err( od->dev, "(%d) wait 2 sec...\n", __LINE__ );
-	msleep( 2000 );
-	dev_err( od->dev, "(%d) Start TX Thread.\n", __LINE__ );
+exit :
+	printk( "(%d) ipc_hsi_fmt_rx_thread : thread stop.\n", __LINE__ );
 
-	sema_init( &transfer_event_sem, 0 );
-	
-	while( 1 ) {
+	return retval;
+}
 
-		if( !ipc_hsi_check_send_data( od ) ) {
-			transfer_thread_waiting = 1;
+static int ipc_hsi_raw_rx_thread( void *data )
+{
+	int retval = 0;
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-			dev_err( od->dev, "(%d) no data and no sem, wait tx event.\n", __LINE__ );
+	ipc_hsi_data *rx_data = NULL;
 
-			down( &transfer_event_sem );
-			transfer_thread_waiting = 0;
+	printk( "(%d) ipc_hsi_raw_rx_thread : start.\n", __LINE__ );
 
-			dev_err( od->dev, "(%d) got tx event.\n", __LINE__ );
-		}
-		else {
-			dev_err( od->dev, "(%d) send data exist\n", __LINE__ );
-		}
+	if( !p_virtual_buff ) {
+		dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : p_virtual_buff is NULL.\n", __LINE__);
 
-		if( cp_restart ) {
-			printk( "[IPC_HSI] (%d)CP Restart.\n", __LINE__ );					
-			goto SILENT_RESET;
-		}
+		retval = -ENODEV;
+		goto exit;
+	}
 
-		ipc_hsi_prepare_tx_data( od, tx_data );
+	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !rx_data ) {
+		dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : rx_data kmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : rx_data kmalloc done.\n", __LINE__ );
 
-		// call write func
-		dev_err( od->dev, "(%d) start write_hsi. len : %d\n", __LINE__, tx_data->len );
-		retval = write_hsi( tx_data->channel, ( u32 * )tx_data->buf, tx_data->len );
-		if( retval < 0 ) {
-			dev_err( od->dev, "(%d) start write_hsi error : %d\n", __LINE__, retval );
+	rx_data->buf = kmalloc( IPC_HSI_RAW_RX_BUF_SIZE, GFP_ATOMIC );
+	if( !rx_data->buf ) {
+		dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : rx_data->buf vmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_RAW_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : rx_data->buf vmalloc done.\n", __LINE__ );
+	
+	while( 1 ) {
+		rx_data->channel = 2;
+		rx_data->len = 0;
+		rx_data->more = 0;
+		
+		dev_dbg( od->dev, "(%d) ipc_hsi_raw_rx_thread : read_hsi start\n", __LINE__ );
+		retval = read_hsi( ( u8 * )rx_data->buf, rx_data->channel, ( u32 * )&rx_data->len );
+		if( retval < rx_data->len ) {
+			dev_err( od->dev, "(%d) ipc_hsi_raw_rx_thread : read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 		}
-		dev_err( od->dev, "(%d) start write_hsi Done : %d\n", __LINE__, retval );
+		else
+			dev_dbg( od->dev, "(%d) ipc_hsi_raw_rx_thread : read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 
-		dev_err( od->dev, "(%d) ===== tx loop =====\n", __LINE__ );
+		ipc_hsi_raw_rx_process( od, rx_data );
 
+		dev_dbg( od->dev, "(%d) ipc_hsi_raw_rx_thread : check rx more : %d\n", __LINE__, rx_data->more );
+		dev_dbg( od->dev, "(%d) ===== ipc_hsi_raw_rx_thread rx loop =====\n", __LINE__ );
 	}
 
 exit :
-	printk( "(%d) thread stop.\n", __LINE__ );
+	printk( "(%d) ipc_hsi_raw_rx_thread : thread stop.\n", __LINE__ );
 
 	return retval;
 }
 
-static int ipc_hsi_rx_thread( void *data )
+static int ipc_hsi_rfs_rx_thread( void *data )
 {
 	int retval = 0;
 	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
 	ipc_hsi_data *rx_data = NULL;
 	
-	daemonize( "ipc_hsi_rx_thread" );
-
-	printk( "(%d) ipc_hsi_rx_thread start.\n", __LINE__ );
+	printk( "(%d) ipc_hsi_rfs_rx_thread : start.\n", __LINE__ );
 
 	if( !p_virtual_buff ) {
-		dev_err( od->dev, "(%d) p_virtual_buff is NULL.\n", __LINE__);
+		dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : p_virtual_buff is NULL.\n", __LINE__);
 
 		retval = -ENODEV;
 		goto exit;
@@ -1837,135 +1995,945 @@
 
 	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
 	if( !rx_data ) {
-		dev_err( od->dev, "(%d) rx_data kmalloc fail.", __LINE__ );
+		dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : rx_data kmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
 	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
-	dev_err( od->dev, "(%d) rx_data kmalloc done.\n", __LINE__ );
+	dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : rx_data kmalloc done.\n", __LINE__ );
 
-	rx_data->buf = kmalloc( IPC_HSI_RX_BUF_SIZE, GFP_ATOMIC );
+	rx_data->buf = kmalloc( IPC_HSI_RFS_RX_BUF_SIZE, GFP_ATOMIC );
 	if( !rx_data->buf ) {
-		dev_err( od->dev, "(%d) rx_data->buf vmalloc fail.", __LINE__ );
+		dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : rx_data->buf vmalloc fail.", __LINE__ );
 		retval = -ENOMEM;
 		goto exit;
 	}
-	memset( ( void * )rx_data->buf, 0, IPC_HSI_RX_BUF_SIZE );
-	dev_err( od->dev, "(%d) rx_data->buf vmalloc done.\n", __LINE__ );
-
-SILENT_RESET :
-
-	printk( "[%s] wait ril_init complete.\n", __func__ );
-	wait_for_completion( &ril_init );
-	printk( "[%s] ril_init completed.\n", __func__ );
-
-	cp_restart = 0;
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_RFS_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : rx_data->buf vmalloc done.\n", __LINE__ );
 
-	dev_err( od->dev, "(%d) wait 2 sec...\n", __LINE__ );
-	msleep( 2000 );
-	dev_err( od->dev, "(%d) Start RX Thread.\n", __LINE__ );
-	
 	while( 1 ) {
-
-		if( cp_restart ) {
-			printk( "[IPC_HSI] (%d)CP Restart.\n", __LINE__ );						
-			goto SILENT_RESET;
+		rx_data->channel = 3;
+		rx_data->len = 0;
+		rx_data->more = 0;
+		
+		dev_dbg( od->dev, "(%d) ipc_hsi_rfs_rx_thread : read_hsi start\n", __LINE__ );
+		retval = read_hsi( ( u8 * )rx_data->buf, rx_data->channel, ( u32 * )&rx_data->len );
+		if( retval < rx_data->len ) {
+			dev_err( od->dev, "(%d) ipc_hsi_rfs_rx_thread : read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 		}
+		else
+			dev_dbg( od->dev, "(%d) ipc_hsi_rfs_rx_thread : read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 
-		do {
-			rx_data->channel = 0;
-			rx_data->len = 0;
-			rx_data->more = 0;
-			
-			// call read func
-			dev_err( od->dev, "(%d) read_hsi start\n", __LINE__ );
-			retval = read_hsi( ( u8 * )rx_data->buf, ( u32 * )&rx_data->channel, ( u32 * )&rx_data->len );
-			if( retval < rx_data->len ) {
-				dev_err( od->dev, "(%d) read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
-			}
-			dev_err( od->dev, "(%d) read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
-
-			ipc_hsi_rx_process( od, rx_data );
-
-			dev_err( od->dev, "(%d) check rx more : %d\n", __LINE__, rx_data->more );
-		} while( rx_data->more );
-
-		dev_err( od->dev, "(%d) ===== rx loop =====\n", __LINE__ );
+		ipc_hsi_rfs_rx_process( od, rx_data );
 
+		dev_dbg( od->dev, "(%d) ipc_hsi_rfs_rx_thread : check rx more : %d\n", __LINE__, rx_data->more );
+		dev_dbg( od->dev, "(%d) ===== ipc_hsi_rfs_rx_thread rx loop =====\n", __LINE__ );
 	}
 
 exit :
-	printk( "(%d) thread stop.\n", __LINE__ );
+	printk( "(%d) ipc_hsi_rfs_rx_thread : thread stop.\n", __LINE__ );
 
 	return retval;
 }
 
+static int ipc_hsi_cmd_rx_thread( void *data )
+{
+	int retval = 0;
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
 
-enum image_type {
-	MODEM_PSI,
-	MODEM_EBL,
-	MODEM_MAIN,
-	MODEM_NV,
-};
+	ipc_hsi_data *rx_data = NULL;
 
-struct image_buf {
-	unsigned int length;
-	unsigned char *buf;
-};
+	printk( "(%d) ipc_hsi_cmd_rx_thread : start.\n", __LINE__ );
 
-#define PSI_OFFSET			0
-#define EBL_OFFSET		0x10000
-#define MAIN_OFFSET		0x28000
-#define NV_OFFSET			0xA00000
+	if( !p_virtual_buff ) {
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : p_virtual_buff is NULL.\n", __LINE__);
 
-#define PSI_LEN				( EBL_OFFSET - PSI_OFFSET - 1 ) // 0xF058
-#define EBL_LEN			( MAIN_OFFSET - EBL_OFFSET ) // 0x13F98
-#define MAIN_LEN			( NV_OFFSET - MAIN_OFFSET ) // 0x84B04D
-#define NV_LEN				( 2 * 1024 * 1024 )
+		retval = -ENODEV;
+		goto exit;
+	}
 
-#define MAIN_OFFSET_VM	0
-#define NV_OFFSET_VM		0xD80000
+	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !rx_data ) {
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : rx_data kmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : rx_data kmalloc done.\n", __LINE__ );
 
-#define SPI_SEND_BLOCK_SIZE		3072//4080//3072//2048
+	rx_data->buf = kmalloc( IPC_HSI_CMD_RX_BUF_SIZE, GFP_ATOMIC );
+	if( !rx_data->buf ) {
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : rx_data->buf vmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_CMD_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : rx_data->buf vmalloc done.\n", __LINE__ );
 
-#define EBL_PACKET_SIZE	3088//4096//3088//2064
-#define EBL_RX_PACKET_SIZE	80
+	while( 1 ) {
+		rx_data->channel = 4;
+		rx_data->len = 0;
+		rx_data->more = 0;
+		
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : read_hsi start\n", __LINE__ );
+		retval = read_hsi( ( u8 * )rx_data->buf, rx_data->channel, ( u32 * )&rx_data->len );
+		if( retval < rx_data->len ) {
+			dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
+		}
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
 
-static void ipc_hsi_send_modem_bin( struct work_struct *send_modem_w )
-{
-	int retval = 0;
-	u32 int_cmd = 0xABCDABCD;
-	u32 int_cmd_fail = 0xDCBADCBA;
-	struct ipc_hsi_send_modem_bin_workq_data *smw 
-		= container_of( send_modem_w, struct ipc_hsi_send_modem_bin_workq_data, send_modem_w );
-	struct ipc_hsi *od = smw->od;
+		ipc_hsi_cmd_rx_process( od, rx_data );
 
-//	unsigned int modem_addr = 0x61500000;//0x60300000;0x61580000;0x61600000;0x61500000
-//	unsigned int nvm_static_fix_addr = 0x60e80000;//0x60e80000;0x61F80000;0x61E80000
-//	unsigned int nvm_static_cal_addr = 0x60f00000;//0x60f00000;0x61F00000;0x61F00000
-//	unsigned int nvm_dynamic_addr = 0x60f80000;//0x60f80000;0x61E80000;0x61F80000
-//	unsigned int nvm_addr = 0x61E00000;//0x60b80000;//0x60C00000;0x61E00000
-//	unsigned short sec_end = 0x0000;
-//	unsigned int force_hw_reset = 0x00111001;
-	
-	dev_dbg( od->dev, "[SPI DUMP] mb : [%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
-		*( u8 * )( p_virtual_buff ), *( u8 * )( p_virtual_buff + 1 ), *( u8 * )( p_virtual_buff + 2 ), *( u8 * )( p_virtual_buff + 3 ), *( u8 * )( p_virtual_buff + 4 ), 
-		 *( u8 * )( p_virtual_buff + 5 ),  *( u8 * )( p_virtual_buff + 6 ),  *( u8 * )( p_virtual_buff + 7 ),  *( u8 * )( p_virtual_buff + 8 ),  *( u8 * )( p_virtual_buff + 9 ), 
-		*( u8 * )( p_virtual_buff + 10 ),  *( u8 * )( p_virtual_buff + 11 ),  *( u8 * )( p_virtual_buff + 12 ),  *( u8 * )( p_virtual_buff + 13 ),  *( u8 * )( p_virtual_buff + 14 ), 
-		*( u8 * )( p_virtual_buff + 15 ),  *( u8 * )( p_virtual_buff + 16 ),  *( u8 * )( p_virtual_buff + 17 ),  *( u8 * )( p_virtual_buff + 18 ),  *( u8 * )( p_virtual_buff + 19 ) );
+		dev_err( od->dev, "(%d) ipc_hsi_cmd_rx_thread : check rx more : %d\n", __LINE__, rx_data->more );
+		dev_err( od->dev, "(%d) ===== ipc_hsi_cmd_rx_thread rx loop =====\n", __LINE__ );
+	}
 
-// TODO Flashless Boot
+exit :
+	printk( "(%d) ipc_hsi_cmd_rx_thread : thread stop.\n", __LINE__ );
 
-	// make data interrupt cmd for success
-	ipc_hsi_make_data_interrupt( od, int_cmd );
+	return retval;
+}
+
+#ifdef LOOP_BACK_TEST
+static int ipc_hsi_loopback_rx_thread( void *data )
+{
+	int retval = 0;
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
+	struct timespec time_check_before, time_check_now;
+	u32 total_read_len = 0;
+
+	ipc_hsi_data *rx_data = NULL;
+
+	printk( "(%d) ipc_hsi_loopback_rx_thread : start.\n", __LINE__ );
+
+	if( !p_virtual_buff ) {
+		dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : p_virtual_buff is NULL.\n", __LINE__);
+
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	rx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !rx_data ) {
+		dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : rx_data kmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : rx_data kmalloc done.\n", __LINE__ );
+
+	rx_data->buf = kmalloc( IPC_HSI_LOOPBACK_RX_BUF_SIZE, GFP_ATOMIC );
+	if( !rx_data->buf ) {
+		dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : rx_data->buf vmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )rx_data->buf, 0, IPC_HSI_LOOPBACK_RX_BUF_SIZE );
+	dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : rx_data->buf vmalloc done.\n", __LINE__ );
+
+	time_check_before = CURRENT_TIME;
+	time_check_now = CURRENT_TIME;
+
+	while( 1 ) {
+		rx_data->channel = 2;
+		rx_data->len = 0;
+		rx_data->more = 0;
+		
+		dev_dbg( od->dev, "(%d) ipc_hsi_loopback_rx_thread : read_hsi start\n", __LINE__ );
+		retval = read_hsi( ( u8 * )rx_data->buf, rx_data->channel, ( u32 * )&rx_data->len );
+		if( retval < rx_data->len ) {
+			dev_err( od->dev, "(%d) ipc_hsi_loopback_rx_thread : read_hsi error. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
+		}
+		dev_dbg( od->dev, "(%d) ipc_hsi_loopback_rx_thread : read_hsi done. len : %d, ret : %d\n", __LINE__, rx_data->len, retval );
+
+		ipc_hsi_loopback_rx_process( od, rx_data );
+		dev_dbg( od->dev, "(%d) ipc_hsi_loopback_rx_thread : ipc_hsi_loopback_rx_process done. len : %d\n", __LINE__, rx_data->len );
+
+		total_read_len += rx_data->len;
+		time_check_now = CURRENT_TIME;
+		if( time_check_now.tv_sec - time_check_before.tv_sec ) {
+			time_check_before = CURRENT_TIME;
+			
+			printk( "[SPEED RX] %d\n", total_read_len );
+
+			total_read_len = 0;
+		}
+
+		up( &transfer_event_sem );
+
+		dev_dbg( od->dev, "(%d) ipc_hsi_loopback_rx_thread : check rx more : %d\n", __LINE__, rx_data->more );
+		dev_dbg( od->dev, "(%d) ===== ipc_hsi_loopback_rx_thread rx loop =====\n", __LINE__ );
+	}
+
+exit :
+	printk( "(%d) ipc_hsi_loopback_rx_thread : thread stop.\n", __LINE__ );
+
+	return retval;
+}
+#endif // LOOP_BACK_TEST
+
+static int ipc_hsi_tx_thread( void *data )
+{
+	int retval = 0;
+	struct ipc_hsi *od = ( struct ipc_hsi * )data;
+	struct task_struct *fmt_read_thread = NULL;
+	struct task_struct *raw_read_thread = NULL;
+	struct task_struct *rfs_read_thread = NULL;
+	struct task_struct *cmd_read_thread = NULL;
+
+#ifdef LOOP_BACK_TEST
+	struct task_struct *loopback_read_thread = NULL;
+#endif // LOOP_BACK_TEST
+
+	ipc_hsi_data *tx_data = NULL;
+
+	printk( "(%d) ipc_hsi_tx_thread start.\n", __LINE__ );
+
+	if( !p_virtual_buff ) {
+		dev_err( od->dev, "(%d) p_virtual_buff is NULL.\n", __LINE__);
+
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	tx_data = kmalloc( sizeof( ipc_hsi_data ), GFP_ATOMIC );
+	if( !tx_data ) {
+		dev_err( od->dev, "(%d) tx_data kmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )tx_data, 0, sizeof( ipc_hsi_data ) );
+	dev_err( od->dev, "(%d) tx_data kmalloc done.\n", __LINE__ );
+
+	tx_data->buf = kmalloc( IPC_HSI_TX_BUF_SIZE, GFP_ATOMIC );
+	if( !tx_data->buf ) {
+		dev_err( od->dev, "(%d) tx_data->buf vmalloc fail.", __LINE__ );
+		retval = -ENOMEM;
+		goto exit;
+	}
+	memset( ( void * )tx_data->buf, 0, IPC_HSI_TX_BUF_SIZE );
+	dev_err( od->dev, "(%d) tx_data->buf vmalloc done.\n", __LINE__ );
+
+SILENT_RESET :
+
+	printk( "[%s] wait ril_init complete.\n", __func__ );
+	wait_for_completion( &ril_init );
+	printk( "[%s] ril_init completed.\n", __func__ );
+
+	cp_restart = 0;
+
+	// set config. of hsi mipi to default for using ipc
+	retval = hsi_reconfigure_protocol();
+
+#ifndef LOOP_BACK_TEST
+
+	if( fmt_read_thread ) {
+		retval = kthread_stop( fmt_read_thread );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) fmt_read_thread kthread_stop fail : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) fmt_read_thread kthread_stop Done : %d\n", __LINE__, retval );
+	}
+	if( raw_read_thread ) {
+		retval = kthread_stop( raw_read_thread );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) raw_read_thread kthread_stop fail : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) raw_read_thread kthread_stop Done : %d\n", __LINE__, retval );
+	}
+	if( rfs_read_thread ) {
+		retval = kthread_stop( rfs_read_thread );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) rfs_read_thread kthread_stop fail : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) rfs_read_thread kthread_stop Done : %d\n", __LINE__, retval );
+	}
+	if( cmd_read_thread ) {
+		retval = kthread_stop( cmd_read_thread );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) cmd_read_thread kthread_stop fail : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) cmd_read_thread kthread_stop Done : %d\n", __LINE__, retval );
+	}
+
+#else
+
+	if( loopback_read_thread ) {
+		retval = kthread_stop( loopback_read_thread );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) loopback_read_thread kthread_stop fail : %d\n", __LINE__, retval );
+		}
+		dev_err( od->dev, "(%d) loopback_read_thread kthread_stop Done : %d\n", __LINE__, retval );
+	}
+	
+#endif // LOOP_BACK_TEST
+
+#ifndef LOOP_BACK_TEST
+
+	fmt_read_thread = kthread_run( ipc_hsi_fmt_rx_thread, ( void * )od, "ipc_hsi_fmt_rx_thread" );
+	if( IS_ERR( fmt_read_thread ) ) {
+		dev_err( od->dev, "kthread_run() - ipc_hsi_fmt_rx_thread failed.\n" );
+		goto exit;
+	}
+	dev_err( od->dev, "kthread_run() - ipc_hsi_fmt_rx_thread Done.\n" );
+	
+	raw_read_thread = kthread_run( ipc_hsi_raw_rx_thread, ( void * )od, "ipc_hsi_raw_rx_thread" );
+	if( IS_ERR( raw_read_thread ) ) {
+		dev_err( od->dev, "kthread_run() - ipc_hsi_raw_rx_thread failed.\n" );
+		goto exit;
+	}
+	dev_err( od->dev, "kthread_run() - ipc_hsi_raw_rx_thread Done.\n" );
+
+	rfs_read_thread = kthread_run( ipc_hsi_rfs_rx_thread, ( void * )od, "ipc_hsi_rfs_rx_thread" );
+	if( IS_ERR( rfs_read_thread ) ) {
+		dev_err( od->dev, "kthread_run() - ipc_hsi_rfs_rx_thread failed.\n" );
+		goto exit;
+	}
+	dev_err( od->dev, "kthread_run() - ipc_hsi_rfs_rx_thread Done.\n" );
+
+	cmd_read_thread = kthread_run( ipc_hsi_cmd_rx_thread, ( void * )od, "ipc_hsi_cmd_rx_thread" );
+	if( IS_ERR( cmd_read_thread ) ) {
+		dev_err( od->dev, "kthread_run() - ipc_hsi_cmd_rx_thread failed.\n" );
+		goto exit;
+	}
+	dev_err( od->dev, "kthread_run() - ipc_hsi_cmd_rx_thread Done.\n" );
+
+#else
+
+	loopback_read_thread = kthread_run( ipc_hsi_loopback_rx_thread, ( void * )od, "ipc_hsi_loopback_rx_thread" );
+	if( IS_ERR( loopback_read_thread ) ) {
+		dev_err( od->dev, "kthread_run() - ipc_hsi_loopback_rx_thread failed.\n" );
+		goto exit;
+	}
+	dev_err( od->dev, "kthread_run() - ipc_hsi_loopback_rx_thread Done.\n" );
+
+#endif // LOOP_BACK_TEST
+
+	dev_err( od->dev, "(%d) wait 2 sec...\n", __LINE__ );
+	msleep( 2000 );
+	dev_err( od->dev, "(%d) Start TX Thread.\n", __LINE__ );
+
+	sema_init( &transfer_event_sem, 0 );
+	
+	while( 1 ) {
+
+#ifndef LOOP_BACK_TEST
+		if( !ipc_hsi_check_send_data( od ) ) {
+			transfer_thread_waiting = 1;
+
+			dev_dbg( od->dev, "(%d) no data and no sem, wait tx event.\n", __LINE__ );
+
+			down( &transfer_event_sem );
+			transfer_thread_waiting = 0;
+
+			dev_dbg( od->dev, "(%d) got tx event.\n", __LINE__ );
+		}
+		else {
+			dev_dbg( od->dev, "(%d) send data exist\n", __LINE__ );
+		}
+#endif // LOOP_BACK_TEST
+
+		if( cp_restart ) {
+			printk( "[IPC_HSI] (%d)CP Restart.\n", __LINE__ );
+			init_completion( &ril_init );
+			goto SILENT_RESET;
+		}
+
+#ifdef LOOP_BACK_TEST	
+		ipc_hsi_prepare_loopback_tx_data( od, tx_data );
+#else
+		ipc_hsi_prepare_tx_data( od, tx_data );
+#endif // LOOP_BACK_TEST
+
+		if( !tx_data->len || !tx_data->channel ) {
+			dev_err( od->dev, "(%d) ZERO len : %d, channel : %d\n", __LINE__, tx_data->len, tx_data->channel );
+		}
+		else {
+			// call write func
+			dev_dbg( od->dev, "(%d) start write_hsi. len : %d\n", __LINE__, tx_data->len );
+			retval = write_hsi( tx_data->channel, ( u32 * )tx_data->buf, tx_data->len );
+			if( retval < 0 ) {
+				dev_err( od->dev, "(%d) start write_hsi error : %d\n", __LINE__, retval );
+			}
+			dev_dbg( od->dev, "(%d) start write_hsi Done : %d\n", __LINE__, retval );
+		}
+
+		dev_dbg( od->dev, "(%d) ===== tx loop =====\n", __LINE__ );
+
+#ifdef LOOP_BACK_TEST
+		down( &transfer_event_sem );
+#endif // LOOP_BACK_TEST
+
+	}
+
+exit :
+	printk( "(%d) thread stop.\n", __LINE__ );
+
+	return retval;
+}
+
+
+
+
+//========================================================//
+//                ++ Flashless Boot. ++                   //
+//========================================================//
+
+typedef struct hsi_protocol_header_rec {
+	unsigned long length:32;
+} hsi_protocol_header;
+
+struct ipc_hsi_send_modem_bin_header {
+	u16 sot;		
+	u16 type;		// Request, Response
+	u16 length;
+};
+
+struct ipc_hsi_send_modem_bin_footer {
+	u16 crc;
+	u16 eot;
+};
+
+enum image_type {
+	MODEM_PSI,
+	MODEM_EBL,
+	MODEM_MAIN,
+	MODEM_NV,
+};
+
+struct image_buf {
+	u32 length;
+	u8 *buf;
+};
+
+#define HSI_SEND_BLOCK_SIZE		16 * 1024   //2048 (byte)
+#define EBL_PACKET_SIZE			HSI_SEND_BLOCK_SIZE + 24
+
+#define PSI_OFFSET			0
+#define EBL_OFFSET			0xF000
+#define MAIN_OFFSET			0x28000
+#define SWVER_OFFSET		0x9FF000
+#define SECURE_OFFSET		0x9FF800
+#define NV_OFFSET			0xa00000
+
+#define PSI_LEN			( EBL_OFFSET - PSI_OFFSET ) // 0xF058
+#define EBL_LEN			( MAIN_OFFSET - EBL_OFFSET ) // 0x13F98
+#define MAIN_LEN		( NV_OFFSET - MAIN_OFFSET ) // 0x84B04D
+#define SECURE_LEN		2048
+#define NV_LEN			( 2 * 1024 * 1024 )
+
+
+#define MAIN_OFFSET_VM		0
+#define NV_OFFSET_VM		0xD80000
+
+#define ReqSecStart				0x0204
+#define ReqSecEnd				0x0205
+#define ReqForceHwReset			0x0208
+#define ReqFlashSetAddress		0x0802
+#define ReqFlashWriteBlock		0x0804
+
+//#define CONFIG_DEBUG_FLASHLESS_BOOT
+#ifdef CONFIG_DEBUG_FLASHLESS_BOOT
+#define flashless_dbg(format,...)	
+	printk ("[ (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+#else
+#define flashless_dbg(format,...)
+#endif
+
+int received_ack = 0;
+wait_queue_head_t ipc_wait;
+
+static u16 ipc_hsi_send_modem_bin_make_crc( u8 *buf )
+{
+	u16 crc = 0;
+	int i;
+	struct ipc_hsi_send_modem_bin_header *header = ( struct ipc_hsi_send_modem_bin_header * )( buf + 4 );
+
+	crc += header->type;
+	crc += header->length;
 
+	buf += 4;
+	buf += sizeof( struct ipc_hsi_send_modem_bin_header );
+	for( i = 0 ; i < header->length ; i++ )
+		crc += *buf++;
+
+	return crc;
+}
+
+#define __USE_THREAD__
+#ifdef __USE_THREAD__
+static int read_modem_ack_thrd(void *data)
+{
+	int ret = 0;
+
+	u32 *rx_b = (u32*)data;
+	u32 mipi_length;
+
+	flashless_dbg("++  \n");
+
+	// 1. Read mipi header to know mipi length
+	flashless_dbg("Try read mpip length..  \n");
+	ret = read_hsi_direct( rx_b, 4 );
+	if( ret < 0 ) {
+		printk("(%s) can not get mipi length ! \n", __func__);
+		//goto read_fail;
+	}
+	mipi_length = *rx_b;
+	flashless_dbg("Read done (mipi length: %d)..  \n", mipi_length);
+	
+	// 2. Read payload
+	mipi_length += (4 - mipi_length % 4) % 4;
+	ret = read_hsi_direct( ++rx_b, mipi_length );
+	if( ret < 0 ) {
+		printk("(%s) can not get payload data ! \n", __func__);
+
+	}
+
+	received_ack = 1;
+	wake_up_interruptible( &ipc_wait );
+
+	flashless_dbg("-- \n ");
+
+//read_fail:
+	
+	return ret;
+}
+#else
+static int read_modem_ack_thrd(u32 *data)
+{
+	int ret = 0;
+
+	u32 *rx_b = (u32*)data;
+	u32 mipi_length;
+
+	flashless_dbg("++  \n",);
+
+	// 1. Read mipi header to know mipi length
+	flashless_dbg("Try read mpip length..  \n");
+	ret = read_hsi_direct( rx_b, 4 );
+	if( ret < 0 ) {
+		printk("(%s) can not get mipi length ! \n", __func__);
+		//goto read_fail;
+	}
+	mipi_length = *rx_b;
+	flashless_dbg("Read done (mipi length: %d)..  \n", mipi_length);
+	
+	// 2. Read payload
+	mipi_length += (4 - mipi_length % 4) % 4;
+	ret = read_hsi_direct( ++rx_b, mipi_length );
+	if( ret < 0 ) {
+		printk("(%s) can not get payload data ! \n", __func__);
+
+	}
+	
+	flashless_dbg("-- \n ");
+
+read_fail:
+	
+	return ret;
+}
+#endif
+
+static int ipc_hsi_send_modem_bin_execute_cmd( struct ipc_hsi *od, u16 type, u32 len, void *data, 
+															u8 *tx_buf, u8 *rx_buf )
+{
+	int retval = 0;
+	u8 *tx_b = tx_buf;
+	u8 *rx_b = rx_buf;
+	u8 *cur_p_tx_b = NULL;
+	u8 *cur_p_rx_b = NULL;
+	int i;
+
+	struct task_struct *read_thread;
+
+	hsi_protocol_header *tx_hsi_header = NULL;
+	hsi_protocol_header *rx_hsi_header = NULL;
+	struct ipc_hsi_send_modem_bin_header *tx_header = NULL;
+	struct ipc_hsi_send_modem_bin_footer *tx_footer = NULL;
+	struct ipc_hsi_send_modem_bin_header *rx_header = NULL;
+	int tx_padding_size = 0;
+
+	flashless_dbg("++\n");
+
+	//
+	// # 1. Init tx, rx buffer
+	//
+#if 0	
+	tx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
+	if( !tx_b ) {
+		dev_err( od->dev, "(%d) tx_b kmalloc fail.", __LINE__ );
+		return -ENOMEM;
+	}
+#endif
+	//memset( tx_b, 0, EBL_PACKET_SIZE);
+	cur_p_tx_b = tx_b;
+
+	tx_hsi_header = ( hsi_protocol_header * )cur_p_tx_b;
+	cur_p_tx_b += sizeof( hsi_protocol_header );
+
+	tx_header = ( struct ipc_hsi_send_modem_bin_header * )( cur_p_tx_b );
+	cur_p_tx_b += sizeof( struct ipc_hsi_send_modem_bin_header );
+
+#if 0
+	rx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
+	if( !rx_b ) {
+		dev_err( od->dev, "(%d) rx_b kmalloc fail.", __LINE__ );
+		return -ENOMEM;
+	}
+#endif
+	//memset( rx_b, 0, EBL_PACKET_SIZE);
+	cur_p_rx_b = rx_b;
+	
+	rx_hsi_header = ( hsi_protocol_header * )cur_p_rx_b;
+	cur_p_rx_b += sizeof( hsi_protocol_header );
+	
+	rx_header = ( struct ipc_hsi_send_modem_bin_header * ) cur_p_rx_b ;
+	cur_p_rx_b += sizeof( struct ipc_hsi_send_modem_bin_header );
+
+	//
+	// # 2. set header value
+	//
+	tx_header->sot = 0x0002;
+	tx_header->type = type;
+	
+	//
+	// # 3. set payload data
+	//
+	if ( len > 0 ) {
+		memcpy( ( void * )cur_p_tx_b, data, len );
+		cur_p_tx_b += len;
+	}
+	tx_header->length = len;  // payload_length
+	
+	//
+	// # 4. set footer value
+	//
+	tx_footer = ( struct ipc_hsi_send_modem_bin_footer * ) cur_p_tx_b;
+	cur_p_tx_b += sizeof( struct ipc_hsi_send_modem_bin_footer );
+
+	tx_footer->crc = ipc_hsi_send_modem_bin_make_crc( tx_b );
+	tx_footer->eot = 0x0003;
+
+	//
+	// # 5. set padding if we need
+	//
+	tx_padding_size = (4 - (cur_p_tx_b - tx_b) % 4) % 4;
+
+	for( i = 0; i < tx_padding_size; i++ )
+ {
+		*(cur_p_tx_b + i) = 0xEA; 
+	}
+	cur_p_tx_b += tx_padding_size;
+
+	tx_hsi_header->length = cur_p_tx_b - tx_b - sizeof( hsi_protocol_header ) - tx_padding_size;
+	
+	/*
+	dev_dbg( od->dev, "[SPI DUMP] tx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
+		tx_b[ 0 ], tx_b[ 1 ], tx_b[ 2 ], tx_b[ 3 ], tx_b[ 4 ], 
+		tx_b[ 5 ], tx_b[ 6 ], tx_b[ 7 ], tx_b[ 8 ], tx_b[ 9 ], 
+		tx_b[ 10 ], tx_b[ 11 ], tx_b[ 12 ], tx_b[ 13 ], tx_b[ 14 ], 
+		tx_b[ 15 ], tx_b[ 16 ], tx_b[ 17 ], tx_b[ 18 ], tx_b[ 19 ],
+		tx_b[ EBL_PACKET_SIZE - 10 ], tx_b[ EBL_PACKET_SIZE - 9 ], tx_b[ EBL_PACKET_SIZE - 8 ], tx_b[ EBL_PACKET_SIZE - 7 ], tx_b[ EBL_PACKET_SIZE - 6 ],
+		tx_b[ EBL_PACKET_SIZE - 5 ], tx_b[ EBL_PACKET_SIZE - 4 ], tx_b[ EBL_PACKET_SIZE - 3 ], tx_b[ EBL_PACKET_SIZE - 2 ], tx_b[ EBL_PACKET_SIZE - 1 ] );
+	*/
+
+
+#if 0	//TX DATA DUMP
+	u16 *t16;
+	t16 = tx_b;
+	printk("%d, length of byte : %d\n", __LINE__, cur_p_tx_b - tx_b );
+
+	printk("\n\nWrite DATA:");
+
+   	for( i = 0; i < (cur_p_tx_b - tx_b)/2; i++) {
+		printk("%04x ", *(t16+i));
+	}
+
+	printk("\n\n");
+
+#endif
+
+	//
+	// # 6. WRITE packet
+	//
+
+#ifdef __USE_THREAD__
+	received_ack = 0;
+
+	/*Creating read thread*/
+	if(type != ReqForceHwReset){
+		read_thread = kthread_run(read_modem_ack_thrd, rx_b, "read_modem_ack_thrd");
+	}
+
+	write_hsi_direct( (u32 *)tx_b, cur_p_tx_b - tx_b );
+	flashless_dbg("[TOTAL_TX_SIZE]: %d\n", (cur_p_tx_b - tx_b));
+
+	if(type != ReqForceHwReset){
+		flashless_dbg("\n   waiting for ACK ....\n");
+		wait_event_interruptible( ipc_wait, received_ack != 0);
+	}
+
+#else 
+	write_hsi_direct( (u32 *)tx_b, cur_p_tx_b - tx_b );
+	flashless_dbg("\n   waiting for ACK ....\n");
+	if(type != ReqForceHwReset)
+		read_modem_ack_thrd( rx_b );
+#endif
+
+#if 0
+	t16 = rx_b + sizeof(rx_hsi_header);
+	printk("Received DATA: Length %lu \n", rx_hsi_header->length);
+	for(i = 0; i < (rx_hsi_header->length)/2; i++) {
+		printk("%04x ", *(t16+i));
+	}
+	printk("\n\n Read Done!!!!!\n\n"
+);
+#endif
+
+	if( rx_header->type != type && type != ReqForceHwReset ) {
+		dev_err( od->dev, "(%d) execute cmd ack error : 0x%x(0x%x)\n", __LINE__, rx_header->type, type );
+
+		dev_err( od->dev, "[HSI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
+			rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
+			rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
+			rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
+			rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
+			rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
+			rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
+		
+		retval = -1;
+	}
+	else {
+		//		dev_dbg( od->dev, "(%d) execute cmd ack Done.\n", __LINE__ );
+	}	
+
+	/*
+	dev_dbg( od->dev, "[SPI DUMP] rx : [%02x %02x %02x %02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ... %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
+		rx_b[ 0 ], rx_b[ 1 ], rx_b[ 2 ], rx_b[ 3 ], rx_b[ 4 ], 
+		rx_b[ 5 ], rx_b[ 6 ], rx_b[ 7 ], rx_b[ 8 ], rx_b[ 9 ], 
+		rx_b[ 10 ], rx_b[ 11 ], rx_b[ 12 ], rx_b[ 13 ], rx_b[ 14 ], 
+		rx_b[ 15 ], rx_b[ 16 ], rx_b[ 17 ], rx_b[ 18 ], rx_b[ 19 ],
+		rx_b[ EBL_PACKET_SIZE - 10 ], rx_b[ EBL_PACKET_SIZE - 9 ], rx_b[ EBL_PACKET_SIZE - 8 ], rx_b[ EBL_PACKET_SIZE - 7 ], rx_b[ EBL_PACKET_SIZE - 6 ],
+		rx_b[ EBL_PACKET_SIZE - 5 ], rx_b[ EBL_PACKET_SIZE - 4 ], rx_b[ EBL_PACKET_SIZE - 3 ], rx_b[ EBL_PACKET_SIZE - 2 ], rx_b[ EBL_PACKET_SIZE - 1 ] );
+	*/
+
+#if 0
+	kfree(tx_b);
+	kfree(rx_b);
+#endif
+
+	if( type == 0x0208 ) // ReqForceHwReset
+		return 0;
+
+	flashless_dbg("--\n");
+
+	return retval;
+}
+
+
+static int ipc_hsi_send_modem_bin_xmit_img( struct ipc_hsi *od, enum image_type type, u32 *address, 
+														u8 *tx_buf, u8 *rx_buf )
+{
+	int retval = 0;
+	struct image_buf img;
+	u32 data_size;
+	u32 send_size = 0;
+	u32 rest_size = 0;
+	u8 *ptr;
+	int i;
+
+	flashless_dbg("type: %d\n", type);
+
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img type : %d.\n", __LINE__, type );
+	switch( type ) {
+		
+		case MODEM_MAIN:
+			img.buf = ( u8 * )( p_virtual_buff + MAIN_OFFSET_VM );
+			img.length = MAIN_LEN;
+			dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img save MAIN to img.\n", __LINE__ );
+				
+			break;
+			
+		case MODEM_NV:
+			img.buf = ( u8 * )( p_virtual_buff + NV_OFFSET_VM );
+			img.length = NV_LEN;
+			dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img save NV to img.\n", __LINE__ );
+			
+			break;
+			
+		default:
+			dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img wrong : %d.", __LINE__, type );
+			return -1;
+	}
+
+	//Command : ReqFlashSetAddress( 0x0802 )
+	retval = ipc_hsi_send_modem_bin_execute_cmd( od, ReqFlashSetAddress, sizeof( u32 ), address, tx_buf, rx_buf );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
+		return -1;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
+	dev_dbg( od->dev, "(%d) Start send img. size : %d\n", __LINE__, img.length );
+
+	flashless_dbg("send address (%x)  \n", *address);
+
+
+	ptr = img.buf;
+	data_size = HSI_SEND_BLOCK_SIZE;
+	rest_size = img.length;
+
+	for( i = 0 ; send_size < img.length ; i++ ) {
+		(i % 100) ?  : printk("\n%d\n", i);
+		if( rest_size < HSI_SEND_BLOCK_SIZE )
+			data_size = rest_size;
+
+		//Command : ReqFlashWriteBlock( 0x0804 )
+		retval = ipc_hsi_send_modem_bin_execute_cmd( od, ReqFlashWriteBlock, data_size, ptr, tx_buf, rx_buf );
+		if( retval < 0 ) {
+			dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
+			return -1;
+		}
+
+		send_size += data_size;
+		rest_size -= data_size;
+		ptr += data_size;
+
+		if( !( i % 100 ) )
+			dev_dbg( od->dev, "(%d) [%d] 0x%x size done, rest size: 0x%x\n", __LINE__, i, send_size, rest_size );
+	}
+
+	return retval;
+}
+
+
+static void ipc_hsi_send_modem_bin( struct work_struct *send_modem_w )
+{
+	int retval = 0;
+	u32 int_cmd = 0xABCDABCD;
+	u32 int_cmd_fail = 0xDCBADCBA;
+	u32 type = 0;
+	struct ipc_hsi_send_modem_bin_workq_data *smw 
+		= container_of( send_modem_w, struct ipc_hsi_send_modem_bin_workq_data, send_modem_w );
+	struct ipc_hsi *od = smw->od;
+
+	u32 modem_addr = 0x60300000;//0x60300000;0x61580000;0x61600000
+	//u32 nvm_static_fix_addr = 0x60e80000;//0x60e80000;0x61F80000;0x61E80000
+	//u32 nvm_static_cal_addr = 0x60f00000;//0x60f00000;0x61F00000;0x61F00000
+	//u32 nvm_dynamic_addr = 0x60f80000;//0x60f80000;0x61E80000;0x61F80000
+	u32 nvm_addr = 0x60C00000;//0x60b80000;//0x60C00000;
+	u16 sec_end = 0x0000;
+	u32 force_hw_reset = 0x00111001;
+	
+	u8 *sec_start = NULL;
+
+	u8 *tx_b;
+	u8 *rx_b;
+
+	tx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
+	if( !tx_b ) {
+		dev_err( od->dev, "(%d) tx_b kmalloc fail.", __LINE__ );
+		return; // -ENOMEM;
+	}
+	memset( tx_b, 0, EBL_PACKET_SIZE);
+
+	rx_b = kmalloc( EBL_PACKET_SIZE, GFP_ATOMIC );
+	if( !rx_b ) {
+		dev_err( od->dev, "(%d) rx_b kmalloc fail.", __LINE__ );
+		return; // -ENOMEM;
+	}
+	memset( rx_b, 0, EBL_PACKET_SIZE);
+
+
+	printk( "[HSI DUMP] mb : [%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x]\n", 
+		*( u8 * )( p_virtual_buff ), *( u8 * )( p_virtual_buff + 1 ), *( u8 * )( p_virtual_buff + 2 ), *( u8 * )( p_virtual_buff + 3 ), *( u8 * )( p_virtual_buff + 4 ), 
+		 *( u8 * )( p_virtual_buff + 5 ),  *( u8 * )( p_virtual_buff + 6 ),  *( u8 * )( p_virtual_buff + 7 ),  *( u8 * )( p_virtual_buff + 8 ),  *( u8 * )( p_virtual_buff + 9 ), 
+		*( u8 * )( p_virtual_buff + 10 ),  *( u8 * )( p_virtual_buff + 11 ),  *( u8 * )( p_virtual_buff + 12 ),  *( u8 * )( p_virtual_buff + 13 ),  *( u8 * )( p_virtual_buff + 14 ), 
+		*( u8 * )( p_virtual_buff + 15 ),  *( u8 * )( p_virtual_buff + 16 ),  *( u8 * )( p_virtual_buff + 17 ),  *( u8 * )( p_virtual_buff + 18 ),  *( u8 * )( p_virtual_buff + 19 ) );
+
+	init_waitqueue_head( &ipc_wait );
+
+
+	//Command : ReqSecStart( 0x0204 )
+	type = ReqSecStart;
+	sec_start = kmalloc( 2048, GFP_ATOMIC );
+	if( !sec_start ) {
+		dev_err( od->dev, "(%d) sec_start kmalloc fail.", __LINE__ );
+		goto err;
+	}
+	
+#if 1 //XMM6260_11A 
+	memcpy( sec_start, ( ( u8 * )p_virtual_buff + SECURE_OFFSET - MAIN_OFFSET ), 2048);	//send secure
+#else
+	memset( sec_start, 0, 2048 );
+#endif
+
+	retval = ipc_hsi_send_modem_bin_execute_cmd( od, type, 2048, ( void * )sec_start, tx_b, rx_b );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
+		goto err;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd Done.\n", __LINE__ );
+	printk("\n\n\n(%s)(%d)  1st step. DONE  \n\n\n\n\n", __func__, __LINE__);
+	
+	retval = ipc_hsi_send_modem_bin_xmit_img( od, MODEM_MAIN, &modem_addr, tx_b, rx_b );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
+		goto err;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img MODEM_MAIN Done.\n", __LINE__ );
+	printk("\n\n\n(%s)(%d)  2nd step. DONE  \n\n\n\n\n", __func__, __LINE__);
+
+	retval = ipc_hsi_send_modem_bin_xmit_img( od, MODEM_NV, &nvm_addr, tx_b, rx_b );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img fail : %d", __LINE__, retval );
+		goto err;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_xmit_img MODEM_NV:nvm_addr Done.\n", __LINE__ );
+	printk("\n\n\n(%s)(%d)  3rd step. DONE  \n\n\n\n\n", __func__, __LINE__);
+
+	//Command : ReqSecEnd( 0x0205 )
+	retval = ipc_hsi_send_modem_bin_execute_cmd( od, ReqSecEnd, sizeof( u16 ), &sec_end, tx_b, rx_b );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
+		goto err;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd; ReqSecEnd Done.\n", __LINE__ );
+	printk("\n\n\n(%s)(%d)  4th step. DONE  \n\n\n\n\n", __func__, __LINE__);
+
+	//Command : ReqForceHwReset( 0x0208 )
+	retval = ipc_hsi_send_modem_bin_execute_cmd( od, ReqForceHwReset, sizeof( u32 ), &force_hw_reset, tx_b, rx_b );
+	if( retval < 0 ) {
+		dev_err( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd fail : %d", __LINE__, retval );
+		goto err;
+	}
+	dev_dbg( od->dev, "(%d) ipc_hsi_send_modem_bin_execute_cmd; ReqForceHwReset Done.\n", __LINE__ );
+
+	printk("\n\n\n(%s)(%d)  5th step. DONE  \n\n\n\n\n", __func__, __LINE__);
+
+	kfree( sec_start );
+
+	// make data interrupt cmd
+	ipc_hsi_make_data_interrupt( od, int_cmd );
+
+	kfree(tx_b);
+	kfree(rx_b);
 	return;
 
 err :
-	// make data interrupt cmd for fail
+	kfree(tx_b);
+	kfree(rx_b);
+	
+	// make data interrupt cmd
 	ipc_hsi_make_data_interrupt( od, int_cmd_fail );
 }
 
+//========================================================//
+//                -- Flashless Boot --                    //
+//========================================================//
+
+
+
+
 #if 0
 extern void ( *onedram_cp_force_crash ) ( void );
 static void ipc_hsi_cp_force_crash( void )
@@ -2004,7 +2972,6 @@
 	cp_restart = 1;
 
 	ipc_hsi_clear_all_vbuff( ipc_hsi );
-	init_completion( &ril_init );
 }
 EXPORT_SYMBOL( ipc_hsi_restart_hsi );
 
@@ -2015,6 +2982,7 @@
 	struct ipc_hsi *od = NULL;
 	struct ipc_hsi_platform_data *pdata;
 	struct resource *res;
+	struct task_struct *tx_thread = NULL;
 
 	printk( "[%s]\n",__func__ );
 	
@@ -2094,25 +3062,23 @@
 	}
 	od->irq_suspend_req = irq_suspend_req;
 
-	r = kernel_thread( ipc_hsi_tx_thread, ( void * )od, 0 );
-	if( r < 0 ) {
-		dev_err( &pdev->dev, "kernel_thread() failed : %d\n", r );
-		
-		goto err;
-	}
+	hsi_start_protocol_single(); 
+	dev_err( &pdev->dev, "(%d) hsi_start_protocol_single Done.\n", __LINE__ );
 
-	r = kernel_thread( ipc_hsi_rx_thread, ( void * )od, 0 );
-	if( r < 0 ) {
-		dev_err( &pdev->dev, "kernel_thread() failed : %d\n", r );
-		
-		goto err;
+	if( tx_thread == NULL ) {
+		tx_thread = kthread_run( ipc_hsi_tx_thread, ( void * )od, "ipc_hsi_tx_thread" );
+		if( IS_ERR( tx_thread ) ) {
+			dev_err( od->dev, "(%d) kthread_run() - ipc_hsi_tx_thread failed.\n", __LINE__ );
+			goto err;
+		}
+		dev_err( od->dev, "(%d) kthread_run() - ipc_hsi_tx_thread Done.\n", __LINE__ );
 	}
-
+	else {
+		dev_err( od->dev, "(%d) ipc_hsi_tx_thread already exist.\n", __LINE__ );
+	}
+	
 //	onedram_cp_force_crash = ipc_hsi_cp_force_crash;
 
-	hsi_start_protocol();
-	dev_err( &pdev->dev, "(%d) hsi_start_protocol Done.\n", __LINE__ );
-
 	dev_err( &pdev->dev, "(%d) platform probe Done.\n", __LINE__ );
 
 	return 0;
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/phone_svn/modemctl/modemctl.c Kernel/drivers/phone_svn/modemctl/modemctl.c
--- Kernel-orig/drivers/phone_svn/modemctl/modemctl.c	2011-02-16 11:29:38.482105455 +0530
+++ Kernel/drivers/phone_svn/modemctl/modemctl.c	2011-02-08 15:17:55.047779943 +0530
@@ -271,7 +271,7 @@
 	}
 
 	if( check_phone_restart ) {
-		dev_dbg( mc->dev, "%s: Phone Restart SPI Init.\n", __func__ );
+		dev_dbg( mc->dev, "%s: Phone Restart HSI Init.\n", __func__ );
 		ipc_hsi_restart_hsi();
 	}
 	else {
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/phone_svn/svnet/sipc4.h Kernel/drivers/phone_svn/svnet/sipc4.h
--- Kernel-orig/drivers/phone_svn/svnet/sipc4.h	2011-02-16 11:29:38.212104866 +0530
+++ Kernel/drivers/phone_svn/svnet/sipc4.h	2011-02-08 15:17:55.057772204 +0530
@@ -42,33 +42,33 @@
 	0x00_10A0       -------------------------------------------
 			RESERVED        (1MB - 4kb-4kb-4kb - 160B)
 	0x0F_E000       -------------------------------------------
-			Formatted Out                   (4KB)
-	0x0F_F000       -------------------------------------------
-			Formatted In                    (4KB)
-	0x10_0000       ===========================================
+			Formatted Out                   (64KB)
+	0x10_E000       -------------------------------------------
+			Formatted In                    (64KB)
+	0x11_E000       ===========================================
 			Raw Out                         (1MB)
-	0x20_0000       ===========================================
+	0x21_E000       ===========================================
 			Raw In                          (1MB)
-	0x30_0000       ===========================================
+	0x31_E000       ===========================================
 			RemoteFS Out                    (1MB)
-	0x40_0000       ===========================================
+	0x41_E000       ===========================================
 			RemoteFS In                     (1MB)
-	0x50_0000       ===========================================
+	0x51_E000       ===========================================
 
 	0xFF_FFFF       ===========================================     
 */
 
-#define FMT_OUT    0x0FE000
-#define FMT_IN     0x0FF000
-#define FMT_SZ     0x1000   /* 4096 bytes */
-
-#define RAW_OUT    0x100000
-#define RAW_IN     0x200000
-#define RAW_SZ     0x100000 /* 1 MB */
-
-#define RFS_OUT    0x300000
-#define RFS_IN     0x400000
-#define RFS_SZ     0x100000 /* 1 MB */
+#define FMT_OUT	0x0FE000
+#define FMT_IN		0x10E000
+#define FMT_SZ		0x10000   /* 65536 bytes */
+
+#define RAW_OUT	0x11E000
+#define RAW_IN		0x21E000
+#define RAW_SZ		0x100000 /* 1 MB */
+
+#define RFS_OUT	0x31E000
+#define RFS_IN		0x41E000
+#define RFS_SZ		0x100000 /* 1 MB */
 
 #define FATAL_DISP     0x001000
 #define FATAL_DISP_SZ  0xA0  /* 160 bytes */
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver.c Kernel/drivers/staging/omap_hsi/hsi_driver.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver.c	2011-02-09 13:07:23.127772655 +0530
@@ -31,16 +31,106 @@
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 
+#include <plat/omap_device.h>
+
 #include "hsi_driver.h"
 
 #define HSI_MODULENAME "omap_hsi"
-#define	HSI_DRIVER_VERSION	"0.2"
+#define	HSI_DRIVER_VERSION	"0.3.0"
 #define HSI_RESETDONE_MAX_RETRIES	5 /* Max 5*L4 Read cycles waiting for */
 					  /* reset to complete */
 #define HSI_RESETDONE_NORMAL_RETRIES	1 /* Reset should complete in 1 R/W */
 					  /* cycle */
 
 
+static void hsi_save_ctx(struct hsi_dev *hsi_ctrl)
+{
+	struct hsi_platform_data *pdata = hsi_ctrl->dev->platform_data;
+	struct platform_device *pdev = to_platform_device(hsi_ctrl->dev);
+	void __iomem *base = hsi_ctrl->base;
+	struct port_ctx *p;
+	int port;
+
+	pdata->ctx->sysconfig = hsi_inl(base, HSI_SYS_SYSCONFIG_REG);
+	pdata->ctx->gdd_gcr = hsi_inl(base, HSI_GDD_GCR_REG);
+	if (hsi_driver_device_is_hsi(pdev))
+		pdata->ctx->dll = hsi_inl(base, HSI_HSR_DLL_REG);
+
+	for (port = 1; port <= pdata->num_ports; port++) {
+		p = &pdata->ctx->pctx[port - 1];
+		/* HSI TOP */
+		p->sys_mpu_enable[0] = hsi_inl(base,
+					       HSI_SYS_MPU_ENABLE_REG(port, 0));
+		p->sys_mpu_enable[1] = hsi_inl(base,
+				       HSI_SYS_MPU_U_ENABLE_REG(port, 0));
+
+		/* HST */
+		p->hst.mode = hsi_inl(base, HSI_HST_MODE_REG(port));
+		if (!hsi_driver_device_is_hsi(pdev))
+			p->hst.frame_size = hsi_inl(base,
+						HSI_HST_FRAMESIZE_REG(port));
+		p->hst.divisor = hsi_inl(base, HSI_HST_DIVISOR_REG(port));
+		p->hst.channels = hsi_inl(base, HSI_HST_CHANNELS_REG(port));
+		p->hst.arb_mode = hsi_inl(base, HSI_HST_ARBMODE_REG(port));
+
+		/* HSR */
+		p->hsr.mode = hsi_inl(base, HSI_HSR_MODE_REG(port));
+		if (!hsi_driver_device_is_hsi(pdev))
+			p->hsr.frame_size = hsi_inl(base,
+						HSI_HSR_FRAMESIZE_REG(port));
+		p->hsr.divisor = hsi_inl(base, HSI_HSR_DIVISOR_REG(port));
+		p->hsr.channels = hsi_inl(base, HSI_HSR_CHANNELS_REG(port));
+		p->hsr.counters = hsi_inl(base, HSI_HSR_COUNTERS_REG(port));
+	}
+}
+
+static void hsi_restore_ctx(struct hsi_dev *hsi_ctrl)
+{
+	struct hsi_platform_data *pdata = hsi_ctrl->dev->platform_data;
+	struct platform_device *pdev = to_platform_device(hsi_ctrl->dev);
+	void __iomem *base = hsi_ctrl->base;
+	struct port_ctx *p;
+	int port;
+
+	hsi_outl(pdata->ctx->sysconfig, base, HSI_SYS_SYSCONFIG_REG);
+	hsi_outl(pdata->ctx->gdd_gcr, base, HSI_GDD_GCR_REG);
+	if (hsi_driver_device_is_hsi(pdev))
+		hsi_outl(pdata->ctx->dll, base, HSI_HSR_DLL_REG);
+
+	for (port = 1; port <= pdata->num_ports; port++) {
+		p = &pdata->ctx->pctx[port - 1];
+		/* HSI TOP */
+		hsi_outl(p->sys_mpu_enable[0], base,
+			 HSI_SYS_MPU_ENABLE_REG(port, 0));
+		hsi_outl(p->sys_mpu_enable[1], base,
+			 HSI_SYS_MPU_U_ENABLE_REG(port, 0));
+
+		/* HST */
+		hsi_outl(p->hst.mode, base, HSI_HST_MODE_REG(port));
+		if (!hsi_driver_device_is_hsi(pdev))
+			hsi_outl(p->hst.frame_size, base,
+				HSI_HST_FRAMESIZE_REG(port));
+		hsi_outl(p->hst.divisor, base, HSI_HST_DIVISOR_REG(port));
+		hsi_outl(p->hst.channels, base, HSI_HST_CHANNELS_REG(port));
+		hsi_outl(p->hst.arb_mode, base, HSI_HST_ARBMODE_REG(port));
+
+		/* HSR */
+		hsi_outl(p->hsr.mode, base, HSI_HSR_MODE_REG(port));
+		if (!hsi_driver_device_is_hsi(pdev))
+			hsi_outl(p->hsr.frame_size, base,
+				HSI_HSR_FRAMESIZE_REG(port));
+		hsi_outl(p->hsr.divisor, base, HSI_HSR_DIVISOR_REG(port));
+		hsi_outl(p->hsr.channels, base, HSI_HSR_CHANNELS_REG(port));
+		hsi_outl(p->hsr.counters, base, HSI_HSR_COUNTERS_REG(port));
+	}
+
+	if (hsi_driver_device_is_hsi(pdev)) {
+		/* SW strategy for HSI fifo management can be changed here */
+		hsi_fifo_mapping(hsi_ctrl, HSI_FIFO_MAPPING_DEFAULT);
+	}
+}
+
+
 /* NOTE: Function called in soft interrupt context (tasklet) */
 int hsi_port_event_handler(struct hsi_port *p, unsigned int event, void *arg)
 {
@@ -216,7 +306,8 @@
 	struct platform_device *pdev = to_platform_device(hsi_ctrl->dev);
 
 	for (port = 1; port <= pdata->num_ports; port++) {
-		cfg = &pdata->ctx.pctx[port - 1];
+		cfg = &pdata->ctx->pctx[port - 1];
+		/* HST */
 		hsi_outl(cfg->hst.mode | cfg->hst.flow |
 			HSI_HST_MODE_WAKE_CTRL_SW, base,
 			HSI_HST_MODE_REG(port));
@@ -227,20 +318,23 @@
 		hsi_outl(cfg->hst.channels, base, HSI_HST_CHANNELS_REG(port));
 		hsi_outl(cfg->hst.arb_mode, base, HSI_HST_ARBMODE_REG(port));
 
+		/* HSR */
 		hsi_outl(cfg->hsr.mode | cfg->hsr.flow, base,
 			 HSI_HSR_MODE_REG(port));
-		hsi_outl(cfg->hsr.frame_size, base,
-			 HSI_HSR_FRAMESIZE_REG(port));
+		if (!hsi_driver_device_is_hsi(pdev))
+			hsi_outl(cfg->hsr.frame_size, base,
+				 HSI_HSR_FRAMESIZE_REG(port));
 		hsi_outl(cfg->hsr.channels, base, HSI_HSR_CHANNELS_REG(port));
 		if (hsi_driver_device_is_hsi(pdev))
 			hsi_outl(cfg->hsr.divisor, base,
 				 HSI_HSR_DIVISOR_REG(port));
-		hsi_outl(cfg->hsr.timeout, base, HSI_HSR_COUNTERS_REG(port));
+		hsi_outl(cfg->hsr.counters, base, HSI_HSR_COUNTERS_REG(port));
 	}
 
 	if (hsi_driver_device_is_hsi(pdev)) {
 		/* SW strategy for HSI fifo management can be changed here */
 		hsi_fifo_mapping(hsi_ctrl, HSI_FIFO_MAPPING_DEFAULT);
+		hsi_outl(pdata->ctx->dll, base, HSI_HSR_DLL_REG);
 	}
 }
 
@@ -301,7 +395,7 @@
 	for (port = 0; port < hsi_ctrl->max_p; port++) {
 		hsi_p = &hsi_ctrl->hsi_port[port];
 		hsi_p->counters_on = 1;
-		hsi_p->reg_counters = pdata->ctx.pctx[port].hsr.timeout;
+		hsi_p->reg_counters = pdata->ctx->pctx[port].hsr.counters;
 		hsi_port_channels_reset(&hsi_ctrl->hsi_port[port]);
 	}
 
@@ -402,8 +496,10 @@
 		hsi_p->max_ch = hsi_driver_device_is_hsi(pd) ?
 		    HSI_CHANNELS_MAX : HSI_SSI_CHANNELS_MAX;
 		hsi_p->irq = 0;
+		hsi_p->cawake_status = -1; /* Unknown */
+		hsi_p->acwake_status = 0;
 		hsi_p->counters_on = 1;
-		hsi_p->reg_counters = pdata->ctx.pctx[port].hsr.timeout;
+		hsi_p->reg_counters = pdata->ctx->pctx[port].hsr.counters;
 		spin_lock_init(&hsi_p->lock);
 		err = hsi_port_channels_init(&hsi_ctrl->hsi_port[port]);
 		if (err < 0)
@@ -478,34 +574,12 @@
 	return 0;
 }
 
-void hsi_clocks_disable(struct device *dev, const char *s)
-{
-	int ret;
-
-	dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_disable: %s\n", s);
-	/* HSI_TODO : this can probably be changed
-	 * to return pm_runtime_put(dev);
-	 */
-	ret = pm_runtime_put_sync(dev);
-	/*pr_info(", returns %d\n", ret);*/
-}
-
-int hsi_clocks_enable(struct device *dev, const char *s)
-{
-	dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_enable: %s\n", s);
-	/* Calls platform_bus_type.pm->runtime_resume(dev)
-	 * which in turn calls :
-	 *  - omap_device_enable()
-	 *  - dev->driver->pm->runtime_resume(dev)
-	 */
-	return pm_runtime_get_sync(dev);
-}
-
 /**
 * hsi_clocks_disable_channel - virtual wrapper for disabling HSI clocks for
 * a given channel
 * @dev - reference to the hsi device.
 * @channel_number - channel number which requests clock to be disabled
+*		    0xFF means no particular channel
 *
 * Note : there is no real HW clock management per HSI channel, this is only
 * virtual to keep track of active channels and ease debug
@@ -513,10 +587,28 @@
 void hsi_clocks_disable_channel(struct device *dev, u8 channel_number,
 				const char *s)
 {
+	struct platform_device *pd = to_platform_device(dev);
+	struct hsi_dev *hsi_ctrl = platform_get_drvdata(pd);
 	int ret;
 
-	dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_disable for channel %d: %s\n",
-		channel_number, s);
+	if (channel_number != 0xFF)
+		dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_disable for "
+			"channel %d: %s\n", channel_number, s);
+	else
+		dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_disable: %s\n", s);
+
+	if (!hsi_ctrl->clock_enabled) {
+		dev_dbg(dev, "Clocks already disabled, skipping...\n");
+		return;
+	}
+	if (hsi_is_hsi_controller_busy(hsi_ctrl)) {
+		dev_dbg(dev, "Cannot disable clocks, HSI port busy\n");
+		return;
+	}
+
+	/* HSI_TODO : this can probably be changed
+	 * to return pm_runtime_put(dev);
+	 */
 	ret = pm_runtime_put_sync(dev);
 	/*pr_info(", returns %d\n", ret);*/
 }
@@ -526,6 +618,7 @@
 * a given channel
 * @dev - reference to the hsi device.
 * @channel_number - channel number which requests clock to be enabled
+*		    0xFF means no particular channel
 *
 * Note : there is no real HW clock management per HSI channel, this is only
 * virtual to keep track of active channels and ease debug
@@ -533,8 +626,20 @@
 int hsi_clocks_enable_channel(struct device *dev, u8 channel_number,
 				const char *s)
 {
-	dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_enable for channel %d: %s\n",
-		channel_number, s);
+	struct platform_device *pd = to_platform_device(dev);
+	struct hsi_dev *hsi_ctrl = platform_get_drvdata(pd);
+
+	if (channel_number != 0xFF)
+		dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_enable for "
+			"channel %d: %s\n", channel_number, s);
+	else
+		dev_dbg(dev, "HSI DRIVER CLK: hsi_clocks_enable: %s\n", s);
+
+	if (hsi_ctrl->clock_enabled) {
+		dev_dbg(dev, "Clocks already enabled, skipping...\n");
+		return -EEXIST;
+	}
+
 	return pm_runtime_get_sync(dev);
 }
 
@@ -683,6 +788,13 @@
 	/* From here no need for HSI HW access */
 	hsi_clocks_disable(hsi_ctrl->dev, __func__);
 
+	/* Set the HSI FCLK to default. */
+	err = omap_device_set_rate(hsi_ctrl->dev, hsi_ctrl->dev,
+					pdata->default_hsi_fclk);
+	if (err)
+		dev_err(&pd->dev, "Cannot set HSI FClk to default value: %ld\n",
+			pdata->default_hsi_fclk);
+
 	return err;
 
 rollback3:
@@ -721,7 +833,7 @@
 }
 
 #ifdef CONFIG_SUSPEND
-static int hsi_suspend(struct device *dev)
+static int hsi_suspend_noirq(struct device *dev)
 {
 	dev_dbg(dev, "%s\n", __func__);
 
@@ -730,7 +842,7 @@
 	return 0;
 }
 
-static int hsi_resume(struct device *dev)
+static int hsi_resume_noirq(struct device *dev)
 {
 	dev_dbg(dev, "%s\n", __func__);
 
@@ -749,14 +861,22 @@
 */
 static int hsi_runtime_resume(struct device *dev)
 {
+	struct platform_device *pd = to_platform_device(dev);
+	struct hsi_dev *hsi_ctrl = platform_get_drvdata(pd);
+
 	dev_dbg(dev, "%s\n", __func__);
+
+	if (hsi_ctrl->clock_enabled)
+		dev_warn(dev, "Warning: clock status mismatch vs runtime PM\n");
+
+	hsi_ctrl->clock_enabled = true;
+
 	/* Restore context */
+	hsi_restore_ctx(hsi_ctrl);
 
 	/* HSI device is now fully operational and _must_ be able to */
 	/* complete I/O operations */
 
-	/* HSI_TODO : missing the runtime resume feature */
-
 	return 0;
 }
 
@@ -770,12 +890,20 @@
 */
 static int hsi_runtime_suspend(struct device *dev)
 {
+	struct platform_device *pd = to_platform_device(dev);
+	struct hsi_dev *hsi_ctrl = platform_get_drvdata(pd);
+
 	dev_dbg(dev, "%s\n", __func__);
+
+	if (!hsi_ctrl->clock_enabled)
+		dev_warn(dev, "Warning: clock status mismatch vs runtime PM\n");
+
 	/* Save context */
+	hsi_save_ctx(hsi_ctrl);
 
-	/* HSI is now ready to be put in low power state */
+	hsi_ctrl->clock_enabled = false;
 
-	/* HSI_TODO : missing the runtime suspend feature */
+	/* HSI is now ready to be put in low power state */
 
 	return 0;
 }
@@ -832,8 +960,8 @@
 #ifdef CONFIG_PM
 static const struct dev_pm_ops hsi_driver_pm_ops = {
 #ifdef CONFIG_SUSPEND
-	.suspend = hsi_suspend,
-	.resume = hsi_resume,
+	.suspend_noirq = hsi_suspend_noirq,
+	.resume_noirq = hsi_resume_noirq,
 #endif
 #ifdef CONFIG_PM_RUNTIME
 	.runtime_suspend = hsi_runtime_suspend,
@@ -883,7 +1011,6 @@
 		pr_err(LOG_NAME "Platform DRIVER register FAILED: %d\n", err);
 		goto rback2;
 	}
-
 	return 0;
 rback2:
 	hsi_debug_exit();
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_debugfs.c Kernel/drivers/staging/omap_hsi/hsi_driver_debugfs.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_debugfs.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_debugfs.c	2011-02-09 13:07:23.157780239 +0530
@@ -161,7 +161,7 @@
 					   HSI_HSR_MAPPING_FIFO_REG(fifo)));
 		}
 		seq_printf(m, "DLL\t: 0x%08x\n",
-			   hsi_inl(base, HSI_HSR_DLL_REG(port)));
+			   hsi_inl(base, HSI_HSR_DLL_REG));
 		seq_printf(m, "DIVISOR\t: 0x%08x\n",
 			   hsi_inl(base, HSI_HSR_DIVISOR_REG(port)));
 	}
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_dma.c Kernel/drivers/staging/omap_hsi/hsi_driver_dma.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_dma.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_dma.c	2011-02-14 12:44:05.614758626 +0530
@@ -59,6 +59,7 @@
 		}
 	}
 
+	lch = hsi_ctrl->gdd_chan_count;
 	return lch;
 }
 
@@ -177,7 +178,7 @@
 		dev_err(hsi_ctrl->dev, "No free GDD logical channels.\n");
 		return -EBUSY;	/* No free GDD logical channels. */
 	} else {
-		dev_dbg(hsi_ctrl->dev, "Allocated DMA channel %d for read on"
+		dev_dbg(hsi_ctrl->dev, "Allocated DMA channel %d for write on"
 					" HSI channel %d.\n", lch,
 					hsi_channel->channel_number);
 	}
@@ -356,6 +357,7 @@
 static void do_hsi_gdd_lch(struct hsi_dev *hsi_ctrl, unsigned int gdd_lch)
 {
 	void __iomem *base = hsi_ctrl->base;
+	struct platform_device *pdev = to_platform_device(hsi_ctrl->dev);
 	struct hsi_channel *ch;
 	unsigned int port;
 	unsigned int channel;
@@ -363,22 +365,22 @@
 	u32 gdd_csr;
 	dma_addr_t dma_h;
 	size_t size;
+	u8 fifo, fifo_words_avail;
+
+	spin_lock(&hsi_ctrl->lock);
 
 	if (hsi_get_info_from_gdd_lch(hsi_ctrl, gdd_lch, &port, &channel,
 				      &is_read_path) < 0) {
+		spin_unlock(&hsi_ctrl->lock);
 		dev_err(hsi_ctrl->dev, "Unable to match the DMA channel %d with"
 			" an HSI channel\n", gdd_lch);
 		return;
-	}
-/* FIXME: to remove when validated: */
-	else {
+	} else {
 		dev_dbg(hsi_ctrl->dev, "DMA event on gdd_lch=%d => port=%d, "
 			"channel=%d, read=%d\n", gdd_lch, port, channel,
 			is_read_path);
 	}
 
-	spin_lock(&hsi_ctrl->lock);
-
 	hsi_outl_and(~HSI_GDD_LCH(gdd_lch), base,
 		     HSI_SYS_GDD_MPU_IRQ_ENABLE_REG);
 	gdd_csr = hsi_inw(base, HSI_GDD_CSR_REG(gdd_lch));
@@ -398,7 +400,25 @@
 			 */
 			hsi_driver_enable_read_interrupt(ch, NULL);
 			spin_unlock(&hsi_ctrl->lock);
+
+			dev_dbg(hsi_ctrl->dev, "Calling read callback "
+						"(size %d).\n", size/4);
 			ch->read_done(ch->dev, size / 4);
+
+			/* Check if FIFO is correctly emptied */
+			if (hsi_driver_device_is_hsi(pdev)) {
+				fifo = hsi_fifo_get_id(hsi_ctrl, channel, port);
+				fifo_words_avail =
+					hsi_get_rx_fifo_occupancy(hsi_ctrl,
+								fifo);
+//				if (fifo_words_avail)
+//					dev_warn(hsi_ctrl->dev,
+//						"WARNING: FIFO %d not empty "
+//						"after DMA copy, remaining "
+//						"%d/%d frames\n",
+//						fifo, fifo_words_avail,
+//						HSI_HSR_FIFO_SIZE);
+			}
 		} else {	/* Write path */
 			dma_h = hsi_inl(base, HSI_GDD_CSSA_REG(gdd_lch));
 			size = hsi_inw(base, HSI_GDD_CEN_REG(gdd_lch)) * 4;
@@ -407,6 +427,9 @@
 			ch = hsi_ctrl_get_ch(hsi_ctrl, port, channel);
 			hsi_reset_ch_write(ch);
 			spin_unlock(&hsi_ctrl->lock);
+
+			dev_dbg(hsi_ctrl->dev, "Calling write callback "
+						"(size %d).\n", size/4);
 			ch->write_done(ch->dev, size / 4);
 		}
 	} else {
@@ -418,9 +441,8 @@
 	}
 }
 
-static void do_hsi_gdd_tasklet(unsigned long device)
+static u32 hsi_process_dma_event(struct hsi_dev *hsi_ctrl)
 {
-	struct hsi_dev *hsi_ctrl = (struct hsi_dev *)device;
 	void __iomem *base = hsi_ctrl->base;
 	unsigned int gdd_lch = 0;
 	u32 status_reg = 0;
@@ -429,6 +451,11 @@
 
 	status_reg = hsi_inl(base, HSI_SYS_GDD_MPU_IRQ_STATUS_REG);
 
+	if (!status_reg) {
+		dev_dbg(hsi_ctrl->dev, "DMA : no event, exit.\n");
+		return 0;
+	}
+
 	for (gdd_lch = 0; gdd_lch < gdd_max_count; gdd_lch++) {
 		if (status_reg & HSI_GDD_LCH(gdd_lch)) {
 			do_hsi_gdd_lch(hsi_ctrl, gdd_lch);
@@ -441,17 +468,39 @@
 	status_reg = hsi_inl(base, HSI_SYS_GDD_MPU_IRQ_STATUS_REG);
 	status_reg &= hsi_inl(base, HSI_SYS_GDD_MPU_IRQ_ENABLE_REG);
 
-	if (status_reg)
-		tasklet_hi_schedule(&hsi_ctrl->hsi_gdd_tasklet);
-	else
-		enable_irq(hsi_ctrl->gdd_irq);
+	return status_reg;
 }
 
-static irqreturn_t hsi_gdd_mpu_handler(int irq, void *hsi_controller)
+static void do_hsi_gdd_tasklet(unsigned long device)
 {
-	struct hsi_dev *hsi_ctrl = hsi_controller;
+	struct hsi_dev *hsi_ctrl = (struct hsi_dev *)device;
+	u32 status_reg;
+
+	dev_dbg(hsi_ctrl->dev, "DMA Tasklet : clock_enabled=%d\n",
+		hsi_ctrl->clock_enabled);
+
+	hsi_clocks_enable(hsi_ctrl->dev, __func__);
+
+	status_reg = hsi_process_dma_event(hsi_ctrl);
+
+	/* Check if clocks are still needed */
+	if (!hsi_is_hsi_controller_busy(hsi_ctrl)) {
+		dev_dbg(hsi_ctrl->dev, "DMA Tasklet : disabling clocks\n");
+
+		hsi_clocks_disable(hsi_ctrl->dev, __func__);
+	}
+
+	enable_irq(hsi_ctrl->gdd_irq);
+}
+
+static irqreturn_t hsi_gdd_mpu_handler(int irq, void *p)
+{
+	struct hsi_dev *hsi_ctrl = p;
 
 	tasklet_hi_schedule(&hsi_ctrl->hsi_gdd_tasklet);
+
+	/* Disable interrupt until Bottom Half has cleared the IRQ status */
+	/* register */
 	disable_irq_nosync(hsi_ctrl->gdd_irq);
 
 	return IRQ_HANDLED;
@@ -461,6 +510,10 @@
 {
 	tasklet_init(&hsi_ctrl->hsi_gdd_tasklet, do_hsi_gdd_tasklet,
 		     (unsigned long)hsi_ctrl);
+
+	dev_info(hsi_ctrl->dev, "Registering IRQ %s (%d)\n",
+					irq_name, hsi_ctrl->gdd_irq);
+
 	if (request_irq(hsi_ctrl->gdd_irq, hsi_gdd_mpu_handler, IRQF_DISABLED,
 			irq_name, hsi_ctrl) < 0) {
 		dev_err(hsi_ctrl->dev, "FAILED to request GDD IRQ %d\n",
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_fifo.c Kernel/drivers/staging/omap_hsi/hsi_driver_fifo.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_fifo.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_fifo.c	2011-02-09 13:07:23.207781425 +0530
@@ -66,7 +66,7 @@
 
 fifo_id_bk:
 	if (unlikely(err < 0)) {
-		dev_err(hsi_ctrl->dev, "Cannot map a fifo to the requested "
+		dev_err(hsi_ctrl->dev, "Cannot map a FIFO to the requested "
 			"params: channel:%d, port:%d; ERR=%d\n", channel, port,
 			fifo_index);
 		fifo_index = err;
@@ -155,6 +155,7 @@
 			channel++;
 		}
 		hsi_ctrl->fifo_mapping_strategy = HSI_FIFO_MAPPING_ALL_PORT1;
+		dev_dbg(hsi_ctrl->dev, "Fifo mapping : All FIFOs for Port1\n");
 	} else if (mtype == HSI_FIFO_MAPPING_SSI) {
 		channel = 0;
 		port = 0;
@@ -175,7 +176,9 @@
 			}
 		}
 
-		hsi_ctrl->fifo_mapping_strategy = HSI_FIFO_MAPPING_DEFAULT;
+		hsi_ctrl->fifo_mapping_strategy = HSI_FIFO_MAPPING_SSI;
+		dev_dbg(hsi_ctrl->dev, "Fifo mapping : 8 FIFOs per Port "
+					"(SSI compatible mode)\n");
 	} else {
 		hsi_ctrl->fifo_mapping_strategy = HSI_FIFO_MAPPING_UNDEF;
 		dev_err(hsi_ctrl->dev, "Bad Fifo strategy request\n");
@@ -288,3 +291,24 @@
 		return HSI_HSR_BUFFER_CH_REG(port, channel);
 	}
 }
+
+
+/**
+ * hsi_get_rx_fifo_occupancy - Return the size of data remaining
+ *				in the given FIFO
+ * @hsi_ctrl - HSI controler data
+ * @fifo - FIFO to look at
+ *
+ * Returns the number of frames (32bits) remaining in the FIFO
+ */
+u8 hsi_get_rx_fifo_occupancy(struct hsi_dev *hsi_ctrl, u8 fifo)
+{
+	void __iomem *base = hsi_ctrl->base;
+	int hsr_mapping, mapping_words;
+
+	hsr_mapping = hsi_inl(base, HSI_HSR_MAPPING_FIFO_REG(fifo));
+	mapping_words = (hsr_mapping >> HSI_HST_MAPPING_THRESH_OFFSET) & 0xF;
+
+	return mapping_words;
+}
+
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_gpio.c Kernel/drivers/staging/omap_hsi/hsi_driver_gpio.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_gpio.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_gpio.c	2011-02-09 13:07:23.217780950 +0530
@@ -25,6 +25,9 @@
 {
 	struct hsi_port *port = (struct hsi_port *)hsi_p;
 
+	/* SSI_TODO : clocks needs to be enabled here */
+	port->cawake_status = hsi_get_cawake(port);
+
 	hsi_do_cawake_process(port);
 }
 
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver.h Kernel/drivers/staging/omap_hsi/hsi_driver.h
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver.h	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver.h	2011-02-09 13:07:23.137781189 +0530
@@ -28,12 +28,14 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/spinlock.h>
+#include <linux/workqueue.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 #include <linux/notifier.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/pm_runtime.h>
 
 #include <mach/omap_hsi.h>
 #include <linux/hsi_driver_if.h>
@@ -56,13 +58,13 @@
 
 #define LOG_NAME		"OMAP HSI: "
 
-/* SW strategies for FIFO mapping */
+/* SW strategies for HSI FIFO mapping */
 enum {
 	HSI_FIFO_MAPPING_UNDEF = 0,
 	HSI_FIFO_MAPPING_SSI,	/* 8 FIFOs per port (SSI compatible mode) */
 	HSI_FIFO_MAPPING_ALL_PORT1,	/* ALL FIFOs mapped on 1st port */
 };
-#define HSI_FIFO_MAPPING_DEFAULT	HSI_FIFO_MAPPING_SSI
+#define HSI_FIFO_MAPPING_DEFAULT	HSI_FIFO_MAPPING_ALL_PORT1
 
 /* Device identifying constants */
 enum {
@@ -119,27 +121,32 @@
  * @irq: IRQ number
  * @cawake_gpio: GPIO number for cawake line (-1 if none)
  * @cawake_gpio_irq: IRQ number for cawake gpio events
+ * @cawake_status: Tracks CAWAKE line status
+ * @acwake_status: Bitmap to track ACWAKE line status per channel
  * @counters_on: indicates if the HSR counters are in use or not
  * @reg_counters: stores the previous counters values when deactivated
  * @lock: Serialize access to the port registers and internal data
- * @hsi_tasklet: Bottom half for interrupts
+ * @hsi_tasklet: Bottom half for Interrupts when clocks are enabled
  * @cawake_tasklet: Bottom half for cawake events
  */
 struct hsi_port {
 	struct hsi_channel hsi_channel[HSI_PORT_MAX_CH];
 	struct hsi_dev *hsi_controller;
 	u8 flags;
-	u8 port_number;
+	u8 port_number;		/* Range [1,2] */
 	u8 max_ch;
 	u8 n_irq;
 	int irq;
 	int cawake_gpio;
 	int cawake_gpio_irq;
+	int cawake_status;
+	unsigned int acwake_status;	/* HSI_TODO : fine tune init values */
 	int counters_on;
 	unsigned long reg_counters;
 	spinlock_t lock; /* access to the port registers and internal data */
 	struct tasklet_struct hsi_tasklet;
-	struct tasklet_struct cawake_tasklet;
+	struct tasklet_struct cawake_tasklet;	/* SSI_TODO : need to replace */
+						/* by a workqueue */
 };
 
 /**
@@ -153,8 +160,7 @@
  * @base: HSI registers base virtual address
  * @phy_base: HSI registers base physical address
  * @lock: Serializes access to internal data and regs
- * @cawake_status: Tracks CAWAKE line status
- * @acwake_status: Bitmap to track ACWAKE line status per channel
+ * @clock_enabled: Indicates if HSI Clocks are ON
  * @gdd_irq: GDD (DMA) irq number
  * @fifo_mapping_strategy: Selected strategy for fifo to ports/channels mapping
  * @gdd_usecount: Holds the number of ongoning DMA transfers
@@ -164,7 +170,7 @@
  * @clk_notifier_register: (PM) callabck for DVFS support
  * @clk_notifier_unregister: (PM) callabck for DVFS support
  * @hsi_nb: (PM) Notification block for DVFS notification chain
- * @hsi_gdd_tasklet: Bottom half for DMA transfers
+ * @hsi_gdd_tasklet: Bottom half for DMA Interrupts when clocks are enabled
  * @dir: debugfs base directory
  * @dev: Reference to the HSI platform device
  */
@@ -175,8 +181,7 @@
 	void __iomem *base;
 	unsigned long phy_base;
 	spinlock_t lock; /* Serializes access to internal data and regs */
-	bool cawake_status;	/* HSI_TODO : fine tune the init values */
-	unsigned int acwake_status;	/* HSI_TODO : fine tune  init values */
+	bool clock_enabled;
 	int gdd_irq;
 	unsigned int fifo_mapping_strategy;
 	unsigned int gdd_usecount;
@@ -203,6 +208,8 @@
 void hsi_reset_ch_read(struct hsi_channel *ch);
 void hsi_reset_ch_write(struct hsi_channel *ch);
 bool hsi_is_channel_busy(struct hsi_channel *ch);
+bool hsi_is_hsi_port_busy(struct hsi_port *pport);
+bool hsi_is_hsi_controller_busy(struct hsi_dev *hsi_ctrl);
 
 int hsi_driver_enable_read_interrupt(struct hsi_channel *hsi_channel,
 					u32 *data);
@@ -244,12 +251,11 @@
 			unsigned int port, unsigned int channel);
 long hsi_hsr_buffer_reg(struct hsi_dev *hsi_ctrl,
 			unsigned int port, unsigned int channel);
+u8 hsi_get_rx_fifo_occupancy(struct hsi_dev *hsi_ctrl, u8 fifo);
 
 int hsi_softreset(struct hsi_dev *hsi_ctrl);
 void hsi_softreset_driver(struct hsi_dev *hsi_ctrl);
 
-void hsi_clocks_disable(struct device *dev, const char *s);
-int hsi_clocks_enable(struct device *dev, const char *s);
 void hsi_clocks_disable_channel(struct device *dev, u8 channel_number,
 				const char *s);
 int hsi_clocks_enable_channel(struct device *dev, u8 channel_number,
@@ -324,9 +330,20 @@
 	if (port->cawake_gpio >= 0)
 		return gpio_get_value(port->cawake_gpio);
 	else
-		return hsi_inl(port->hsi_controller->base,
+		return (HSI_HSR_MODE_WAKE_STATUS ==
+			(hsi_inl(port->hsi_controller->base,
 				HSI_HSR_MODE_REG(port->port_number)) &
-				HSI_HSR_MODE_WAKE_STATUS;
+				HSI_HSR_MODE_WAKE_STATUS));
+}
+
+static inline void hsi_clocks_disable(struct device *dev, const char *s)
+{
+	hsi_clocks_disable_channel(dev, 0xFF, s);
+}
+
+static inline int hsi_clocks_enable(struct device *dev, const char *s)
+{
+	return hsi_clocks_enable_channel(dev, 0xFF, s);
 }
 
 #endif /* __HSI_DRIVER_H__ */
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_if.c Kernel/drivers/staging/omap_hsi/hsi_driver_if.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_if.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_if.c	2011-02-09 13:07:23.247777778 +0530
@@ -109,8 +109,8 @@
 		if (((cfg->flow & HSI_FLOW_VAL_MASK) != HSI_FLOW_SYNCHRONIZED)
 		    && (cfg->flow != NOT_SET))
 			return -EINVAL;
-
-		if ((cfg->frame_size > HSI_FRAMESIZE_MAX) &&
+		/* HSI only supports payload size of 32bits */
+		if ((cfg->frame_size != HSI_FRAMESIZE_MAX) &&
 		    (cfg->frame_size != NOT_SET))
 			return -EINVAL;
 	}
@@ -142,6 +142,8 @@
 				 HSI_HSR_CHANNELS_REG(port));
 	}
 
+	/* HSI_TODO: HSR counters need to be configurable */
+
 	return hsi_set_rx_divisor(sport, cfg->divisor);
 }
 
@@ -258,28 +260,29 @@
 	struct hsi_port *port;
 	struct hsi_dev *hsi_ctrl;
 
-	dev_dbg(&dev->device, "%s\n", __func__);
-
 	if (!dev || !dev->ch) {
 		pr_err(LOG_NAME "Wrong HSI device %p\n", dev);
 		return -EINVAL;
 	}
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	ch = dev->ch;
 	if (!ch->read_done || !ch->write_done) {
-		dev_err(&dev->device, "Trying to open with no (read/write) "
-			"callbacks registered\n");
+		dev_err(dev->device.parent,
+			"Trying to open with no (read/write) callbacks "
+			"registered\n");
 		return -EINVAL;
 	}
 	port = ch->hsi_port;
 	hsi_ctrl = port->hsi_controller;
 
+	spin_lock_bh(&hsi_ctrl->lock);
 	hsi_clocks_enable_channel(dev->device.parent, ch->channel_number,
 				__func__);
 
-	spin_lock_bh(&hsi_ctrl->lock);
 	if (ch->flags & HSI_CH_OPEN) {
-		dev_err(&dev->device, "Port %d Channel %d already OPENED\n",
+		dev_err(dev->device.parent,
+			"Port %d Channel %d already OPENED\n",
 			dev->n_p, dev->n_ch);
 		spin_unlock_bh(&hsi_ctrl->lock);
 		return -EBUSY;
@@ -293,11 +296,9 @@
 	/* NOTE: error and break are port events and do not need to be
 	 * enabled for HSI extended enable register */
 
-	spin_unlock_bh(&hsi_ctrl->lock);
-
-	/* Cut the clocks and wait for ACWAKE change */
 	hsi_clocks_disable_channel(dev->device.parent, ch->channel_number,
 				__func__);
+	spin_unlock_bh(&hsi_ctrl->lock);
 
 	return 0;
 }
@@ -319,23 +320,48 @@
 	struct hsi_channel *ch;
 	int err;
 
-	dev_dbg(&dev->device, "%s @%x, size %d u32\n", __func__, (u32) addr,
-		size);
-
 	if (unlikely(!dev || !dev->ch || !addr || (size <= 0))) {
-		dev_err(&dev->device, "Wrong parameters "
-			"hsi_device %p data %p count %d", dev, addr, size);
+		dev_err(dev->device.parent,
+			"Wrong parameters hsi_device %p data %p count %d",
+			dev, addr, size);
 		return -EINVAL;
 	}
+	dev_dbg(dev->device.parent, "%s @%x, size %d u32\n", __func__,
+		(u32) addr, size);
+
 	if (unlikely(!(dev->ch->flags & HSI_CH_OPEN))) {
-		dev_err(&dev->device, "HSI device NOT open\n");
+		dev_err(dev->device.parent, "HSI device NOT open\n");
 		return -EINVAL;
 	}
 
 	ch = dev->ch;
+
+	if (pm_runtime_suspended(dev->device.parent) ||
+		!ch->hsi_port->hsi_controller->clock_enabled) {
+		dev_info(dev->device.parent,
+			"hsi_write with HSI clocks OFF, clock_enabled = %d\n",
+			ch->hsi_port->hsi_controller->clock_enabled);
+	}
+
 	spin_lock_bh(&ch->hsi_port->hsi_controller->lock);
+	hsi_clocks_enable_channel(dev->device.parent,
+				ch->channel_number, __func__);
+
+	if (ch->write_data.addr != NULL) {
+		dev_err(dev->device.parent, "# Invalid request - Write "
+				"operation pending port %d channel %d\n",
+					ch->hsi_port->port_number,
+					ch->channel_number);
+
+		hsi_clocks_disable_channel(dev->device.parent,
+					ch->channel_number, __func__);
+		spin_unlock_bh(&ch->hsi_port->hsi_controller->lock);
+		return -EINVAL;
+	}
+
 	ch->write_data.addr = addr;
 	ch->write_data.size = size;
+	ch->write_data.lch = -1;
 
 	if (size == 1)
 		err = hsi_driver_enable_write_interrupt(ch, addr);
@@ -346,10 +372,12 @@
 		ch->write_data.addr = NULL;
 		ch->write_data.size = 0;
 	}
+
 	spin_unlock_bh(&ch->hsi_port->hsi_controller->lock);
 
+	/* Leave clocks enabled until transfer is complete (write callback */
+	/* is called */
 	return err;
-
 }
 EXPORT_SYMBOL(hsi_write);
 
@@ -369,23 +397,44 @@
 	struct hsi_channel *ch;
 	int err;
 
-	dev_dbg(&dev->device, "%s @%x, size %d u32\n", __func__, (u32) addr,
-		size);
-
 	if (unlikely(!dev || !dev->ch || !addr || (size <= 0))) {
-		dev_err(&dev->device, "Wrong parameters "
+		dev_err(dev->device.parent, "Wrong parameters "
 			"hsi_device %p data %p count %d", dev, addr, size);
 		return -EINVAL;
 	}
+	dev_dbg(dev->device.parent, "%s @%x, size %d u32\n", __func__,
+		(u32) addr, size);
+
 	if (unlikely(!(dev->ch->flags & HSI_CH_OPEN))) {
-		dev_err(&dev->device, "HSI device NOT open\n");
+		dev_err(dev->device.parent, "HSI device NOT open\n");
 		return -EINVAL;
 	}
 
 	ch = dev->ch;
+
+	if (pm_runtime_suspended(dev->device.parent) ||
+				!ch->hsi_port->hsi_controller->clock_enabled) {
+		dev_info(dev->device.parent,
+			"hsi_read with HSI clocks OFF, clock_enabled = %d\n",
+			ch->hsi_port->hsi_controller->clock_enabled);
+	}
+
 	spin_lock_bh(&ch->hsi_port->hsi_controller->lock);
+	hsi_clocks_enable_channel(dev->device.parent, ch->channel_number,
+				__func__);
+
+	if (ch->read_data.addr != NULL) {
+		dev_err(dev->device.parent, "# Invalid request - Read "
+				"operation pending port %d channel %d\n",
+					ch->hsi_port->port_number,
+					ch->channel_number);
+		err = -EINVAL;
+		goto done;
+	}
+
 	ch->read_data.addr = addr;
 	ch->read_data.size = size;
+	ch->read_data.lch = -1;
 
 	if (size == 1)
 		err = hsi_driver_enable_read_interrupt(ch, addr);
@@ -396,6 +445,10 @@
 		ch->read_data.addr = NULL;
 		ch->read_data.size = 0;
 	}
+
+done:
+	hsi_clocks_disable_channel(dev->device.parent, ch->channel_number,
+				__func__);
 	spin_unlock_bh(&ch->hsi_port->hsi_controller->lock);
 
 	return err;
@@ -418,26 +471,26 @@
  */
 void hsi_write_cancel(struct hsi_device *dev)
 {
-	dev_dbg(&dev->device, "%s\n", __func__);
-
 	if (unlikely(!dev || !dev->ch)) {
 		pr_err(LOG_NAME "Wrong HSI device %p\n", dev);
 		return;
 	}
+	dev_dbg(dev->device.parent, "%s\n", __func__);
+
 	if (unlikely(!(dev->ch->flags & HSI_CH_OPEN))) {
-		dev_err(&dev->device, "HSI device NOT open\n");
+		dev_err(dev->device.parent, "HSI device NOT open\n");
 		return;
 	}
 
+	spin_lock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 	hsi_clocks_enable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
 
-	spin_lock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 	__hsi_write_cancel(dev->ch);
-	spin_unlock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 
 	hsi_clocks_disable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
+	spin_unlock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 }
 EXPORT_SYMBOL(hsi_write_cancel);
 
@@ -457,27 +510,26 @@
  */
 void hsi_read_cancel(struct hsi_device *dev)
 {
-	dev_dbg(&dev->device, "%s\n", __func__);
-
 	if (unlikely(!dev || !dev->ch)) {
 		pr_err(LOG_NAME "Wrong HSI device %p\n", dev);
 		return;
 	}
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	if (unlikely(!(dev->ch->flags & HSI_CH_OPEN))) {
-		dev_err(&dev->device, "HSI device NOT open\n");
+		dev_err(dev->device.parent, "HSI device NOT open\n");
 		return;
 	}
 
+	spin_lock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 	hsi_clocks_enable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
 
-	spin_lock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 	__hsi_read_cancel(dev->ch);
-	spin_unlock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 
 	hsi_clocks_disable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
+	spin_unlock_bh(&dev->ch->hsi_port->hsi_controller->lock);
 }
 EXPORT_SYMBOL(hsi_read_cancel);
 
@@ -495,33 +547,29 @@
 	struct hsi_dev *hsi_ctrl;
 	int err;
 
-	dev_dbg(&dev->device, "%s\n", __func__);
-
 	if (unlikely(!dev || !dev->ch))
 		return -EINVAL;
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	if (unlikely(!(dev->ch->flags & HSI_CH_OPEN))) {
-		dev_err(&dev->device, "HSI device NOT open\n");
+		dev_err(dev->device.parent, "HSI device NOT open\n");
 		return -EINVAL;
 	}
 
 	ch = dev->ch;
 	hsi_ctrl = ch->hsi_port->hsi_controller;
 
-	/* Safety : enable the clocks */
+	spin_lock_bh(&hsi_ctrl->lock);
 	hsi_clocks_enable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
 
-	spin_lock_bh(&hsi_ctrl->lock);
 	ch->flags |= HSI_CH_RX_POLL;
 
 	err = hsi_driver_enable_read_interrupt(ch, NULL);
 
-	spin_unlock_bh(&hsi_ctrl->lock);
-
-	/* Cut the clocks */
 	hsi_clocks_disable_channel(dev->device.parent, dev->ch->channel_number,
 				__func__);
+	spin_unlock_bh(&hsi_ctrl->lock);
 
 	return err;
 }
@@ -541,13 +589,12 @@
 {
 	struct hsi_channel *ch;
 	struct hsi_dev *hsi_ctrl;
+	struct hsi_port *pport;
 	void __iomem *base;
 	unsigned int port, channel;
-	u32 wake;
+	u32 acwake;
 	int err = 0;
 
-	dev_dbg(&dev->device, "IOCTL: command %d\n", command);
-
 	if (unlikely((!dev) ||
 		     (!dev->ch) ||
 		     (!dev->ch->hsi_port) ||
@@ -558,30 +605,39 @@
 	}
 
 	ch = dev->ch;
+	pport = ch->hsi_port;
 	hsi_ctrl = ch->hsi_port->hsi_controller;
 	port = ch->hsi_port->port_number;
 	channel = ch->channel_number;
 	base = hsi_ctrl->base;
 
+	dev_dbg(dev->device.parent, "IOCTL: ch %d, command %d\n",
+		channel, command);
+
+	spin_lock_bh(&hsi_ctrl->lock);
+	hsi_clocks_enable_channel(dev->device.parent,
+				  ch->channel_number, __func__);
+
 	switch (command) {
 	case HSI_IOCTL_ACWAKE_UP:
-		/* Wake up request to Modem (typically OMAP initiated or */
-		/* ACK from Modem following CAWAKE high) */
+		if (ch->flags & HSI_CH_ACWAKE) {
+			dev_warn(dev->device.parent, "Duplicate ACWAKE UP\n");
+			err = -EPERM;
+			goto out;
+		}
+
+		/* Wake up request to Modem (typically OMAP initiated) */
 		/* Symetrical disable will be done in HSI_IOCTL_ACWAKE_DOWN */
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
 
-		spin_lock_bh(&hsi_ctrl->lock);
 		ch->flags |= HSI_CH_ACWAKE;
-		hsi_ctrl->acwake_status |= BIT(channel);
+		pport->acwake_status |= BIT(channel);
 
 		/* We only claim once the wake line per channel */
-		wake = hsi_inl(base, HSI_SYS_WAKE_REG(port));
-		if (!(wake & HSI_WAKE(channel))) {
+		acwake = hsi_inl(base, HSI_SYS_WAKE_REG(port));
+		if (!(acwake & HSI_WAKE(channel))) {
 			hsi_outl(HSI_SET_WAKE(channel), base,
 				 HSI_SYS_SET_WAKE_REG(port));
 		}
-		spin_unlock_bh(&hsi_ctrl->lock);
 
 		goto out;
 		break;
@@ -589,54 +645,44 @@
 		/* Low power request initiation (OMAP initiated, typically */
 		/* following inactivity timeout) */
 		/* ACPU HSI block shall still be capable of receiving */
+		if (!(ch->flags & HSI_CH_ACWAKE)) {
+			dev_warn(dev->device.parent, "Duplicate ACWAKE DOWN\n");
+			err = -EPERM;
+			goto out;
+		}
 
-		/* Safety clock enable: */
-		/* Clocks should be on, but to be sure we enable them here. */
-		/* Clocks will be disabled immediatly after register access */
-		/* (or at least clock counter will be decremented) */
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
-
-		spin_lock_bh(&hsi_ctrl->lock);
-
-		wake = hsi_inl(base, HSI_SYS_WAKE_REG(port));
-		/* Release the wake line per channel */
-		if ((wake & HSI_WAKE(channel))) {
-			hsi_outl(HSI_CLEAR_WAKE(channel), base,
-				 HSI_SYS_CLEAR_WAKE_REG(port));
+		acwake = hsi_inl(base, HSI_SYS_WAKE_REG(port));
+		if (unlikely(pport->acwake_status !=
+				(acwake & HSI_WAKE_MASK))) {
+			dev_warn(dev->device.parent,
+				"ACWAKE shadow register mismatch"
+				" acwake_status: 0x%x, HSI_SYS_WAKE_REG: 0x%x",
+				pport->acwake_status, acwake);
+			pport->acwake_status = acwake & HSI_WAKE_MASK;
 		}
+		/* SSI_TODO: add safety check for SSI also */
 
 		ch->flags &= ~HSI_CH_ACWAKE;
-		hsi_ctrl->acwake_status &= ~BIT(channel);
+		pport->acwake_status &= ~BIT(channel);
 
-		spin_unlock_bh(&hsi_ctrl->lock);
-
-		/* Check if CAWAKE is already low */
-		if (!hsi_get_cawake(ch->hsi_port)) {
-			dev_info(hsi_ctrl->dev,
-				"CAWAKE is already low at the time of ACWAKE "
-				"down, clocks should be disabled soon...\n");
+		if (hsi_is_hsi_controller_busy(hsi_ctrl)) {
+			dev_dbg(dev->device.parent,
+				"HSI clocks still needed, cannot disable...");
+		} else {
+			dev_dbg(dev->device.parent,
+			"HSI clocks are no more needed, disabling clocks...\n");
 		}
 
-		/* 1st call : End of safety clock enable. */
-		/* This may should not lead yet to a real HW clock cut down */
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
-
-		/* 2nd call :*/
-		/* Disable clocks (symetrical to enable clocks of ACWAKE UP)*/
-		/* Here clocks are very likely disabled */
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
+		/* Release the wake line per channel */
+		if ((acwake & HSI_WAKE(channel))) {
+			hsi_outl(HSI_CLEAR_WAKE(channel), base,
+				 HSI_SYS_CLEAR_WAKE_REG(port));
+		}
 
 		goto out;
 		break;
 	case HSI_IOCTL_SEND_BREAK:
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
 		hsi_outl(1, base, HSI_HST_BREAK_REG(port));
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		/*HSI_TODO : need to deactivate clock after BREAK frames sent*/
 		/*Use interrupt ? (if TX BREAK INT exists)*/
 		break;
@@ -644,26 +690,14 @@
 		if (arg == NULL) {
 			err = -EINVAL;
 			goto out;
-		} else
-			hsi_clocks_enable_channel(dev->device.parent,
-						  ch->channel_number, __func__);
+		}
 		*(u32 *) arg = hsi_inl(base, HSI_SYS_WAKE_REG(port));
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_FLUSH_RX:
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
 		hsi_outl(0, base, HSI_HSR_RXSTATE_REG(port));
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_FLUSH_TX:
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
 		hsi_outl(0, base, HSI_HST_TXSTATE_REG(port));
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_GET_CAWAKE:
 		if (!arg) {
@@ -674,83 +708,58 @@
 			err = -ENODEV;
 			goto out;
 		}
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
 		*(unsigned int *)arg = hsi_get_cawake(dev->ch->hsi_port);
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_SET_RX:
 		if (!arg) {
 			err = -EINVAL;
 			goto out;
 		}
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
-		spin_lock_bh(&hsi_ctrl->lock);
 		err = hsi_set_rx(dev->ch->hsi_port, (struct hsr_ctx *)arg);
-		spin_unlock_bh(&hsi_ctrl->lock);
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_GET_RX:
 		if (!arg) {
 			err = -EINVAL;
 			goto out;
 		}
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
-		spin_lock_bh(&hsi_ctrl->lock);
 		hsi_get_rx(dev->ch->hsi_port, (struct hsr_ctx *)arg);
-		spin_unlock_bh(&hsi_ctrl->lock);
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_SET_TX:
 		if (!arg) {
 			err = -EINVAL;
 			goto out;
 		}
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
-		spin_lock_bh(&hsi_ctrl->lock);
 		err = hsi_set_tx(dev->ch->hsi_port, (struct hst_ctx *)arg);
-		spin_unlock_bh(&hsi_ctrl->lock);
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_GET_TX:
 		if (!arg) {
 			err = -EINVAL;
 			goto out;
 		}
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
-		spin_lock_bh(&hsi_ctrl->lock);
 		hsi_get_tx(dev->ch->hsi_port, (struct hst_ctx *)arg);
-		spin_unlock_bh(&hsi_ctrl->lock);
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	case HSI_IOCTL_SW_RESET:
-		hsi_clocks_enable_channel(dev->device.parent,
-					  ch->channel_number, __func__);
+
 		dev_info(dev->device.parent, "SW Reset\n");
-		spin_lock_bh(&hsi_ctrl->lock);
 		err = hsi_softreset(hsi_ctrl);
 
 		/* Reset HSI config to default */
 		hsi_softreset_driver(hsi_ctrl);
-		spin_unlock_bh(&hsi_ctrl->lock);
-
-		hsi_clocks_disable_channel(dev->device.parent,
-					   ch->channel_number, __func__);
 		break;
 	default:
 		err = -ENOIOCTLCMD;
 		break;
 	}
 out:
+	/* All IOCTL end by disabling the clocks, except ACWAKE high */
+	if (command != HSI_IOCTL_ACWAKE_UP) {
+		/* Disable clocks (symetrical to enable clocks of ACWAKE UP) */
+		/* This may lead to a real HW clock cut down based on CAWAKE */
+		/* status */
+		hsi_clocks_disable_channel(dev->device.parent,
+					   ch->channel_number, __func__);
+	}
+	spin_unlock_bh(&hsi_ctrl->lock);
 
 	return err;
 }
@@ -764,12 +773,11 @@
 {
 	struct hsi_dev *hsi_ctrl;
 
-	dev_dbg(&dev->device, "%s\n", __func__);
-
 	if (!dev || !dev->ch) {
 		pr_err(LOG_NAME "Trying to close wrong HSI device %p\n", dev);
 		return;
 	}
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	hsi_ctrl = dev->ch->hsi_port->hsi_controller;
 
@@ -801,7 +809,7 @@
 		     void (*read_cb) (struct hsi_device *dev,
 				      unsigned int size))
 {
-	dev_dbg(&dev->device, "%s\n", __func__);
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	dev->ch->read_done = read_cb;
 }
@@ -819,7 +827,7 @@
 		      void (*write_cb) (struct hsi_device *dev,
 					unsigned int size))
 {
-	dev_dbg(&dev->device, "%s\n", __func__);
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	dev->ch->write_done = write_cb;
 }
@@ -835,10 +843,12 @@
 						  unsigned int event,
 						  void *arg))
 {
-	dev_dbg(&dev->device, "%s\n", __func__);
+	dev_dbg(dev->device.parent, "%s\n", __func__);
 
 	write_lock_bh(&dev->ch->rw_lock);
 	dev->ch->port_event = port_event_cb;
 	write_unlock_bh(&dev->ch->rw_lock);
 }
 EXPORT_SYMBOL(hsi_set_port_event_cb);
+
+
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_driver_int.c Kernel/drivers/staging/omap_hsi/hsi_driver_int.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_driver_int.c	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_driver_int.c	2011-02-14 12:44:05.699613682 +0530
@@ -45,6 +45,52 @@
 	return true;
 }
 
+/* Check if a HSI port is busy :
+ * - data transfer (Read or Write) is ongoing for a given HSI channel
+ * - ACWAKE is high
+ * - CAWAKE is high
+ */
+bool hsi_is_hsi_port_busy(struct hsi_port *pport)
+{
+	struct hsi_dev *hsi_ctrl = pport->hsi_controller;
+	int ch;
+
+	pport->cawake_status = hsi_get_cawake(pport);
+
+	if (pport->acwake_status || pport->cawake_status) {
+		dev_dbg(hsi_ctrl->dev, "Port %d: WAKE status: acwake_status %d,"
+			"cawake_status %d", pport->port_number,
+			pport->acwake_status, pport->cawake_status);
+		return true;
+	}
+
+	for (ch = 0; ch < pport->max_ch; ch++)
+		if (hsi_is_channel_busy(&pport->hsi_channel[ch])) {
+			dev_dbg(hsi_ctrl->dev, "Port %d; channel %d "
+				"busy\n", pport->port_number, ch);
+			return true;
+		}
+
+	return false;
+}
+
+/* Check if HSI controller is busy :
+ * - One of the HSI port is busy
+ */
+bool hsi_is_hsi_controller_busy(struct hsi_dev *hsi_ctrl)
+{
+	int port;
+
+	for (port = 0; port < hsi_ctrl->max_p; port++)
+		if (hsi_is_hsi_port_busy(&hsi_ctrl->hsi_port[port])) {
+			dev_dbg(hsi_ctrl->dev, "Port %d busy\n", port + 1);
+			return true;
+		}
+
+	dev_dbg(hsi_ctrl->dev, "No activity on HSI controller\n");
+	return false;
+}
+
 /* Enables the Data Accepted Interrupt of HST for the given channel */
 int hsi_driver_enable_write_interrupt(struct hsi_channel *ch, u32 * data)
 {
@@ -96,11 +142,10 @@
 	buff_offset = hsi_hst_bufstate_f_reg(p->hsi_controller, port, channel);
 	if (buff_offset >= 0)
 		hsi_outl_and(~HSI_BUFSTATE_CHANNEL(channel), base, buff_offset);
-
 	hsi_reset_ch_write(ch);
 }
 
-void hsi_driver_disable_read_interrupt(struct hsi_channel *ch)
+void hsi_driver_cancel_read_interrupt(struct hsi_channel *ch)
 {
 	struct hsi_port *p = ch->hsi_port;
 	unsigned int port = p->port_number;
@@ -109,21 +154,32 @@
 
 	hsi_outl_and(~HSI_HSR_DATAAVAILABLE(channel), base,
 		     HSI_SYS_MPU_ENABLE_CH_REG(port, p->n_irq, channel));
+	hsi_reset_ch_read(ch);
 }
 
-void hsi_driver_cancel_read_interrupt(struct hsi_channel *ch)
+void hsi_driver_disable_write_interrupt(struct hsi_channel *ch)
 {
 	struct hsi_port *p = ch->hsi_port;
 	unsigned int port = p->port_number;
 	unsigned int channel = ch->channel_number;
 	void __iomem *base = p->hsi_controller->base;
 
-	hsi_outl_and(~HSI_HSR_DATAAVAILABLE(channel), base,
+	hsi_outl_and(~HSI_HST_DATAACCEPT(channel), base,
 		     HSI_SYS_MPU_ENABLE_CH_REG(port, p->n_irq, channel));
+}
 
-	hsi_reset_ch_read(ch);
+void hsi_driver_disable_read_interrupt(struct hsi_channel *ch)
+{
+	struct hsi_port *p = ch->hsi_port;
+	unsigned int port = p->port_number;
+	unsigned int channel = ch->channel_number;
+	void __iomem *base = p->hsi_controller->base;
+
+	hsi_outl_and(~HSI_HSR_DATAAVAILABLE(channel), base,
+		     HSI_SYS_MPU_ENABLE_CH_REG(port, p->n_irq, channel));
 }
 
+/* HST_ACCEPTED interrupt processing */
 static void hsi_do_channel_tx(struct hsi_channel *ch)
 {
 	struct hsi_dev *hsi_ctrl = ch->hsi_port->hsi_controller;
@@ -140,24 +196,29 @@
 	dev_dbg(hsi_ctrl->dev,
 		"Data Accepted interrupt for channel %d.\n", n_ch);
 
-	spin_lock(&hsi_ctrl->lock);
+	spin_lock_bh(&hsi_ctrl->lock);
+
+	hsi_driver_disable_write_interrupt(ch);
 
 	if (ch->write_data.addr == NULL) {
-		hsi_outl_and(~HSI_HST_DATAACCEPT(n_ch), base,
-			     HSI_SYS_MPU_ENABLE_CH_REG(n_p, irq, n_ch));
+		dev_err(hsi_ctrl->dev, "Error, NULL Write address.\n");
 		hsi_reset_ch_write(ch);
-		spin_unlock(&hsi_ctrl->lock);
-		(*ch->write_done) (ch->dev, 1);
+
 	} else {
 		buff_offset = hsi_hst_buffer_reg(hsi_ctrl, n_p, n_ch);
 		if (buff_offset >= 0) {
 			hsi_outl(*(ch->write_data.addr), base, buff_offset);
 			ch->write_data.addr = NULL;
 		}
-		spin_unlock(&hsi_ctrl->lock);
 	}
+
+	spin_unlock_bh(&hsi_ctrl->lock);
+
+	dev_dbg(hsi_ctrl->dev, "Calling write callback.\n");
+	(*ch->write_done) (ch->dev, 1);
 }
 
+/* HSR_AVAILABLE interrupt processing */
 static void hsi_do_channel_rx(struct hsi_channel *ch)
 {
 	struct hsi_dev *hsi_ctrl = ch->hsi_port->hsi_controller;
@@ -168,6 +229,7 @@
 	long buff_offset;
 	int rx_poll = 0;
 	int data_read = 0;
+	int fifo, fifo_words_avail;
 
 	n_ch = ch->channel_number;
 	n_p = ch->hsi_port->port_number;
@@ -176,7 +238,20 @@
 	dev_dbg(hsi_ctrl->dev,
 		"Data Available interrupt for channel %d.\n", n_ch);
 
-	spin_lock(&hsi_ctrl->lock);
+	spin_lock_bh(&hsi_ctrl->lock);
+
+	/*
+	 * Check race condition: DMA RX initiated as RX transmission just
+	 * started in interrupt mode (default) -
+	 * acknowledge then ignore interrupt occurence
+	 */
+	if (ch->read_data.lch != -1) {
+		dev_err(hsi_ctrl->dev, "DMA RX initiated but RX already"
+					" started in interrupt mode\n");
+
+		hsi_driver_disable_read_interrupt(ch);
+		goto done;
+	}
 
 	if (ch->flags & HSI_CH_RX_POLL)
 		rx_poll = 1;
@@ -189,36 +264,57 @@
 		}
 	}
 
-	hsi_outl_and(~HSI_HSR_DATAAVAILABLE(n_ch), base,
-		     HSI_SYS_MPU_ENABLE_CH_REG(n_p, irq, n_ch));
+	hsi_driver_disable_read_interrupt(ch);
 	hsi_reset_ch_read(ch);
 
-	spin_unlock(&hsi_ctrl->lock);
+	/* Check if FIFO is correctly emptied */
+	if (hsi_driver_device_is_hsi(to_platform_device(hsi_ctrl->dev))) {
+		fifo = hsi_fifo_get_id(hsi_ctrl, n_ch, n_p);
+		fifo_words_avail = hsi_get_rx_fifo_occupancy(hsi_ctrl, fifo);
+#if 0		
+		if (fifo_words_avail)
+			dev_warn(hsi_ctrl->dev,
+				"WARNING: RX FIFO %d not empty after CPU copy, "
+				"remaining %d/%d frames\n",
+				fifo, fifo_words_avail, HSI_HSR_FIFO_SIZE);
+#endif
+	}
 
-	if (rx_poll)
+done:
+	spin_unlock_bh(&hsi_ctrl->lock);
+
+	if (rx_poll) {
 		hsi_port_event_handler(ch->hsi_port,
 				       HSI_EVENT_HSR_DATAAVAILABLE,
 				       (void *)n_ch);
+	}
 
-	if (data_read)
+	if (data_read) {
+		dev_dbg(hsi_ctrl->dev, "Calling read callback.\n");
 		(*ch->read_done) (ch->dev, 1);
+	}
 }
 
+/* CAWAKE line management */
 void hsi_do_cawake_process(struct hsi_port *pport)
 {
 	struct hsi_dev *hsi_ctrl = pport->hsi_controller;
+	bool cawake_status = hsi_get_cawake(pport);
+
+	/* Deal with init condition */
+	if (unlikely(pport->cawake_status < 0))
+		pport->cawake_status = !cawake_status;
 
 	/* Check CAWAKE line status */
-	if (hsi_get_cawake(pport)) {
+	if (cawake_status) {
 		/* CAWAKE went high. This can be for 2 reasons: */
 		/*  - Ack from modem following an ACWAKE high from OMAP */
 		/*	(ACPU wakeup) */
 		/*  - Initial request from modem to wake up */
 		/*	(OMAP is in low power) */
 		dev_dbg(hsi_ctrl->dev, "CAWAKE rising edge detected\n");
-		hsi_ctrl->cawake_status = 1;
 
-		if (hsi_ctrl->acwake_status) {
+		if (pport->acwake_status) {
 			/* Case 1: Ack from modem following an ACWAKE high */
 			/*	(ACPU requests a Modem wakeup) */
 			dev_dbg(hsi_ctrl->dev, "ACWAKE already high,"
@@ -234,31 +330,38 @@
 			/*	through the IOPAD daisy chain wakeup */
 			dev_dbg(hsi_ctrl->dev,
 				"ACWAKE low, OMAP awaken from non-OFF mode\n");
+		}
 
-			/*Not needed as clocks should already be ON*/
-			/*hsi_clocks_enable(hsi_ctrl->dev);*/
+		/* Check for possible mismatch (race condition) */
+		if (unlikely(pport->cawake_status)) {
+			dev_warn(hsi_ctrl->dev,
+				"CAWAKE race is detected: %s.\n",
+				"HI -> LOW -> HI");
+			hsi_port_event_handler(pport, HSI_EVENT_CAWAKE_DOWN,
+						NULL);
 		}
+		pport->cawake_status = 1;
 
 		hsi_port_event_handler(pport, HSI_EVENT_CAWAKE_UP, NULL);
 	} else {
-		/* CAWAKE went low. Only 1 reason for this : */
+		/* CAWAKE went low. Only 1 valid reason for this : */
 		/*  - Ack from modem following an ACWAKE low */
 		/*	(ACPU low power mode request) */
 		dev_dbg(hsi_ctrl->dev, "CAWAKE falling edge detected\n");
-		hsi_ctrl->cawake_status = 0;
 
-		if (unlikely(hsi_ctrl->acwake_status)) {
-			dev_err(hsi_ctrl->dev,
-				"Unauthorized modem transition to Low Power "
-				"Mode : ACWAKE is still high whereas it should"
-				" be low\n");
-			return;
+		if (unlikely(pport->acwake_status)) {
+			dev_info(hsi_ctrl->dev,
+				"Modem transition to Low Power Mode\n");
 		}
 
-		/* Enter low power mode */
-		/*hsi_clocks_disable(hsi_ctrl->dev);*/
-		/* This will be done later in tasklet, as soon as we do not */
-		/* need any register access */
+		if (unlikely(!pport->cawake_status)) {
+			dev_warn(hsi_ctrl->dev,
+				"CAWAKE race is detected: %s.\n",
+				"LOW -> HI -> LOW");
+			hsi_port_event_handler(pport, HSI_EVENT_CAWAKE_UP,
+						NULL);
+		}
+		pport->cawake_status = 0;
 
 		/* Inform upper layers */
 		hsi_port_event_handler(pport, HSI_EVENT_CAWAKE_DOWN, NULL);
@@ -273,10 +376,12 @@
  * @start: interrupt index to start on
  * @stop: interrupt index to stop on
  *
+ * returns the bitmap of processed events
+ *
  * This function calls the related processing functions and triggered events.
  * Events are cleared after corresponding function has been called.
 */
-static void hsi_driver_int_proc(struct hsi_port *pport,
+static u32 hsi_driver_int_proc(struct hsi_port *pport,
 				unsigned long status_offset,
 				unsigned long enable_offset, unsigned int start,
 				unsigned int stop)
@@ -293,6 +398,15 @@
 	status_reg = hsi_inl(base, status_offset);
 	status_reg &= hsi_inl(base, enable_offset);
 
+	if (!status_reg) {
+		dev_dbg(hsi_ctrl->dev, "Channels [%d,%d] : no event, exit.\n",
+			start, stop);
+		return 0;
+	} else {
+		dev_dbg(hsi_ctrl->dev, "Channels [%d,%d] : Events 0x%08x\n",
+			start, stop, status_reg);
+	}
+
 	if (status_reg & HSI_BREAKDETECTED) {
 		dev_info(hsi_ctrl->dev, "Hardware BREAK on port %d\n", port);
 		hsi_outl(0, base, HSI_HSR_BREAK_REG(port));
@@ -355,62 +469,64 @@
 
 	/* Reset status bits */
 	hsi_outl(channels_served, base, status_offset);
+
+	return channels_served;
 }
 
-static void do_hsi_tasklet(unsigned long hsi_port)
+static u32 hsi_process_int_event(struct hsi_port *pport)
 {
-	struct hsi_port *pport = (struct hsi_port *)hsi_port;
-	struct hsi_dev *hsi_ctrl = pport->hsi_controller;
-	void __iomem *base = hsi_ctrl->base;
 	unsigned int port = pport->port_number;
 	unsigned int irq = pport->n_irq;
 	u32 status_reg;
-	struct platform_device *pd = to_platform_device(hsi_ctrl->dev);
 
 	/* Process events for channels 0..7 */
-	hsi_driver_int_proc(pport,
+	status_reg = hsi_driver_int_proc(pport,
 			    HSI_SYS_MPU_STATUS_REG(port, irq),
 			    HSI_SYS_MPU_ENABLE_REG(port, irq),
 			    0, min(pport->max_ch, (u8) HSI_SSI_CHANNELS_MAX));
 
 	/* Process events for channels 8..15 */
 	if (pport->max_ch > HSI_SSI_CHANNELS_MAX)
-		hsi_driver_int_proc(pport,
+		status_reg |= hsi_driver_int_proc(pport,
 				    HSI_SYS_MPU_U_STATUS_REG(port, irq),
 				    HSI_SYS_MPU_U_ENABLE_REG(port, irq),
 				    HSI_SSI_CHANNELS_MAX, pport->max_ch);
 
-	/* Get unprocessed events for channels 0..7 */
-	status_reg = hsi_inl(base, HSI_SYS_MPU_STATUS_REG(port, irq)) &
-	    hsi_inl(base, HSI_SYS_MPU_ENABLE_REG(port, irq));
+	return status_reg;
+}
+
+static void do_hsi_tasklet(unsigned long hsi_port)
+{
+	struct hsi_port *pport = (struct hsi_port *)hsi_port;
+	struct hsi_dev *hsi_ctrl = pport->hsi_controller;
+	u32 status_reg;
+
+	dev_dbg(hsi_ctrl->dev, "Int Tasklet : clock_enabled=%d\n",
+		hsi_ctrl->clock_enabled);
 
-	/* Get unprocessed events for channels 8..15 */
-	if (hsi_driver_device_is_hsi(pd))
-		status_reg |=
-		    (hsi_inl(base, HSI_SYS_MPU_U_STATUS_REG(port, irq)) &
-		     hsi_inl(base, HSI_SYS_MPU_U_ENABLE_REG(port, irq)));
+	hsi_clocks_enable(hsi_ctrl->dev, __func__);
 
-	/* Check if clocks can be disabled */
-	if (!hsi_ctrl->acwake_status && !hsi_ctrl->cawake_status) {
-		dev_dbg(hsi_ctrl->dev,
-			"ACWAKE & CAWAKE are low, all events processed, "
-			"disabling clocks\n");
-		/*hsi_clocks_disable(hsi_ctrl->dev);*/
-	}
+	status_reg = hsi_process_int_event(pport);
 
-	/* Re-queue unprocessed events */
-	if (status_reg)
-		tasklet_hi_schedule(&pport->hsi_tasklet);
-	else
-		enable_irq(pport->irq);
+	/* Check if clocks are still needed */
+	if (!hsi_is_hsi_controller_busy(hsi_ctrl)) {
+		dev_dbg(hsi_ctrl->dev, "Int Tasklet : request for "
+					"clocks disable\n");
+
+		hsi_clocks_disable(hsi_ctrl->dev, __func__);
+	}
+	enable_irq(pport->irq);
 }
 
-static irqreturn_t hsi_mpu_handler(int irq, void *hsi_port)
+static irqreturn_t hsi_mpu_handler(int irq, void *p)
 {
-	struct hsi_port *p = hsi_port;
+	struct hsi_port *pport = p;
 
-	tasklet_hi_schedule(&p->hsi_tasklet);
-	disable_irq_nosync(p->irq);
+	tasklet_hi_schedule(&pport->hsi_tasklet);
+
+	/* Disable interrupt until Bottom Half has cleared the IRQ status */
+	/* register */
+	disable_irq_nosync(pport->irq);
 
 	return IRQ_HANDLED;
 }
@@ -418,8 +534,11 @@
 int __init hsi_mpu_init(struct hsi_port *hsi_p, const char *irq_name)
 {
 	int err;
-	/* HSI_TODO : use DECLARE_TASKLET */
+
 	tasklet_init(&hsi_p->hsi_tasklet, do_hsi_tasklet, (unsigned long)hsi_p);
+
+	dev_info(hsi_p->hsi_controller->dev, "Registering IRQ %s (%d)\n",
+						irq_name, hsi_p->irq);
 	err = request_irq(hsi_p->irq, hsi_mpu_handler, IRQF_DISABLED,
 			  irq_name, hsi_p);
 	if (err < 0) {
@@ -428,11 +547,15 @@
 		return -EBUSY;
 	}
 
+	/* HSI_TODO : use device_may_wakeup() before calling this function */
+	enable_irq_wake(hsi_p->irq);
+
 	return 0;
 }
 
 void hsi_mpu_exit(struct hsi_port *hsi_p)
 {
+	disable_irq_wake(hsi_p->irq);
 	tasklet_disable(&hsi_p->hsi_tasklet);
 	free_irq(hsi_p->irq, hsi_p);
 }
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_protocol.c Kernel/drivers/staging/omap_hsi/hsi_protocol.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_protocol.c	2011-02-16 11:29:38.482105455 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol.c	2011-02-08 09:55:55.297771422 +0530
@@ -16,7 +16,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/* #define DEBUG */
+#define DEBUG 1
+
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -65,8 +66,8 @@
 
         pr_debug("%s, ev = {0x%x, 0x%p, %u}\n", __func__, ev->event, ev->data,
                  ev->count);
-        printk("%s, ev = {0x%x, 0x%p, %u} ch{%d} \n", __func__, ev->event, ev->data,
-                 ev->count, ch);
+//        printk("%s, ev = {0x%x, 0x%p, %u} ch{%d} \n", __func__, ev->event, ev->data,
+//                 ev->count, ch);
 
         spin_lock(&hsi_protocol_data[ch].lock);
 
@@ -106,7 +107,7 @@
                 list_add_tail(&entry->list, &hsi_protocol_data[ch].tx_queue);
 		spin_unlock(&hsi_protocol_data[ch].lock);
                 pr_debug("%s, HSI_EV_OUT\n", __func__);
-                printk("%s, HSI_EV_OUT\n", __func__);
+                //printk("%s, HSI_EV_OUT\n", __func__);
                 wake_up_interruptible(&hsi_protocol_data[ch].tx_wait);
                 break;
         case HSI_EV_EXCEP:
@@ -176,6 +177,7 @@
 
                 if (data_len) {
                         pr_debug("%s, RX finished\n", __func__);
+                        //printk("%s, RX finished, ch-> %d, length = %d\n", __func__, ch, count);
                         spin_lock_bh(&hsi_protocol_data[ch].lock);
                         hsi_protocol_data[ch].poll_event &= ~(POLLIN | POLLRDNORM);
                         spin_unlock_bh(&hsi_protocol_data[ch].lock);
@@ -219,25 +221,21 @@
 	unsigned int data_len = 0, ret = -1;
 	struct protocol_queue *entry;
 
-	printk("%s\n",__func__);
         ret = if_hsi_write(ch, buffer, length);
         if (ret < 0) {
 		pr_err("HSI Write ERROR %s \n", __func__);
                 goto out2;
         }else
-		printk("if_hsi_write() returned successfuly\n");
 	spin_lock_bh(&hsi_protocol_data[ch].lock);
         hsi_protocol_data[ch].poll_event &= ~(POLLOUT | POLLWRNORM);
         add_wait_queue(&hsi_protocol_data[ch].tx_wait, &wait);
         spin_unlock_bh(&hsi_protocol_data[ch].lock);
 
-	printk("Added task to waitqueue, sleeping\n");
 	for (;;) {
                 data = NULL;
                 data_len = 0;
 
                 set_current_state(TASK_INTERRUPTIBLE);
-		printk("Inside for loop\n");
                 spin_lock_bh(&hsi_protocol_data[ch].lock);
                 if (!list_empty(&hsi_protocol_data[ch].tx_queue)) {
                         entry = list_entry(hsi_protocol_data[ch].tx_queue.next,
@@ -246,13 +244,12 @@
                         data_len = entry->count;
                         list_del(&entry->list);
                         kfree(entry);
-			printk("data_len = %d\n",data_len);
                 }
                 spin_unlock_bh(&hsi_protocol_data[ch].lock);
 
                 if (data_len) {
                         pr_debug("%s, TX finished\n", __func__);
-                        printk("%s, TX finished\n", __func__);
+                        //printk("%s, TX finished, data_len = %d, ch-> %d\n", __func__,length,ch);
                         ret = data_len;
                         break;
                 } else if (signal_pending(current)) {
@@ -261,9 +258,7 @@
                         goto out;
                 }
 
-                printk("%s, going to sleep...\n", __func__); 
                 schedule();
-                printk("%s, woke up\n", __func__); 
         }
 
 out:
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_protocol_cmd.c Kernel/drivers/staging/omap_hsi/hsi_protocol_cmd.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_protocol_cmd.c	2011-02-16 11:29:38.482105455 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol_cmd.c	2011-02-14 12:44:05.730863814 +0530
@@ -1,7 +1,9 @@
 /* 
+ *File -  hsi_protocol_if_cmd.c
  *
- * Copyright (C) 2011 Samsung Electrnoics. All rights reserved.
- * 
+ * Implements HSI protocol for Infineon Modem.
+ *
+ * Copyright (C) 2011 Samsung Electronics. All rights reserved.
  *
  * Author: Rupesh Gujare <rupesh.g@samsung.com>
  *
@@ -33,8 +35,9 @@
 int if_hsi_openchannel(struct if_hsi_channel *channel);
 int if_hsi_closechannel(struct if_hsi_channel *channel);
 
-extern u32 avlb_ch, avlb_length;
-extern u32 actual_write;
+extern struct if_hsi_cmd hsi_cmd_history;
+extern int tx_cmd_history_p;
+extern int rx_cmd_history_p;
 
 /*Decode command from received PDU on channle 0*/
 int hsi_decode_cmd( u32 *cmd_data, u32 *cmd, u32 *ch, u32 *param)
@@ -74,7 +77,7 @@
 	case HSI_LL_MSG_ACK:
 		*ch = ((data & 0x0F000000) >> 24);
 		*param = (data & 0x00FFFFFF);
-		printk("ACK Received ch=%d, param=%d\n",*ch, *param);
+		//printk("ACK Received ch=%d, param=%d\n",*ch, *param);
 		break;
 	
 	case HSI_LL_MSG_CONF_RATE:
@@ -224,24 +227,58 @@
 	return ret;
 }
 
+static int saved_cmd_queue = 0;
+static u32 cmd_saved[ 5 ];
 int hsi_protocol_send_command(u32 cmd, u32 channel, u32 param)
 {
-	u32 cmd_array[4] = {0, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC}, ret = -1;
+	struct if_hsi_channel *channel_zero;
+	u32 cmd_array[4] = {0x00000000, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC}, ret = -1;
 
+	channel_zero = &hsi_protocol_iface.channels[0]; 
 	cmd_array[0] = protocol_create_cmd(cmd, channel, &param);
-	ret = hsi_proto_write(0, &cmd_array, 16 );
+	//printk("[%s] CMD = %08x \n",__func__, cmd_array[0]);
+	while (channel_zero->tx_state != HSI_LL_TX_STATE_IDLE){
+		cmd_saved[ saved_cmd_queue ] = cmd_array[ 0 ];
+		saved_cmd_queue++;
+		printk( "(%s) cmd_saved : %x(%d) \n", __func__, cmd_array[ 0 ], saved_cmd_queue );
+
+		return 0;
+	}
+
+SEND_RETRY :
+	
+	channel_zero->tx_state = HSI_LL_TX_STATE_TX;
+	ret = hsi_proto_write(0, cmd_array, 16 );
 	if(ret < 0){
-		printk("Command Write failed %s()\n", __func__);
+		printk("(%s) Command Write failed, CMD->%X \n", __func__,cmd_array[0]);
+		channel_zero->tx_state = HSI_LL_TX_STATE_IDLE;
 		return -1;
-	}else
+	}else{
+		channel_zero->tx_state = HSI_LL_TX_STATE_IDLE;
+
+		printk("[%s] CMD = %08x \n",__func__, cmd_array[0]);
+		
+		hsi_cmd_history.tx_cmd[ tx_cmd_history_p ] = cmd_array[ 0 ];
+		hsi_cmd_history.tx_cmd_time[ tx_cmd_history_p ] = CURRENT_TIME;
+		tx_cmd_history_p++;
+		if( tx_cmd_history_p >= 50 ) tx_cmd_history_p = 0;
+
+		if( saved_cmd_queue ) {
+			saved_cmd_queue--;
+			cmd_array[ 0 ] = cmd_saved[ saved_cmd_queue ];
+
+			goto SEND_RETRY;
+		}
+		
 		return 0;
+	}
 }
 
 
 void rx_stm(u32 cmd, u32 ch, u32 param)
 {
 	struct if_hsi_channel *channel;
-	u32 size = 0, ret;
+	u32 size = 0, tmp_cmd = 0, ret, i;
 	channel = &hsi_protocol_iface.channels[ch]; 
 
 	switch(cmd){
@@ -257,8 +294,7 @@
 		switch(channel->tx_state){
 		case HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED:
 			channel->tx_state = HSI_LL_TX_STATE_IDLE;
-			printk("Received CONN_CLOSED\n");
-			if_hsi_closechannel(channel);
+			//printk("[%s] Received CONN_CLOSED. ch-> %d\n",__func__,ch);
 			break;
 
 		default:
@@ -272,38 +308,28 @@
 
 	case HSI_LL_MSG_ACK:
 		switch(channel->tx_state){
-		struct hst_ctx tx_config;
 		
 		case HSI_LL_TX_STATE_WAIT_FOR_ACK:
 		case HSI_LL_TX_STATE_SEND_OPEN_CONN:
-			printk("ACK received %s()\n",__func__);
-			ret = if_hsi_openchannel(channel);
-			if (ret != 0)
-				pr_err("Unable to open channel %d after ACK for data transfer\n", channel->channel_id);	
-			/*Set Tx Config*/
-			hsi_ioctl(channel->dev, HSI_IOCTL_GET_TX, &tx_config);
-			tx_config.mode = 2;
-			tx_config.channels = HSI_MAX_CHANNELS;
-			ret = hsi_ioctl(channel->dev, HSI_IOCTL_SET_TX, &tx_config);
-			if ( ret == 0)
-				printk ("SET_TX Successful %s()\n",__func__);
+			//printk("ACK received %s()\n",__func__);
 			
 			channel->tx_state = HSI_LL_TX_STATE_TX;
 			size = param;
-			if ((size > 16) && (size % 4))
-				size += (4 - (size % 4));
+			// TEMP: send/read by 16 byte unit for v.11A(CP)
+			if ((size > 16) && (size % 16))
+				size += (16 - (size % 16));
 			else if (size < 16)
 				size = 16;
-			printk("Writing %d bytes data on channel %d, tx_buf = %x,  in %s()\n", size, ch, channel->tx_buf, __func__);
+			//printk("Writing %d bytes data on channel %d, tx_buf = %x,  in %s()\n", size, ch, channel->tx_buf, __func__);
 			ret = hsi_proto_write(ch, channel->tx_buf, size);
 			channel->tx_state = HSI_LL_TX_STATE_WAIT_FOR_CONN_CLOSED;
-			actual_write = ret;
 			wake_up_interruptible (&ipc_write_wait);
+			channel->tx_nak_count = 0;
 			break;
 
 		case HSI_LL_TX_STATE_CLOSED:/* ACK as response to CANCEL_CONN */
 			if(channel->rx_state == HSI_LL_RX_STATE_WAIT_FOR_CANCEL_CONN_ACK)
-			 channel->rx_state = HSI_LL_RX_STATE_CLOSED;
+			 channel->rx_state = HSI_LL_RX_STATE_IDLE;
 			break;
 
 		case HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK: /* ACK as response to CONF_RATE */
@@ -318,16 +344,33 @@
 
 	case HSI_LL_MSG_NAK:
 		switch(channel->tx_state){
-		case HSI_LL_TX_STATE_WAIT_FOR_ACK:
-			channel->tx_state = HSI_LL_TX_STATE_NACK;
-			break;
+			case HSI_LL_TX_STATE_WAIT_FOR_ACK:
+				printk("(%s) NAK received. ch->%d \n",__func__,ch);
+				channel->tx_state = HSI_LL_TX_STATE_NACK;
+				if (channel->tx_nak_count < 5 ){
+
+					tmp_cmd = ((HSI_LL_MSG_OPEN_CONN_OCTET & 0x0000000F) << 28) |
+						  ((ch                         & 0x000000FF) << 24);
+					for(i=49; i >= 0; i--){
+						if((hsi_cmd_history.tx_cmd[i] & 0xFFF00000) == tmp_cmd)
+						break;
+					}
+					size = (hsi_cmd_history.tx_cmd[i] & 0x000FFFFF);
+					hsi_protocol_send_command(HSI_LL_MSG_OPEN_CONN_OCTET, ch, size);
+					channel->tx_nak_count++;
+				}else{
+					hsi_protocol_send_command(HSI_LL_MSG_BREAK, ch, size);
+					printk("(%s) Sending MSG_BREAK. ch->%d \n",__func__,ch);
+					//TODO Reset All channels and inform IPC write about failure (Possibly by sending signal)
+				}
+				break;
 
-		 case HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK: /* NAK as response to CONF_RATE */
-		 channel->tx_state = HSI_LL_TX_STATE_IDLE;
-		break;
+			case HSI_LL_TX_STATE_WAIT_FOR_CONF_ACK: /* NAK as response to CONF_RATE */
+				channel->tx_state = HSI_LL_TX_STATE_IDLE;
+				break;
 
-		default:
-			pr_err("ERROR - Received NAK in invalid state\n");
+			default:
+				pr_err("ERROR - Received NAK in invalid state. state->%d\n",channel->tx_state);
 		}
 		break;
 
@@ -338,35 +381,26 @@
 
 	case HSI_LL_MSG_OPEN_CONN_OCTET:
 		switch(channel->rx_state){
-			case HSI_LL_RX_STATE_CLOSED:
-				printk("OPEN_CONN_OCTET in %s()\n",__func__);
+			//case HSI_LL_RX_STATE_CLOSED:
+			case HSI_LL_RX_STATE_IDLE:
+				//printk("OPEN_CONN_OCTET in %s(), ch-> %d\n",__func__, ch);
 				channel->rx_state = HSI_LL_RX_STATE_TO_ACK;
-				ret = if_hsi_openchannel(channel);
-				if ( ret < 0){
-					printk("%s() Channel Open failed\n",__func__);
-					hsi_protocol_send_command(HSI_LL_MSG_NAK, ch, param);
-					channel->rx_state = HSI_LL_RX_STATE_CLOSED;
-					break;
-				}else{
-					printk("%s() Channel Open Successful\n",__func__);
-					set_tx_config(channel, 2, HSI_MAX_CHANNELS);
-					hsi_protocol_send_command(HSI_LL_MSG_ACK, ch, param);
-				}
-				channel->rx_state = HSI_LL_RX_STATE_SEND_ACK;
+				hsi_protocol_send_command(HSI_LL_MSG_ACK, ch, param);
+				
+				channel->rx_count = param; 
 				channel->rx_state = HSI_LL_RX_STATE_RX;
-				avlb_ch = ch;
-				avlb_length = param; 
-				printk("Waking up IPC read\n");
+				//printk("Waking up IPC read, length in command = %d\n", param);
 				wake_up_interruptible (&ipc_read_wait);
-				//Open channel Set RX config & Read Data & close channel 
-				//hsi_protocol_send_command(HSI_LL_MSG_CONN_CLOSED, ch, param);
-				//channel->HSI_LL_RX_STATE_IDLE;
 				break;
+			
 			case HSI_LL_RX_STATE_BLOCKED:
 				//TODO
 				break;
+			
 			default:
-				pr_err("OPEN_CONN_OCTET in invalid state\n");
+				pr_err("OPEN_CONN_OCTET in invalid state, Current State -> %d\n", channel->rx_state);
+				printk("Sending NAK to channel-> %d\n",ch);
+				hsi_protocol_send_command(HSI_LL_MSG_NAK, ch, param);
 		}
 		break;	
 	
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi_protocol_if.c Kernel/drivers/staging/omap_hsi/hsi_protocol_if.c
--- Kernel-orig/drivers/staging/omap_hsi/hsi_protocol_if.c	2011-02-16 11:29:38.482105455 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi_protocol_if.c	2011-02-14 12:44:05.770864079 +0530
@@ -30,28 +30,23 @@
 #include <linux/poll.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
+#include <linux/proc_fs.h>
 
 #include <linux/hsi_driver_if.h>
 #include "hsi-protocol-if.h" 
 
-#define DEBUG	1
+//#define DEBUG	1
+//#define DEBUG_PHY_DATA	1
 
 #define HSI_CHANNEL_STATE_UNAVAIL       (1 << 0)
 #define HSI_CHANNEL_STATE_READING       (1 << 1)
 #define HSI_CHANNEL_STATE_WRITING       (1 << 2)
 
-#define MAX_HSI_IPC_BUFFER		512*1024
-
-
-
-
 
 struct if_hsi_iface hsi_protocol_iface;
-
-u32 avlb_ch, avlb_length = 0;
-u32 actual_write;
 wait_queue_head_t ipc_read_wait, ipc_write_wait;
 
+
 static void if_hsi_protocol_port_event(struct hsi_device *dev, unsigned int event,
                               void *arg);
 static int __devinit hsi_protocol_probe(struct hsi_device *dev);
@@ -66,7 +61,9 @@
 	},
 };
 
-
+struct if_hsi_cmd hsi_cmd_history;
+int tx_cmd_history_p = 0;
+int rx_cmd_history_p = 0;
 
 static int if_hsi_read_on(int ch, u32 *data, unsigned int count)
 {
@@ -98,8 +95,13 @@
 {
 	struct if_hsi_channel *channel;
         struct hsi_event ev;
+	
+#ifdef DEBUG_PHY_DATA
+	u32 *tmp;
+	u32 i;
+#endif
 
-	printk("if_hsi_proto_read_done() is called for ch-> %d\n",dev->n_ch);
+	//printk("if_hsi_proto_read_done() is called for ch-> %d\n",dev->n_ch);
         channel = &hsi_protocol_iface.channels[dev->n_ch];
         dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, dev->n_ch);
         spin_lock(&channel->lock);
@@ -108,7 +110,19 @@
         ev.data = channel->rx_data;
         ev.count = 4 * size;
         spin_unlock(&channel->lock);
-        if_notify(dev->n_ch, &ev);
+
+#ifdef DEBUG_PHY_DATA
+	//Check received data -> Commented as it adds delay which causes MSG_BREAK
+	tmp = channel->rx_data;
+	printk("[%s](%d)(%d) RX = ",__func__, dev->n_ch, ev.count);
+	for (i=0; i< ( ( size > 5 )? 5 : size ); i++){
+		printk("%08x ",*tmp);
+		tmp++;
+	}
+	printk("\n");
+#endif
+
+	if_notify(dev->n_ch, &ev);
 }
 
 int if_hsi_read(int ch, u32 *data, unsigned int count)
@@ -137,10 +151,8 @@
         int ret;
 	
         channel = &hsi_protocol_iface.channels[ch];
-	printk("In Funcion - %s acquiring channel->lock\n",__func__);
 
         spin_lock(&channel->lock);
-	printk("In Funcion - %s\n Acquired channel->lock\n",__func__);
         if (channel->state & HSI_CHANNEL_STATE_WRITING) {
                 pr_err("Write still pending on channel %d\n", ch);
                 printk("Write still pending on channel %d\n", ch);
@@ -153,9 +165,7 @@
         channel->state |= HSI_CHANNEL_STATE_WRITING;
         spin_unlock(&channel->lock);
         dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, ch);
-	printk("hsi_write() Starting ...\n");
         ret = hsi_write(channel->dev, address, count / 4);
-	printk("hsi_write() returned %d, %s()\n", ret, __func__);
         return ret;
 }
 
@@ -164,8 +174,13 @@
 {
 	struct if_hsi_channel *channel;
         struct hsi_event ev;
+		
+#ifdef DEBUG_PHY_DATA
+	u32 *tmp;
+	u32 i;
+#endif
 
-	printk("if_hsi_proto_write_done() is called for ch-> %d\n",dev->n_ch);
+	//printk("if_hsi_proto_write_done() is called for ch-> %d\n",dev->n_ch);
         channel = &hsi_protocol_iface.channels[dev->n_ch];
         dev_dbg(&channel->dev->device, "%s, ch = %d\n", __func__, dev->n_ch);
 
@@ -175,6 +190,18 @@
         ev.data = channel->tx_data;
         ev.count = 4 * size;
         spin_unlock(&channel->lock);
+
+#ifdef DEBUG_PHY_DATA
+	//Check Outgoing data, Commented as it adds delay which causes MSG_BREAK
+	tmp = channel->tx_data;
+	printk("[%s](%d)(%d) TX = ",__func__, dev->n_ch, ev.count);
+	for (i=0; i< ( ( size > 5 )? 5 : size ); i++){
+		printk("%08x ",*tmp);
+		tmp++;
+	}
+	printk("\n");
+#endif
+
         if_notify(dev->n_ch, &ev);
 
 }
@@ -287,7 +314,7 @@
 
         channel->opened = 1;
 	channel->tx_state = HSI_LL_TX_STATE_IDLE;
-	channel->rx_state = HSI_LL_RX_STATE_IDLE;
+	channel->rx_state = HSI_LL_RX_STATE_TO_CONN_READY;
 	printk("setting channel->opened=1 for channel %d\n", channel->dev->n_ch);
 leave:
         spin_unlock(&channel->lock);
@@ -345,22 +372,26 @@
 */
 static int hsi_read_thrd(void *data)
 {
-	u32 cmd_data[4], cmd, channel, param ;
+	u32 cmd_data[4], cmd, channel, param = 0;
 	int ret;
 
 	printk("Inside read thread\n");
 	while(1){
 		/*Call hsi_proto_read*/
 		/*Read 16 bytes due to Modem limitation*/
-		hsi_proto_read(0,&cmd_data, (4 * 4));
-		printk("hsi_proto_read returned\n");
+		hsi_proto_read(0, cmd_data, (4 * 4));
+
+		hsi_cmd_history.rx_cmd[ rx_cmd_history_p ] = cmd_data[ 0 ];
+		hsi_cmd_history.rx_cmd_time[ rx_cmd_history_p ] = CURRENT_TIME;
+		rx_cmd_history_p++;
+		if( rx_cmd_history_p >= 50 ) rx_cmd_history_p = 0;
 
 		/*Decode Command*/
 		ret = hsi_decode_cmd(&cmd_data[0], &cmd, &channel, &param);
 		if(ret != 0){
 			pr_err("Can not decode command\n");
 			}else{
-				printk("cmd is %x\n",cmd);
+				printk("%s(),CMD Received->  %x, ch-> %d, param-> %d. \n",__func__, cmd, channel, param);
 				/*Rx State Machine*/
 				rx_stm(cmd, channel, param);
 			}
@@ -373,43 +404,67 @@
 {
 	struct hst_ctx tx_config;
 	struct hsr_ctx rx_config;
-	int ret = 0;
+	int i, ret = 0;
 
 	printk("In function  %s()\n",__func__);	
-	/*Open channel 0 */
-	ret = if_hsi_openchannel(&hsi_protocol_iface.channels[0]);
-	if (ret < 0){
-		pr_err("Can not Open channel 0. Can not start HSI protocol \n");
-		goto err;
-	}else
-		printk("if_hsi_openchannel() returned %d\n", ret);
-
-	/*Set Rx Config*/
-	hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_GET_RX, &rx_config);
-	rx_config.mode = 2;
-	rx_config.channels = HSI_MAX_CHANNELS;
-	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_RX, &rx_config);
-	if ( ret == 0)
-		printk ("SET_RX Successful\n");
-	
-	/*Set Tx Config*/
-	hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_GET_TX, &tx_config);
-	tx_config.mode = 2;
-	tx_config.channels = HSI_MAX_CHANNELS;
-	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_TX, &tx_config);
-	if ( ret == 0)
-		printk ("SET_TX Successful\n");
-	
-	/* Making ACWAKE HIGH here as clocks are disabled otherwise*/
-	//hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
-	
-	/*Create read thread*/
-	//read_thread = kthread_run(hsi_read_thrd, NULL, "hsi_read_thread");
-err: 
+	/*Open All channels */
+	for (i=0; i <= 5; i++){
+		ret = if_hsi_openchannel(&hsi_protocol_iface.channels[i]);
+		if (ret < 0){
+			pr_err("Can not Open channel->%d . Can not start HSI protocol \n",i);
+		}else
+			printk("Channel->%d Open Successful\n", i);
+
+		/*Set Rx Config*/
+		hsi_ioctl(hsi_protocol_iface.channels[i].dev, HSI_IOCTL_GET_RX, &rx_config);
+		rx_config.mode = 2;
+		rx_config.divisor = 1;
+		rx_config.channels = HSI_MAX_CHANNELS;
+		ret = hsi_ioctl(hsi_protocol_iface.channels[i].dev, HSI_IOCTL_SET_RX, &rx_config);
+		if ( ret == 0)
+			printk ("SET_RX Successful for ch->%d\n", i);
+	
+		/*Set Tx Config*/
+		hsi_ioctl(hsi_protocol_iface.channels[i].dev, HSI_IOCTL_GET_TX, &tx_config);
+		tx_config.mode = 2;
+		tx_config.divisor = 1;
+		tx_config.channels = HSI_MAX_CHANNELS;
+		ret = hsi_ioctl(hsi_protocol_iface.channels[i].dev, HSI_IOCTL_SET_TX, &tx_config);
+		if ( ret == 0)
+			printk ("SET_TX Successful for ch->%d\n", i);
+	}	
+	/*Make channel-0 tx_state to IDLE*/
+	hsi_protocol_iface.channels[0].tx_state = HSI_LL_TX_STATE_IDLE;
 	return ret;
 }
 EXPORT_SYMBOL(hsi_start_protocol);
 
+static int hsi_protocol_proc( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	char *p = page;
+	int len, i;
+
+	p += sprintf( p, "======= HISTORY OF CMD =======\n" );
+	p += sprintf( p, "   tx_cmd_history_p : %d\n", tx_cmd_history_p );
+	p += sprintf( p, "   rx_cmd_history_p : %d\n", rx_cmd_history_p );
+	for( i = 0; i < 50; i++ ) {
+		p += sprintf( p, "   [%d] tx : 0x%08x(%lu.%09lu), rx : 0x%08x(%lu.%09lu)\n", 
+			i, hsi_cmd_history.tx_cmd[ i ], ( unsigned long )hsi_cmd_history.tx_cmd_time[ i ].tv_sec, ( unsigned long )hsi_cmd_history.tx_cmd_time[ i ].tv_nsec,
+			hsi_cmd_history.rx_cmd[ i ], ( unsigned long )hsi_cmd_history.rx_cmd_time[ i ].tv_sec, ( unsigned long )hsi_cmd_history.rx_cmd_time[ i ].tv_nsec );
+	}
+	p += sprintf( p, "======= HISTORY OF CMD =======\n" );
+
+	len = ( p - page ) - off;
+	if( len < 0 ) {
+		len = 0;
+	}
+
+	*eof = ( len <= count ) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
 int __devexit hsi_protocol_remove(struct hsi_device *dev)
 {
 	struct if_hsi_channel *channel;
@@ -466,16 +521,16 @@
 		channel->state = 0;
 		channel->rx_state = HSI_LL_RX_STATE_CLOSED;
 		channel->tx_state = HSI_LL_TX_STATE_CLOSED;
+		channel->tx_count = 0;
+		channel->rx_count = 0;
+		channel->tx_nak_count = 0;
+		channel->rx_nak_count = 0;
 		channel->rx_buf = NULL;
 		channel->tx_buf = NULL;
 		hsi_protocol_iface.init_chan_map ^= (1 << dev->n_ch);
 	}
 	spin_unlock_bh(&hsi_protocol_iface.lock);
 
-	//hsi_start_protocol();	
-/*	printk("Starting write_hsi() function\n");	
-	port = write_hsi(0, data, 4);
-	printk("write_hsi returned %d\n",port);	*/
 	return 0;
 	
 }
@@ -485,7 +540,8 @@
 {
 	struct if_hsi_channel *channel;
 	int i, ret;
-		
+	struct proc_dir_entry *dir;
+	
 	for (i = 0; i < HSI_MAX_PORTS; i++)
                 if_hsi_protocol_driver.ch_mask[i] = 0;
 	
@@ -509,6 +565,12 @@
 	if (ret)
 		pr_err("Error while registering HSI driver %d", ret);
 
+	dir = create_proc_read_entry( "driver/hsi_cmd", 0, 0, hsi_protocol_proc, NULL );
+	if( dir == NULL ) {
+		printk("create_proc_read_entry Fail.\n");
+	}
+	printk("create_proc_read_entry Done.\n");
+
 	return ret;
 }
 
@@ -540,13 +602,184 @@
 
 }
 
+u32 initialization = 0;
+
+/*Write data to channel*/
+int write_hsi(u32 ch, u32 *data, int length)
+{
+	int ret;	
+	//u32 cmd[4] = {0x00000000, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC};
+	struct if_hsi_channel *channel;
+	struct task_struct *read_thread;
+
+	channel = &hsi_protocol_iface.channels[ch];
+	channel->tx_buf = data;	
+	channel->tx_count = 0;
+
+	//cmd[0] = protocol_create_cmd(HSI_LL_MSG_OPEN_CONN_OCTET, ch, (void *)&length);
+	//printk("data ptr is %x\n", data); 
+
+	if (initialization == 0){
+		/* ACWAKE ->HIGH */
+		ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
+		if(ret == 0)
+			printk("ACWAKE pulled high in %s()\n",__func__);
+
+		/*Creating read thread*/
+		read_thread = kthread_run(hsi_read_thrd, NULL, "hsi_read_thread");
+	
+		initialization++;
+	}
+	/*Wait till previous data transfer is over*/
+	while(channel->tx_state != HSI_LL_TX_STATE_IDLE) {
+		//printk( "Wait 5ms previous data transfer isn't over %s()\n", __func__ );
+		
+		msleep(5);
+	}
+	channel->tx_state = HSI_LL_TX_STATE_WAIT_FOR_ACK;
+	
+	//send_cmd(cmd, channel, data)
+	//ret = hsi_proto_write(0, &cmd, 4*4);
+	//printk("Write returned %d\n", ret); 	
+	hsi_protocol_send_command(HSI_LL_MSG_OPEN_CONN_OCTET, ch, length);
+	
+	wait_event_interruptible(ipc_write_wait, channel->tx_count != 0);
+
+	return	channel->tx_count;
+
+
+}
+EXPORT_SYMBOL(write_hsi);
+
+
+int read_hsi(u8 *data, u32 ch, u32 *length)
+{
+	int ret, size, tmp,actual_length;
+	struct if_hsi_channel *channel;
+
+	channel = &hsi_protocol_iface.channels[ch];
+	channel->rx_state = HSI_LL_RX_STATE_IDLE;
+	
+	//printk("In read_hsi() function, Sleeping ... channel-> %d\n",ch);
+	wait_event_interruptible(ipc_read_wait,(channel->rx_count != 0));
+	//printk("In read_hsi() function, Waking Up ... channel-> %d\n",ch);
+
+	actual_length = channel->rx_count;
+	size = channel->rx_count;
+	// TEMP: send/read by 16 byte unit for v.11A(CP)
+	if ((size > 16) && (size % 16))
+		size += (16 - (size % 16));
+	else if (size < 16)
+		size = 16;
+	ret = hsi_proto_read(ch, (u32 *)data, size);
+	if( ret < 0)
+		printk("Read in IPC failed, %s()\n",__func__);
+	
+	//printk("%s() read returned %d, actual_length = %d, ch-> %d\n",__func__, ret,actual_length,ch );
+	//printk("%s() sending CONN_CLOSED. \n",__func__);
+	tmp = hsi_protocol_send_command(HSI_LL_MSG_CONN_CLOSED, ch, 0);
+	//printk("%s() Sending CONN_CLOSED Finished. ret = %d\n",__func__, tmp);
+	
+	*length = actual_length;
+	channel->rx_count = 0;
+	
+	//printk("%s() RETURNING TO IPC with ret = %d\n",__func__, ret);
+	return ret;
+
+}
+EXPORT_SYMBOL(read_hsi);
+
+
+//========================================================//
+//                ++ Flashless Boot. ++                   //
+//========================================================//
+int hsi_start_protocol_single( void )
+{
+	int ret = 0;
+
+	struct hst_ctx tx_config;
+	struct hsr_ctx rx_config;
+
+	/*Open channel 0 */
+	ret = if_hsi_openchannel(&hsi_protocol_iface.channels[0]);
+	if (ret < 0){
+		pr_err("Can not Open channel 0. Can not start HSI protocol \n");
+		goto err;
+	}else
+		printk("if_hsi_openchannel() returned %d\n", ret);
+
+	
+	/*Set Tx Config*/
+	hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_GET_TX, &tx_config);
+	tx_config.mode = 2;
+	tx_config.channels = 1;
+	tx_config.divisor = 3;	
+	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_TX, &tx_config);
+	if ( ret < 0 ) {
+		printk( "write_hsi_direct : SET_TX Fail : %d\n", ret );
+		return ret;
+	}
+
+	hsi_ioctl( hsi_protocol_iface.channels[ 0 ].dev, HSI_IOCTL_GET_RX, &rx_config );
+	rx_config.mode = 2;
+	rx_config.channels = 1;
+	rx_config.divisor = 3;
+	//rx_config.timeout = HZ / 2;
+	ret = hsi_ioctl( hsi_protocol_iface.channels[0].dev, HSI_IOCTL_SET_RX, &rx_config);
+	if ( ret < 0 ) {
+		printk( "write_hsi_direct : SET_RX Fail : %d\n", ret );
+		return ret;
+	}
+
+	/* ACWAKE ->HIGH */
+	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
+	if(ret == 0)
+		printk("ACWAKE pulled high in %s()\n",__func__);
+
+err: 
+
+	return ret;
+}
+EXPORT_SYMBOL( hsi_start_protocol_single );
+
+int hsi_reconfigure_protocol( void )
+{
+	int ret = 0;
+	
+	/* ACWAKE ->LOW */
+	ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_DOWN, NULL);
+	if(ret == 0)
+		printk("ACWAKE pulled low in %s()\n",__func__);
+	else
+		printk("ACWAKE down fail!! %d\n", ret);
+
+
+	/*Clse channel 0 */
+	ret = if_hsi_closechannel(&hsi_protocol_iface.channels[0]);
+	if (ret < 0){
+		pr_err("Can not Close channel 0. Can not Stop HSI protocol for flashless\n");
+		goto err;
+	}
+
+
+	printk( "(%s)(%d) hsi_start_protocol Start.\n", __func__, __LINE__ );
+	hsi_start_protocol();
+	printk( "(%s)(%d) hsi_start_protocol Done.\n", __func__, __LINE__ );
+
+err: 
+
+	return ret;
+}
+EXPORT_SYMBOL( hsi_reconfigure_protocol );
+
 int write_hsi_direct( u32 *data, int length )
 {
 	int retval = 0;
+#if 0
 	struct hst_ctx tx_config;
 
-	printk( "write_hsi_direct : len : %d\n", length );
 
+	printk( "write_hsi_direct : len : %d\n", length );
 	hsi_ioctl( hsi_protocol_iface.channels[ 0 ].dev, HSI_IOCTL_GET_TX, &tx_config );
 	tx_config.mode = 2;
 	tx_config.channels = 1;
@@ -563,22 +796,25 @@
 		printk("write_hsi_direct : ACWAKE High Fail : %d\n", retval );
 		return retval;
 	}
-	printk( "write_hsi_direct : ACWAKE High\n" );
+#endif
 
-	if( ( length > 16 ) || ( length % 4 ) ) {
+#if 0
+	if( ( length > 16 ) && ( length % 4 ) ) {
 		length += ( 4 - ( length % 4 ) );
 	}
 	else if( length < 16 ) {
 		length = 16;
 	}
-	printk( "write_hsi_direct : new len : %d\n", length );
+#endif
+
+//	printk( "write_hsi_direct : new len : %d\n", length );
 	
 	retval = hsi_proto_write( 0, data, length );
 	if( retval < 0 ) {
 		printk( "write_hsi_direct : hsi_proto_write Fail : %d\n", retval );
 		return retval;
 	}
-	printk( "write_hsi_direct : Write returned %d\n", retval );
+	//printk( "write_hsi_direct : Write returned %d\n", retval );
 
 	return retval;
 }
@@ -587,10 +823,11 @@
 int read_hsi_direct( u32 *data, int length )
 {
 	int retval = 0;
+#if 0
 	struct hsr_ctx rx_config;
 
-	printk( "read_hsi_direct : len : %d\n", length );
 
+	printk( "read_hsi_direct : len : %d\n", length );
 	hsi_ioctl( hsi_protocol_iface.channels[ 0 ].dev, HSI_IOCTL_GET_RX, &rx_config );
 	rx_config.mode = 2;
 	rx_config.channels = 1;
@@ -608,118 +845,31 @@
 		return retval;
 	}
 	printk( "read_hsi_direct : ACWAKE High\n" );
+#endif
 
-	if( ( length > 16 ) || ( length % 4 ) ) {
+#if 0
+	if( ( length > 16 ) && ( length % 4 ) ) {
 		length += ( 4 - ( length % 4 ) );
 	}
 	else if( length < 16 ) {
 		length = 16;
 	}
-	printk( "read_hsi_direct : new len : %d\n", length );
+#endif
+	//printk( "read_hsi_direct : new len : %d\n", length );
 	
 	retval = hsi_proto_read( 0, data, length );
 	if( retval < 0 ) {
 		printk( "read_hsi_direct : hsi_proto_read Fail : %d\n", retval );
 		return retval;
 	}
-	printk( "read_hsi_direct : Read returned %d\n", retval );
+	//printk( "read_hsi_direct : Read returned %d\n", retval );
 
 	return retval;
 }
 EXPORT_SYMBOL( read_hsi_direct );
 
-u32 initialization = 0;
-
-/*write data to channel*/
-int write_hsi(u32 ch, u32 *data, int length)
-{
-	int ret;	
-	u32 cmd[4] = {0, 0xAAAAAAAA, 0xBBBBBBBB, 0xCCCCCCCC};
-	struct if_hsi_channel *channel;
-	struct task_struct *read_thread;
-
-	channel = &hsi_protocol_iface.channels[ch];
-	channel->tx_buf = data;	
-	actual_write = 0;
-
-	cmd[0] = protocol_create_cmd(HSI_LL_MSG_OPEN_CONN_OCTET, ch, (void *)&length);
-	printk("data ptr is %x\n", data); 
-
-	if (initialization == 0){
-		/* ACWAKE ->HIGH */
-		ret = hsi_ioctl(hsi_protocol_iface.channels[0].dev, HSI_IOCTL_ACWAKE_UP, NULL);
-		if(ret == 0)
-			printk("ACWAKE pulled high in %s()\n",__func__);
-
-		/*Creating read thread*/
-		read_thread = kthread_run(hsi_read_thrd, NULL, "hsi_read_thread");
-	
-		initialization++;
-	}
-
-	channel->tx_state = HSI_LL_TX_STATE_WAIT_FOR_ACK;
-	
-	//send_cmd(cmd, channel, data)
-	ret = hsi_proto_write(0, &cmd, 4*4);
-	printk("Write returned %d\n", ret); 	
-
-	wait_event_interruptible(ipc_write_wait, actual_write != 0);
-
-	return	actual_write;
-
-
-/*	printk("%s() Opening channel %d\n", __func__, channel);
-	ret = if_hsi_openchannel(&hsi_protocol_iface.channels[channel]);
-	if (ret < 0){
-		pr_err("Can not Open channel 0. Can not start HSI protocol \n");
-		//Close Channel
-		if_hsi_closechannel(&hsi_protocol_iface.channels[channel]);
-		return -1;
-
-	}else{
-	//Send Data
-	printk("Channel Open successful. ret = %d, func-%s\n", ret, __func__);
-	ret = hsi_proto_write(channel, data, length);
-	//Close Channel
-	if_hsi_closechannel(&hsi_protocol_iface.channels[channel]);*/
-}
-EXPORT_SYMBOL(write_hsi);
-
-
-int read_hsi(u8 *data, u32 *ch, u32 *length)
-{
-	int ret, size, tmp;
-	struct if_hsi_channel *channel;
-
-	printk("In read_hsi() function, Sleeping ...\n");
-	wait_event_interruptible(ipc_read_wait,(avlb_length != 0));
-	printk("In read_hsi() function, Waking Up ...\n");
-
-	channel = &hsi_protocol_iface.channels[avlb_ch];	
-	
-	size = avlb_length;
-	if ((size > 16) && (size % 4))
-		size += (4 - (size % 4));
-	else if (size < 16)
-		size = 16;
-	ret = hsi_proto_read(avlb_ch, data, size);
-	if( ret < 0)
-		printk("Read in IPC failed, %s()\n",__func__);
-	
-	printk("%s() read returned %d, actual_length = %d, ch-> %d\n",__func__, ret,avlb_length, avlb_ch);
-	tmp = if_hsi_closechannel(channel);
-	printk("%s() closed channel, sending CONN_CLOSED. ret = %d\n",__func__, tmp);
-	tmp = hsi_protocol_send_command(HSI_LL_MSG_CONN_CLOSED, avlb_ch, 0);
-	printk("%s() Sending CONN_CLOSED Finished. ret = %d\n",__func__, tmp);
-	
-	*ch = avlb_ch;
-	*length = avlb_length;
-	avlb_length = 0;
-	
-	printk("%s() RETURNING TO IPC with ret = %d\n",__func__, ret);
-	return ret;
-
-}
-EXPORT_SYMBOL(read_hsi);
+//========================================================//
+//                -- Flashless Boot. --                   //
+//========================================================//
 
 
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/drivers/staging/omap_hsi/hsi-protocol-if.h Kernel/drivers/staging/omap_hsi/hsi-protocol-if.h
--- Kernel-orig/drivers/staging/omap_hsi/hsi-protocol-if.h	2011-02-16 11:29:38.482105455 +0530
+++ Kernel/drivers/staging/omap_hsi/hsi-protocol-if.h	2011-02-08 09:55:55.281530112 +0530
@@ -55,6 +55,8 @@
 	u32 *rx_buf;
 	unsigned int tx_state;
 	unsigned int rx_state;
+	unsigned int tx_nak_count;
+	unsigned int rx_nak_count;
         spinlock_t lock; /* Serializes access to channel data */
 };
 
@@ -65,6 +67,13 @@
         spinlock_t lock; /* Serializes access to HSI functional interface */
 };
 
+struct if_hsi_cmd {
+	u32 tx_cmd[ 50 ];
+	u32 rx_cmd[ 50 ];
+	struct timespec tx_cmd_time[ 50 ];
+	struct timespec rx_cmd_time[ 50 ];
+};
+
 enum {
   HSI_LL_MSG_BREAK           = 0x00,
   HSI_LL_MSG_ECHO            = 0x01,
diff -urN -x .git -x .gitignore -x .pc -x patches -x .mailmap Kernel-orig/include/linux/hsi_driver_if.h Kernel/include/linux/hsi_driver_if.h
--- Kernel-orig/include/linux/hsi_driver_if.h	2011-01-24 11:55:54.000000000 +0530
+++ Kernel/include/linux/hsi_driver_if.h	2011-02-09 13:07:23.389030504 +0530
@@ -82,7 +82,7 @@
 	u32 flow;
 	u32 frame_size;
 	u32 divisor;
-	u32 timeout;
+	u32 counters;
 	u32 channels;
 };
 
@@ -94,15 +94,15 @@
 
 /**
  * struct ctrl_ctx - hsi controller regs context
- * @loss_count: hsi last loss count
- * @sysconfig: keeps sysconfig reg state
- * @gdd_gcr: keeps gcr reg state
+ * @sysconfig: keeps HSI_SYSCONFIG reg state
+ * @gdd_gcr: keeps DMA_GCR reg state
+ * @dll: keeps HSR_DLL state
  * @pctx: array of port context
  */
 struct ctrl_ctx {
-	int loss_count;
 	u32 sysconfig;
 	u32 gdd_gcr;
+	u32 dll;
 	struct port_ctx *pctx;
 };
 /* END DPS */
@@ -118,8 +118,9 @@
 	int (*device_shutdown) (struct platform_device *pdev);
 	int (*device_idle) (struct platform_device *pdev);
 	u8 num_ports;
-	struct ctrl_ctx ctx;
+	struct ctrl_ctx *ctx;
 	u8 hsi_gdd_chan_count;
+	unsigned long default_hsi_fclk;
 };
 
 /**
