Index: android-2.6.35/arch/arm/configs/android_omap4tab_rev04_defconfig
===================================================================
--- android-2.6.35.orig/arch/arm/configs/android_omap4tab_rev04_defconfig	2010-12-22 14:36:08.431988271 +0530
+++ android-2.6.35/arch/arm/configs/android_omap4tab_rev04_defconfig	2010-12-22 14:36:39.051987788 +0530
@@ -770,11 +770,12 @@
 # CONFIG_MG_DISK is not set
 CONFIG_NEW_SENSORS=y
 CONFIG_OPTICAL=y
-CONFIG_OPTICAL_ISL29023=y
+CONFIG_OPTICAL_GP2A=y
 CONFIG_ACCEL=y
 CONFIG_ACCEL_KXSD9=y
-CONFIG_COMPASS=y
-CONFIG_COMPASS_AK8973B=y
+# CONFIG_COMPASS is not set
+CONFIG_GYRO=y
+CONFIG_GYRO_MPU3050=y
 CONFIG_MISC_DEVICES=y
 # CONFIG_AD525X_DPOT is not set
 CONFIG_ANDROID_PMEM=y
@@ -785,7 +786,7 @@
 # CONFIG_SENSORS_TSL2550 is not set
 CONFIG_TWL6030_POWER_OFF=y
 # CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_AK8975 is not set
+CONFIG_SENSORS_AK8975=y
 # CONFIG_TWL6040_VIB is not set
 # CONFIG_DS1682 is not set
 # CONFIG_TI_DAC7512 is not set
@@ -793,7 +794,7 @@
 # CONFIG_BMP085 is not set
 # CONFIG_WL127X_RFKILL is not set
 # CONFIG_APANIC is not set
-CONFIG_LP530AL_GYRO_SENSOR=y
+# CONFIG_LP530AL_GYRO_SENSOR is not set
 # CONFIG_C2PORT is not set
 
 #
Index: android-2.6.35/drivers/misc/akm8975.c
===================================================================
--- android-2.6.35.orig/drivers/misc/akm8975.c	2010-12-10 15:11:21.000000000 +0530
+++ android-2.6.35/drivers/misc/akm8975.c	2010-12-22 14:36:09.813238964 +0530
@@ -16,8 +16,7 @@
 
 /*
  * Revised by AKM 2009/04/02
- * Revised by Motorola 2010/05/27
- *
+ * 
  */
 
 #include <linux/interrupt.h>
@@ -28,705 +27,908 @@
 #include <linux/gpio.h>
 #include <linux/uaccess.h>
 #include <linux/delay.h>
+#include <linux/jiffies.h>
 #include <linux/input.h>
 #include <linux/workqueue.h>
 #include <linux/freezer.h>
 #include <linux/akm8975.h>
 #include <linux/earlysuspend.h>
 
-#define AK8975DRV_CALL_DBG 0
-#if AK8975DRV_CALL_DBG
-#define FUNCDBG(msg)	pr_err("%s:%s\n", __func__, msg);
+#define AKM8975_DEBUG		0
+#define AKM8975_DEBUG_MSG	0
+#define AKM8975_DEBUG_FUNC	0
+#define AKM8975_DEBUG_DATA	0
+#define MAX_FAILURE_COUNT	3
+#define AKM8975_RETRY_COUNT	10
+#define AKM8975_DEFAULT_DELAY	100
+
+#if AKM8975_DEBUG_MSG
+#define AKMDBG(format, ...)	printk(KERN_INFO "AKM8975 " format "\n", ## __VA_ARGS__)
+#else
+#define AKMDBG(format, ...)
+#endif
+
+#if AKM8975_DEBUG_FUNC
+#define AKMFUNC(func) printk(KERN_INFO "AKM8975 " func " is called\n")
 #else
-#define FUNCDBG(msg)
+#define AKMFUNC(func)
 #endif
 
-#define AK8975DRV_DATA_DBG 0
-#define MAX_FAILURE_COUNT 10
+static struct i2c_client *this_client;
 
 struct akm8975_data {
-	struct i2c_client *this_client;
-	struct akm8975_platform_data *pdata;
 	struct input_dev *input_dev;
 	struct work_struct work;
-	struct mutex flags_lock;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend early_suspend;
-#endif
+	struct early_suspend akm_early_suspend;
 };
 
-/*
-* Because misc devices can not carry a pointer from driver register to
-* open, we keep this global. This limits the driver to a single instance.
-*/
-struct akm8975_data *akmd_data;
-
+/* Addresses to scan -- protected by sense_data_mutex */
+static char sense_data[SENSOR_DATA_SIZE];
+static struct mutex sense_data_mutex;
+static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
 static DECLARE_WAIT_QUEUE_HEAD(open_wq);
 
+static atomic_t data_ready;
+static atomic_t open_count;
 static atomic_t open_flag;
+static atomic_t reserve_open_flag;
 
-static short m_flag;
-static short a_flag;
-static short t_flag;
-static short mv_flag;
-
-static short akmd_delay;
-
-static ssize_t akm8975_show(struct device *dev, struct device_attribute *attr,
-				 char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	return sprintf(buf, "%u\n", i2c_smbus_read_byte_data(client,
-							     AK8975_REG_CNTL));
-}
-static ssize_t akm8975_store(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	unsigned long val;
-	strict_strtoul(buf, 10, &val);
-	if (val > 0xff)
-		return -EINVAL;
-	i2c_smbus_write_byte_data(client, AK8975_REG_CNTL, val);
-	return count;
-}
-static DEVICE_ATTR(akm_ms1, S_IWUSR | S_IRUGO, akm8975_show, akm8975_store);
+static atomic_t m_flag;
+static atomic_t a_flag;
+static atomic_t mv_flag;
+
+static int failure_count = 0;
+
+static short akmd_delay = AKM8975_DEFAULT_DELAY;
+
+static atomic_t suspend_flag = ATOMIC_INIT(0);
+
+static struct akm8975_platform_data *pdata;
 
-static int akm8975_i2c_rxdata(struct akm8975_data *akm, char *buf, int length)
+static int AKI2C_RxData(char *rxData, int length)
 {
+	uint8_t loop_i;
 	struct i2c_msg msgs[] = {
 		{
-			.addr = akm->this_client->addr,
+			.addr = this_client->addr,
 			.flags = 0,
 			.len = 1,
-			.buf = buf,
+			.buf = rxData,
 		},
 		{
-			.addr = akm->this_client->addr,
+			.addr = this_client->addr,
 			.flags = I2C_M_RD,
 			.len = length,
-			.buf = buf,
+			.buf = rxData,
 		},
 	};
-
-	FUNCDBG("called");
-
-	if (i2c_transfer(akm->this_client->adapter, msgs, 2) < 0) {
-		pr_err("akm8975_i2c_rxdata: transfer error\n");
-		return EIO;
-	} else
-		return 0;
+#if AKM8975_DEBUG_DATA
+	int i;
+	char addr = rxData[0];
+#endif
+#ifdef AKM8975_DEBUG
+	/* Caller should check parameter validity.*/
+	if ((rxData == NULL) || (length < 1)) {
+		return -EINVAL;
+	}
+#endif
+	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+	
+	if (loop_i >= AKM8975_RETRY_COUNT) {
+		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
+		return -EIO;
+	}
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "RxData: len=%02x, addr=%02x\n  data=", length, addr);
+	for (i = 0; i < length; i++) {
+		printk(KERN_INFO " %02x", rxData[i]);
+	}
+    printk(KERN_INFO "\n");
+#endif
+	return 0;
 }
 
-static int akm8975_i2c_txdata(struct akm8975_data *akm, char *buf, int length)
+static int AKI2C_TxData(char *txData, int length)
 {
-	struct i2c_msg msgs[] = {
+	uint8_t loop_i;
+	struct i2c_msg msg[] = {
 		{
-			.addr = akm->this_client->addr,
+			.addr = this_client->addr,
 			.flags = 0,
 			.len = length,
-			.buf = buf,
+			.buf = txData,
 		},
 	};
+#if AKM8975_DEBUG_DATA
+	int i;
+#endif
+#ifdef AKM8975_DEBUG
+	/* Caller should check parameter validity.*/
+	if ((txData == NULL) || (length < 2)) {
+		return -EINVAL;
+	}
+#endif	
+	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+	
+	if (loop_i >= AKM8975_RETRY_COUNT) {
+		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
+		return -EIO;
+	}
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "TxData: len=%02x, addr=%02x\n  data=", length, txData[0]);
+	for (i = 0; i < (length-1); i++) {
+		printk(KERN_INFO " %02x", txData[i + 1]);
+	}
+	printk(KERN_INFO "\n");
+#endif
+	return 0;
+}
 
-	FUNCDBG("called");
+static int AKECS_SetMode_SngMeasure(void)
+{
+	char buffer[2];
+	
+	atomic_set(&data_ready, 0);
+	
+	/* Set measure mode */
+	buffer[0] = AK8975_REG_CNTL;
+	buffer[1] = AK8975_MODE_SNG_MEASURE;
+	
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_SetMode_SelfTest(void)
+{
+	char buffer[2];
+	
+	/* Set measure mode */
+	buffer[0] = AK8975_REG_CNTL;
+	buffer[1] = AK8975_MODE_SELF_TEST;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_SetMode_FUSEAccess(void)
+{
+	char buffer[2];
+	
+	/* Set measure mode */
+	buffer[0] = AK8975_REG_CNTL;
+	buffer[1] = AK8975_MODE_FUSE_ACCESS;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_SetMode_PowerDown(void)
+{
+	char buffer[2];
+	
+	/* Set powerdown mode */
+	buffer[0] = AK8975_REG_CNTL;
+	buffer[1] = AK8975_MODE_POWERDOWN;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
 
-	if (i2c_transfer(akm->this_client->adapter, msgs, 1) < 0) {
-		pr_err("akm8975_i2c_txdata: transfer error\n");
-		return -EIO;
-	} else
-		return 0;
+static int AKECS_SetMode(char mode)
+{
+	int ret;
+	
+	switch (mode) {
+		case AK8975_MODE_SNG_MEASURE:
+			ret = AKECS_SetMode_SngMeasure();
+			break;
+		case AK8975_MODE_SELF_TEST:
+			ret = AKECS_SetMode_SelfTest();
+			break;
+		case AK8975_MODE_FUSE_ACCESS:
+			ret = AKECS_SetMode_FUSEAccess();
+			break;
+		case AK8975_MODE_POWERDOWN:
+			ret = AKECS_SetMode_PowerDown();
+			/* wait at least 100us after changing mode */
+			udelay(100);
+			break;
+		default:
+			AKMDBG("%s: Unknown mode(%d)", __func__, mode);
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int AKECS_CheckDevice(void)
+{
+	char buffer[2];
+	int ret;
+	
+	/* Set measure mode */
+	buffer[0] = AK8975_REG_WIA;
+	
+	/* Read data */
+	ret = AKI2C_RxData(buffer, 1);
+	if (ret < 0) {
+		return ret;
+	}
+	/* Check read data */
+	if (buffer[0] != 0x48) {
+		return -ENXIO;
+	}
+	
+	return 0;
 }
 
-static void akm8975_ecs_report_value(struct akm8975_data *akm, short *rbuf)
+static int AKECS_GetData(char *rbuf, int size)
 {
-	struct akm8975_data *data = i2c_get_clientdata(akm->this_client);
+#ifdef AKM8975_DEBUG
+	/* This function is not exposed, so parameters 
+	 should be checked internally.*/
+	if ((rbuf == NULL) || (size < SENSOR_DATA_SIZE)) {
+		return -EINVAL;
+	}
+#endif
+
+	wait_event_interruptible_timeout(data_ready_wq, atomic_read(&data_ready), msecs_to_jiffies(1000));
 
-	FUNCDBG("called");
+	if (!atomic_read(&data_ready))
+	{
+		AKMDBG("%s: data_ready is not set.", __func__);
 
-#if AK8975DRV_DATA_DBG
-	pr_info("akm8975_ecs_report_value: yaw = %d, pitch = %d, roll = %d\n",
-				 rbuf[0], rbuf[1], rbuf[2]);
-	pr_info("tmp = %d, m_stat= %d, g_stat=%d\n", rbuf[3], rbuf[4], rbuf[5]);
-	pr_info("Acceleration:	 x = %d LSB, y = %d LSB, z = %d LSB\n",
-				 rbuf[6], rbuf[7], rbuf[8]);
-	pr_info("Magnetic:	 x = %d LSB, y = %d LSB, z = %d LSB\n\n",
-				 rbuf[9], rbuf[10], rbuf[11]);
+		if (!atomic_read(&suspend_flag))
+		{
+			AKMDBG("%s: suspend_flag is not set.", __func__);
+			failure_count++;
+
+			if (failure_count >= MAX_FAILURE_COUNT)
+			{
+				printk(KERN_ERR
+				       "AKM8975 AKECS_GetData: successive %d failure.\n",
+				       failure_count);
+				atomic_set(&open_flag, -1);
+				wake_up(&open_wq);
+				failure_count = 0;
+			}
+
+		}
+
+		return -1;
+
+	}
+	
+	mutex_lock(&sense_data_mutex);
+	memcpy(rbuf, sense_data, size);
+	atomic_set(&data_ready, 0);
+	mutex_unlock(&sense_data_mutex);
+	
+	failure_count = 0;
+	return 0;
+}
+
+static void AKECS_SetYPR(short *rbuf)
+{
+	struct akm8975_data *data = i2c_get_clientdata(this_client);
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "AKM8975 %s:\n", __func__);
+	printk(KERN_INFO "  yaw =%6d, pitch =%6d, roll =%6d\n",
+		   rbuf[0], rbuf[1], rbuf[2]);
+	printk(KERN_INFO "  tmp =%6d, m_stat =%6d, g_stat =%6d\n",
+		   rbuf[3], rbuf[4], rbuf[5]);
+	printk(KERN_INFO "  Acceleration[LSB]: %6d,%6d,%6d\n",
+	       rbuf[6], rbuf[7], rbuf[8]);
+	printk(KERN_INFO "  Geomagnetism[LSB]: %6d,%6d,%6d\n",
+	       rbuf[9], rbuf[10], rbuf[11]);
 #endif
-	mutex_lock(&akm->flags_lock);
 	/* Report magnetic sensor information */
-	if (m_flag) {
+	if (atomic_read(&m_flag)) {
 		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
 		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
 		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
 		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
 	}
-
+	
 	/* Report acceleration sensor information */
-	if (a_flag) {
+	if (atomic_read(&a_flag)) {
 		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
 		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
 		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
 		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
 	}
-
-	/* Report temperature information */
-	if (t_flag)
-		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
-
-	if (mv_flag) {
+	
+	/* Report magnetic vector information */
+	if (atomic_read(&mv_flag)) {
 		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
 		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
 		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
 	}
-	mutex_unlock(&akm->flags_lock);
-
+	
 	input_sync(data->input_dev);
 }
 
-static void akm8975_ecs_close_done(struct akm8975_data *akm)
+static int AKECS_GetOpenStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
+	return atomic_read(&open_flag);
+}
+
+static int AKECS_GetCloseStatus(void)
 {
-	FUNCDBG("called");
-	mutex_lock(&akm->flags_lock);
-	m_flag = 1;
-	a_flag = 1;
-	t_flag = 1;
-	mv_flag = 1;
-	mutex_unlock(&akm->flags_lock);
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
+	return atomic_read(&open_flag);
 }
 
+static void AKECS_CloseDone(void)
+{
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&mv_flag, 1);
+}
+
+/***** akm_aot functions ***************************************/
 static int akm_aot_open(struct inode *inode, struct file *file)
 {
 	int ret = -1;
 
-	FUNCDBG("called");
-	if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
-		wake_up(&open_wq);
-		ret = 0;
+	AKMFUNC("akm_aot_open");
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
+		}
 	}
-
-	ret = nonseekable_open(inode, file);
-	if (ret)
-		return ret;
-
-	file->private_data = akmd_data;
-
 	return ret;
 }
 
 static int akm_aot_release(struct inode *inode, struct file *file)
 {
-	FUNCDBG("called");
+	AKMFUNC("akm_aot_release");
+	atomic_set(&reserve_open_flag, 0);
 	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
 	wake_up(&open_wq);
 	return 0;
 }
 
-static int akm_aot_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
+static int
+akm_aot_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
 {
-	void __user *argp = (void __user *) arg;
+	void __user *argp = (void __user *)arg;
 	short flag;
-	struct akm8975_data *akm = file->private_data;
-
-	FUNCDBG("called");
-
+	
 	switch (cmd) {
-	case ECS_IOCTL_APP_SET_MFLAG:
-	case ECS_IOCTL_APP_SET_AFLAG:
-	case ECS_IOCTL_APP_SET_MVFLAG:
-		if (copy_from_user(&flag, argp, sizeof(flag)))
-			return -EFAULT;
-		if (flag < 0 || flag > 1)
-			return -EINVAL;
-		break;
-	case ECS_IOCTL_APP_SET_DELAY:
-		if (copy_from_user(&flag, argp, sizeof(flag)))
-			return -EFAULT;
-		break;
-	default:
-		break;
+		case ECS_IOCTL_APP_SET_MFLAG:
+		case ECS_IOCTL_APP_SET_AFLAG:
+		case ECS_IOCTL_APP_SET_MVFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			if (flag < 0 || flag > 1) {
+				return -EINVAL;
+			}
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
-
-	mutex_lock(&akm->flags_lock);
+	
 	switch (cmd) {
-	case ECS_IOCTL_APP_SET_MFLAG:
-	  m_flag = flag;
-		break;
-	case ECS_IOCTL_APP_GET_MFLAG:
-		flag = m_flag;
-		break;
-	case ECS_IOCTL_APP_SET_AFLAG:
-		a_flag = flag;
-		break;
-	case ECS_IOCTL_APP_GET_AFLAG:
-		flag = a_flag;
-		break;
-	case ECS_IOCTL_APP_SET_MVFLAG:
-		mv_flag = flag;
-		break;
-	case ECS_IOCTL_APP_GET_MVFLAG:
-		flag = mv_flag;
-		break;
-	case ECS_IOCTL_APP_SET_DELAY:
-		akmd_delay = flag;
-		break;
-	case ECS_IOCTL_APP_GET_DELAY:
-		flag = akmd_delay;
-		break;
-	default:
-		return -ENOTTY;
+		case ECS_IOCTL_APP_SET_MFLAG:
+			atomic_set(&m_flag, flag);
+			AKMDBG("MFLAG is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_MFLAG:
+			flag = atomic_read(&m_flag);
+			break;
+		case ECS_IOCTL_APP_SET_AFLAG:
+			atomic_set(&a_flag, flag);
+			AKMDBG("AFLAG is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_AFLAG:
+			flag = atomic_read(&a_flag);
+			break;
+		case ECS_IOCTL_APP_SET_MVFLAG:
+			atomic_set(&mv_flag, flag);
+			AKMDBG("MVFLAG is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_MVFLAG:
+			flag = atomic_read(&mv_flag);
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			akmd_delay = flag;
+			AKMDBG("Delay is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_DELAY:
+			flag = akmd_delay;
+			break;
+		default:
+			return -ENOTTY;
 	}
-	mutex_unlock(&akm->flags_lock);
-
+	
 	switch (cmd) {
-	case ECS_IOCTL_APP_GET_MFLAG:
-	case ECS_IOCTL_APP_GET_AFLAG:
-	case ECS_IOCTL_APP_GET_MVFLAG:
-	case ECS_IOCTL_APP_GET_DELAY:
-		if (copy_to_user(argp, &flag, sizeof(flag)))
-			return -EFAULT;
-		break;
-	default:
-		break;
+		case ECS_IOCTL_APP_GET_MFLAG:
+		case ECS_IOCTL_APP_GET_AFLAG:
+		case ECS_IOCTL_APP_GET_MVFLAG:
+		case ECS_IOCTL_APP_GET_DELAY:
+			if (copy_to_user(argp, &flag, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
-
+	
 	return 0;
 }
 
+/***** akmd functions ********************************************/
 static int akmd_open(struct inode *inode, struct file *file)
 {
-	int err = 0;
-
-	FUNCDBG("called");
-	err = nonseekable_open(inode, file);
-	if (err)
-		return err;
-
-	file->private_data = akmd_data;
-	return 0;
+	AKMFUNC("akmd_open");
+	return nonseekable_open(inode, file);
 }
 
 static int akmd_release(struct inode *inode, struct file *file)
 {
-	struct akm8975_data *akm = file->private_data;
-
-	FUNCDBG("called");
-	akm8975_ecs_close_done(akm);
+	AKMFUNC("akmd_release");
+	AKECS_CloseDone();
 	return 0;
 }
 
-static int akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-		      unsigned long arg)
-{
-	void __user *argp = (void __user *) arg;
-
-	char rwbuf[16];
-	int ret = -1;
-	int status;
-	short value[12];
-	short delay;
-	struct akm8975_data *akm = file->private_data;
-
-	FUNCDBG("called");
-
+static int
+akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		   unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	
+	/* NOTE: In this function the size of "char" should be 1-byte. */
+	char sData[SENSOR_DATA_SIZE];/* for GETDATA */
+	char rwbuf[RWBUF_SIZE];		/* for READ/WRITE */
+	char mode;					/* for SET_MODE*/
+	short value[12];			/* for SET_YPR */
+	short delay;				/* for GET_DELAY */
+	int status;					/* for OPEN/CLOSE_STATUS */
+	int ret = -1;				/* Return value. */
+	/*AKMDBG("%s (0x%08X).", __func__, cmd);*/
+	
 	switch (cmd) {
-	case ECS_IOCTL_READ:
-	case ECS_IOCTL_WRITE:
-		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-
-	case ECS_IOCTL_SET_YPR:
-		if (copy_from_user(&value, argp, sizeof(value)))
-			return -EFAULT;
-		break;
-
-	default:
-		break;
+		case ECS_IOCTL_WRITE:
+		case ECS_IOCTL_READ:
+			if (argp == NULL) {
+				AKMDBG("invalid argument.");
+				return -EINVAL;
+			}
+			if (copy_from_user(&rwbuf, argp, sizeof(rwbuf))) {
+				AKMDBG("copy_from_user failed.");
+				return -EFAULT;
+			}
+			break;
+		case ECS_IOCTL_SET_MODE:
+			if (argp == NULL) {
+				AKMDBG("invalid argument.");
+				return -EINVAL;
+			}
+			if (copy_from_user(&mode, argp, sizeof(mode))) {
+				AKMDBG("copy_from_user failed.");
+				return -EFAULT;
+			}
+			break;
+		case ECS_IOCTL_SET_YPR:
+			if (argp == NULL) {
+				AKMDBG("invalid argument.");
+				return -EINVAL;
+			}
+			if (copy_from_user(&value, argp, sizeof(value))) {
+				AKMDBG("copy_from_user failed.");
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
-
+	
 	switch (cmd) {
-	case ECS_IOCTL_READ:
-		if (rwbuf[0] < 1)
-			return -EINVAL;
-
-		ret = akm8975_i2c_rxdata(akm, &rwbuf[1], rwbuf[0]);
-		if (ret < 0)
-			return ret;
-		break;
-
-	case ECS_IOCTL_WRITE:
-		if (rwbuf[0] < 2)
-			return -EINVAL;
-
-		ret = akm8975_i2c_txdata(akm, &rwbuf[1], rwbuf[0]);
-		if (ret < 0)
-			return ret;
-		break;
-	case ECS_IOCTL_SET_YPR:
-		akm8975_ecs_report_value(akm, value);
-		break;
-
-	case ECS_IOCTL_GET_OPEN_STATUS:
-		wait_event_interruptible(open_wq,
-					 (atomic_read(&open_flag) != 0));
-		status = atomic_read(&open_flag);
-		break;
-	case ECS_IOCTL_GET_CLOSE_STATUS:
-		wait_event_interruptible(open_wq,
-					 (atomic_read(&open_flag) == 0));
-		status = atomic_read(&open_flag);
-		break;
-
-	case ECS_IOCTL_GET_DELAY:
-		delay = akmd_delay;
-		break;
-
-	default:
-		FUNCDBG("Unknown cmd\n");
-		return -ENOTTY;
+		case ECS_IOCTL_WRITE:
+			AKMFUNC("IOCTL_WRITE");
+			if ((rwbuf[0] < 2) || (rwbuf[0] > (RWBUF_SIZE-1))) {
+				AKMDBG("invalid argument.");
+				return -EINVAL;
+			}
+			ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case ECS_IOCTL_READ:
+			AKMFUNC("IOCTL_READ");
+			if ((rwbuf[0] < 1) || (rwbuf[0] > (RWBUF_SIZE-1))) {
+				AKMDBG("invalid argument.");
+				return -EINVAL;
+			}
+			ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case ECS_IOCTL_SET_MODE:
+			AKMFUNC("IOCTL_SET_MODE");
+			ret = AKECS_SetMode(mode);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case ECS_IOCTL_GETDATA:
+			AKMFUNC("IOCTL_GET_DATA");
+			ret = AKECS_GetData(sData, SENSOR_DATA_SIZE);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case ECS_IOCTL_SET_YPR:
+			AKECS_SetYPR(value);
+			break;
+		case ECS_IOCTL_GET_OPEN_STATUS:
+			AKMFUNC("IOCTL_GET_OPEN_STATUS");
+			status = AKECS_GetOpenStatus();
+			AKMDBG("AKECS_GetOpenStatus returned (%d)", status);
+			break;
+		case ECS_IOCTL_GET_CLOSE_STATUS:
+			AKMFUNC("IOCTL_GET_CLOSE_STATUS");
+			status = AKECS_GetCloseStatus();
+			AKMDBG("AKECS_GetCloseStatus returned (%d)", status);
+			break;
+		case ECS_IOCTL_GET_DELAY:
+			AKMFUNC("IOCTL_GET_DELAY");
+			delay = akmd_delay;
+			break;
+		default:
+			return -ENOTTY;
 	}
-
+	
 	switch (cmd) {
-	case ECS_IOCTL_READ:
-		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_GET_OPEN_STATUS:
-	case ECS_IOCTL_GET_CLOSE_STATUS:
-		if (copy_to_user(argp, &status, sizeof(status)))
-			return -EFAULT;
-		break;
-	case ECS_IOCTL_GET_DELAY:
-		if (copy_to_user(argp, &delay, sizeof(delay)))
-			return -EFAULT;
-		break;
-	default:
-		break;
+		case ECS_IOCTL_READ:
+			if (copy_to_user(argp, &rwbuf, rwbuf[0]+1)) {
+				AKMDBG("copy_to_user failed.");
+				return -EFAULT;
+			}
+			break;
+		case ECS_IOCTL_GETDATA:
+			if (copy_to_user(argp, &sData, sizeof(sData))) {
+				AKMDBG("copy_to_user failed.");
+				return -EFAULT;
+			}
+			break;
+		case ECS_IOCTL_GET_OPEN_STATUS:
+		case ECS_IOCTL_GET_CLOSE_STATUS:
+			if (copy_to_user(argp, &status, sizeof(status))) {
+				AKMDBG("copy_to_user failed.");
+				return -EFAULT;
+			}
+			break;
+		case ECS_IOCTL_GET_DELAY:
+			if (copy_to_user(argp, &delay, sizeof(delay))) {
+				AKMDBG("copy_to_user failed.");
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
-
+	
 	return 0;
 }
 
-/* needed to clear the int. pin */
-static void akm_work_func(struct work_struct *work)
+static void akm8975_work_func(struct work_struct *work)
 {
-	struct akm8975_data *akm =
-	    container_of(work, struct akm8975_data, work);
 
-	FUNCDBG("called");
-	enable_irq(akm->this_client->irq);
-}
+	//printk("AKM8975 akm8975_work_func called\n");
+	disable_irq(this_client->irq);
 
-static irqreturn_t akm8975_interrupt(int irq, void *dev_id)
-{
-	struct akm8975_data *akm = dev_id;
-	FUNCDBG("called");
-
-	disable_irq_nosync(akm->this_client->irq);
-	schedule_work(&akm->work);
-	return IRQ_HANDLED;
-}
-
-static int akm8975_power_off(struct akm8975_data *akm)
-{
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	if (akm->pdata->power_off)
-		akm->pdata->power_off();
-
-	return 0;
-}
-
-static int akm8975_power_on(struct akm8975_data *akm)
-{
-	int err;
-
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	if (akm->pdata->power_on) {
-		err = akm->pdata->power_on();
-		if (err < 0)
-			return err;
+	char buffer[SENSOR_DATA_SIZE];
+	int ret;
+	
+	memset(buffer, 0, SENSOR_DATA_SIZE);
+	buffer[0] = AK8975_REG_ST1;
+	ret = AKI2C_RxData(buffer, SENSOR_DATA_SIZE);
+	if (ret < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_work_func: I2C failed\n");
+		return;
 	}
-	return 0;
+	/* Check ST bit */
+	if ((buffer[0] & 0x01) != 0x01) {
+		printk(KERN_ERR "AKM8975 akm8975_work_func: ST is not set\n");
+		return;
+	}
+	
+	mutex_lock(&sense_data_mutex);
+	memcpy(sense_data, buffer, SENSOR_DATA_SIZE);
+	atomic_set(&data_ready, 1);
+	wake_up(&data_ready_wq);
+	mutex_unlock(&sense_data_mutex);
+	
+	enable_irq(this_client->irq);
+	
+	AKMFUNC("akm8975_work_func");
 }
 
-static int akm8975_suspend(struct i2c_client *client, pm_message_t mesg)
+static irqreturn_t akm8975_interrupt(int irq, void *dev_id)
 {
-	struct akm8975_data *akm = i2c_get_clientdata(client);
+	struct akm8975_data *data = dev_id;
+	AKMFUNC("akm8975_interrupt");
 
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	/* TO DO: might need more work after power mgmt
-	   is enabled */
-	return akm8975_power_off(akm);
-}
+	// Followin is a blocking call.
+	// Waits for IRQ_HANDLED, Hence moved to akm8975_work_func.
+	//disable_irq(this_client->irq);
 
-static int akm8975_resume(struct i2c_client *client)
-{
-	struct akm8975_data *akm = i2c_get_clientdata(client);
+	schedule_work(&data->work);
 
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	/* TO DO: might need more work after power mgmt
-	   is enabled */
-	return akm8975_power_on(akm);
+	return IRQ_HANDLED;
 }
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
 static void akm8975_early_suspend(struct early_suspend *handler)
 {
-	struct akm8975_data *akm;
-	akm = container_of(handler, struct akm8975_data, early_suspend);
-
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	akm8975_suspend(akm->this_client, PMSG_SUSPEND);
+	AKMFUNC("akm8975_early_suspend");
+	atomic_set(&suspend_flag, 1);
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	disable_irq(this_client->irq);
+	AKMDBG("suspended with flag=%d", 
+	       atomic_read(&reserve_open_flag));
 }
 
 static void akm8975_early_resume(struct early_suspend *handler)
 {
-	struct akm8975_data *akm;
-	akm = container_of(handler, struct akm8975_data, early_suspend);
-
-#if AK8975DRV_CALL_DBG
-	pr_info("%s\n", __func__);
-#endif
-	akm8975_resume(akm->this_client);
-}
-#endif
-
-
-static int akm8975_init_client(struct i2c_client *client)
-{
-	struct akm8975_data *data;
-	int ret;
-
-	data = i2c_get_clientdata(client);
-
-	ret = request_irq(client->irq, akm8975_interrupt, IRQF_TRIGGER_RISING,
-				"akm8975", data);
-
-	if (ret < 0) {
-		pr_err("akm8975_init_client: request irq failed\n");
-		goto err;
-	}
-
-	init_waitqueue_head(&open_wq);
-
-	mutex_lock(&data->flags_lock);
-	m_flag = 1;
-	a_flag = 1;
-	t_flag = 1;
-	mv_flag = 1;
-	mutex_unlock(&data->flags_lock);
-
-	return 0;
-err:
-  return ret;
+	AKMFUNC("akm8975_early_resume");
+	enable_irq(this_client->irq);
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+	AKMDBG("resumed with flag=%d", 
+	       atomic_read(&reserve_open_flag));
 }
 
-static const struct file_operations akmd_fops = {
+/*********************************************/
+static struct file_operations akmd_fops = {
 	.owner = THIS_MODULE,
 	.open = akmd_open,
 	.release = akmd_release,
 	.ioctl = akmd_ioctl,
 };
 
-static const struct file_operations akm_aot_fops = {
+static struct file_operations akm_aot_fops = {
 	.owner = THIS_MODULE,
 	.open = akm_aot_open,
 	.release = akm_aot_release,
 	.ioctl = akm_aot_ioctl,
 };
 
-static struct miscdevice akm_aot_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "akm8975_aot",
-	.fops = &akm_aot_fops,
-};
-
 static struct miscdevice akmd_device = {
 	.minor = MISC_DYNAMIC_MINOR,
 	.name = "akm8975_dev",
 	.fops = &akmd_fops,
 };
 
-int akm8975_probe(struct i2c_client *client,
-		  const struct i2c_device_id *devid)
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8975_aot",
+	.fops = &akm_aot_fops,
+};
+
+/*********************************************/
+int akm8975_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct akm8975_data *akm;
-	int err;
-	FUNCDBG("called");
-
-	if (client->dev.platform_data == NULL) {
-		dev_err(&client->dev, "platform data is NULL. exiting.\n");
-		err = -ENODEV;
-		goto exit_platform_data_null;
-	}
+	int err = 0, val;
+	
+	AKMFUNC("akm8975_probe");
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "platform data is NULL. exiting.\n");
+		printk(KERN_ERR "AKM8975 akm8975_probe: check_functionality failed.\n");
 		err = -ENODEV;
-		goto exit_check_functionality_failed;
+		goto exit0;
 	}
-
+	
+	/* Allocate memory for driver data */
 	akm = kzalloc(sizeof(struct akm8975_data), GFP_KERNEL);
 	if (!akm) {
-		dev_err(&client->dev,
-			"failed to allocate memory for module data\n");
+		printk(KERN_ERR "AKM8975 akm8975_probe: memory allocation failed.\n");
 		err = -ENOMEM;
-		goto exit_alloc_data_failed;
+		goto exit1;
 	}
-
-	akm->pdata = client->dev.platform_data;
-
-	mutex_init(&akm->flags_lock);
-	INIT_WORK(&akm->work, akm_work_func);
+	
+	INIT_WORK(&akm->work, akm8975_work_func);
 	i2c_set_clientdata(client, akm);
 
-	err = akm8975_power_on(akm);
-	if (err < 0)
-		goto exit_power_on_failed;
-
-	akm8975_init_client(client);
-	akm->this_client = client;
-	akmd_data = akm;
-
+	#if 0	
+	/* Check platform data*/
+	if (client->dev.platform_data == NULL) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: platform data is NULL\n");
+		err = -ENOMEM;
+		goto exit2;
+	}	
+	/* Copy to global variable */
+	pdata = client->dev.platform_data;
+	#endif
+
+	this_client = client;
+	
+	/* Check connection */
+	err = AKECS_CheckDevice();
+	if (err < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: set power down mode error\n");
+		goto exit3;
+	}
+	
+	/* IRQ */
+        val = omap_readl(0x4A100160);
+	printk("pin-MUX val=%x\n\n\n" ,val);
+        val |= 0x0103;
+        omap_writel(val, 0x4A100160);
+	printk("pin-MUX val=%x\n\n\n" ,val);
+
+	err = request_irq(client->irq, akm8975_interrupt, IRQ_TYPE_EDGE_RISING,
+					  "akm8975_DRDY", akm);
+	if (err < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: request irq failed\n");
+		goto exit4;
+	}
+	
+	/* Declare input device */
 	akm->input_dev = input_allocate_device();
 	if (!akm->input_dev) {
 		err = -ENOMEM;
-		dev_err(&akm->this_client->dev,
-			"input device allocate failed\n");
-		goto exit_input_dev_alloc_failed;
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: Failed to allocate input device\n");
+		goto exit5;
 	}
-
+	/* Setup input device */
 	set_bit(EV_ABS, akm->input_dev->evbit);
-
-	/* yaw */
+	/* yaw (0, 360) */
 	input_set_abs_params(akm->input_dev, ABS_RX, 0, 23040, 0, 0);
-	/* pitch */
+	/* pitch (-180, 180) */
 	input_set_abs_params(akm->input_dev, ABS_RY, -11520, 11520, 0, 0);
-	/* roll */
+	/* roll (-90, 90) */
 	input_set_abs_params(akm->input_dev, ABS_RZ, -5760, 5760, 0, 0);
-	/* x-axis acceleration */
+	/* x-axis acceleration (720 x 8G) */
 	input_set_abs_params(akm->input_dev, ABS_X, -5760, 5760, 0, 0);
-	/* y-axis acceleration */
+	/* y-axis acceleration (720 x 8G) */
 	input_set_abs_params(akm->input_dev, ABS_Y, -5760, 5760, 0, 0);
-	/* z-axis acceleration */
+	/* z-axis acceleration (720 x 8G) */
 	input_set_abs_params(akm->input_dev, ABS_Z, -5760, 5760, 0, 0);
 	/* temparature */
+	/*
 	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	 */
 	/* status of magnetic sensor */
-	input_set_abs_params(akm->input_dev, ABS_RUDDER, 0, 3, 0, 0);
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
 	/* status of acceleration sensor */
-	input_set_abs_params(akm->input_dev, ABS_WHEEL, 0, 3, 0, 0);
-	/* x-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
+	/* x-axis of raw magnetic vector (-4096, 4095) */
 	input_set_abs_params(akm->input_dev, ABS_HAT0X, -20480, 20479, 0, 0);
-	/* y-axis of raw magnetic vector */
+	/* y-axis of raw magnetic vector (-4096, 4095) */
 	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -20480, 20479, 0, 0);
-	/* z-axis of raw magnetic vector */
+	/* z-axis of raw magnetic vector (-4096, 4095) */
 	input_set_abs_params(akm->input_dev, ABS_BRAKE, -20480, 20479, 0, 0);
-
+	/* Set name */
 	akm->input_dev->name = "compass";
-
+	
+	/* Register */
 	err = input_register_device(akm->input_dev);
 	if (err) {
-		pr_err("akm8975_probe: Unable to register input device: %s\n",
-					 akm->input_dev->name);
-		goto exit_input_register_device_failed;
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: Unable to register input device\n");
+		goto exit6;
 	}
-
+	
 	err = misc_register(&akmd_device);
 	if (err) {
-		pr_err("akm8975_probe: akmd_device register failed\n");
-		goto exit_misc_device_register_failed;
+		printk(KERN_ERR
+			   "AKM8975 akm8975_probe: akmd_device register failed\n");
+		goto exit7;
 	}
-
+	
 	err = misc_register(&akm_aot_device);
 	if (err) {
-		pr_err("akm8975_probe: akm_aot_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-
-	err = device_create_file(&client->dev, &dev_attr_akm_ms1);
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	akm->early_suspend.suspend = akm8975_early_suspend;
-	akm->early_suspend.resume = akm8975_early_resume;
-	register_early_suspend(&akm->early_suspend);
-#endif
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: akm_aot_device register failed\n");
+		goto exit8;
+	}
+	
+	mutex_init(&sense_data_mutex);
+	
+	init_waitqueue_head(&data_ready_wq);
+	init_waitqueue_head(&open_wq);
+	
+	/* As default, report all information */
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&mv_flag, 1);
+	
+	akm->akm_early_suspend.suspend = akm8975_early_suspend;
+	akm->akm_early_suspend.resume = akm8975_early_resume;
+	register_early_suspend(&akm->akm_early_suspend);
+	
+	AKMDBG("successfully probed.");
 	return 0;
-
-exit_misc_device_register_failed:
-exit_input_register_device_failed:
+	
+exit8:
+	misc_deregister(&akmd_device);
+exit7:
+	input_unregister_device(akm->input_dev);
+exit6:
 	input_free_device(akm->input_dev);
-exit_input_dev_alloc_failed:
-	akm8975_power_off(akm);
-exit_power_on_failed:
+exit5:
+	free_irq(client->irq, akm);
+exit4:
+exit3:
+exit2:
 	kfree(akm);
-exit_alloc_data_failed:
-exit_check_functionality_failed:
-exit_platform_data_null:
+exit1:
+exit0:
 	return err;
+	
 }
 
-static int __devexit akm8975_remove(struct i2c_client *client)
+static int akm8975_remove(struct i2c_client *client)
 {
 	struct akm8975_data *akm = i2c_get_clientdata(client);
-	FUNCDBG("called");
-	free_irq(client->irq, NULL);
-	input_unregister_device(akm->input_dev);
-	misc_deregister(&akmd_device);
+	AKMFUNC("akm8975_remove");
+	unregister_early_suspend(&akm->akm_early_suspend);
 	misc_deregister(&akm_aot_device);
-	akm8975_power_off(akm);
+	misc_deregister(&akmd_device);
+	input_unregister_device(akm->input_dev);
+	free_irq(client->irq, akm);
 	kfree(akm);
+	AKMDBG("successfully removed.");
 	return 0;
 }
 
 static const struct i2c_device_id akm8975_id[] = {
-	{ "akm8975", 0 },
+	{AKM8975_I2C_NAME, 0 },
 	{ }
 };
 
-MODULE_DEVICE_TABLE(i2c, akm8975_id);
-
 static struct i2c_driver akm8975_driver = {
-	.probe = akm8975_probe,
-	.remove = akm8975_remove,
-#ifndef CONFIG_HAS_EARLYSUSPEND
-	.resume = akm8975_resume,
-	.suspend = akm8975_suspend,
-#endif
-	.id_table = akm8975_id,
+	.probe		= akm8975_probe,
+	.remove 	= akm8975_remove,
+	.id_table	= akm8975_id,
 	.driver = {
-		.name = "akm8975",
+		.name = AKM8975_I2C_NAME,
 	},
 };
 
 static int __init akm8975_init(void)
 {
-	pr_info("AK8975 compass driver: init\n");
-	FUNCDBG("AK8975 compass driver: init\n");
+	printk(KERN_INFO "AKM8975 compass driver: initialize\n");
 	return i2c_add_driver(&akm8975_driver);
 }
 
 static void __exit akm8975_exit(void)
 {
-	FUNCDBG("AK8975 compass driver: exit\n");
+	printk(KERN_INFO "AKM8975 compass driver: release\n");
 	i2c_del_driver(&akm8975_driver);
 }
 
 module_init(akm8975_init);
 module_exit(akm8975_exit);
 
-MODULE_AUTHOR("Hou-Kun Chen <hk_chen@htc.com>");
-MODULE_DESCRIPTION("AK8975 compass driver");
+MODULE_AUTHOR("viral wang <viral_wang@htc.com>");
+MODULE_DESCRIPTION("AKM8975 compass driver");
 MODULE_LICENSE("GPL");
+
Index: android-2.6.35/drivers/sensors/gyro-mpu3050/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/gyro-mpu3050/Kconfig	2010-12-22 14:36:09.813238964 +0530
@@ -0,0 +1,16 @@
+#
+# MPU3050 Gyroscope Sensor Configuration
+#
+
+config GYRO
+	bool "Gyroscope Sensor"
+	default y
+	help
+	  This option enables gyroscope sensors
+
+config GYRO_MPU3050
+	depends on GYRO
+	tristate "MPU3050 gyroscope driver"
+	default y
+	help
+	  This option enables gyroscope sensors using MPU3050 driver.
Index: android-2.6.35/drivers/sensors/gyro-mpu3050/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/gyro-mpu3050/Makefile	2010-12-22 14:36:09.813238964 +0530
@@ -0,0 +1,9 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# AUTHOR	: Throughc
+##############################################################################
+# VERSION&DATE	: Version 1.00	2007/12/25 (Throughc)
+##############################################################################
+
+obj-$(CONFIG_GYRO)	+= mpu3050.o
+
Index: android-2.6.35/drivers/sensors/gyro-mpu3050/mpu3050.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/gyro-mpu3050/mpu3050.c	2010-12-22 14:36:31.023862479 +0530
@@ -0,0 +1,544 @@
+#include<asm/uaccess.h>
+#include<asm/mach-types.h>
+#include<linux/module.h>
+#include<linux/init.h>
+#include<linux/input.h>
+#include<linux/i2c.h>
+#include<linux/hrtimer.h>
+#include<linux/delay.h>
+#include<linux/workqueue.h>
+#include <linux/slab.h>
+
+#include "mpu3050.h"
+
+#define MODULE_NAME "mpu3050"
+
+static struct i2c_client* mpu3050_client;
+struct mpu3050_dev *mpu3050_dev;
+struct class *gyro_class;
+
+struct input_dev *gyro_input;
+
+static struct workqueue_struct *mpu3050_work_q;
+static struct delayed_work mpu3050_delayed_work_q;
+
+int mpu3050_timeout = -1;
+
+int mpu3050_i2c_read( u8 reg, u8 *rdata , int length) //Read from register "reg", in buffer "rdata","length" number of bytes
+{
+	int count =0;
+	int ret =0;
+	struct i2c_msg msg[2];
+
+	msg[0].addr = mpu3050_client->addr;
+	msg[0].flags=0;
+	msg[0].len=1;
+	msg[0].buf=&reg;
+
+	count = i2c_transfer(mpu3050_client->adapter, msg, 1);
+	
+	if(count==1)
+	{
+		msg[0].addr=mpu3050_client->addr;
+		msg[0].flags=I2C_M_RD;
+		msg[0].len=length;
+		msg[0].buf=rdata;
+		count = i2c_transfer(mpu3050_client->adapter, msg, 1);
+
+		if(count != 1)
+		{
+			ret = -1;
+		}
+	}
+	else
+	{
+		ret=-1;
+	}
+
+	return ret;
+#if 0
+	int ret;
+	char outbuffer[2] = { 0, 0 };
+
+	outbuffer[0] = reg;
+
+	ret = i2c_master_send(mpu3050_client, outbuffer, 1);
+	if (ret < 0) {
+		printk(KERN_WARNING "%s: error asking for gsensor data at "
+			"address %02x,%02x: %d\n",
+			__func__, mpu3050_client->addr, reg, ret);
+		return ret;
+	}
+
+	mdelay(1);
+
+	ret = i2c_master_recv(mpu3050_client, rdata, length);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: error reading gsensor data at ""address %02x,%02x: %d\n", __func__, mpu3050_client->addr, reg, ret);
+		return ret;
+	}
+	return 0;
+#endif
+}
+	
+int mpu3050_i2c_write(u8 reg, u8 value)
+{
+	u8 data[2];
+	int ret =0, count=0;
+	struct i2c_msg msg[1];
+
+	data[0]=reg;
+	data[1]=value;
+
+	msg[0].addr = mpu3050_client->addr;
+	msg[0].flags=0;
+	msg[0].len=2;
+	msg[0].buf=data;
+
+	count = i2c_transfer(mpu3050_client->adapter, msg, 1);
+	if(count !=1)
+	{
+		ret = -1;
+	}
+
+	return ret;
+}
+
+//TODO
+static int mpu3050_open(struct inode *inode,struct file *filep)
+{
+return 0;
+}
+
+
+//TODO
+static int mpu3050_release(struct inode *inode, struct file *filep)
+{
+return 0;
+}
+
+
+//TODO
+static int mpu3050_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+return 0;
+}
+
+//TODO
+static int mpu3050_write (struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+{
+	return 0;
+}
+
+static int mpu3050_set_operation_mode(u8 mode)
+{
+	int ret=0;
+
+	//Power-OFF
+	if( mode == 0 )
+	{
+		if ( (ret = mpu3050_i2c_write( MPU3050_PWR_MGMNT, GYRO_MODE_STANDBY )) < 0 )
+		{
+			ret = -EFAULT;
+			printk("Error in mpu3050_set_operation_mode: MPU3050_PWR_MGMNT\n");
+		}
+	}
+
+	//Power-ON
+	else if ( mode == 1 )
+	{
+		if ( (ret = mpu3050_i2c_write( MPU3050_PWR_MGMNT, GYRO_MODE_ALL_ON )) < 0 )
+		{
+			ret = -EFAULT;
+			printk("Error in mpu3050_set_operation_mode: MPU3050_PWR_MGMNT\n");
+		}
+
+		#if 0
+		if( (ret = mpu3050_i2c_write( MPU3050_USER_CTRL, 0x01 )) < 0 )
+		{
+			ret = -EFAULT;
+			printk("Error in mpu3050_set_operation_mode: MPU3050_USER_CTRL\n");
+		}
+		#endif
+
+		if( (ret = mpu3050_i2c_write( MPU3050_DLPF_FS_SYNC, GYRO_RANGE_2000 )) < 0 )
+		{
+			ret = -EFAULT;
+			printk("Error in mpu3050_set_operation_mode: MPU3050_DLPF_FS_SYNC\n");
+		}
+	}
+
+	return ret;
+}
+
+static int mpu3050_read_gyro_xyz(u16 *gyro_data_16)
+{
+
+	//printk("mpu3050_read_gyro_xyz called\n");
+
+	int ret = -1;
+	u8 gyro_data[6];
+
+	ret = mpu3050_i2c_read( MPU3050_GYRO_XOUT_H, gyro_data, 6 );
+	if( ret < 0)
+	{
+		printk("mpu3050_i2c_read failed!!!!\n\n");
+	}
+	else
+	{
+		gyro_data_16[0]= (gyro_data[0] * 256) + gyro_data[1];
+		gyro_data_16[1]= (gyro_data[2] * 256) + gyro_data[3];
+		gyro_data_16[2]= (gyro_data[4] * 256) + gyro_data[5];
+
+		#ifdef MPU3050_DEBUG
+		printk("XH=%x XL=%x\nYH=%x YL=%x\nZH=%x ZL=%x\n\n",gyro_data[0], gyro_data[1], gyro_data[2], gyro_data[3], gyro_data[4], gyro_data[5]);
+		printk("gyrodata X=%d Y=%d Z=%d \n\n\n\n",gyro_data_16[0], gyro_data_16[1], gyro_data_16[2]);
+		#endif
+	}
+
+	return ret;
+}
+
+static int mpu3050_set_interrupt_config(u8 interrupt_mode)
+{
+	u8 interrupt = 0;
+	int ret=0;
+	interrupt |= (1<<interrupt_mode);
+	ret = mpu3050_i2c_write(MPU3050_INT_CFG, interrupt);
+	if(ret < 0)
+	{
+		printk("Error in Interrupt Configuration");
+		ret = -EFAULT;
+	}
+	return (ret);
+}
+
+static int mpu3050_get_interrupt_config(u8 * interrupt_config)
+{
+	int ret =0;
+	ret = mpu3050_i2c_read( MPU3050_INT_CFG, interrupt_config, 1);
+
+	return (ret);
+}
+
+
+static int mpu3050_work(void)
+{
+	//printk("mpu3050_work called\n");
+	u16 gyro_values[3];
+	int ret =0;
+
+	ret = mpu3050_read_gyro_xyz(gyro_values);
+
+	if(ret < 0)
+	{
+		printk("mpu3050_read_gyro_xyz FAILED\n");
+		return (-1);
+	}
+
+	input_report_rel(gyro_input, REL_X, gyro_values[0] );
+	input_report_rel(gyro_input, REL_Y, gyro_values[1] );
+	input_report_rel(gyro_input, REL_Z, gyro_values[2] );
+	input_sync(gyro_input);
+
+	if(mpu3050_timeout > -1)
+	{
+		queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
+	}
+
+	return 0;
+}
+
+
+static int mpu3050_ioctl( struct inode *inode, struct file *filp, unsigned int ioctl_cmd, unsigned long arg )
+{
+	int ret =0;
+	void __user *argp = (void __user*)arg;
+	
+	u16 gyro_xyz[3];
+	
+	if(_IOC_TYPE(ioctl_cmd) != MPU3050_GYRO_IOC_MAGIC)
+	{
+		printk("mpu3050 cmd magic type error\n");
+		return -ENOTTY;
+	}
+
+	if(_IOC_NR(ioctl_cmd)>MPU3050_GYRO_IOC_MAXNR)
+	{
+		printk("mpu3050 cmd number error\n");
+		return -ENOTTY;
+	}
+
+	switch(ioctl_cmd)
+	{
+
+		case MPU3050_GYRO_IOC_GET_OPERATION_MODE:
+		{
+			// u8 mode;
+			// if(ret = mpu3050_get_operation_mode(&mode) < 0)
+			//	//debug message
+			// else if(copy_to_user(argp,(void *)&mode,sizeof(u8)))
+			//	return (-EFAULT);
+			//
+			printk("[mpu3050] get_operation_mode called\n");
+			return(0);
+		}
+
+		case MPU3050_GYRO_IOC_SET_OPERATION_MODE:
+		{		
+			unsigned char mode = 0;
+			if(copy_from_user( &mode, argp, sizeof(mode)))
+			{
+				printk(KERN_ERR"Copy_from_user failed\n");
+				return (-EFAULT);
+			}
+			printk("\n\nmpu3050 mode==%x\n\n",mode);
+		
+			// Power-OFF mode
+			if( mode == GYRO_POWER_OFF)
+			{
+				printk("Gyro[mpu3050] Power-OFF\n");
+				mpu3050_timeout = -1;
+				flush_workqueue(mpu3050_work_q);
+				ret = mpu3050_set_operation_mode(mode);
+			}
+			// Power-ON mode;
+			// delay need to be set and work need to be done
+			else if ( mode == GYRO_POWER_ON)
+			{
+				ret = mpu3050_set_operation_mode(mode);
+				printk("Gyro[mpu3050] Power-ON\n");
+				mpu3050_timeout = msecs_to_jiffies(200);
+				queue_delayed_work(mpu3050_work_q, &mpu3050_delayed_work_q, mpu3050_timeout);
+			}
+
+			if( ret < 0 )
+			{
+				printk("mpu3050: set_operation_mode Failed\n");
+				return (-EFAULT);			
+			}
+
+			return(0);
+		}
+
+
+		case MPU3050_GYRO_IOC_SET_POLL_DELAY:
+		{
+			u32 delay;
+
+			if(copy_from_user(&delay, argp, sizeof(delay) ))
+			{
+				printk("mpu3050: copy_from_user failed\n");
+				return (-EFAULT);
+			}
+
+			else
+			{
+				mpu3050_timeout = msecs_to_jiffies(delay);
+				printk("mpu3050 polling delay=%d\n", mpu3050_timeout);
+			}
+
+			return(0);
+		}
+
+
+		default:
+		{
+			printk(KERN_ERR"mpu3050: UNKNOWN IOCTL\n");
+			return (-ENOTTY);
+		}
+	}
+}
+
+
+struct file_operations mpu_fops =
+{
+	.owner   = THIS_MODULE,
+	.read    = mpu3050_read,
+	.write   = mpu3050_write,
+	.open    = mpu3050_open,
+	.ioctl   = mpu3050_ioctl,
+	.release = mpu3050_release,
+};
+
+static int mpu3050_probe(struct i2c_client *client,const struct i2c_device_id *id )
+{
+	int ret = 0;
+	int result_gyro=-1;
+	u16 gyro_xyz[3];
+
+	struct device *dev_gyro;
+	mpu3050_client = client;
+	
+	//Allocate Gyro-device
+	mpu3050_dev = kzalloc(sizeof *mpu3050_dev, GFP_KERNEL);
+	if(mpu3050_dev < 0)
+	{
+		printk("[MPU-3050]:Not enough memory while allocating Device\n");
+		return -ENOMEM;
+	}
+
+	//Initialize lock;
+	mutex_init(&mpu3050_dev->lock);
+	mpu3050_dev->client = client;
+	i2c_set_clientdata(client, mpu3050_dev);
+	mpu3050_client = client;
+	
+	#ifdef MPU3050_DEBUG
+		printk(KERN_INFO MODULE_NAME"Registering [MPU-3050] Gyro-Driver at address:%d",mpu3050_client->addr);
+		printk("--------%s %d\n",__func__,__LINE__);
+	#endif
+	
+	//Register char-driver
+	result_gyro = register_chrdev ( (int)NULL, GYRO_DEV_NAME, &mpu_fops);
+
+	if(result_gyro <0)
+	{
+		printk(KERN_ERR "Error while registering[MPU-3050] the char-device\n");
+		return result_gyro;
+	}
+
+
+	gyro_class = class_create(THIS_MODULE,GYRO_DEV_NAME);
+	if(IS_ERR(gyro_class))
+		{
+			printk(KERN_ERR"Error while[MPU-3050] Creating the gyro_class\n");
+			unregister_chrdev(result_gyro,GYRO_DEV_NAME);
+			return PTR_ERR(gyro_class);
+		}
+
+	dev_gyro = device_create(gyro_class, NULL, MKDEV(result_gyro ,0),"%s",GYRO_DEV_NAME);
+
+	if(IS_ERR(dev_gyro))
+	{
+		printk(KERN_ERR "Error while[MPU-3050] Creating the dev_gyro\n");
+		return PTR_ERR(dev_gyro);
+	}
+	
+
+	//Register input device
+	gyro_input = input_allocate_device();
+
+	if(NULL == gyro_input)
+	{
+		printk(KERN_ERR"\n[MPU3050-GYROSENSOR] Error while allocating input device");
+		return -EIO;
+	}
+
+	mpu3050_dev->inputdev=gyro_input;
+	set_bit(EV_REL, gyro_input->evbit);
+	set_bit(REL_X, gyro_input->relbit);
+	set_bit(REL_Y, gyro_input->relbit);
+	set_bit(REL_Z, gyro_input->relbit);
+	
+	gyro_input->name="mpu3050_gyro";
+	gyro_input->dev.parent = &mpu3050_client->dev;
+
+	ret = input_register_device(gyro_input);
+	if(ret)
+	{
+		printk("mpu3050 Gyro Sensor couldn't be registered:%d\n",ret);
+		goto release_input_dev;
+	}	
+
+
+	//Workqueue Initialisation
+	mpu3050_work_q = create_singlethread_workqueue("gyro_sensor_mpu3050_work_queue");
+	INIT_DELAYED_WORK( (struct delayed_work *)&mpu3050_delayed_work_q, mpu3050_work);
+
+
+	#ifdef MPU3050_DEBUG
+	// Initializing the device;
+	// MPU-3050 is being used as gyrosensor only (i.e. in pass-thru mode)
+	if((ret = mpu3050_set_operation_mode(GYRO_POWER_ON))<0)
+	{
+		printk("mpu3050_set_operation_mode failed");
+		ret = -EFAULT;
+	}
+		msleep(1000);
+		mpu3050_read_gyro_xyz(gyro_xyz);
+		printk("mpu3050\n x=%hi y=%hi z=%hi\n", gyro_xyz[0], gyro_xyz[1], gyro_xyz[2]);
+	#endif
+
+release_input_dev:
+	input_free_device(gyro_input);
+	return ret;
+}
+static int  mpu3050_remove(struct i2c_client *client)
+{
+	struct mpu3050_dev *mpu3050 = i2c_get_clientdata(client);
+
+	input_unregister_device(mpu3050->inputdev);
+	input_free_device(mpu3050->inputdev);
+	kfree(mpu3050);
+
+	return 0;
+}
+
+#if CONFIG_PM
+static int mpu3050_suspend(struct i2c_client * client, pm_message_t mesg)
+{
+	#ifdef MPU3050_DEBUG
+	printk(KERN_INFO MODULE_NAME ": suspending device...\n");
+	#endif
+	return 0;
+}
+
+static int mpu3050_resume(struct i2c_client * client)
+{
+	#ifdef MPU3050_DEBUG
+	printk(KERN_INFO MODULE_NAME ": resuming device...\n");
+	#endif
+	return 0;
+}
+#else
+
+#define mpu3050_suspend NULL
+#define mpu3050_resume NULL
+
+#endif
+
+static const struct i2c_device_id mpu3050_ids[] = {	
+        { MODULE_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mpu3050_ids);
+
+static struct i2c_driver mpu3050_driver = {
+	.driver = {
+		.name	= MODULE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = mpu3050_ids,
+	.probe = mpu3050_probe,
+	.remove = mpu3050_remove,
+#if CONFIG_PM
+	.suspend = mpu3050_suspend,
+	.resume = mpu3050_resume,
+#endif
+};
+
+
+static int __init mpu3050_init(void)
+{
+	#ifdef MPU3050_DEBUG
+	printk(KERN_INFO MODULE_NAME ": Registering MPU-3050 driver\n");
+	#endif
+	return i2c_add_driver(&mpu3050_driver);
+}
+
+static void __exit mpu3050_exit(void)
+{
+	#ifdef MPU3050_DEBUG
+	printk(KERN_INFO MODULE_NAME ": Unregistered MPU-3050 driver\n");
+	#endif
+	i2c_del_driver(&mpu3050_driver);
+}
+
+module_init(mpu3050_init);
+module_exit(mpu3050_exit);
+
+MODULE_AUTHOR("Dharam Kumar");
+MODULE_DESCRIPTION("MPU-3050 Driver");
+MODULE_LICENSE("GPL");
+
Index: android-2.6.35/drivers/sensors/gyro-mpu3050/mpu3050.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/gyro-mpu3050/mpu3050.h	2010-12-22 14:36:31.013862815 +0530
@@ -0,0 +1,183 @@
+#ifndef __MPU3050_H__
+#define __MPU3050_H__
+
+#if 0
+#define MPU3050_DEBUG	1
+#endif
+
+/*Debug Related Macros */
+#define error(fmt,arg...) printk(fmt "\n",## arg)
+
+#ifdef MPU3050_DEBUG
+#define debug(fmt,arg...) printk("--------" fmt "\n",## arg)
+#else
+#define debug(fmt,arg...)
+#endif
+
+//#define GYRO_DEV_MAJOR 238
+#define GYRO_DEV_NAME "gyroscope"
+
+/* MPU3050 IOCTLs....*/
+#define MPU3050_GYRO_IOC_MAGIC 				'M'
+
+#define MPU3050_GYRO_IOC_READ_GYRO_XYZ		        _IOR(MPU3050_GYRO_IOC_MAGIC,0,u32)
+#define MPU3050_GYRO_IOC_READ_ACCEL_XYZ			_IOR(MPU3050_GYRO_IOC_MAGIC,1,u32)
+#define MPU3050_GYRO_IOC_READ_TEMP			_IOR(MPU3050_GYRO_IOC_MAGIC,2,u32)
+#define MPU3050_GYRO_IOC_SET_POLL_DELAY			_IOW(MPU3050_GYRO_IOC_MAGIC,3,u32)
+
+#define MPU3050_GYRO_IOC_GET_OFFSETS			_IOR(MPU3050_GYRO_IOC_MAGIC,4,u32)
+#define MPU3050_GYRO_IOC_SET_OFFSETS			_IOW(MPU3050_GYRO_IOC_MAGIC,5,u32)
+
+#define MPU3050_GYRO_IOC_GET_OPERATION_MODE		_IOR(MPU3050_GYRO_IOC_MAGIC,6,u8)
+#define MPU3050_GYRO_IOC_SET_OPERATION_MODE		_IOW(MPU3050_GYRO_IOC_MAGIC,7,u8)
+
+#define MPU3050_GYRO_IOC_GET_INTERRUPT_CONFIG		_IOR(MPU3050_GYRO_IOC_MAGIC,8,u8)
+#define MPU3050_GYRO_IOC_SET_INTERRUPT_CONFIG		_IOW(MPU3050_GYRO_IOC_MAGIC,9,u8)
+
+
+#define MPU3050_GYRO_IOC_MAXNR				10
+
+
+#if 0
+//Different Modes in which the driver could work.
+#define GYRO_POWER_DOWN 0
+#define GYRO_MASTER_ACCEL 1
+#define GYRO_ONLY 2
+#define GYRO_MASTER_ACCEL_FIFO 3
+#define GYRO_ONLY_FIFO	4
+#endif
+
+// Mode numbers for different IOCTLs
+#define GYRO_POWER_OFF	0
+#define GYRO_POWER_ON	1
+
+// MPU3050_USER_CTRL Register values for different modes
+#define GYRO_MODE_STANDBY	0x78
+#define GYRO_MODE_ALL_ON	0x00
+
+struct mpu3050_dev_state
+{
+u8 mode;
+u16 gyro_xyz[3];
+u16 accel_xyz[3];
+u16 temperature;
+u16 offsets[3];
+};
+
+struct mpu3050_dev
+{
+struct i2c_client *client;
+struct input_dev *inputdev;
+struct mutex lock;
+struct mpu3050_dev_state state;
+};
+
+// MPU-3050 details
+#define MPU3050_WHO_AM_I	0x00
+#define MPU3050_PRODUCT_ID	0X01
+
+// Register for Offsets
+#define MPU3050_XOFFS_USER_H 	0X0C
+#define MPU3050_XOFFS_USER_L 	0X0D
+#define MPU3050_YOFFS_USER_H 	0X0E
+#define MPU3050_YOFFS_USER_L 	0X0F
+#define MPU3050_ZOFFS_USER_H 	0X10
+#define MPU3050_ZOFFS_USER_L 	0X11
+
+// Registers for miscellanous configurations.
+#define MPU3050_FIFO_EN		0X12
+#define MPU3050_AUX_VDDIO	0X13
+#define MPU3050_AUX_SLV_ADDR	0X14
+#define MPU3050_SMPALRT_DIV	0X15
+#define MPU3050_DLPF_FS_SYNC	0X16
+#define MPU3050_INT_CFG		0X17
+#define MPU3050_AUX_ADDR	0X18
+#define MPU3050_INT_STATUS	0X1A
+
+// Registers for Temperature; X,Y and Z gyro values
+#define MPU3050_TEMP_OUT_H 	0X1B
+#define MPU3050_TEMP_OUT_L 	0X1C
+#define MPU3050_GYRO_XOUT_H	0X1D
+#define MPU3050_GYRO_XOUT_L	0X1E
+#define MPU3050_GYRO_YOUT_H	0X1F
+#define MPU3050_GYRO_YOUT_L	0X20
+#define MPU3050_GYRO_ZOUT_H	0X21
+#define MPU3050_GYRO_ZOUT_L 	0X22
+#define MPU3050_AUX_XOUT_H	0X23
+#define MPU3050_AUX_XOUT_L	0X24
+#define MPU3050_AUX_YOUT_H	0X25
+#define MPU3050_AUX_YOUT_L	0X26
+#define MPU3050_AUX_ZOUT_H	0X27
+#define MPU3050_AUX_ZOUT_L	0X28
+
+// Register for count of bytes occupied in FIFO Buffer(max =512)
+#define MPU3050_FIFO_COUNTH	0X3A
+#define MPU3050_FIFO_COUNTL	0X3B
+
+// Register for FIFO-Buffer Read.
+#define MPU3050_FIFO_R		0X3C
+
+// Register for User Options
+#define MPU3050_USER_CTRL	0X3D
+
+// Register for Power-Management options.
+#define MPU3050_PWR_MGMNT	0X3E
+
+
+// Sampling Rate.Default value = 8kHz
+#define DEFAULT_SMPLRTDIVIDER	0x00 		// Using Formula : 8kHz/(1)= 8kHz
+#define DFLT_SMPL_CFG		0x00 		// 256Hz low pass sample filter
+
+// All 4 modes assign DLPF_CFG so as to set 8kHz sampling-rate & LPF of 256Hz
+// EXT_SYNC_SET ignored for time-being 
+#define GYRO_RANGE_250 		0x00
+#define GYRO_RANGE_500 		0x08
+#define GYRO_RANGE_1000		0x10	
+#define GYRO_RANGE_2000		0x18
+
+// Operations for User control; For register MPU3050_USER_CTRL
+#define ENABLE_FIFO_READ	(1 << 6)
+#define ENABLE_ACCEL_READ	(1 << 5)
+#define RESET_GYRO_FUNC		(1 << 0)
+#define RESET_FIFO_FUNC		(1 << 1)
+#define RESET_ACCEL_FUNC	(1 << 3)
+
+// Power_control Operations; For Register: MPU3050_PWR_MGM
+#define SLEEP			(1 << 6)
+#define	H_RESET			(1 << 7)
+#define STDBY_GYROX		(1 << 5)
+#define STDBY_GYROY		(1 << 4)
+#define STDBY_GYROZ		(1 << 3)
+
+#define CLOCK_INTERNAL_OSCILLATOR 	0
+#define CLOCK_EXT_32KHZ			(1 << 0)
+#define CLOCK_EXT_19KHZ			(1 << 1)
+#define CLOCK_RESET			((1 << 2)|(1 << 1)|(1 << 0))
+
+
+
+// Interrupt-Related Operations..
+// when will be the interrupts enabled.
+// Need to initialize interrupt configuration.
+#define INTERRUPT_WHEN_DATA 		0
+#define INTERRUPT_WHEN_DMP		1
+#define INTERRUPT_WHEN_MPU_READY 	2
+
+
+// If FIFO_READ is enabled;we need to specify what values will go
+// in Buffer. Register : MPU3050_FIFO_EN
+#define FIFO_TEMP_ENABLE	(1<<7)
+#define FIFO_GYROX_ENABLE	(1<<6)
+#define FIFO_GYROY_ENABLE	(1<<5)
+#define FIFO_GYROZ_ENABLE	(1<<4)
+#define FIFO_ACCELX_ENABLE	(1<<3)
+#define FIFO_ACCELY_ENABLE	(1<<2)
+#define FIFO_ACCELZ_ENABLE	(1<<1)
+#define FIFO_FOOTER_ENABLE	(1<<0)
+
+#define DEFAULT_FIFO (FIFO_GYROX_ENABLE)|FIFO_GYROY_ENABLE|FIFO_GYROZ_ENABLE|FIFO_ACCELX_ENABLE \
+						|FIFO_ACCELY_ENABLE|FIFO_ACCELZ_ENABLE|FIFO_FOOTER_ENABLE
+
+
+
+#endif
Index: android-2.6.35/drivers/sensors/optical/Kconfig
===================================================================
--- android-2.6.35.orig/drivers/sensors/optical/Kconfig	2010-12-22 14:36:03.913238838 +0530
+++ android-2.6.35/drivers/sensors/optical/Kconfig	2010-12-22 14:36:09.823238303 +0530
@@ -11,7 +11,13 @@
 config OPTICAL_ISL29023
 	depends on OPTICAL
 	tristate "Ambient Light Sensor driver"
-	default y
+	default n
 	help
 	  This option enables light sensors using isl29023.
 
+config OPTICAL_GP2A
+        depends on OPTICAL
+        tristate "Proximity/Ambient Light Sensor Driver"
+        default n 
+        help
+         This Option enbales  proximity/light sensor using gp2a.
Index: android-2.6.35/drivers/sensors/optical/Makefile
===================================================================
--- android-2.6.35.orig/drivers/sensors/optical/Makefile	2010-12-22 14:36:03.913238838 +0530
+++ android-2.6.35/drivers/sensors/optical/Makefile	2010-12-22 14:36:09.823238303 +0530
@@ -9,3 +9,4 @@
 				  isl29023_i2c.o \
 				  isl29023.o
 
+obj-$(CONFIG_OPTICAL_GP2A) += gp2a.o
Index: android-2.6.35/drivers/sensors/optical/gp2a.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ android-2.6.35/drivers/sensors/optical/gp2a.c	2010-12-22 14:36:31.033862657 +0530
@@ -0,0 +1,625 @@
+#include<asm/uaccess.h>
+#include<asm/mach-types.h>
+#include<linux/module.h>
+#include<linux/init.h>
+#include<linux/input.h>
+#include<linux/i2c.h>
+#include<linux/hrtimer.h>
+#include<linux/delay.h>
+#include<linux/workqueue.h>
+#include <linux/slab.h>
+#include<linux/gpio.h>
+#include <linux/i2c/twl6030-gpadc.h>
+
+#define MODULE_NAME "gp2a"
+
+#if 0
+#define GP2A_DEBUG
+#endif
+
+//Register-Addresses.
+#define REG_PROX	0x00
+#define REG_GAIN	0x01
+#define	REG_HYS		0x02
+#define REG_CYCLE	0x03
+#define REG_OPMOD	0x04
+#define REG_CON		0x06
+
+#define LIGHT_DEV_NAME "lightsensor"
+
+//Different Modes
+#define POWER_UP 			0
+#define POWER_DOWN 			1
+#define NORMAL_MODE 			2
+#define INTERRUPT_MODE 			3
+
+#define GP2A_LIGHT_IOC_MAGIC 				221
+#define GP2A_LIGHT_IOC_MAGIC_NR_MAX 			4
+
+#define GP2A_LIGHT_IOC_SET_OPERATION_MODE         		_IOW(GP2A_LIGHT_IOC_MAGIC, 0,u8)
+#define GP2A_LIGHT_IOC_GET_OPERATION_MODE         		_IOR(GP2A_LIGHT_IOC_MAGIC, 1,u8)
+#define GP2A_LIGHT_IOC_GET_LUX_VALUE				_IOR(GP2A_LIGHT_IOC_MAGIC,2,u8)
+#define GP2A_LIGHT_IOC_SET_POLL_DELAY				_IOW(GP2A_LIGHT_IOC_MAGIC,3,u16)
+
+
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
+#define OMAP4TAB_PS_ON_GPIO                            35
+static unsigned gp2a_ps_on_gpio;
+#endif
+
+struct gp2a_dev
+{
+struct i2c_client *client;
+struct input_dev *inputdev;
+struct mutex lock;
+};
+
+static struct twl6030_gpadc_request conv_request = {
+        .channels = (0x1 << 3),
+        .do_avg = 0,
+	.method = TWL6030_GPADC_SW2,
+	.type = 0,
+	.active = 0,
+	.result_pending = 0,
+	.func_cb = NULL,
+
+};
+
+static struct i2c_client* gp2a_client;
+struct gp2a_dev *gp2a_dev;
+struct class *light_class;
+
+struct input_dev *light_input;
+
+static struct workqueue_struct *gp2a_work_q;
+static struct delayed_work gp2a_delayed_work_q;
+
+int gp2a_timeout = -1;
+static int gp2a_initialize_register(u8 mode);
+
+// GP2A has different i2c_read.
+// The register address and the buffer (in which data is to be read)
+// must go in one single "i2c_transfer"
+int gp2a_i2c_read( u8 reg, u8 *rdata) //Read from register "reg", in buffer "rdata"
+{
+	int count =0;
+	int ret =0;
+	struct i2c_msg msg[1];
+	u8 data[2]={0,0};
+	data[0]=reg;
+	
+	msg[0].addr = gp2a_client->addr;
+	msg[0].flags=I2C_M_RD;
+	msg[0].len=2;
+	msg[0].buf=data;
+	
+	count = i2c_transfer(gp2a_client->adapter, msg, 1);
+	*rdata=data[1];
+	#ifdef GP2A_DEBUG
+	printk("Count in gp2a_i2c_read:%d\n",count);
+	#endif
+
+	if(count !=1)
+		ret= -1;
+	return ret;
+#if 0
+	int ret;
+	char outbuffer[2] = { 0, 0 };
+
+	outbuffer[0] = reg;
+
+	ret = i2c_master_send(gp2a_client, outbuffer, 1);
+	if (ret < 0) {
+		printk(KERN_WARNING "%s: error asking for gsensor data at "
+			"address %02x,%02x: %d\n",
+			__func__, gp2a_client->addr, reg, ret);
+		return ret;
+	}
+
+	mdelay(1);
+
+	ret = i2c_master_recv(gp2a_client, rdata, length);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: error reading gsensor data at ""address %02x,%02x: %d\n", __func__, gp2a_client->addr, reg, ret);
+		return ret;
+	}
+	return 0;
+#endif
+}
+
+
+int gp2a_i2c_write(u8 reg, u8 value)
+{
+	u8 data[2];
+	int ret =0, count=0;
+	struct i2c_msg msg[1];
+
+	data[0]=reg;
+	data[1]=value;
+
+	msg[0].addr = gp2a_client->addr;
+	msg[0].flags=0;
+	msg[0].len=2;
+	msg[0].buf=data;
+
+	count = i2c_transfer(gp2a_client->adapter, msg, 1);
+	if(count !=1)
+	{
+		ret = -1;
+	}
+
+	return ret;
+}
+
+
+static int gp2a_get_lux_value(u8 *lux_value)
+{
+#ifdef GP2A_DEBUG
+	printk("gp2a_read_lux_value called\n");
+#endif
+
+	int ret=-1;
+	unsigned int als_out;
+	
+	ret = gp2a_i2c_read(REG_PROX,lux_value);
+	if(ret <0)
+	{
+		printk("gp2a_i2c_read failed !!\n");
+	}
+
+	// Proximity bit is LSB of the data-byte.
+	// Discard remaining 7 bits
+	// NOTE: Proximity = 0 in "near" state, 1 in "far" state.
+	*lux_value = !((*lux_value )& 0x01);
+
+	// Ambient Light sensing
+        twl6030_gpadc_conversion(&conv_request);
+	als_out = conv_request.rbuf[3];
+
+
+#ifdef GP2A_DEBUG
+	printk("gp2a: ALS_OUT=%u\n\n", als_out);
+	printk("gp2a: proximity_bit=%hi\n",*lux_value);
+#endif
+
+	return ret;
+}
+
+
+static int gp2a_set_operation_mode(u8 mode)
+{
+	int ret=-1;
+
+	switch(mode)
+	{
+		case POWER_UP:
+		{
+			//Power up the GPIO-35 too.
+			gpio_direction_output(gp2a_ps_on_gpio, 1);	
+			printk("Light[GP2A] Power-up\n");
+			#if 0
+			if((ret = gp2a_i2c_write(REG_OPMOD,0x01))<0)   //Software-Shutdown Disabed.
+			{
+				ret = -EFAULT;
+				printk("Error in gp2a_set_operation_mode: REG_OPMOD \n");
+			}
+			#endif
+			if((ret = gp2a_initialize_register(NORMAL_MODE))<0)
+			{
+				ret = -EFAULT;
+				printk("Error in gp2a_register_initialization\n");
+			}
+			if(gp2a_timeout < 0)
+			{
+				gp2a_timeout=msecs_to_jiffies(200);
+			}
+		
+			queue_delayed_work(gp2a_work_q, &gp2a_delayed_work_q, gp2a_timeout);
+			break;
+		}
+
+		case POWER_DOWN:
+		{
+			printk("Light[GP2A] Power-down\n");
+			gp2a_timeout=-1;
+			flush_workqueue(gp2a_work_q);
+			if((ret = gp2a_i2c_write(REG_OPMOD,0x00))<0) //Software-Shutdown Enabled.
+
+			{
+			ret=-EFAULT;
+			printk("Error in gp2a_set_operation_mode: REG_OPMOD \n");
+			}
+
+			// WARNING: rev0.4 board When PS_ON_GPIO --> GND, i2c_read fails.
+			// After that sensors do not come up properly next time.
+			// So Avoid PS_ON_GPIO --> GND on rev0.4 board
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV != 4)
+			//Shut down the GPIO-35 as the device has been shut down.
+			gpio_direction_output(gp2a_ps_on_gpio, 0);
+#endif
+			break;
+		}
+
+	}
+
+	return ret;
+}
+
+
+static int gp2a_initialize_register(u8 mode)
+{
+	int ret =-1;
+	u8 return_reg_value=0;
+
+
+	switch(mode)
+	{
+		case NORMAL_MODE:
+		{
+			printk("Light[GP2A] Initializing Registers in Normal-Mode\n");
+			if((ret = gp2a_i2c_write(REG_GAIN,0x08))<0)
+			{
+				printk("Error in gp2a_initialize_register: REG_GAIN \n");
+				return ret;
+			}
+			#ifdef GP2A_DEBUG
+			msleep(10);
+			if((ret=gp2a_i2c_read(REG_GAIN,&return_reg_value))<0)
+			{
+				printk("Error in gp2a_initiaize_register:gp2a_i2c_read:REG_GAIN\n");
+				return ret;
+			}
+			printk("After Writing Gain; Read Value:%d\n",return_reg_value);
+			#endif
+			if((ret = gp2a_i2c_write(REG_HYS,0xc2))<0)
+			{
+				printk("Error in gp2a_initialize_register: REG_HYS \n");
+				return ret;
+			}
+			#ifdef GP2A_DEBUG
+			msleep(10);
+			if((ret=gp2a_i2c_read(REG_HYS,&return_reg_value))<0)
+			{
+				printk("Error in gp2a_i2c_read:REG_HYS\n");
+				return ret;
+			}
+			printk("After writing HYS; value read back is:%d",return_reg_value);
+			#endif
+			if((ret = gp2a_i2c_write(REG_CYCLE,0x04))<0)
+			{
+				printk("Error in gp2a_initialize_register: REG_CYCLE \n");
+				return ret;
+			}
+			if((ret = gp2a_i2c_write(REG_OPMOD,0x01))<0)
+			{
+				printk("Error in gp2a_initialize_register: REG_OPMOD \n");
+				return ret;
+			}
+			break;
+		}
+
+		case INTERRUPT_MODE:
+		{
+			printk("Light[GP2A] Initializing Registers in Interrupt-Mode\n");
+			return 0;
+		}
+
+		default:
+		{
+			return ret;
+		}
+	}
+}
+
+
+static int gp2a_ioctl(struct inode *inode, struct file *filp, unsigned int ioctl_cmd, unsigned long arg )
+{
+	int ret =0;
+	void __user *argp = (void __user*)arg;
+	u8 lux_value;
+
+
+	if(_IOC_TYPE(ioctl_cmd) != GP2A_LIGHT_IOC_MAGIC)
+	{
+		printk("GP2A cmd magic type error\n");
+		return -ENOTTY;
+	}
+
+	if(_IOC_NR(ioctl_cmd)>GP2A_LIGHT_IOC_MAGIC_NR_MAX)
+	{
+		printk("gp2a cmd number error\n");
+		return -ENOTTY;
+	}
+
+	switch(ioctl_cmd)
+	{
+
+		case GP2A_LIGHT_IOC_SET_OPERATION_MODE:
+		{
+			u8 mode =0;
+
+			if(copy_from_user(&mode,argp,sizeof(mode)))
+			{
+				printk(KERN_ERR"copy_from_user failed\n");
+				return -EFAULT;
+			}
+
+			printk("\n\ngp2a mode==%x\n\n",mode);
+			ret = gp2a_set_operation_mode(mode);
+		}
+
+
+		case GP2A_LIGHT_IOC_SET_POLL_DELAY:
+		{
+			u16 delay;
+			if(copy_from_user(&delay,argp,sizeof(delay)))
+			{
+				printk("gp2a: copy_from_user failed\n");
+				return -EFAULT;
+			}
+			else
+			{
+				gp2a_timeout=msecs_to_jiffies(delay);
+				printk("gp2a polling delay=%d\n",gp2a_timeout);
+			}
+
+			return 0;
+		}
+
+
+		case GP2A_LIGHT_IOC_GET_OPERATION_MODE:
+		{
+			return 0;
+			//TODO
+		}
+
+
+		case GP2A_LIGHT_IOC_GET_LUX_VALUE:
+		{
+			return 0;
+			//TODO
+		}
+
+
+		default:
+		{
+			printk(KERN_ERR"GP2A: UNKNOWN IOCTL\n");
+			return (-ENOTTY);
+		}
+	}
+}
+
+static int gp2a_work(void)
+{
+	//printk("gp2a_work called\n");
+	u8 lux_value;
+	int ret =0;
+
+	ret = gp2a_get_lux_value(&lux_value);
+
+	if(ret < 0)
+	{
+		printk("gp2a_read_lux_value FAILED\n");
+		return (-1);
+	}
+
+	input_report_abs(light_input, ABS_DISTANCE, (lux_value & 0x01) );	// Proximity
+	input_report_abs(light_input, ABS_MISC, conv_request.rbuf[3] );		// Ambient light
+	input_sync(light_input);
+
+	if(gp2a_timeout > -1)
+	{
+		queue_delayed_work(gp2a_work_q, &gp2a_delayed_work_q, gp2a_timeout);
+	}
+
+	return 0;
+}
+
+
+struct file_operations gp2a_fops =
+{
+	.owner   = THIS_MODULE,
+
+	//.read    = gp2a_read, 
+	//.write   = gp2a_write,
+	//.open    = gp2a_open,
+	.ioctl   = gp2a_ioctl,
+	//.release = gp2a_release,
+};
+
+
+static int gp2a_probe(struct i2c_client *client,const struct i2c_device_id *id )
+{
+	int ret = 0;
+	int result_light=-1;
+	u8 lux_value= 0;  // Proximitiy values =0 or 1.
+
+	struct device *dev_light;
+	gp2a_client = client;
+	
+	//Allocate light-device
+	gp2a_dev = kzalloc(sizeof *gp2a_dev, GFP_KERNEL);
+	if(gp2a_dev < 0)
+	{
+		printk("[GP2A_LIGHT]:Not enough memory while allocating Device\n");
+		return -ENOMEM;
+	}
+
+	//Initialize lock;
+	mutex_init(&gp2a_dev->lock);
+	gp2a_dev->client = client;
+	i2c_set_clientdata(client, gp2a_dev);
+	gp2a_client = client;
+	
+	
+	printk(KERN_INFO MODULE_NAME"Registering [GP2A_LIGHT] Light-Driver at address:%d",gp2a_client->addr);
+	printk("--------%s %d\n",__func__,__LINE__);
+	
+	
+	//Register char-driver
+	result_light = register_chrdev ( (int)NULL, LIGHT_DEV_NAME, &gp2a_fops);
+
+	if(result_light <0)
+	{
+		printk(KERN_ERR "Error while registering[GP2A_LIGHT] the char-device\n");
+		return result_light;
+	}
+
+
+	light_class = class_create(THIS_MODULE,LIGHT_DEV_NAME);
+	if(IS_ERR(light_class))
+		{
+			printk(KERN_ERR"Error while[GP2A_LIGHT] Creating the light_class\n");
+			unregister_chrdev(result_light,LIGHT_DEV_NAME);
+			return PTR_ERR(light_class);
+		}
+
+	dev_light = device_create(light_class, NULL, MKDEV(result_light ,0),"%s",LIGHT_DEV_NAME);
+
+	if(IS_ERR(dev_light))
+	{
+		printk(KERN_ERR "Error while[GP2A_LIGHT] Creating the dev_light\n");
+		return PTR_ERR(dev_light);
+	}
+	
+
+	//Register input device
+	light_input = input_allocate_device();
+
+	if(NULL == light_input)
+	{
+		printk(KERN_ERR"\n[gp2a-lightSENSOR] Error while allocating input device");
+		return -EIO;
+	}
+
+	gp2a_dev->inputdev=light_input;
+	set_bit(EV_ABS, light_input->evbit);
+	set_bit(ABS_MISC, light_input->absbit);
+	set_bit(ABS_DISTANCE, light_input->absbit);
+	
+	
+	light_input->name="gp2a_light";
+	light_input->dev.parent = &gp2a_client->dev;
+	
+	//input_set_abs_params(light_input,ABS_MISC,0,30000,0,0);
+	input_set_abs_params(light_input,ABS_DISTANCE,0,1,0,0);
+	
+	ret = input_register_device(light_input);
+	if(ret)
+	{
+		printk("gp2a light Sensor couldn't be registered:%d\n",ret);
+		goto release_input_dev;
+	}	
+
+
+	//Workqueue Initialisation
+	gp2a_work_q = create_singlethread_workqueue("light_sensor_gp2a_work_queue");
+	INIT_DELAYED_WORK( (struct delayed_work *)&gp2a_delayed_work_q, gp2a_work);
+
+	//Initializing the GPIO for GP2A
+	gp2a_ps_on_gpio = OMAP4TAB_PS_ON_GPIO;
+        ret = gpio_request(gp2a_ps_on_gpio, "GP2A Power On GPIO");
+        if (ret) {
+                printk(KERN_ERR "failed to get GP2A Power on GPIO\n");
+                return -EFAULT;
+        }
+
+	#ifdef GP2A_DEBUG
+	// Initializing the device;
+	// GP2A_LIGHT is being used as lightsensor
+	if((ret = gp2a_set_operation_mode(POWER_UP))<0)
+	{
+		printk("gp2a_set_operation_mode failed");
+		ret = -EFAULT;
+	}
+		msleep(1000);
+		gp2a_get_lux_value(&lux_value);
+		printk("gp2a: proximity_register value=%hi \n", lux_value);
+		lux_value = lux_value & 0x01;
+		printk("gp2a: proximity_bit=%hi\n",lux_value);
+	#endif
+
+	return 0;
+
+release_input_dev:
+	input_free_device(light_input);
+	return ret;
+}
+
+static int  gp2a_remove(struct i2c_client *client)
+{
+	struct gp2a_dev *gp2a = i2c_get_clientdata(client);
+
+	input_unregister_device(gp2a->inputdev);
+	input_free_device(gp2a->inputdev);
+	kfree(gp2a);
+
+	return 0;
+}
+#if CONFIG_PM
+static int gp2a_suspend(struct i2c_client * client, pm_message_t mesg)
+{
+	#ifdef GP2A_DEBUG
+	printk(KERN_INFO MODULE_NAME ": suspending device...\n");
+	#endif
+	return 0;
+}
+
+static int gp2a_resume(struct i2c_client * client)
+{
+	#ifdef GP2A_DEBUG
+	printk(KERN_INFO MODULE_NAME ": resuming device...\n");
+	#endif
+	return 0;
+}
+#else
+#define gp2a_suspend NULL
+#define gp2a_resume NULL
+
+#endif
+
+static const struct i2c_device_id gp2a_ids[] = {	
+        { MODULE_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, gp2a_ids);
+
+static struct i2c_driver gp2a_driver = {
+	.driver = {
+		.name	= MODULE_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = gp2a_ids,
+	.probe = gp2a_probe,
+	.remove = gp2a_remove,
+#if CONFIG_PM
+	.suspend = gp2a_suspend,
+	.resume = gp2a_resume,
+#endif
+};
+
+
+static int __init gp2a_init(void)
+{
+	#ifdef GP2A_DEBUG
+	printk(KERN_INFO MODULE_NAME ": Registering GP2A driver\n");
+	#endif
+	return i2c_add_driver(&gp2a_driver);
+}
+
+static void __exit gp2a_exit(void)
+{
+	#ifdef GP2A_DEBUG
+	printk(KERN_INFO MODULE_NAME ": Unregistered GP2A driver\n");
+	#endif
+	i2c_del_driver(&gp2a_driver);
+}
+
+
+module_init(gp2a_init);
+module_exit(gp2a_exit);
+
+MODULE_AUTHOR("Dharam Kumar");
+MODULE_DESCRIPTION("GP2A Driver");
+MODULE_LICENSE("GPL");
Index: android-2.6.35/drivers/sensors/optical/isl29023.c
===================================================================
--- android-2.6.35.orig/drivers/sensors/optical/isl29023.c	2010-12-22 14:36:03.913238838 +0530
+++ android-2.6.35/drivers/sensors/optical/isl29023.c	2010-12-22 14:36:09.823238303 +0530
@@ -30,6 +30,12 @@
 static int isl29023_ioctl(struct inode *, struct file *, unsigned int ,unsigned long);
 #endif
 
+
+static struct workqueue_struct *isl29023_work_q;
+static struct delayed_work isl29023_delayed_work_q;
+static int isl29023_work(void);
+int isl29023_timeout = -1;
+
 struct class *lightsensor_class;
 struct device *switch_cmd_dev;
 static bool light_enable = OFF;
@@ -108,14 +114,38 @@
     {
         case ISL29023_LIGHT_IOC_SET_OPERATION_MODE:
 			{
-				u8 mode;
-				debug("ISL29023_LIGHT_IOC_SET_OPERATION_MODE called");	
+				int mode;
+				debug("ISL29023_LIGHT_IOC_SET_OPERATION_MODE called");
 				
-				if(copy_from_user((void*) &mode, argp, sizeof(u8)))        	   	 
-        	   	       ret = -EFAULT;        	   	   
-                else if( (ret = isl29023_set_operation_mode(mode)) < 0 )        		
+				if(copy_from_user((void*) &mode, argp, sizeof(int)))
+				{       	   	 
+					debug("copy_from_user failed");
+					ret = -EFAULT;        	   	   
+				}
+
+				printk ("mode == %d\n", mode);
+				if((int)mode == 0)	//power-down mode
+				{
+					debug("power-down");
+					isl29023_timeout = -1;
+					flush_workqueue(isl29023_work_q);
+				}
+				else
+				{
+					//power-on modes
+					debug("power-up");
+					//Initially schedule workqueue with lowest polling frequency
+					isl29023_timeout = msecs_to_jiffies(200);
+					queue_delayed_work(isl29023_work_q, &isl29023_delayed_work_q, isl29023_timeout);
+				}
+
+
+				if( (ret = isl29023_set_operation_mode(mode)) < 0 )        		
+				{
 					debug("ISL29023_LIGHT_IOC_SET_OPERATION_MODE failed"); 			
-				break;
+				}
+
+			break;
 			}
         case ISL29023_LIGHT_IOC_SET_LUX_RANGE:			
 			{
@@ -193,24 +223,27 @@
         	   	       ret = -EFAULT; 
 				break;
 			}
-		case ISL29023_LIGHT_IOC_GET_LUX_VALUE:
-			{
-				u32 lux_value;
-				debug("ISL29023_LIGHT_IOC_GET_LUX_VALUE called");	
-				
-               			if( (ret = isl29023_get_lux_value(&lux_value)) < 0 )        
-				{
-					debug("ISL29023_LIGHT_IOC_GET_LUX_VALUE failed");
-				}
-				else
-				{
-					input_report_abs(isl29023_input_dev, ABS_MISC, lux_value );
-					input_report_abs(isl29023_input_dev, ABS_DISTANCE, lux_value );
 
-					input_sync(isl29023_input_dev);
-				}
-				break;
+		case ISL29023_LIGHT_IOC_SET_POLL_DELAY:
+		{
+			u32 delay;
+			debug("ISL29023_LIGHT_IOC_SET_POLL_DELAY called");	
+
+
+			//obtain delay from userspace and update the polling frequency accordingly
+			if(copy_from_user((void*) &delay, argp, sizeof(u32)))        	   	 
+			{
+				ret = -EFAULT;
+			}
+			else
+			{
+				isl29023_timeout = msecs_to_jiffies(delay);
+				printk("lp530al polling delay =%d\n", isl29023_timeout);
 			}
+
+			break;
+		}
+
 		default:
 			debug("Unknown IOCTL command");
             ret = -ENOTTY;
@@ -381,6 +414,33 @@
 }
 static DEVICE_ATTR(lightsensor_file_cmd, S_IRUGO | S_IWUGO, lightsensor_file_cmd_show, lightsensor_file_cmd_store);
 
+static int isl29023_work(void)
+{
+	debug("ISL29023_WORK called!!");
+
+	int ret = 0;
+	u32 lux_value;
+
+	ret = isl29023_get_lux_value(&lux_value);
+	
+	if( ret < 0 )        
+	{
+		debug("ISL29023_LIGHT_IOC_GET_LUX_VALUE failed");
+		return(-1);
+	}
+
+	input_report_abs(isl29023_input_dev, ABS_MISC, lux_value );
+	input_report_abs(isl29023_input_dev, ABS_DISTANCE, lux_value );
+	input_sync(isl29023_input_dev);
+
+	if (isl29023_timeout > -1)
+	{
+		queue_delayed_work(isl29023_work_q, &isl29023_delayed_work_q, isl29023_timeout);
+	}
+
+	return 0;
+
+}
 
 int __init isl29023_drv_init(void)
 {
@@ -440,6 +500,10 @@
     		goto release_input_dev;
   	}
 
+	//Workqueue Initialisation
+	isl29023_work_q = create_singlethread_workqueue("light_sensor_isl29023_work_queue");
+	INIT_DELAYED_WORK( (struct delayed_work *)&isl29023_delayed_work_q, isl29023_work);
+
 
 	/*create sysfs attributes*/
 	ret = sysfs_create_group(&isl29023_misc_device.this_device->kobj, &isl29003_attr_group);
Index: android-2.6.35/drivers/sensors/optical/isl29023.h
===================================================================
--- android-2.6.35.orig/drivers/sensors/optical/isl29023.h	2010-12-22 14:36:03.913238838 +0530
+++ android-2.6.35/drivers/sensors/optical/isl29023.h	2010-12-22 14:36:09.823238303 +0530
@@ -36,7 +36,8 @@
 #define ISL29023_LIGHT_IOC_GET_LUX_RANGE         		_IOR(ISL29023_LIGHT_IOC_MAGIC, 5,u32)
 #define ISL29023_LIGHT_IOC_GET_ADC_RESOLUTION       		_IOR(ISL29023_LIGHT_IOC_MAGIC, 6,u8)
 #define ISL29023_LIGHT_IOC_GET_INTERRUPT_PERSIST      		_IOR(ISL29023_LIGHT_IOC_MAGIC, 7,u8)
-#define ISL29023_LIGHT_IOC_GET_LUX_VALUE			_IOR(ISL29023_LIGHT_IOC_MAGIC, 8,u32)
+#define ISL29023_LIGHT_IOC_SET_POLL_DELAY	     		_IOR(ISL29023_LIGHT_IOC_MAGIC, 8, u32)
+
 #endif
 
 #endif
Index: android-2.6.35/include/linux/akm8975.h
===================================================================
--- android-2.6.35.orig/include/linux/akm8975.h	2010-12-10 15:11:25.000000000 +0530
+++ android-2.6.35/include/linux/akm8975.h	2010-12-22 14:36:09.823238303 +0530
@@ -6,17 +6,21 @@
 
 #include <linux/ioctl.h>
 
+#define AKM8975_I2C_NAME "akm8975"
+
 /*! \name AK8975 operation mode
  \anchor AK8975_Mode
  Defines an operation mode of the AK8975.*/
 /*! @{*/
-#define AK8975_MODE_SNG_MEASURE   0x01
-#define	AK8975_MODE_SELF_TEST     0x08
-#define	AK8975_MODE_FUSE_ACCESS   0x0F
-#define	AK8975_MODE_POWER_DOWN    0x00
+#define AK8975_MODE_SNG_MEASURE	0x01
+#define	AK8975_MODE_SELF_TEST	0x08
+#define	AK8975_MODE_FUSE_ACCESS	0x0F
+#define	AK8975_MODE_POWERDOWN	0x00
 /*! @}*/
 
-#define RBUFF_SIZE		8	/* Rx buffer size */
+#define SENSOR_DATA_SIZE		8	/* Rx buffer size, i.e from ST1 to ST2 */
+#define RWBUF_SIZE				16	/* Read/Write buffer size.*/
+
 
 /*! \name AK8975 register address
 \anchor AK8975_REG
@@ -52,35 +56,36 @@
 #define AKMIO                   0xA1
 
 /* IOCTLs for AKM library */
-#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x02, char[5])
-#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x03, char[5])
-#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x08, char[RBUFF_SIZE])
-#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x0C, short[12])
-#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x0D, int)
-#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x0E, int)
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x01, char*)
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x02, char*)
+#define ECS_IOCTL_RESET      	        _IO(AKMIO, 0x03) /* NOT used in AK8975 */
+#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x04, short)
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x05, char[SENSOR_DATA_SIZE])
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x06, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x07, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x08, int)
 #define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
+#define ECS_IOCTL_GET_PROJECT_NAME      _IOR(AKMIO, 0x0D, char[64])
+#define ECS_IOCTL_GET_MATRIX            _IOR(AKMIO, 0x0E, short [4][3][3])
 
 /* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
 #define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
 #define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
 #define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
 #define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
+#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)/* NOT use */
+#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)/* NOT use */
+#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)	/* NOT use */
 #define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
 #define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
-/* Set raw magnetic vector flag */
 #define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)
-/* Get raw magnetic vector flag */
 #define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)
-#define ECS_IOCTL_APP_SET_TFLAG         _IOR(AKMIO, 0x15, short)
-
 
 struct akm8975_platform_data {
-	int intr;
-
-	int (*init)(void);
-	void (*exit)(void);
-	int (*power_on)(void);
-	int (*power_off)(void);
+	char layouts[3][3];
+	char project_name[64];
+	int gpio_DRDY;
 };
 
 #endif
Index: android-2.6.35/drivers/sensors/Kconfig
===================================================================
--- android-2.6.35.orig/drivers/sensors/Kconfig	2010-12-22 14:36:04.371988428 +0530
+++ android-2.6.35/drivers/sensors/Kconfig	2010-12-22 14:36:09.823238303 +0530
@@ -9,5 +9,6 @@
 source "drivers/sensors/optical/Kconfig"
 source "drivers/sensors/accel/Kconfig"
 source "drivers/sensors/compass/Kconfig"
+source "drivers/sensors/gyro-mpu3050/Kconfig"
 endif # NEW_SENSORS
 
Index: android-2.6.35/drivers/sensors/Makefile
===================================================================
--- android-2.6.35.orig/drivers/sensors/Makefile	2010-12-22 14:36:03.691988648 +0530
+++ android-2.6.35/drivers/sensors/Makefile	2010-12-22 14:36:09.823238303 +0530
@@ -6,4 +6,5 @@
 obj-$(CONFIG_ACCEL)		+= accel/
 obj-$(CONFIG_OPTICAL)		+= optical/
 obj-$(CONFIG_COMPASS)		+= compass/
+obj-$(CONFIG_GYRO_MPU3050)    += gyro-mpu3050/
 
Index: android-2.6.35/arch/arm/mach-omap2/board-4430univ-sensors.c
===================================================================
--- android-2.6.35.orig/arch/arm/mach-omap2/board-4430univ-sensors.c	2010-12-22 14:36:03.681988196 +0530
+++ android-2.6.35/arch/arm/mach-omap2/board-4430univ-sensors.c	2010-12-22 14:36:09.823238303 +0530
@@ -68,8 +68,10 @@
 
 void __init omap4430univ_sensors_init(void)
 {
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <=2)
 	omap4430univ_akm8973_init();
 	omap4430univ_isl29023_init();
+#endif
 	omap4430univ_kxsd9_init();
 }
 
Index: android-2.6.35/arch/arm/mach-omap2/board-omap4tab10-1.c
===================================================================
--- android-2.6.35.orig/arch/arm/mach-omap2/board-omap4tab10-1.c	2010-12-22 14:36:09.531988717 +0530
+++ android-2.6.35/arch/arm/mach-omap2/board-omap4tab10-1.c	2010-12-22 14:36:39.603862870 +0530
@@ -78,19 +78,38 @@
 #define OMAP4TAB_MICBIAS_EN2_GPIO			49
 #endif
 
-#define OMAP4SDP_MDM_PWR_EN_GPIO			157
+
+/* For Sensors */
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
 #define OMAP4TAB_ISL29023_INT_GPIO			52
 #define OMAP4TAB_KXSD9_INT_GPIO				94
-#define OMAP4TAB_AKM8973_INT_GPIO			157
+#define OMAP4TAB_AKM_INT_GPIO				157
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
+#define OMAP4TAB_KXSD9_INT_GPIO				94
+#define OMAP4TAB_AKM_INT_GPIO				157
+#define OMAP4TAB_MPU3050_INT_GPIO			45
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
+#define OMAP4TAB_KXSD9_INT_GPIO				122
+#define OMAP4TAB_AKM_INT_GPIO				157
+#define OMAP4TAB_MPU3050_INT_GPIO			45
+#endif
 
 #define CONTROL_CORE_PAD0_I2C3_SDA_PAD1_I2C4_SCL	0x4A10012C
 #define CONTROL_CORE_PAD0_I2C4_SDA_PAD1_MCSPI1_CLK	0x4A100130
 
 /* For Battery Driver */
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
 #define OMAP4430_GPIO_TA_NCONNECTED			151
 #define OMAP4430_GPIO_TA_EN				54
 #define OMAP4430_GPIO_TA_NSTAT				11
 #define OMAP4430_GPIO_TA_NCHG				12
+#endif
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
+#define OMAP4430_GPIO_TA_NCONNECTED			152
+#define OMAP4430_GPIO_TA_EN				56
+#define OMAP4430_GPIO_TA_NSTAT				11
+#define OMAP4430_GPIO_TA_NCHG				153
+#endif
 #define OMAP4430_GPIO_USBSW_NINT			44
 
 #if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
@@ -978,10 +997,12 @@
 };
 
 static struct i2c_board_info __initdata omap4tab_i2c_2_boardinfo[] = {
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
 	{
 		I2C_BOARD_INFO("isl29023", 0x44),
 		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_ISL29023_INT_GPIO),
 	},
+#endif
 	{
 		I2C_BOARD_INFO("secFuelgaugeDev", 0x34),
 	},
@@ -1003,18 +1024,49 @@
 };
 
 static struct i2c_board_info __initdata omap4tab_i2c_4_boardinfo[] = {
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
+	{
+		I2C_BOARD_INFO("kxsd9", 0x18),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
+	},
 	{
 		I2C_BOARD_INFO("akm8973", 0x1C),
-		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_AKM8973_INT_GPIO),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_AKM_INT_GPIO),
 	},
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
 	{
 		I2C_BOARD_INFO("kxsd9", 0x18),
 		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
 	},
-#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
+	{
+		I2C_BOARD_INFO("mpu3050", 0x68),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO("akm8975", 0x0C),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_AKM_INT_GPIO),
+	},
         {
                 I2C_BOARD_INFO("cmc623_i2c_driver", 0x38),
         },
+
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
+	{
+		I2C_BOARD_INFO("kxsd9", 0x18),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_KXSD9_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO("mpu3050", 0x68),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_MPU3050_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO("akm8975", 0x0C),
+		.irq	= OMAP_GPIO_IRQ(OMAP4TAB_AKM_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO("gp2a",0x44),
+		
+	},
 #endif
 
 };
@@ -1242,11 +1294,13 @@
 
 static void omap4tab_touch_init(void)
 {
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
 	printk("[SHANKAR] %s[%d] Entry \n", __func__, __LINE__);
 	gpio_request(101, "TOUCH ENable GPIO");
 	gpio_direction_output(101, 1);
 	msleep(200);
 	printk("[SHANKAR] %s[%d] exit \n", __func__, __LINE__);
+#endif
 	
 }
 static void omap4tab_vib_motor_init(void)
@@ -1254,8 +1308,10 @@
 	/* Move this to proper place TBD */
 	gpio_request(OMAP4TAB_MOTOR_EN1_GPIO, "Vib Motor 1 GPIO");
 	gpio_direction_output(OMAP4TAB_MOTOR_EN1_GPIO, 0);
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
 	gpio_request(OMAP4TAB_MOTOR_EN2_GPIO, "Vib Motor 2 GPIO");
 	gpio_direction_output(OMAP4TAB_MOTOR_EN2_GPIO, 0);
+#endif
 }
 
 #elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
Index: android-2.6.35/drivers/sensors/accel/kxsd9.c
===================================================================
--- android-2.6.35.orig/drivers/sensors/accel/kxsd9.c	2010-12-22 14:36:05.741988541 +0530
+++ android-2.6.35/drivers/sensors/accel/kxsd9.c	2010-12-22 14:36:09.823238303 +0530
@@ -133,20 +133,31 @@
 	y = 0x8000 - 0x100 * buf[2] - buf[3];
 	z = buf[4] * 0x100 + buf[5] - 0x8000 - 1000; // calib?
 
-
+// Re-map the axes to account for different placement of sensor-IC
+// in the different revisions of the device.
+#if (CONFIG_SAMSUNG_OMAP4_TAB_REV <= 2)
 	acc->x = x;
 	acc->y = y;
 	acc->z = z;
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 3)
+	acc->x = y;
+	acc->y = -x;
+	acc->z = z;
+#elif (CONFIG_SAMSUNG_OMAP4_TAB_REV == 4)
+	acc->x = y;
+	acc->y = x;
+	acc->z = z;
+#endif
 
 #if KXSD9_DEBUG
 	printk("X:%d, Y:%d, Z:%d\n", acc->x, acc->y, acc->z);
 #endif
 
-	input_report_abs(kxsd9_input_dev, ABS_X, x );
-	input_report_abs(kxsd9_input_dev, ABS_Y, y );
-	input_report_abs(kxsd9_input_dev, ABS_Z, z );
+	//input_report_abs(kxsd9_input_dev, ABS_X, acc->x );
+	//input_report_abs(kxsd9_input_dev, ABS_Y, acc->y );
+	//input_report_abs(kxsd9_input_dev, ABS_Z, acc->z );
 
-	input_sync(kxsd9_input_dev);
+	//input_sync(kxsd9_input_dev);
 
 	return err;
 }
@@ -258,7 +269,7 @@
 			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
 			{
 #if KXSD9_DEBUG           
-				printk("[BMA150] copy_from_user error\n");
+				printk("[KXSD9] copy_from_user error\n");
 #endif
 				return -EFAULT;
 			}
@@ -268,7 +279,7 @@
 			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
 			{
 #if KXSD9_DEBUG           
-				printk("[BMA150] copy_from_user error\n");
+				printk("[KXSD9] copy_from_user error\n");
 #endif
 				return -EFAULT;
 			}
@@ -278,7 +289,7 @@
 			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
 			{
 #if KXSD9_DEBUG
-				printk("[BMA150] copy_from_user error\n");
+				printk("[KXSD9] copy_from_user error\n");
 #endif
 				return -EFAULT;
 			}
@@ -368,7 +379,7 @@
     		goto release_input_dev;
   	}
 
-        kxsd9_read_accel_xyz(kxsd9, &accels );
+        //kxsd9_read_accel_xyz(kxsd9, &accels );
 
 	return 0;
 
Index: android-2.6.35/drivers/sensors/accel/kxsd9.h
===================================================================
--- android-2.6.35.orig/drivers/sensors/accel/kxsd9.h	2010-12-22 14:36:04.141988371 +0530
+++ android-2.6.35/drivers/sensors/accel/kxsd9.h	2010-12-22 14:36:09.823238303 +0530
@@ -16,14 +16,6 @@
 		kxsd9_i2c_rxdata(reg_data, r_len)
 
 
-/* BMA150 IOCTL */
-#define BMA150_IOC_MAGIC		'B'
-#define BMA150_SET_RANGE		_IOWR(BMA150_IOC_MAGIC,4, unsigned char)
-#define BMA150_SET_MODE			_IOWR(BMA150_IOC_MAGIC,6, unsigned char)
-#define BMA150_SET_BANDWIDTH		_IOWR(BMA150_IOC_MAGIC,8, unsigned char)
-#define BMA150_READ_ACCEL_XYZ		_IOWR(BMA150_IOC_MAGIC,46,short)
-#define BMA150_IOC_MAXNR		48
-
 /* KXSD9 IOCTL */
 #define KXSD9_IOC_MAGIC			'K'
 #define KXSD9_SET_RANGE			_IOWR(KXSD9_IOC_MAGIC,4, unsigned char)
@@ -246,66 +238,5 @@
 
 #define MAX_12BIT		((1 << 12) - 1)
 
-/* Function prototypes */
-
-int bma020_init(kxsd9_t *);
-int bma020_set_image (kxsd9regs_t *);
-int bma020_get_image(kxsd9regs_t *);
-int bma020_get_offset(unsigned char, unsigned short *);
-int bma020_set_offset(unsigned char, unsigned short );
-int bma020_set_offset_eeprom(unsigned char, unsigned short);
-int bma020_soft_reset(void);
-int bma020_update_image(void);
-int bma020_write_ee(unsigned char , unsigned char ) ;
-int bma020_set_ee_w(unsigned char);
-int bma020_selftest(unsigned char);
-int bma020_get_selftest_result(unsigned char *);
-int bma020_set_range(char);
-int bma020_get_range(unsigned char*);
-int bma020_set_mode(unsigned char);
-unsigned char bma020_get_mode(void);
-int bma020_set_wake_up_pause(unsigned char);
-int bma020_get_wake_up_pause(unsigned char *);
-int bma020_set_bandwidth(char);
-int bma020_get_bandwidth(unsigned char *);
-int bma020_set_low_g_threshold(unsigned char);
-int bma020_get_low_g_threshold(unsigned char*);
-int bma020_set_low_g_hysteresis(unsigned char);
-int bma020_set_low_g_countdown(unsigned char);
-int bma020_get_low_g_countdown(unsigned char *);
-int bma020_get_low_g_hysteresis(unsigned char*);
-int bma020_set_low_g_duration(unsigned char);
-int bma020_get_low_g_duration(unsigned char*);
-int bma020_set_high_g_threshold(unsigned char);
-int bma020_get_high_g_threshold(unsigned char*);
-int bma020_set_high_g_hysteresis(unsigned char);
-int bma020_set_high_g_countdown(unsigned char);
-int bma020_get_high_g_countdown(unsigned char *);
-int bma020_get_high_g_hysteresis(unsigned char*);
-int bma020_set_high_g_duration(unsigned char);
-int bma020_get_high_g_duration(unsigned char*);
-int bma020_set_any_motion_threshold(unsigned char);
-int bma020_get_any_motion_threshold(unsigned char*);
-int bma020_set_any_motion_count(unsigned char);
-int bma020_get_any_motion_count(unsigned char *);
-int bma020_read_accel_x(short *);
-int bma020_read_accel_y(short *);
-int bma020_read_accel_z(short *);
-int bma020_read_temperature(unsigned char*);
-int kxsd9_read_accel_xyz(struct kxsd9 *, kxsd9acc_t *);
-int bma020_get_interrupt_status(unsigned char *);
-int bma020_reset_interrupt(void);
-int bma020_set_interrupt_mask(unsigned char);
-int bma020_get_interrupt_mask(unsigned char *);
-int bma020_set_low_g_int(unsigned char);
-int bma020_set_high_g_int(unsigned char);
-int bma020_set_any_motion_int(unsigned char);
-int bma020_set_alert_int(unsigned char);
-int bma020_set_advanced_int(unsigned char);
-int bma020_latch_int(unsigned char);
-int bma020_set_new_data_int(unsigned char onoff);
-int bma020_pause(int);
-int bma020_read_reg(unsigned char , unsigned char *, unsigned char);
-int bma020_write_reg(unsigned char , unsigned char*, unsigned char );
 #endif   // __KXSD9_H__
 
