From: Sebastien Guiriec <s-guiriec@ti.com>
Date: Wed, 2 Feb 2011 05:37:06 +0000 (+0100)
Subject: Update driver to ABE HAL 09.11.
X-Git-Url: http://git.omapzoom.org/?p=kernel%2Fomap.git;a=commitdiff_plain;h=477208b0e6b022698a8e2d391e6165b1bf039aac;hp=5d85bef2bca31b9ae80ba007727f1da5559407db

Update driver to ABE HAL 09.11.

Highlights:
- Added support for: DMIC1, DMIC2, DMIC3, AMIC, DL1, DL2, BT_UL gains
- Create structure for ABE HAL global variable

List of available features of this release:
- Stereo multimedia (48kHz) and stereo voice (8/16kHz) player and recorder
- Router of microphones to the recorder ports (VX_UL, MM_UL, MM_UL2)
- Mixers with gain balance (DL1, DL2) on the headset and handsfree paths
- Equalizer (DL1_EQ, DL2_EQ) on the headset and hands-free paths
- Sidetone loop for voice communication
- Ping-Pong large 48kBytes buffer on MM_DL multimedia port
- Low-power OPP25% (multimedia player) and OPP50% (voice calls)
- Auto-adaptive asynchronous sample-rate converters on voice ports
  (VX_DL, VX_UL, BT_VX_UL, BT_VX_DL) and multimedia port MM_EXT_IN
- All data formats (Mono, Stereo, 16bits Left/Right-shifted) on McBSP
- Translation to the Linux coding style
- Ping-Pong underflow handling mechanism
- Sidetone Equalizer
- Multichannel audio capture (up to 7 channels) at OPP100%
- Separate filters for AMIC and DMIC 96->48KHz SRC/Equalizer
- Self-adapting drift compensation at MM_EXT_IN port
- Precomputed test pattern implementation
- SMEM reset on the EQ coefficients load
- Automatic main port selection
- Saturation control (automatic gain computation)
- Mute/unmute capability
- Reference counting at PDM_DL port
- Echo Reference at MM_UL, MM_UL2 or VX_UL PORT
- Basic SLIMbus support
- FIFO underflow for sDMA/IRQ access at MM_DL/TONES_DL/VX_DL ports
- Distinct gain support for : DMIC1, DMIC2, DMIC3, AMIC, DL1, DL2, BT_UL gains.

Change-Id: If60288595bff77709f56f9b15e335a02a3732e25
Signed-off-by: Sebastien Guiriec <s-guiriec@ti.com>
Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
---

Index: kernel/sound/soc/omap/abe/Makefile
===================================================================
--- kernel.orig/sound/soc/omap/abe/Makefile	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/Makefile	2011-03-28 15:57:05.778353967 +0900
@@ -1,4 +1,5 @@
 snd-soc-abe-hal-objs += abe_api.o \
+			abe_aess.o \
 			abe_dbg.o \
 			abe_dat.o \
 			abe_ext.o \
Index: kernel/sound/soc/omap/abe/abe_aess.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/sound/soc/omap/abe/abe_aess.c	2011-03-28 15:57:05.778353967 +0900
@@ -0,0 +1,163 @@
+/*
+ * ALSA SoC OMAP ABE driver
+ *
+ * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+
+#include "abe_main.h"
+#include "abe_ref.h"
+#include "abe_typedef.h"
+#include "abe_initxxx_labels.h"
+#include "abe_dbg.h"
+#include "abe_mem.h"
+
+/**
+ * abe_clear_irq - clear ABE interrupt
+ *
+ * This subroutine is call to clear MCU Irq
+ */
+int abe_clear_irq(void)
+{
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET + ABE_MCU_IRQSTATUS, 1);
+	return 0;
+}
+EXPORT_SYMBOL(abe_clear_irq);
+
+/**
+ * abe_write_event_generator - Selects event generator source
+ * @e: Event Generation Counter, McPDM, DMIC or default.
+ *
+ * Loads the AESS event generator hardware source.
+ * Loads the firmware parameters accordingly.
+ * Indicates to the FW which data stream is the most important to preserve
+ * in case all the streams are asynchronous.
+ * If the parameter is "default", then HAL decides which Event source
+ * is the best appropriate based on the opened ports.
+ *
+ * When neither the DMIC and the McPDM are activated, the AE will have
+ * its EVENT generator programmed with the EVENT_COUNTER.
+ * The event counter will be tuned in order to deliver a pulse frequency higher
+ * than 96 kHz.
+ * The DPLL output at 100% OPP is MCLK = (32768kHz x6000) = 196.608kHz
+ * The ratio is (MCLK/96000)+(1<<1) = 2050
+ * (1<<1) in order to have the same speed at 50% and 100% OPP
+ * (only 15 MSB bits are used at OPP50%)
+ */
+int abe_write_event_generator(u32 source)
+{
+	u32 event, selection;
+	u32 counter = EVENT_GENERATOR_COUNTER_DEFAULT;
+	u32 start = EVENT_GENERATOR_ON;
+
+	_log(id_write_event_generator, source, 0, 0);
+	switch (source) {
+	case EVENT_TIMER:
+		selection = EVENT_SOURCE_COUNTER;
+		event = 0;
+		break;
+	case EVENT_44100:
+		selection = EVENT_SOURCE_COUNTER;
+		event = 0;
+		counter = EVENT_GENERATOR_COUNTER_44100;
+		break;
+	default:
+		abe->dbg_param |= ERR_API;
+		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
+		return -EINVAL;
+	}
+	abe_current_event_id = source;
+
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    EVENT_GENERATOR_COUNTER, counter);
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    EVENT_SOURCE_SELECTION, selection);
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    EVENT_GENERATOR_START, start);
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    AUDIO_ENGINE_SCHEDULER, event);
+
+	return 0;
+}
+EXPORT_SYMBOL(abe_write_event_generator);
+
+/**
+ * abe_start_event_generator - Starts event generator source
+ *
+ * Start the event genrator of AESS. No more event will be send to AESS engine.
+ * Upper layer must wait 1/96kHz to be sure that engine reaches
+ * the IDLE instruction.
+ */
+int abe_start_event_generator(void)
+{
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    EVENT_GENERATOR_START, 1);
+	return 0;
+}
+EXPORT_SYMBOL(abe_start_event_generator);
+
+/**
+ * abe_stop_event_generator - Stops event generator source
+ *
+ * Stop the event genrator of AESS. No more event will be send to AESS engine.
+ * Upper layer must wait 1/96kHz to be sure that engine reaches
+ * the IDLE instruction.
+ */
+int abe_stop_event_generator(void)
+{
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET +
+			    EVENT_GENERATOR_START, 0);
+	return 0;
+}
+EXPORT_SYMBOL(abe_stop_event_generator);
+
+/**
+ * abe_hw_configuration
+ *
+ */
+void abe_hw_configuration()
+{
+	/* enables the DMAreq from AESS AESS_DMAENABLE_SET = 255 */
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET + 0x60, 0xFF);
+	/* enables the MCU IRQ from AESS to Cortex A9 */
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET + 0x3C, 0x01);
+}
+
+/**
+ * abe_disable_irq - disable MCU/DSP ABE interrupt
+ *
+ * This subroutine is disabling ABE MCU/DSP Irq
+ */
+int abe_disable_irq(void)
+{
+	/*
+	 * disables the DMAreq from AESS AESS_DMAENABLE_CLR = 127
+	 * DMA_Req7 will still be enabled as it is used for ABE trace
+	 */
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET + 0x64, 0x7F);
+	/* disables the MCU IRQ from AESS to Cortex A9 */
+	omap_abe_reg_writel(abe, OMAP_ABE_AESS_OFFSET + 0x40, 0x01);
+	return 0;
+}
+EXPORT_SYMBOL(abe_disable_irq);
+
Index: kernel/sound/soc/omap/abe/abe_api.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_api.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_api.c	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,17 +18,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
-#include "abe_main.h"
-#include "abe_typedef.h"
-#include "abe_initxxx_labels.h"
-#include "abe_dbg.h"
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/slab.h>
 
-u32 warm_boot = 0;
+#include "abe_main.h"
+#include "abe_ref.h"
+#include "abe_typedef.h"
+#include "abe_initxxx_labels.h"
+#include "abe_dbg.h"
 
 /**
  * abe_reset_hal - reset the ABE/HAL
@@ -39,34 +40,33 @@
  * default AESS registers.
  * Called after a PRCM cold-start reset of ABE
  */
-abehal_status abe_reset_hal(void)
+int abe_reset_hal(void)
 {
 	u32 i;
+
 	_log(id_reset_hal, 0, 0, 0);
-	abe_dbg_output = TERMINAL_OUTPUT;
-	abe_dbg_activity_log_write_pointer = 0;
+	abe->dbg_output = TERMINAL_OUTPUT;
+	abe->dbg_activity_log_write_pointer = 0;
 	/* IRQ & DBG circular read pointer in DMEM */
-	abe_irq_dbg_read_ptr = 0;
-	/* PDM_DL enable/disable collisions */
-	pdm_dl1_status = 0;
-	pdm_dl2_status = 0;
-	pdm_vib_status = 0;
+	abe->irq_dbg_read_ptr = 0;
 	/* default = disable the mixer's adaptive gain control */
 	abe_use_compensated_gain(0);
 	/* reset the default gain values */
 	for (i = 0; i < MAX_NBGAIN_CMEM; i++) {
-		abe_muted_gains_indicator[i] = 0;
-		abe_desired_gains_decibel[i] = (u32) GAIN_MUTE;
-		abe_desired_gains_linear[i] = 0;
-		abe_desired_ramp_delay_ms[i] = 0;
-		abe_muted_gains_decibel[i] = (u32) GAIN_TOOLOW;
+		abe->muted_gains_indicator[i] = 0;
+		abe->desired_gains_decibel[i] = (u32) GAIN_MUTE;
+		abe->desired_gains_linear[i] = 0;
+		abe->desired_ramp_delay_ms[i] = 0;
+		abe->muted_gains_decibel[i] = (u32) GAIN_TOOLOW;
 	}
 	/* set debug mask to "enable all traces" */
-	abe_dbg_mask = (abe_dbg_t) (0);
+	abe->dbg_mask = (abe_dbg_t) (0);
 	abe_hw_configuration();
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_reset_hal);
+
 /**
  * abe_load_fw_param - Load ABE Firmware memories
  * @PMEM: Pointer of Program memory data
@@ -78,22 +78,16 @@
  * @DMEM: Pointer of Data memory data
  * @DMEM_SIZE: Size of DMEM data
  *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
  */
-abehal_status abe_load_fw_param(u32 *ABE_FW)
+int abe_load_fw_param(u32 *ABE_FW)
 {
-	u32 event_gen;
 	u32 pmem_size, dmem_size, smem_size, cmem_size;
 	u32 *pmem_ptr, *dmem_ptr, *smem_ptr, *cmem_ptr, *fw_ptr;
+
 	_log(id_load_fw_param, 0, 0, 0);
-#if PC_SIMULATION
-	/* the code is loaded from the Checkers */
-#else
 #define ABE_FW_OFFSET 5
 	fw_ptr = ABE_FW;
-	abe_firmware_version_number = *fw_ptr++;
+	abe->firmware_version_number = *fw_ptr++;
 	pmem_size = *fw_ptr++;
 	cmem_size = *fw_ptr++;
 	dmem_size = *fw_ptr++;
@@ -102,73 +96,29 @@
 	cmem_ptr = pmem_ptr + (pmem_size >> 2);
 	dmem_ptr = cmem_ptr + (cmem_size >> 2);
 	smem_ptr = dmem_ptr + (dmem_size >> 2);
-	/* do not load PMEM */
-	if (warm_boot) {
-		/* Stop the event Generator */
-		event_gen = 0;
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-			       EVENT_GENERATOR_START, &event_gen, 4);
-		/* Now we are sure the firmware is stalled */
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, 0, cmem_ptr,
-			       cmem_size);
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, 0, smem_ptr,
-			       smem_size);
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, 0, dmem_ptr,
-			       dmem_size);
-		/* Restore the event Generator status */
-		event_gen = 1;
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-			       EVENT_GENERATOR_START, &event_gen, 4);
-	} else {
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_PMEM, 0, pmem_ptr,
-			       pmem_size);
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, 0, cmem_ptr,
-			       cmem_size);
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, 0, smem_ptr,
-			       smem_size);
-		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, 0, dmem_ptr,
-			       dmem_size);
-	}
-	warm_boot = 1;
-#endif
+	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_PMEM, 0,
+		       pmem_ptr, pmem_size);
+	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, 0,
+		       cmem_ptr, cmem_size);
+	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, 0,
+		       smem_ptr, smem_size);
+	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, 0,
+		       dmem_ptr, dmem_size);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_load_fw_param);
-/**
- * abe_load_fw - Load ABE Firmware and initialize memories
- *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
- */
-abehal_status abe_load_fw(void)
-{
-	_log(id_load_fw, 0, 0, 0);
-	abe_load_fw_param((u32 *) abe_firmware_array);
-	abe_reset_all_ports();
-	abe_build_scheduler_table();
-	abe_reset_all_sequence();
-	abe_select_main_port(PDM_DL_PORT);
-	return 0;
-}
-EXPORT_SYMBOL(abe_load_fw);
+
 /**
  * abe_reload_fw - Reload ABE Firmware after OFF mode
- *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
  */
-abehal_status abe_reload_fw(void)
+int abe_reload_fw(void)
 {
-	warm_boot = 0;
 	abe_load_fw_param((u32 *) abe_firmware_array);
 	abe_build_scheduler_table();
-
 	/* IRQ & DBG circular read pointer in DMEM */
-	abe_dbg_activity_log_write_pointer = 0;
-	abe_irq_dbg_read_ptr = 0;
-
+	abe->dbg_activity_log_write_pointer = 0;
+	abe->irq_dbg_read_ptr = 0;
 	/* Restore Gains not managed by the drivers */
 	abe_write_gain(GAINS_SPLIT, GAIN_0dB, RAMP_100MS, GAIN_LEFT_OFFSET);
 	abe_write_gain(GAINS_SPLIT, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
@@ -176,12 +126,29 @@
 	abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
 	abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_100MS, GAIN_LEFT_OFFSET);
 	abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
-
 	return 0;
 }
 EXPORT_SYMBOL(abe_reload_fw);
+
+/**
+ * abe_load_fw - Load ABE Firmware and initialize memories
+ *
+ */
+int abe_load_fw(void)
+{
+	_log(id_load_fw, 0, 0, 0);
+	abe_load_fw_param((u32 *) abe_firmware_array);
+	abe_reset_all_ports();
+	abe_build_scheduler_table();
+	abe_reset_all_sequence();
+	abe_select_main_port(PDM_DL_PORT);
+	return 0;
+}
+EXPORT_SYMBOL(abe_load_fw);
+
 /**
- * abe_read_hardware_configuration - Return default HW periferals configuration
+ * abe_read_hardware_configuration - Returns default
+ *	HW periferals configuration
  * @u: use-case description list (pointer)
  * @o: opp mode (pointer)
  * @hw: pointer to the output HW structure
@@ -191,19 +158,19 @@
  * H : pointer to the output structure
  *
  * Operations :
- * return a structure with the HW thresholds compatible with the HAL/FW/AESS_ATC
- * will be upgraded in FW06
- * return a structure with the HW thresholds compatible with the HAL/FW/AESS_ATC
+ * Returns a structure with the HW thresholds compatible with
+ *	the HAL/FW/AESS_ATC. Will be upgraded in FW06.
  */
-abehal_status abe_read_hardware_configuration(u32 *u, u32 *o,
-					      abe_hw_config_init_t *hw)
+int abe_read_hardware_configuration(u32 *u, u32 *o,
+				abe_hw_config_init_t *hw)
 {
 	_log(id_read_hardware_configuration, (u32) u,
-	     (u32) u >> 8, (u32) u >> 16);
+		(u32) u >> 8, (u32) u >> 16);
 	abe_read_use_case_opp(u, o);
 	/* 0: 96kHz 1:192kHz */
 	hw->MCPDM_CTRL__DIV_SEL = 0;
-	/* 0: no command in the FIFO, 1: 6 data on each lines (with commands) */
+	/* 0: no command in the FIFO,
+	1: 6 data on each lines (with commands) */
 	hw->MCPDM_CTRL__CMD_INT = 1;
 	/* 0:MSB aligned 1:LSB aligned */
 	hw->MCPDM_CTRL__PDMOUTFORMAT = 0;
@@ -256,9 +223,11 @@
 		ABE_ATC_MCPDMDL_DMA_REQ;
 	/* THE famous EVENT timer ! */
 	hw->HAL_EVENT_SELECTION = EVENT_TIMER;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_hardware_configuration);
+
 /**
  * abe_irq_processing - Process ABE interrupt
  *
@@ -268,33 +237,35 @@
  * for the delivery of "end of time sequenced tasks" notifications, some are
  * originated from the Ping-Pong protocols, some are generated from
  * the embedded debugger when the firmware stops on programmable break-points,
- * etc
+ * etc ...
  */
-abehal_status abe_irq_processing(void)
+int abe_irq_processing(void)
 {
 	u32 abe_irq_dbg_write_ptr, i, cmem_src, sm_cm;
 	abe_irq_data_t IRQ_data;
-#define IrqFiFoMask ((D_McuIrqFifo_sizeof >> 2) -1)
+#define IrqFiFoMask ((D_McuIrqFifo_sizeof >> 2) - 1)
+
 	_log(id_irq_processing, 0, 0, 0);
 	/* extract the write pointer index from CMEM memory (INITPTR format) */
 	/* CMEM address of the write pointer in bytes */
 	cmem_src = MCU_IRQ_FIFO_ptr_labelID << 2;
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_CMEM, cmem_src,
-		       &sm_cm, sizeof(abe_irq_dbg_write_ptr));
+			&sm_cm, sizeof(abe_irq_dbg_write_ptr));
 	/* AESS left-pointer index located on MSBs */
 	abe_irq_dbg_write_ptr = sm_cm >> 16;
 	abe_irq_dbg_write_ptr &= 0xFF;
 	/* loop on the IRQ FIFO content */
 	for (i = 0; i < D_McuIrqFifo_sizeof; i++) {
 		/* stop when the FIFO is empty */
-		if (abe_irq_dbg_write_ptr == abe_irq_dbg_read_ptr)
+		if (abe_irq_dbg_write_ptr == abe->irq_dbg_read_ptr)
 			break;
 		/* read the IRQ/DBG FIFO */
 		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
 			       (D_McuIrqFifo_ADDR +
-				(abe_irq_dbg_read_ptr << 2)),
+				(abe->irq_dbg_read_ptr << 2)),
 			       (u32 *) &IRQ_data, sizeof(IRQ_data));
-		abe_irq_dbg_read_ptr = (abe_irq_dbg_read_ptr + 1) &IrqFiFoMask;
+		abe->irq_dbg_read_ptr =
+			(abe->irq_dbg_read_ptr + 1) & IrqFiFoMask;
 		/* select the source of the interrupt */
 		switch (IRQ_data.tag) {
 		case IRQtag_APS:
@@ -314,23 +285,11 @@
 		}
 	}
 	abe_monitoring();
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_irq_processing);
-/**
- * abe_clear_irq - clear ABE interrupt
- *
- * This subroutine is call to clear MCU Irq
- */
-abehal_status abe_clear_irq(void)
-{
-	u32 clear_abe_irq = 1;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC, ABE_MCU_IRQSTATUS,
-		       &clear_abe_irq, 4);
 
-	return 0;
-}
-EXPORT_SYMBOL(abe_clear_irq);
 /**
  * abe_select_main_port - Select stynchronization port for Event generator.
  * @id: audio port name
@@ -338,9 +297,10 @@
  * tells the FW which is the reference stream for adjusting
  * the processing on 23/24/25 slots
  */
-abehal_status abe_select_main_port(u32 id)
+int abe_select_main_port(u32 id)
 {
 	u32 selection;
+
 	_log(id_select_main_port, id, 0, 0);
 	/* flow control */
 	selection = D_IOdescr_ADDR + id * sizeof(ABE_SIODescriptor) +
@@ -351,78 +311,16 @@
 	if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN)
 		selection |= 0x80000;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_Slot23_ctrl_ADDR,
-		       &selection, 4);
-	return 0;
-}
-/**
- * abe_write_event_generator - Select event generator source
- * @e: Event Generation Counter, McPDM, DMIC or default.
- *
- * load the AESS event generator hardware source. Loads the firmware parameters
- * accordingly. Indicates to the FW which data stream is the most important to preserve
- * in case all the streams are asynchronous. If the parameter is "default", let the HAL
- * decide which Event source is the best appropriate based on the opened ports.
- *
- * When neither the DMIC and the McPDM are activated the AE will have its EVENT generator programmed
- * with the EVENT_COUNTER. The event counter will be tuned in order to deliver a pulse frequency higher
- * than 96 kHz. The DPLL output at 100% OPP is MCLK = (32768kHz x6000) = 196.608kHz
- * The ratio is (MCLK/96000)+(1<<1) = 2050
- * (1<<1) in order to have the same speed at 50% and 100% OPP (only 15 MSB bits are used at OPP50%)
- */
-abehal_status abe_write_event_generator(u32 e)
-{
-	u32 event, selection, counter, start;
-	_log(id_write_event_generator, e, 0, 0);
-	counter = EVENT_GENERATOR_COUNTER_DEFAULT;
-	start = EVENT_GENERATOR_ON;
-	abe_current_event_id = e;
-	switch (e) {
-	case EVENT_TIMER:
-		selection = EVENT_SOURCE_COUNTER;
-		event = 0;
-		break;
-	case EVENT_44100:
-		selection = EVENT_SOURCE_COUNTER;
-		event = 0;
-		counter = EVENT_GENERATOR_COUNTER_44100;
-		break;
-	default:
-		abe_dbg_param |= ERR_API;
-		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
-	}
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-		       EVENT_GENERATOR_COUNTER, &counter, 4);
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-		       EVENT_SOURCE_SELECTION, &selection, 4);
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-		       EVENT_GENERATOR_START, &start, 4);
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-		       AUDIO_ENGINE_SCHEDULER, &event, 4);
+			&selection, 4);
 	return 0;
 }
-EXPORT_SYMBOL(abe_write_event_generator);
-/**
- * abe_stop_event_generator - Stop event generator source
- *
- * Stop the event genrator of AESS. No more event will be send to AESS engine.
- * Upper layer needs to wait 1/96kHz to be sure that engine reach IDLE instruction
- */
-abehal_status abe_stop_event_generator(void)
-{
-	u32 event_gen;
-	/* Stop the event Generator */
-	event_gen = 0;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC,
-		       EVENT_GENERATOR_START, &event_gen, 4);
-	return 0;
-}
-EXPORT_SYMBOL(abe_stop_event_generator);
+
 /**
  * abe_read_use_case_opp() - description for void abe_read_use_case_opp().
  *
  * returns the expected min OPP for a given use_case list
  */
-abehal_status abe_read_use_case_opp(u32 *u, u32 *o)
+int abe_read_use_case_opp(u32 *u, u32 *o)
 {
 	u32 opp, i;
 	u32 *ptr = u;
@@ -430,12 +328,13 @@
 #define OPP_25 1
 #define OPP_50 2
 #define OPP_100 4
+
 	_log(id_read_use_case_opp, (u32) u, (u32) u >> 8, (u32) u >> 16);
 	opp = i = 0;
 	do {
 		/* check for pointer errors */
 		if (i > MAX_READ_USE_CASE_OPP) {
-			abe_dbg_param |= ERR_API;
+			abe->dbg_param |= ERR_API;
 			abe_dbg_error_log(ABE_READ_USE_CASE_OPP_ERR);
 			break;
 		}
@@ -483,9 +382,11 @@
 		*o = ABE_OPP50;
 	else
 		*o = ABE_OPP25;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_use_case_opp);
+
 /**
  * abe_set_opp_processing - Set OPP mode for ABE Firmware
  * @opp: OOPP mode
@@ -501,9 +402,11 @@
  * this switch.
  *
  */
-abehal_status abe_set_opp_processing(u32 opp)
+int abe_set_opp_processing(u32 opp)
 {
 	u32 dOppMode32, sio_desc_address;
+	ABE_SIODescriptor sio_desc;
+
 	_lock_enter;
 	_log(id_set_opp_processing, opp, 0, 0);
 	switch (opp) {
@@ -516,7 +419,7 @@
 		dOppMode32 = DOPPMODE32_OPP50;
 		break;
 	default:
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
 	case ABE_OPP100:
 		/* OPP100% */
@@ -527,35 +430,41 @@
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       D_maxTaskBytesInSlot_ADDR, &dOppMode32, sizeof(u32));
 	sio_desc_address = dmem_port_descriptors + (MM_EXT_IN_PORT *
-						    sizeof(ABE_SIODescriptor));
+						sizeof(ABE_SIODescriptor));
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,
-		       (u32 *) &sio_desc, sizeof(sio_desc));
+			(u32 *) &sio_desc, sizeof(sio_desc));
 	if (dOppMode32 == DOPPMODE32_OPP100) {
 		/* ASRC input buffer, size 40 */
 		sio_desc.smem_addr1 = smem_mm_ext_in_opp100;
 		/* Init MM_EXT_IN ASRC and enable its adaptation */
 		abe_init_asrc_mm_ext_in(250);
-	} else
+	} else {
 		/* at OPP 50 or without ASRC */
 		sio_desc.smem_addr1 = smem_mm_ext_in_opp50;
+	}
+
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,
-		       (u32 *) &sio_desc, sizeof(sio_desc));
+			(u32 *) &sio_desc, sizeof(sio_desc));
+
 	sio_desc_address = dmem_port_descriptors + (BT_VX_UL_PORT *
-						    sizeof(ABE_SIODescriptor));
+						sizeof(ABE_SIODescriptor));
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,
-		       (u32 *) &sio_desc, sizeof(sio_desc));
+			(u32 *) &sio_desc, sizeof(sio_desc));
 	if (dOppMode32 == DOPPMODE32_OPP100) {
 		/* ASRC input buffer, size 40 */
 		sio_desc.smem_addr1 = smem_bt_vx_ul_opp100;
 		/* Init MM_EXT_IN ASRC and enable its adaptation */
 		abe_init_asrc_bt_ul(250);
-	} else
+	} else {
 		/* at OPP 50 or without ASRC */
 		sio_desc.smem_addr1 = smem_bt_vx_ul_opp50;
+	}
+
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,
 		       (u32 *) &sio_desc, sizeof(sio_desc));
+
 	sio_desc_address = dmem_port_descriptors + (BT_VX_DL_PORT *
-						    sizeof(ABE_SIODescriptor));
+						sizeof(ABE_SIODescriptor));
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_desc_address,
 		       (u32 *) &sio_desc, sizeof(sio_desc));
 	if (dOppMode32 == DOPPMODE32_OPP100) {
@@ -563,14 +472,19 @@
 		sio_desc.smem_addr1 = smem_bt_vx_dl_opp100;
 		/* Init MM_EXT_IN ASRC and enable its adaptation */
 		abe_init_asrc_bt_dl(250);
-	} else
+	} else {
 		/* at OPP 50 or without ASRC */
 		sio_desc.smem_addr1 = smem_bt_vx_dl_opp50;
+	}
+
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_desc_address,
 		       (u32 *) &sio_desc, sizeof(sio_desc));
+
 	return 0;
+
 }
 EXPORT_SYMBOL(abe_set_opp_processing);
+
 /**
  * abe_set_ping_pong_buffer
  * @port: ABE port ID
@@ -579,15 +493,18 @@
  * Updates the next ping-pong buffer with "size" bytes copied from the
  * host processor. This API notifies the FW that the data transfer is done.
  */
-abehal_status abe_set_ping_pong_buffer(u32 port, u32 n_bytes)
+int abe_set_ping_pong_buffer(u32 port, u32 n_bytes)
 {
 	u32 sio_pp_desc_address, struct_offset, n_samples, datasize,
 		base_and_size, *src;
+	ABE_SPingPongDescriptor desc_pp;
+
 	_log(id_set_ping_pong_buffer, port, n_bytes, n_bytes >> 8);
 	/* ping_pong is only supported on MM_DL */
 	if (port != MM_DL_PORT) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	}
 	/* translates the number of bytes in samples */
 	/* data size in DMEM words */
@@ -596,7 +513,7 @@
 	datasize = datasize << 2;
 	n_samples = n_bytes / datasize;
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, D_PingPongDesc_ADDR,
-		       (u32 *) &desc_pp, sizeof(desc_pp));
+			(u32 *) &desc_pp, sizeof(desc_pp));
 	/*
 	 * read the port SIO descriptor and extract the current pointer
 	 * address after reading the counter
@@ -614,10 +531,12 @@
 	sio_pp_desc_address = D_PingPongDesc_ADDR + struct_offset;
 	src = &base_and_size;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, sio_pp_desc_address,
-		       (u32 *) &base_and_size, sizeof(u32));
+			(u32 *) &base_and_size, sizeof(u32));
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_set_ping_pong_buffer);
+
 /**
  * abe_read_next_ping_pong_buffer
  * @port: ABE portID
@@ -626,20 +545,23 @@
  *
  * Tell the next base address of the next ping_pong Buffer and its size
  */
-abehal_status abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n)
+int abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n)
 {
 	u32 sio_pp_desc_address;
+	ABE_SPingPongDescriptor desc_pp;
+
 	_log(id_read_next_ping_pong_buffer, port, 0, 0);
 	/* ping_pong is only supported on MM_DL */
 	if (port != MM_DL_PORT) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	}
 	/* read the port SIO descriptor and extract the current pointer
 	   address after reading the counter */
 	sio_pp_desc_address = D_PingPongDesc_ADDR;
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_pp_desc_address,
-		       (u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));
+			(u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));
 	if ((desc_pp.counter & 0x1) == 0) {
 		_log(id_read_next_ping_pong_buffer, port, 0, 0);
 		*p = desc_pp.nextbuff0_BaseAddr;
@@ -649,29 +571,33 @@
 	}
 	/* translates the number of samples in bytes */
 	*n = abe_size_pingpong;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_next_ping_pong_buffer);
+
 /**
  * abe_init_ping_pong_buffer
  * @id: ABE port ID
  * @size_bytes:size of the ping pong
  * @n_buffers:number of buffers (2 = ping/pong)
- * @p:returned address of the ping-pong list of base address (byte offset
-	from DMEM start)
+ * @p:returned address of the ping-pong list of base addresses
+ *	(byte offset from DMEM start)
  *
  * Computes the base address of the ping_pong buffers
  */
-abehal_status abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,
-					u32 *p)
+int abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,
+				u32 *p)
 {
 	u32 i, dmem_addr;
+
 	_log(id_init_ping_pong_buffer, id, size_bytes, n_buffers);
 	/* ping_pong is supported in 2 buffers configuration right now but FW
 	   is ready for ping/pong/pung/pang... */
 	if (id != MM_DL_PORT || n_buffers > MAX_PINGPONG_BUFFERS) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	}
 	for (i = 0; i < n_buffers; i++) {
 		dmem_addr = dmem_ping_pong_buffer + (i * size_bytes);
@@ -681,24 +607,30 @@
 	/* global data */
 	abe_size_pingpong = size_bytes;
 	*p = (u32) dmem_ping_pong_buffer;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_init_ping_pong_buffer);
+
 /**
  * abe_read_offset_from_ping_buffer
  * @id: ABE port ID
- * @n:  returned address of the offset from the ping buffer start address expressed in samples
+ * @n:  returned address of the offset
+ *	from the ping buffer start address (in samples)
  *
- * Computes the current firmware ping pong read pointer location, expressed in samples,
- * as the offset from the start address of ping buffer.
+ * Computes the current firmware ping pong read pointer location,
+ * expressed in samples, as the offset from the start address of ping buffer.
  */
-abehal_status abe_read_offset_from_ping_buffer(u32 id, u32 *n)
+int abe_read_offset_from_ping_buffer(u32 id, u32 *n)
 {
 	u32 sio_pp_desc_address;
+	ABE_SPingPongDescriptor desc_pp;
+
 	/* ping_pong is only supported on MM_DL */
 	if (MM_DL_PORT != id) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	} else {
 		/* read the port SIO ping pong descriptor */
 		sio_pp_desc_address = D_PingPongDesc_ADDR;
@@ -709,19 +641,24 @@
 		   the value of the counter */
 		if ((desc_pp.counter & 0x1) == 0) {
 			/* the next is buffer0, hence the current is buffer1 */
-			if (abe_port[MM_DL_PORT].format.samp_format &
-			    (MONO_MSB | MONO_RSHIFTED_16 | STEREO_16_16)) {
+			switch (abe_port[MM_DL_PORT].format.samp_format) {
+			case MONO_MSB:
+			case MONO_RSHIFTED_16:
+			case STEREO_16_16:
 				*n = abe_size_pingpong / 4 +
 					desc_pp.nextbuff1_Samples -
 					desc_pp.workbuff_Samples;
-			} else if (abe_port[MM_DL_PORT].format.samp_format &
-				    (STEREO_MSB | STEREO_RSHIFTED_16)) {
+				break;
+			case STEREO_MSB:
+			case STEREO_RSHIFTED_16:
 				*n = abe_size_pingpong / 8 +
 					desc_pp.nextbuff1_Samples -
 					desc_pp.workbuff_Samples;
-			} else {
-				abe_dbg_param |= ERR_API;
+				break;
+			default:
+				abe->dbg_param |= ERR_API;
 				abe_dbg_error_log(ABE_PARAMETER_ERROR);
+				return -EINVAL;
 			}
 		} else {
 			/* the next is buffer1, hence the current is buffer0 */
@@ -729,9 +666,11 @@
 				desc_pp.workbuff_Samples;
 		}
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_offset_from_ping_buffer);
+
 /**
  * abe_plug_subroutine
  * @id: returned sequence index after plugging a new subroutine
@@ -741,23 +680,25 @@
  *
  * register a list of subroutines for call-back purpose
  */
-abehal_status abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,
-				  u32 *params)
+int abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,
+			  u32 *params)
 {
 	_log(id_plug_subroutine, (u32) (*id), (u32) f, n);
 	abe_add_subroutine(id, (abe_subroutine2) f, n, (u32 *) params);
 	return 0;
 }
 EXPORT_SYMBOL(abe_plug_subroutine);
+
 /**
  * abe_set_sequence_time_accuracy
  * @fast: fast counter
  * @slow: slow counter
  *
  */
-abehal_status abe_set_sequence_time_accuracy(u32 fast, u32 slow)
+int abe_set_sequence_time_accuracy(u32 fast, u32 slow)
 {
 	u32 data;
+
 	_log(id_set_sequence_time_accuracy, fast, slow, 0);
 	data = minimum(MAX_UINT16, fast / FW_SCHED_LOOP_FREQ_DIV1000);
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_fastCounter_ADDR,
@@ -768,6 +709,7 @@
 	return 0;
 }
 EXPORT_SYMBOL(abe_set_sequence_time_accuracy);
+
 /**
  * abe_reset_port
  * @id: ABE port ID
@@ -776,13 +718,14 @@
  * processing features.
  * Clears the internal AE buffers.
  */
-abehal_status abe_reset_port(u32 id)
+int abe_reset_port(u32 id)
 {
 	_log(id_reset_port, id, 0, 0);
 	abe_port[id] = ((abe_port_t *) abe_port_init)[id];
 	return 0;
 }
 EXPORT_SYMBOL(abe_reset_port);
+
 /**
  * abe_read_remaining_data
  * @id:	ABE port_ID
@@ -790,9 +733,11 @@
  *
  * computes the remaining amount of data in the buffer.
  */
-abehal_status abe_read_remaining_data(u32 port, u32 *n)
+int abe_read_remaining_data(u32 port, u32 *n)
 {
 	u32 sio_pp_desc_address;
+	ABE_SPingPongDescriptor desc_pp;
+
 	_log(id_read_remaining_data, port, 0, 0);
 	/*
 	 * read the port SIO descriptor and extract the
@@ -800,11 +745,13 @@
 	 */
 	sio_pp_desc_address = D_PingPongDesc_ADDR;
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, sio_pp_desc_address,
-		       (u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));
+			(u32 *) &desc_pp, sizeof(ABE_SPingPongDescriptor));
 	*n = desc_pp.workbuff_Samples;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_remaining_data);
+
 /**
  * abe_disable_data_transfer
  * @id: ABE port id
@@ -813,40 +760,16 @@
  * disable the IO task (@f = 0)
  * clear ATC DMEM buffer, ATC enabled
  */
-abehal_status abe_disable_data_transfer(u32 id)
+int abe_disable_data_transfer(u32 id)
 {
 	abe_port_protocol_t *protocol;
+
 	_log(id_disable_data_transfer, id, 0, 0);
-	/* there is only one PDM_DL physical port shared
-	   with DL1/DL2/VIB. Here is a check for the need to stop
-	   PDM_DL if some activity is already on */
-	if (id == PDM_DL1_PORT) {
-		pdm_dl1_status = 0;
-		if (pdm_dl2_status || pdm_vib_status)
-			return 0;
-		else
-			id = PDM_DL_PORT;
-	}
-	if (id == PDM_DL2_PORT) {
-		pdm_dl2_status = 0;
-		if (pdm_dl1_status || pdm_vib_status)
-			return 0;
-		else
-			id = PDM_DL_PORT;
-	}
-	if (id == PDM_VIB_PORT) {
-		pdm_vib_status = 0;
-		if (pdm_dl1_status || pdm_dl2_status)
-			return 0;
-		else
-			id = PDM_DL_PORT;
-	}
 	/* MM_DL managed in ping-pong */
 	if (id == MM_DL_PORT) {
 		protocol = &(abe_port[MM_DL_PORT].protocol);
-		if (protocol->protocol_switch == PINGPONG_PORT_PROT) {
+		if (protocol->protocol_switch == PINGPONG_PORT_PROT)
 			abe_disable_pp_io_task(MM_DL_PORT);
-		}
 	}
 	/* local host variable status= "port is running" */
 	abe_port[id].status = OMAP_ABE_PORT_ACTIVITY_IDLE;
@@ -857,9 +780,11 @@
 	abe_clean_temporary_buffers(id);
 	/* select the main port based on the desactivation of this port */
 	abe_decide_main_port();
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_disable_data_transfer);
+
 /**
  * abe_enable_data_transfer
  * @ip: ABE port id
@@ -868,35 +793,12 @@
  * reset ATC pointers
  * enable the IO task (@f <> 0)
  */
-abehal_status abe_enable_data_transfer(u32 id)
+int abe_enable_data_transfer(u32 id)
 {
 	abe_port_protocol_t *protocol;
 	abe_data_format_t format;
+
 	_log(id_enable_data_transfer, id, 0, 0);
-	/* there is only one PDM_DL physical port shared
-	   with DL1/DL2/VIB. Here is a check for the need to enable
-	   PDM_DL when some activity is already on */
-	if (id == PDM_DL1_PORT) {
-		id = PDM_DL_PORT;
-		if (pdm_dl1_status == 1)
-			return 0;
-		else
-			pdm_dl1_status = 1;
-	}
-	if (id == PDM_DL2_PORT) {
-		id = PDM_DL_PORT;
-		if (pdm_dl2_status == 1)
-			return 0;
-		else
-			pdm_dl2_status = 1;
-	}
-	if (id == PDM_VIB_PORT) {
-		id = PDM_DL_PORT;
-		if (pdm_vib_status == 1)
-			return 0;
-		else
-			pdm_vib_status = 1;
-	}
 	abe_clean_temporary_buffers(id);
 	if (id == PDM_UL_PORT) {
 		/* initializes the ABE ATC descriptors in DMEM - MCPDM_UL */
@@ -915,9 +817,8 @@
 	/* MM_DL managed in ping-pong */
 	if (id == MM_DL_PORT) {
 		protocol = &(abe_port[MM_DL_PORT].protocol);
-		if (protocol->protocol_switch == PINGPONG_PORT_PROT) {
+		if (protocol->protocol_switch == PINGPONG_PORT_PROT)
 			abe_enable_pp_io_task(MM_DL_PORT);
-		}
 	}
 	if (id == DMIC_PORT) {
 		/* one DMIC port enabled = all DMICs enabled,
@@ -941,9 +842,11 @@
 	abe_enable_dma_request(id);
 	/* select the main port based on the activation of this new port */
 	abe_decide_main_port();
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_enable_data_transfer);
+
 /**
  * abe_connect_cbpr_dmareq_port
  * @id: port name
@@ -955,8 +858,8 @@
  * enables the data echange between a DMA and the ABE through the
  *	CBPr registers of AESS.
  */
-abehal_status abe_connect_cbpr_dmareq_port(u32 id, abe_data_format_t *f, u32 d,
-					   abe_dma_t *returned_dma_t)
+int abe_connect_cbpr_dmareq_port(u32 id, abe_data_format_t *f, u32 d,
+				   abe_dma_t *returned_dma_t)
 {
 	_log(id_connect_cbpr_dmareq_port, id, f->f, f->samp_format);
 	abe_port[id] = ((abe_port_t *) abe_port_init)[id];
@@ -966,18 +869,20 @@
 	abe_port[id].protocol.p.prot_dmareq.dma_addr = ABE_DMASTATUS_RAW;
 	abe_port[id].protocol.p.prot_dmareq.dma_data = (1 << d);
 	abe_port[id].status = OMAP_ABE_PORT_INITIALIZED;
+	/* load the dma_t with physical information from AE memory mapping */
+	abe_init_dma_t(id, &((abe_port[id]).protocol));
 	/* load the micro-task parameters */
 	abe_init_io_tasks(id, &((abe_port[id]).format),
 			  &((abe_port[id]).protocol));
-	/* load the dma_t with physical information from AE memory mapping */
-	abe_init_dma_t(id, &((abe_port[id]).protocol));
 	/* load the ATC descriptors - disabled */
 	abe_init_atc(id);
 	/* return the dma pointer address */
 	abe_read_port_address(id, returned_dma_t);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_cbpr_dmareq_port);
+
 /**
  * abe_connect_dmareq_ping_pong_port
  * @id: port name
@@ -991,16 +896,18 @@
  * the DMEM memory of ABE. On each dma_request activation the DMA will exchange
  * "s" bytes and switch to the "pong" buffer for a new buffer exchange.
  */
-abehal_status abe_connect_dmareq_ping_pong_port(u32 id, abe_data_format_t *f,
-						u32 d, u32 s,
-						abe_dma_t *returned_dma_t)
+int abe_connect_dmareq_ping_pong_port(u32 id, abe_data_format_t *f,
+					u32 d, u32 s,
+					abe_dma_t *returned_dma_t)
 {
 	abe_dma_t dma1;
+
 	_log(id_connect_dmareq_ping_pong_port, id, f->f, f->samp_format);
 	/* ping_pong is only supported on MM_DL */
 	if (id != MM_DL_PORT) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	}
 	/* declare PP buffer and prepare the returned dma_t */
 	abe_init_ping_pong_buffer(MM_DL_PORT, s, 2,
@@ -1019,12 +926,15 @@
 			  &((abe_port[id]).protocol));
 	/* load the dma_t with physical information from AE memory mapping */
 	abe_init_dma_t(id, &((abe_port[id]).protocol));
-	dma1.data = (u32 *) (abe_port[id].dma.data + ABE_DMEM_BASE_ADDRESS_L3);
+	dma1.data = (u32 *) (abe_port[id].dma.data +
+		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
 	dma1.iter = abe_port[id].dma.iter;
 	*returned_dma_t = dma1;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_dmareq_ping_pong_port);
+
 /**
  * abe_connect_irq_ping_pong_port
  * @id: port name
@@ -1040,15 +950,16 @@
  * "abe_set_ping_pong_buffer" to notify the new amount of samples in the
  * pong buffer.
  */
-abehal_status abe_connect_irq_ping_pong_port(u32 id, abe_data_format_t *f,
+int abe_connect_irq_ping_pong_port(u32 id, abe_data_format_t *f,
 					     u32 subroutine_id, u32 size,
 					     u32 *sink, u32 dsp_mcu_flag)
 {
 	_log(id_connect_irq_ping_pong_port, id, f->f, f->samp_format);
 	/* ping_pong is only supported on MM_DL */
 	if (id != MM_DL_PORT) {
-		abe_dbg_param |= ERR_API;
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
+		return -EINVAL;
 	}
 	abe_port[id] = ((abe_port_t *) abe_port_init)[id];
 	(abe_port[id]).format = (*f);
@@ -1071,9 +982,11 @@
 	/* load the ATC descriptors - disabled */
 	abe_init_atc(id);
 	*sink = (abe_port[id]).protocol.p.prot_pingpong.buf_addr;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_irq_ping_pong_port);
+
 /**
  * abe_connect_serial_port()
  * @id: port name
@@ -1085,8 +998,8 @@
  * voice streams to VX_UL, VX_DL, BT_VX_UL, BT_VX_DL. It abstracts the
  * abe_write_port API.
  */
-abehal_status abe_connect_serial_port(u32 id, abe_data_format_t *f,
-				      u32 mcbsp_id)
+int abe_connect_serial_port(u32 id, abe_data_format_t *f,
+			      u32 mcbsp_id)
 {
 	u32 UC_NULL[] = { 0 };
 	u32 OPP;
@@ -1107,9 +1020,11 @@
 			  &((abe_port[id]).protocol));
 	/* load the ATC descriptors - disabled */
 	abe_init_atc(id);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_serial_port);
+
 /**
  * abe_connect_slimbus_port
  * @id: port name
@@ -1120,15 +1035,14 @@
  * enables the data echanges between 1/2 SB and an ATC buffers in
  * DMEM.
  */
-abehal_status abe_connect_slimbus_port(u32 id, abe_data_format_t *f,
-				       u32 sb_port1, u32 sb_port2)
+int abe_connect_slimbus_port(u32 id, abe_data_format_t *f,
+			       u32 sb_port1, u32 sb_port2)
 {
-	u32 UC_NULL[] = {
-		0
-	};
+	u32 UC_NULL[] = { 0 };
 	u32 OPP;
 	abe_hw_config_init_t CONFIG;
 	u32 iter;
+
 	_log(id_connect_slimbus_port, id, f->samp_format, sb_port2);
 	abe_port[id] = ((abe_port_t *) abe_port_init)[id];
 	(abe_port[id]).format = (*f);
@@ -1148,9 +1062,11 @@
 			  &((abe_port[id]).protocol));
 	/* load the ATC descriptors - disabled */
 	abe_init_atc(id);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_slimbus_port);
+
 /**
  * abe_connect_tdm_port
  * @id: port name
@@ -1161,12 +1077,13 @@
  * enables the data echanges between TDM McBSP ATC buffers in
  * DMEM and 1/2 SMEM buffers
  */
-abehal_status abe_connect_tdm_port(u32 id, abe_data_format_t *f, u32 mcbsp_id)
+int abe_connect_tdm_port(u32 id, abe_data_format_t *f, u32 mcbsp_id)
 {
 	u32 UC_NULL[] = { 0 };
 	u32 OPP;
 	abe_hw_config_init_t CONFIG;
 	u32 iter;
+
 	_log(id_connect_tdm_port, id, f->samp_format, mcbsp_id);
 	abe_port[id] = ((abe_port_t *) abe_port_init)[id];
 	(abe_port[id]).format = (*f);
@@ -1187,9 +1104,11 @@
 			  &((abe_port[id]).protocol));
 	/* load the ATC descriptors - disabled */
 	abe_init_atc(id);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_tdm_port);
+
 /**
  * abe_read_port_address
  * @dma: output pointer to the DMA iteration and data destination pointer
@@ -1198,39 +1117,44 @@
  * Depending on the protocol being used, adds the base address offset L3
  * (DMA) or MPU (ARM)
  */
-abehal_status abe_read_port_address(u32 port, abe_dma_t *dma2)
+int abe_read_port_address(u32 port, abe_dma_t *dma2)
 {
 	abe_dma_t_offset dma1;
 	u32 protocol_switch;
+
 	_log(id_read_port_address, port, 0, 0);
 	dma1 = (abe_port[port]).dma;
 	protocol_switch = abe_port[port].protocol.protocol_switch;
 	switch (protocol_switch) {
 	case PINGPONG_PORT_PROT:
 		/* return the base address of the buffer in L3 and L4 spaces */
-		(*dma2).data = (void *)(dma1.data + ABE_DMEM_BASE_ADDRESS_L3);
-		(*dma2).l3_dmem =
-			(void *)(dma1.data + ABE_DMEM_BASE_ADDRESS_L3);
-		(*dma2).l4_dmem =
-			(void *)(dma1.data + ABE_DMEM_BASE_ADDRESS_L4);
+		(*dma2).data = (void *)(dma1.data +
+			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
+		(*dma2).l3_dmem = (void *)(dma1.data +
+			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
+		(*dma2).l4_dmem = (void *)(dma1.data +
+			ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);
 		break;
 	case DMAREQ_PORT_PROT:
 		/* return the CBPr(L3), DMEM(L3), DMEM(L4) address */
-		(*dma2).data = (void *)(dma1.data + ABE_ATC_BASE_ADDRESS_L3);
+		(*dma2).data = (void *)(dma1.data +
+			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_ATC_BASE_OFFSET_MPU);
 		(*dma2).l3_dmem =
-			(void *)((abe_port[port]).protocol.p.prot_dmareq.
-				 buf_addr + ABE_DMEM_BASE_ADDRESS_L3);
+			(void *)((abe_port[port]).protocol.p.prot_dmareq.buf_addr +
+			ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
 		(*dma2).l4_dmem =
-			(void *)((abe_port[port]).protocol.p.prot_dmareq.
-				 buf_addr + ABE_DMEM_BASE_ADDRESS_L4);
+			(void *)((abe_port[port]).protocol.p.prot_dmareq.buf_addr +
+			ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);
 		break;
 	default:
 		break;
 	}
 	(*dma2).iter = (dma1.iter);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_port_address);
+
 /*
  *  ABE_SELECT_DATA_SOURCE
  *
@@ -1253,11 +1177,13 @@
  *  Operations :
  *
  *  Return value :
- *      None.
+ *      status
  */
-abehal_status abe_select_data_source(u32 port_id, u32 smem_source)
+int abe_select_data_source(u32 port_id, u32 smem_source)
 {
 	u32 sio_desc_address;
+	ABE_SIODescriptor sio_desc;
+
 	sio_desc_address = dmem_port_descriptors +
 		(port_id * sizeof(ABE_SIODescriptor));
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
@@ -1265,9 +1191,11 @@
 	sio_desc.smem_addr1 = (u16) smem_source;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       sio_desc_address, (u32 *) &sio_desc, sizeof(sio_desc));
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_select_data_source);
+
 /**
  * abe_write_equalizer
  * @id: name of the equalizer
@@ -1275,9 +1203,10 @@
  *
  * Load the coefficients in CMEM.
  */
-abehal_status abe_write_equalizer(u32 id, abe_equ_t *param)
+int abe_write_equalizer(u32 id, abe_equ_t *param)
 {
 	u32 eq_offset, length, *src, eq_mem, eq_mem_len;
+
 	_log(id_write_equalizer, id, 0, 0);
 	switch (id) {
 	default:
@@ -1340,9 +1269,11 @@
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, eq_offset, src, length);
 	/* reset SMEM buffers after the coefficients are loaded */
 	abe_reset_mem(ABE_SMEM, eq_mem << 3, eq_mem_len << 3);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_write_equalizer);
+
 /**
  * abe_write_asrc
  * @id: name of the port
@@ -1355,10 +1286,11 @@
  * or vice versa, there will be click in the output signal. Loading the drift
  * value with zero disables the feature.
  */
-abehal_status abe_write_asrc(u32 port, s32 dppm)
+int abe_write_asrc(u32 port, s32 dppm)
 {
 	s32 dtempvalue, adppm, drift_sign, drift_sign_addr, alpha_params_addr;
 	s32 alpha_params[3];
+
 	_log(id_write_asrc, port, dppm, dppm >> 8);
 	/*
 	 * x = ppm
@@ -1410,28 +1342,28 @@
 		alpha_params[2] = (0x00100000 - (dtempvalue / 2)) << 2;
 	}
 	switch (port) {
-		/* asynchronous sample-rate-converter for the uplink voice path */
+	/* asynchronous sample-rate-converter for the uplink voice path */
 	case VX_DL_PORT:
 		drift_sign_addr = D_AsrcVars_DL_VX_ADDR + (1 * sizeof(s32));
 		alpha_params_addr = D_AsrcVars_DL_VX_ADDR + (3 * sizeof(s32));
 		break;
-		/* asynchronous sample-rate-converter for the downlink voice path */
+	/* asynchronous sample-rate-converter for the downlink voice path */
 	case VX_UL_PORT:
 		drift_sign_addr = D_AsrcVars_UL_VX_ADDR + (1 * sizeof(s32));
 		alpha_params_addr = D_AsrcVars_UL_VX_ADDR + (3 * sizeof(s32));
 		break;
-		/* asynchronous sample-rate-converter for the BT_UL path */
+	/* asynchronous sample-rate-converter for the BT_UL path */
 	case BT_VX_UL_PORT:
 		drift_sign_addr = D_AsrcVars_BT_UL_ADDR + (1 * sizeof(s32));
 		alpha_params_addr = D_AsrcVars_BT_UL_ADDR + (3 * sizeof(s32));
 		break;
-		/* asynchronous sample-rate-converter for the BT_DL path */
+	/* asynchronous sample-rate-converter for the BT_DL path */
 	case BT_VX_DL_PORT:
 		drift_sign_addr = D_AsrcVars_BT_DL_ADDR + (1 * sizeof(s32));
 		alpha_params_addr = D_AsrcVars_BT_DL_ADDR + (3 * sizeof(s32));
 		break;
 	default:
-		/* asynchronous sample-rate-converter for the MM_EXT_IN path */
+	/* asynchronous sample-rate-converter for the MM_EXT_IN path */
 	case MM_EXT_IN_PORT:
 		drift_sign_addr = D_AsrcVars_MM_EXT_IN_ADDR + (1 * sizeof(s32));
 		alpha_params_addr =
@@ -1442,9 +1374,11 @@
 		       (u32 *) &drift_sign, 4);
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, alpha_params_addr,
 		       (u32 *) &alpha_params[0], 12);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_write_asrc);
+
 /**
  * abe_write_aps
  * @id: name of the aps filter
@@ -1456,12 +1390,13 @@
  * activated".
  * Loading all the coefficients value with zero disables the feature.
  */
-abehal_status abe_write_aps(u32 id, abe_aps_t *param)
+int abe_write_aps(u32 id, abe_aps_t *param)
 {
 	_log(id_write_aps, id, 0, 0);
 	return 0;
 }
 EXPORT_SYMBOL(abe_write_aps);
+
 /**
  * abe_use_compensated_gain
  * @on_off:
@@ -1470,12 +1405,13 @@
  * on_off = 1 allows the "abe_write_gain" to adjust the overall
  * gains of the mixer to be tuned not to create saturation
  */
-abehal_status abe_use_compensated_gain(u32 on_off)
+int abe_use_compensated_gain(u32 on_off)
 {
-	abe_compensated_mixer_gain = on_off;
+	abe->compensated_mixer_gain = on_off;
 	return 0;
 }
 EXPORT_SYMBOL(abe_use_compensated_gain);
+
 /**
  * abe_disable_gain
  * Parameters:
@@ -1483,26 +1419,29 @@
  *	sub-port id
  *
  */
-abehal_status abe_disable_gain(u32 id, u32 p)
+int abe_disable_gain(u32 id, u32 p)
 {
 	u32 mixer_offset, f_g, ramp;
 	abe_gain_offset(id, &mixer_offset);
+
 	/* save the input parameters for mute/unmute */
-	ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
+	ramp = abe->desired_ramp_delay_ms[mixer_offset + p];
 	f_g = GAIN_MUTE;
-	if (!(abe_muted_gains_indicator[mixer_offset + p] & 0x02)) {
+	if (!(abe->muted_gains_indicator[mixer_offset + p] & 0x02)) {
 		/* Check if we are in mute */
-		if (!(abe_muted_gains_indicator[mixer_offset + p] & 0x01)) {
-			abe_muted_gains_decibel[mixer_offset + p] =
-				abe_desired_gains_decibel[mixer_offset + p];
+		if (!(abe->muted_gains_indicator[mixer_offset + p] & 0x01)) {
+			abe->muted_gains_decibel[mixer_offset + p] =
+				abe->desired_gains_decibel[mixer_offset + p];
 			/* mute the gain */
 			abe_write_gain(id, f_g, ramp, p);
 		}
-		abe_muted_gains_indicator[mixer_offset + p] |= 0x02;
+		abe->muted_gains_indicator[mixer_offset + p] |= 0x02;
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_disable_gain);
+
 /**
  * abe_enable_gain
  * Parameters:
@@ -1510,21 +1449,24 @@
  *	sub-port id
  *
  */
-abehal_status abe_enable_gain(u32 id, u32 p)
+int abe_enable_gain(u32 id, u32 p)
 {
 	u32 mixer_offset, f_g, ramp;
+
 	abe_gain_offset(id, &mixer_offset);
-	if ((abe_muted_gains_indicator[mixer_offset + p] & 0x02)) {
+	if ((abe->muted_gains_indicator[mixer_offset + p] & 0x02)) {
 		/* restore the input parameters for mute/unmute */
-		f_g = abe_muted_gains_decibel[mixer_offset + p];
-		ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
-		abe_muted_gains_indicator[mixer_offset + p] &= ~0x02;
+		f_g = abe->muted_gains_decibel[mixer_offset + p];
+		ramp = abe->desired_ramp_delay_ms[mixer_offset + p];
+		abe->muted_gains_indicator[mixer_offset + p] &= ~0x02;
 		/* unmute the gain */
 		abe_write_gain(id, f_g, ramp, p);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_enable_gain);
+
 /**
  * abe_mute_gain
  * Parameters:
@@ -1532,23 +1474,26 @@
  *	sub-port id
  *
  */
-abehal_status abe_mute_gain(u32 id, u32 p)
+int abe_mute_gain(u32 id, u32 p)
 {
 	u32 mixer_offset, f_g, ramp;
+
 	abe_gain_offset(id, &mixer_offset);
 	/* save the input parameters for mute/unmute */
-	ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
+	ramp = abe->desired_ramp_delay_ms[mixer_offset + p];
 	f_g = GAIN_MUTE;
-	if (!abe_muted_gains_indicator[mixer_offset + p]) {
-		abe_muted_gains_decibel[mixer_offset + p] =
-			abe_desired_gains_decibel[mixer_offset + p];
+	if (!abe->muted_gains_indicator[mixer_offset + p]) {
+		abe->muted_gains_decibel[mixer_offset + p] =
+			abe->desired_gains_decibel[mixer_offset + p];
 		/* mute the gain */
 		abe_write_gain(id, f_g, ramp, p);
 	}
-	abe_muted_gains_indicator[mixer_offset + p] |= 0x01;
+	abe->muted_gains_indicator[mixer_offset + p] |= 0x01;
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_mute_gain);
+
 /**
  * abe_unmute_gain
  * Parameters:
@@ -1556,40 +1501,45 @@
  *	sub-port id
  *
  */
-abehal_status abe_unmute_gain(u32 id, u32 p)
+int abe_unmute_gain(u32 id, u32 p)
 {
 	u32 mixer_offset, f_g, ramp;
+
 	abe_gain_offset(id, &mixer_offset);
-	if ((abe_muted_gains_indicator[mixer_offset + p] & 0x01)) {
+	if ((abe->muted_gains_indicator[mixer_offset + p] & 0x01)) {
 		/* restore the input parameters for mute/unmute */
-		f_g = abe_muted_gains_decibel[mixer_offset + p];
-		ramp = abe_desired_ramp_delay_ms[mixer_offset + p];
-		abe_muted_gains_indicator[mixer_offset + p] &= ~0x01;
+		f_g = abe->muted_gains_decibel[mixer_offset + p];
+		ramp = abe->desired_ramp_delay_ms[mixer_offset + p];
+		abe->muted_gains_indicator[mixer_offset + p] &= ~0x01;
 		/* unmute the gain */
 		abe_write_gain(id, f_g, ramp, p);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_unmute_gain);
+
 /**
- * abe_write_mixer
- * @id: name of the mixer
- * @param: list of input gains of the mixer
- * @p: list of port corresponding to the above gains
+ * abe_write_gain
+ * @id: gain name or mixer name
+ * @f_g: list of input gains of the mixer
+ * @ramp: gain ramp speed factor
+ * @p: list of ports corresponding to the above gains
  *
- * Load the gain coefficients in FW memory. This API can be called when
+ * Loads the gain coefficients to FW memory. This API can be called when
  * the corresponding MIXER is not activated. After reloading the firmware
  * the default coefficients corresponds to "all input and output mixer's gain
  * in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p)
+int abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p)
 {
 	u32 lin_g, sum_g, mixer_target, mixer_offset, i, mean_gain, mean_exp;
 	u32 new_gain_linear[4];
 	s32 gain_index;
 	u32 alpha, beta;
 	u32 ramp_index;
+
 	_log(id_write_gain, id, f_g, p);
 	gain_index = ((f_g - min_mdb) / 100);
 	gain_index = maximum(gain_index, 0);
@@ -1597,16 +1547,16 @@
 	lin_g = abe_db2lin_table[gain_index];
 	abe_gain_offset(id, &mixer_offset);
 	/* save the input parameters for mute/unmute */
-	abe_desired_gains_linear[mixer_offset + p] = lin_g;
-	abe_desired_gains_decibel[mixer_offset + p] = f_g;
-	abe_desired_ramp_delay_ms[mixer_offset + p] = ramp;
+	abe->desired_gains_linear[mixer_offset + p] = lin_g;
+	abe->desired_gains_decibel[mixer_offset + p] = f_g;
+	abe->desired_ramp_delay_ms[mixer_offset + p] = ramp;
 	/* SMEM word32 address */
 	mixer_target = (S_GTarget1_ADDR << 1);
 	mixer_target += mixer_offset;
 	mixer_target += p;
 	/* translate coef address in Bytes */
 	mixer_target <<= 2;
-	if (abe_compensated_mixer_gain) {
+	if (abe->compensated_mixer_gain) {
 		switch (id) {
 		case MIXDL1:
 		case MIXDL2:
@@ -1614,8 +1564,8 @@
 		case MIXAUDUL:
 			/* compute the sum of the gain of the mixer */
 			for (sum_g = i = 0; i < 4; i++)
-				sum_g += abe_desired_gains_linear[mixer_offset +
-								  i];
+				sum_g += abe->desired_gains_linear[
+						mixer_offset + i];
 			/* lets avoid a division by 0 */
 			if (sum_g == 0)
 				break;
@@ -1632,7 +1582,7 @@
 			for (i = 0; i < 4; i++) {
 				/* new gain = desired gain divided by sum of gains */
 				new_gain_linear[i] =
-					(abe_desired_gains_linear
+					(abe->desired_gains_linear
 					 [mixer_offset + i]
 					 << 8) / mean_gain;
 				new_gain_linear[i] = (mean_exp > 0) ?
@@ -1652,14 +1602,14 @@
 			break;
 		}
 	} else {
-		if (!abe_muted_gains_indicator[mixer_offset + p])
+		if (!abe->muted_gains_indicator[mixer_offset + p])
 			/* load the S_G_Target SMEM table */
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM,
 				       mixer_target, (u32 *) &lin_g,
 				       sizeof(lin_g));
 		else
 			/* update muted gain with new value */
-			abe_muted_gains_decibel[mixer_offset + p] = f_g;
+			abe->muted_gains_decibel[mixer_offset + p] = f_g;
 	}
 	ramp = maximum(minimum(RAMP_MAXLENGTH, ramp), RAMP_MINLENGTH);
 	/* ramp data should be interpolated in the table instead */
@@ -1689,9 +1639,11 @@
 	mixer_target <<= 2;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_CMEM, mixer_target,
 		       (u32 *) &beta, sizeof(beta));
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_write_gain);
+
 /**
  * abe_write_mixer
  * @id: name of the mixer
@@ -1704,13 +1656,14 @@
  * gain in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_write_mixer(u32 id, s32 f_g, u32 f_ramp, u32 p)
+int abe_write_mixer(u32 id, s32 f_g, u32 f_ramp, u32 p)
 {
 	_log(id_write_mixer, id, f_ramp, p);
 	abe_write_gain(id, f_g, f_ramp, p);
 	return 0;
 }
 EXPORT_SYMBOL(abe_write_mixer);
+
 /**
  * abe_read_gain
  * @id: name of the mixer
@@ -1718,9 +1671,10 @@
  * @p: list of port corresponding to the above gains
  *
  */
-abehal_status abe_read_gain(u32 id, u32 *f_g, u32 p)
+int abe_read_gain(u32 id, u32 *f_g, u32 p)
 {
 	u32 mixer_target, mixer_offset, i;
+
 	_log(id_read_gain, id, (u32) f_g, p);
 	abe_gain_offset(id, &mixer_offset);
 	/* SMEM word32 address */
@@ -1729,8 +1683,7 @@
 	mixer_target += p;
 	/* translate coef address in Bytes */
 	mixer_target <<= 2;
-
-	if (!abe_muted_gains_indicator[mixer_offset + p]) {
+	if (!abe->muted_gains_indicator[mixer_offset + p]) {
 		/* load the S_G_Target SMEM table */
 		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_SMEM, mixer_target,
 			       (u32 *) f_g, sizeof(*f_g));
@@ -1744,12 +1697,13 @@
 		*f_g = (i * 100) + min_mdb;
 	} else {
 		/* update muted gain with new value */
-		*f_g = abe_muted_gains_decibel[mixer_offset + p];
+		*f_g = abe->muted_gains_decibel[mixer_offset + p];
 	}
 
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_gain);
+
 /**
  * abe_read_mixer
  * @id: name of the mixer
@@ -1762,13 +1716,14 @@
  * gain in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_read_mixer(u32 id, u32 *f_g, u32 p)
+int abe_read_mixer(u32 id, u32 *f_g, u32 p)
 {
 	_log(id_read_mixer, id, 0, p);
 	abe_read_gain(id, f_g, p);
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_mixer);
+
 /**
  * abe_set_router_configuration
  * @Id: name of the router
@@ -1792,89 +1747,97 @@
  * indexes 14 .. 15 = RESERVED (NULL)
  *	ZERO_labelID, ZERO_labelID,
  */
-abehal_status abe_set_router_configuration(u32 id, u32 k, u32 *param)
+int abe_set_router_configuration(u32 id, u32 k, u32 *param)
 {
 	_log(id_set_router_configuration, id, (u32) param, (u32) param >> 8);
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-		       D_aUplinkRouting_ADDR, param, D_aUplinkRouting_sizeof);
+			       D_aUplinkRouting_ADDR,
+			       param, D_aUplinkRouting_sizeof);
 	return 0;
 }
 EXPORT_SYMBOL(abe_set_router_configuration);
+
 /**
  * ABE_READ_DEBUG_TRACE
  *
- * Parameter :
- *	data destination pointer
- *	max number of data read
+ * Parameters :
+ * @data: data destination pointer
+ * @n	: max number of read data
  *
  * Operations :
- *	reads the AE circular data pointer holding pairs of debug data+
- * 	timestamps, and store the pairs in linear addressing to the parameter
- * 	pointer. Stops the copy when the max parameter is reached or when the
- * 	FIFO is empty.
+ * Reads the AE circular data pointer that holds pairs of debug data +
+ * timestamps, and stores the pairs, via linear addressing, to the parameter
+ * pointer.
+ * Stops the copy when the max parameter is reached or when the FIFO is empty.
  *
  * Return value :
- *	None.
+ *	status
  */
-abehal_status abe_read_debug_trace(u32 *data, u32 *n)
+int abe_read_debug_trace(u32 *data, u32 *n)
 {
 	_log(id_select_data_source, 0, 0, 0);
 	return 0;
 }
 EXPORT_SYMBOL(abe_read_debug_trace);
+
 /**
  * abe_connect_debug_trace
  * @dma2:pointer to the DMEM trace buffer
  *
  * returns the address and size of the real-time debug trace buffer,
- * the content of which will vary from one firmware release to an other
+ * the content of which will vary from one firmware release to another
  */
-abehal_status abe_connect_debug_trace(abe_dma_t *dma2)
+int abe_connect_debug_trace(abe_dma_t *dma2)
 {
 	_log(id_connect_debug_trace, 0, 0, 0);
 	/* return the base address of the ping buffer in L3 and L4 spaces */
-	(*dma2).data = (void *)(D_DEBUG_FIFO_ADDR + ABE_DMEM_BASE_ADDRESS_L3);
-	(*dma2).l3_dmem =
-		(void *)(D_DEBUG_FIFO_ADDR + ABE_DMEM_BASE_ADDRESS_L3);
-	(*dma2).l4_dmem =
-		(void *)(D_DEBUG_FIFO_ADDR + ABE_DMEM_BASE_ADDRESS_L4);
-	(*dma2).iter = D_DEBUG_FIFO_sizeof;
+	(*dma2).data = (void *)(D_DEBUG_FIFO_ADDR +
+		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
+	(*dma2).l3_dmem = (void *)(D_DEBUG_FIFO_ADDR +
+		ABE_DEFAULT_BASE_ADDRESS_L3 + ABE_DMEM_BASE_OFFSET_MPU);
+	(*dma2).l4_dmem = (void *)(D_DEBUG_FIFO_ADDR +
+		ABE_DEFAULT_BASE_ADDRESS_L4 + ABE_DMEM_BASE_OFFSET_MPU);
+	(*dma2).iter = (D_DEBUG_FIFO_sizeof + D_DEBUG_FIFO_HAL_sizeof)>>2;
 	return 0;
 }
 EXPORT_SYMBOL(abe_connect_debug_trace);
+
 /**
  * abe_set_debug_trace
  * @debug: debug ID from a list to be defined
  *
- * load a mask which filters the debug trace to dedicated types of data
+ * loads a mask which filters the debug trace to dedicated types of data
  */
-abehal_status abe_set_debug_trace(abe_dbg_t debug)
+int abe_set_debug_trace(abe_dbg_t debug)
 {
 	_log(id_set_debug_trace, 0, 0, 0);
-	abe_dbg_mask = debug;
+	abe->dbg_mask = debug;
 	return 0;
 }
 EXPORT_SYMBOL(abe_set_debug_trace);
+
 /**
  * abe_remote_debugger_interface
  *
  * interpretation of the UART stream from the remote debugger commands.
  * The commands consist in setting break points, loading parameter
  */
-abehal_status abe_remote_debugger_interface(u32 n, u8 *p)
+int abe_remote_debugger_interface(u32 n, u8 *p)
 {
 	_log(id_remote_debugger_interface, n, 0, 0);
 	return 0;
 }
 EXPORT_SYMBOL(abe_remote_debugger_interface);
+
 /**
  * abe_enable_test_pattern
  *
  */
-abehal_status abe_enable_test_pattern(u32 smem_id, u32 on_off)
+int abe_enable_test_pattern(u32 smem_id, u32 on_off)
 {
 	u16 dbg_on, dbg_off, idx_patch, task_patch, addr_patch;
 	u32 patch, task32;
+
 	_log(id_enable_test_pattern, on_off, smem_id, smem_id >> 8);
 	switch (smem_id) {
 	case DBG_PATCH_AMIC:
@@ -1970,15 +1933,17 @@
 		task32 = (0xFFFF0000L & task32) | (0x0000FFFF & patch);
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, addr_patch & (~0x03),
 		       &task32, 4);
+
 	return 0;
 }
 EXPORT_SYMBOL(abe_enable_test_pattern);
+
 /**
  * abe_wakeup - Wakeup ABE
  *
  * Wakeup ABE in case of retention
  */
-abehal_status abe_wakeup(void)
+int abe_wakeup(void)
 {
 	/* Restart event generator */
 	abe_write_event_generator(EVENT_TIMER);
@@ -1987,24 +1952,7 @@
 	return 0;
 }
 EXPORT_SYMBOL(abe_wakeup);
-/**
- * abe_disable_irq - disable MCU/DSP ABE interrupt
- *
- * This subroutine is disabling ABE MCU/DSP Irq
- */
-abehal_status abe_disable_irq(void)
-{
-	u32 atc_reg;
-	/* disables the DMAreq from AESS AESS_DMAENABLE_CLR = 127
-	 * DMA_Req7 will still be enabled as it is used for ABE trace */
-	atc_reg = 0x7F;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC, 0x64, &atc_reg, 4);
-	/* disables the MCU IRQ from AESS to Cortex A9 */
-	atc_reg = 0x01;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC, 0x40, &atc_reg, 4);
-	return 0;
-}
-EXPORT_SYMBOL(abe_disable_irq);
+
 /**
  * abe_check_activity - Check if some ABE activity.
  *
@@ -2013,28 +1961,36 @@
  * return 0: no more activity on ABE. Event generator can be stopped
  *
  */
-u32 abe_check_activity(void)
+int abe_check_activity(void)
 {
-	u32 i;
-	u32 ret;
-	ret = 0;
+	u32 i, ret = 0;
+
 	for (i = 0; i < (LAST_PORT_ID - 1); i++) {
 		if (abe_port[abe_port_priority[i]].status ==
-		    OMAP_ABE_PORT_ACTIVITY_RUNNING)
+				OMAP_ABE_PORT_ACTIVITY_RUNNING)
 			break;
 	}
 	if (i < (LAST_PORT_ID - 1))
 		ret = 1;
+
 	return ret;
 }
 EXPORT_SYMBOL(abe_check_activity);
+
 /**
  * abe_init_mem - Allocate Kernel space memory map for ABE
  *
  * Memory map of ABE memory space for PMEM/DMEM/SMEM/DMEM
  */
-void abe_init_mem(void __iomem *_io_base)
+int abe_init_mem(void __iomem *_io_base)
 {
-	io_base = _io_base;
+	abe = kzalloc(sizeof(struct omap_abe), GFP_KERNEL);
+	if (abe == NULL)
+		return -ENOMEM;
+
+	abe->io_base = _io_base;
+	mutex_init(&abe->mutex);
+
+	return 0;
 }
 EXPORT_SYMBOL(abe_init_mem);
Index: kernel/sound/soc/omap/abe/abe_api.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_api.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_api.h	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,6 +20,31 @@
  */
 #ifndef _ABE_API_H_
 #define _ABE_API_H_
+
+#include <linux/string.h>
+#include <linux/mutex.h>
+
+struct omap_abe {
+	void __iomem *io_base;
+	u32 firmware_version_number;
+	u16 MultiFrame[PROCESSING_SLOTS][TASKS_IN_SLOT];
+	u32 compensated_mixer_gain;
+	u8  muted_gains_indicator[MAX_NBGAIN_CMEM];
+	u32 desired_gains_decibel[MAX_NBGAIN_CMEM];
+	u32 muted_gains_decibel[MAX_NBGAIN_CMEM];
+	u32 desired_gains_linear[MAX_NBGAIN_CMEM];
+	u32 desired_ramp_delay_ms[MAX_NBGAIN_CMEM];
+	struct mutex mutex;
+
+	/* Debug Data */
+	u32 irq_dbg_read_ptr;
+	u32 dbg_activity_log[D_DEBUG_HAL_TASK_sizeof];
+	u32 dbg_activity_log_write_pointer;
+	u32 dbg_mask;
+	u32 dbg_param;
+	u32 dbg_output;
+};
+
 /**
  * abe_reset_hal - reset the ABE/HAL
  * @rdev: regulator source
@@ -29,7 +54,8 @@
  * default AESS registers.
  * Called after a PRCM cold-start reset of ABE
  */
-abehal_status abe_reset_hal(void);
+int abe_reset_hal(void);
+
 /**
  * abe_load_fw_param - Load ABE Firmware memories
  * @PMEM: Pointer of Program memory data
@@ -41,29 +67,23 @@
  * @DMEM: Pointer of Data memory data
  * @DMEM_SIZE: Size of DMEM data
  *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
  */
-abehal_status abe_load_fw_param(u32 *FW);
+int abe_load_fw_param(u32 *FW);
+
 /**
- * abe_load_fw - Load ABE Firmware and initialize memories
- *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
+ * abe_reload_fw - Reload ABE Firmware after OFF mode
  */
-abehal_status abe_load_fw(void);
+int abe_reload_fw(void);
+
 /**
- * abe_reload_fw - Reload ABE Firmware after OFF mode
+ * abe_load_fw - Load ABE Firmware and initialize memories
  *
- * loads the Audio Engine firmware, generate a single pulse on the Event
- * generator to let execution start, read the version number returned from
- * this execution.
  */
-abehal_status abe_reload_fw(void);
+int abe_load_fw(void);
+
 /**
- * abe_read_hardware_configuration - Return default HW periferals configuration
+ * abe_read_hardware_configuration - Returns default
+ *	HW periferals configuration
  * @u: use-case description list (pointer)
  * @o: opp mode (pointer)
  * @hw: pointer to the output HW structure
@@ -73,12 +93,12 @@
  * H : pointer to the output structure
  *
  * Operations :
- * return a structure with the HW thresholds compatible with the HAL/FW/AESS_ATC
- * will be upgraded in FW06
- * return a structure with the HW thresholds compatible with the HAL/FW/AESS_ATC
+ * Returns a structure with the HW thresholds compatible with
+ *	the HAL/FW/AESS_ATC. Will be upgraded in FW06.
  */
-abehal_status abe_read_hardware_configuration(u32 *u, u32 *o,
-					      abe_hw_config_init_t *hw);
+int abe_read_hardware_configuration(u32 *u, u32 *o,
+				abe_hw_config_init_t *hw);
+
 /**
  * abe_irq_processing - Process ABE interrupt
  *
@@ -90,36 +110,52 @@
  * the embedded debugger when the firmware stops on programmable break-points,
  * etc ...
  */
-abehal_status abe_irq_processing(void);
+int abe_irq_processing(void);
+
 /**
- * abe_clear_irq - clear ABE interrupt
+ * abe_irq_clear - clear ABE interrupt
  *
  * This subroutine is call to clear MCU Irq
  */
-abehal_status abe_clear_irq(void);
+int abe_clear_irq(void);
+
 /**
  * abe_disable_irq - disable MCU/DSP ABE interrupt
  *
  * This subroutine is disabling ABE MCU/DSP Irq
  */
-abehal_status abe_disable_irq(void);
+int abe_disable_irq(void);
+
 /*
  * abe_check_activity - check all ports are closed
  */
-u32 abe_check_activity(void);
+int abe_check_activity(void);
+
 /**
  * abe_wakeup - Wakeup ABE
  *
  * Wakeup ABE in case of retention
  */
-abehal_status abe_wakeup(void);
+int abe_wakeup(void);
+
 /**
- * abe_stop_event_generator - Stop event generator source
+ * abe_start_event_generator - Stops event generator source
+ *
+ * Start the event genrator of AESS. No more event will be send to AESS engine.
+ * Upper layer must wait 1/96kHz to be sure that engine reaches
+ * the IDLE instruction.
+ */
+int abe_start_event_generator(void);
+
+/**
+ * abe_stop_event_generator - Stops event generator source
  *
  * Stop the event genrator of AESS. No more event will be send to AESS engine.
- * Upper layer needs to wait 1/96kHz to be sure that engine reach IDLE instruction
+ * Upper layer must wait 1/96kHz to be sure that engine reaches
+ * the IDLE instruction.
  */
-abehal_status abe_stop_event_generator(void);
+int abe_stop_event_generator(void);
+
 /**
  * abe_select_main_port - Select stynchronization port for Event generator.
  * @id: audio port name
@@ -127,29 +163,37 @@
  * tells the FW which is the reference stream for adjusting
  * the processing on 23/24/25 slots
  */
-abehal_status abe_select_main_port(u32 id);
+int abe_select_main_port(u32 id);
+
 /**
- * abe_write_event_generator - Select event generator source
+ * abe_write_event_generator - Selects event generator source
  * @e: Event Generation Counter, McPDM, DMIC or default.
  *
- * load the AESS event generator hardware source. Loads the firmware parameters
- * accordingly. Indicates to the FW which data stream is the most important to preserve
- * in case all the streams are asynchronous. If the parameter is "default", let the HAL
- * decide which Event source is the best appropriate based on the opened ports.
- *
- * When neither the DMIC and the McPDM are activated the AE will have its EVENT generator programmed
- * with the EVENT_COUNTER. The event counter will be tuned in order to deliver a pulse frequency higher
- * than 96 kHz. The DPLL output at 100% OPP is MCLK = (32768kHz x6000) = 196.608kHz
+ * Loads the AESS event generator hardware source.
+ * Loads the firmware parameters accordingly.
+ * Indicates to the FW which data stream is the most important to preserve
+ * in case all the streams are asynchronous.
+ * If the parameter is "default", then HAL decides which Event source
+ * is the best appropriate based on the opened ports.
+ *
+ * When neither the DMIC and the McPDM are activated, the AE will have
+ * its EVENT generator programmed with the EVENT_COUNTER.
+ * The event counter will be tuned in order to deliver a pulse frequency higher
+ * than 96 kHz.
+ * The DPLL output at 100% OPP is MCLK = (32768kHz x6000) = 196.608kHz
  * The ratio is (MCLK/96000)+(1<<1) = 2050
- * (1<<1) in order to have the same speed at 50% and 100% OPP (only 15 MSB bits are used at OPP50%)
+ * (1<<1) in order to have the same speed at 50% and 100% OPP
+ * (only 15 MSB bits are used at OPP50%)
  */
-abehal_status abe_write_event_generator(u32 e);
+int abe_write_event_generator(u32 e);
+
 /**
  * abe_read_use_case_opp() - description for void abe_read_use_case_opp().
  *
  * returns the expected min OPP for a given use_case list
  */
-abehal_status abe_read_use_case_opp(u32 *u, u32 *o);
+int abe_read_use_case_opp(u32 *u, u32 *o);
+
 /**
  * abe_set_opp_processing - Set OPP mode for ABE Firmware
  * @opp: OOPP mode
@@ -165,7 +209,8 @@
  * this switch.
  *
  */
-abehal_status abe_set_opp_processing(u32 opp);
+int abe_set_opp_processing(u32 opp);
+
 /**
  * abe_set_ping_pong_buffer
  * @port: ABE port ID
@@ -174,7 +219,8 @@
  * Updates the next ping-pong buffer with "size" bytes copied from the
  * host processor. This API notifies the FW that the data transfer is done.
  */
-abehal_status abe_set_ping_pong_buffer(u32 port, u32 n_bytes);
+int abe_set_ping_pong_buffer(u32 port, u32 n_bytes);
+
 /**
  * abe_read_next_ping_pong_buffer
  * @port: ABE portID
@@ -183,7 +229,8 @@
  *
  * Tell the next base address of the next ping_pong Buffer and its size
  */
-abehal_status abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n);
+int abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n);
+
 /**
  * abe_init_ping_pong_buffer
  * @id: ABE port ID
@@ -194,17 +241,20 @@
  *
  * Computes the base address of the ping_pong buffers
  */
-abehal_status abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,
-					u32 *p);
+int abe_init_ping_pong_buffer(u32 id, u32 size_bytes, u32 n_buffers,
+				u32 *p);
+
 /**
  * abe_read_offset_from_ping_buffer
  * @id: ABE port ID
- * @n:  returned address of the offset from the ping buffer start address expressed in samples
+ * @n:  returned address of the offset
+ *	from the ping buffer start address (in samples)
  *
- * Computes the current firmware ping pong read pointer location, expressed in samples,
- * as the offset from the start address of ping buffer.
+ * Computes the current firmware ping pong read pointer location,
+ * expressed in samples, as the offset from the start address of ping buffer.
  */
-abehal_status abe_read_offset_from_ping_buffer(u32 id, u32 *n);
+int abe_read_offset_from_ping_buffer(u32 id, u32 *n);
+
 /**
  * abe_plug_subroutine
  * @id: returned sequence index after plugging a new subroutine
@@ -214,15 +264,17 @@
  *
  * register a list of subroutines for call-back purpose
  */
-abehal_status abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,
-				  u32 *params);
+int abe_plug_subroutine(u32 *id, abe_subroutine2 f, u32 n,
+			  u32 *params);
+
 /**
  * abe_set_sequence_time_accuracy
  * @fast: fast counter
  * @slow: slow counter
  *
  */
-abehal_status abe_set_sequence_time_accuracy(u32 fast, u32 slow);
+int abe_set_sequence_time_accuracy(u32 fast, u32 slow);
+
 /**
  * abe_reset_port
  * @id: ABE port ID
@@ -231,7 +283,8 @@
  * processing features.
  * Clears the internal AE buffers.
  */
-abehal_status abe_reset_port(u32 id);
+int abe_reset_port(u32 id);
+
 /**
  * abe_read_remaining_data
  * @id:	ABE port_ID
@@ -239,7 +292,8 @@
  *
  * computes the remaining amount of data in the buffer.
  */
-abehal_status abe_read_remaining_data(u32 port, u32 *n);
+int abe_read_remaining_data(u32 port, u32 *n);
+
 /**
  * abe_disable_data_transfer
  * @id: ABE port id
@@ -248,7 +302,8 @@
  * disable the IO task (@f = 0)
  * clear ATC DMEM buffer, ATC enabled
  */
-abehal_status abe_disable_data_transfer(u32 id);
+int abe_disable_data_transfer(u32 id);
+
 /**
  * abe_enable_data_transfer
  * @ip: ABE port id
@@ -257,7 +312,8 @@
  * reset ATC pointers
  * enable the IO task (@f <> 0)
  */
-abehal_status abe_enable_data_transfer(u32 id);
+int abe_enable_data_transfer(u32 id);
+
 /**
  * abe_set_dmic_filter
  * @d: DMIC decimation ratio : 16/25/32/40
@@ -267,7 +323,8 @@
  * roll-off at 20kHz.
  * The default table is loaded with the DMIC 2.4MHz recommended configuration.
  */
-abehal_status abe_set_dmic_filter(u32 d);
+int abe_set_dmic_filter(u32 d);
+
 /**
  * abe_connect_cbpr_dmareq_port
  * @id: port name
@@ -279,8 +336,9 @@
  * enables the data echange between a DMA and the ABE through the
  *	CBPr registers of AESS.
  */
-abehal_status abe_connect_cbpr_dmareq_port(u32 id, abe_data_format_t *f, u32 d,
-					   abe_dma_t *returned_dma_t);
+int abe_connect_cbpr_dmareq_port(u32 id, abe_data_format_t *f, u32 d,
+				   abe_dma_t *returned_dma_t);
+
 /**
  * abe_connect_dmareq_ping_pong_port
  * @id: port name
@@ -294,9 +352,10 @@
  * the DMEM memory of ABE. On each dma_request activation the DMA will exchange
  * "s" bytes and switch to the "pong" buffer for a new buffer exchange.
  */
-abehal_status abe_connect_dmareq_ping_pong_port(u32 id, abe_data_format_t *f,
-						u32 d, u32 s,
-						abe_dma_t *returned_dma_t);
+int abe_connect_dmareq_ping_pong_port(u32 id, abe_data_format_t *f,
+					u32 d, u32 s,
+					abe_dma_t *returned_dma_t);
+
 /**
  * abe_connect_irq_ping_pong_port
  * @id: port name
@@ -312,9 +371,10 @@
  * "abe_set_ping_pong_buffer" to notify the new amount of samples in the
  * pong buffer.
  */
-abehal_status abe_connect_irq_ping_pong_port(u32 id, abe_data_format_t *f,
-					     u32 subroutine_id, u32 size,
-					     u32 *sink, u32 dsp_mcu_flag);
+int abe_connect_irq_ping_pong_port(u32 id, abe_data_format_t *f,
+				     u32 subroutine_id, u32 size,
+				     u32 *sink, u32 dsp_mcu_flag);
+
 /**
  * abe_connect_serial_port()
  * @id: port name
@@ -326,8 +386,9 @@
  * voice streams to VX_UL, VX_DL, BT_VX_UL, BT_VX_DL. It abstracts the
  * abe_write_port API.
  */
-abehal_status abe_connect_serial_port(u32 id, abe_data_format_t *f,
-				      u32 mcbsp_id);
+int abe_connect_serial_port(u32 id, abe_data_format_t *f,
+			      u32 mcbsp_id);
+
 /**
  * abe_connect_slimbus_port
  * @id: port name
@@ -338,8 +399,9 @@
  * enables the data echanges between 1/2 SB and an ATC buffers in
  * DMEM.
  */
-abehal_status abe_connect_slimbus_port(u32 id, abe_data_format_t *f,
-				       u32 sb_port1, u32 sb_port2);
+int abe_connect_slimbus_port(u32 id, abe_data_format_t *f,
+			       u32 sb_port1, u32 sb_port2);
+
 /**
  * abe_connect_tdm_port
  * @id: port name
@@ -350,7 +412,8 @@
  * enables the data echanges between TDM McBSP ATC buffers in
  * DMEM and 1/2 SMEM buffers
  */
-abehal_status abe_connect_tdm_port(u32 id, abe_data_format_t *f, u32 mcbsp_id);
+int abe_connect_tdm_port(u32 id, abe_data_format_t *f, u32 mcbsp_id);
+
 /**
  * abe_read_port_address
  * @dma: output pointer to the DMA iteration and data destination pointer
@@ -359,7 +422,8 @@
  * Depending on the protocol being used, adds the base address offset L3
  * (DMA) or MPU (ARM)
  */
-abehal_status abe_read_port_address(u32 port, abe_dma_t *dma2);
+int abe_read_port_address(u32 port, abe_dma_t *dma2);
+
 /**
  * abe_write_equalizer
  * @id: name of the equalizer
@@ -367,7 +431,8 @@
  *
  * Load the coefficients in CMEM.
  */
-abehal_status abe_write_equalizer(u32 id, abe_equ_t *param);
+int abe_write_equalizer(u32 id, abe_equ_t *param);
+
 /**
  * abe_write_asrc
  * @id: name of the port
@@ -380,7 +445,8 @@
  * or vice versa, there will be click in the output signal. Loading the drift
  * value with zero disables the feature.
  */
-abehal_status abe_write_asrc(u32 port, s32 dppm);
+int abe_write_asrc(u32 port, s32 dppm);
+
 /**
  * abe_write_aps
  * @id: name of the aps filter
@@ -392,7 +458,8 @@
  * activated".
  * Loading all the coefficients value with zero disables the feature.
  */
-abehal_status abe_write_aps(u32 id, abe_aps_t *param);
+int abe_write_aps(u32 id, abe_aps_t *param);
+
 /**
  * abe_write_mixer
  * @id: name of the mixer
@@ -405,12 +472,18 @@
  * in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p);
-abehal_status abe_use_compensated_gain(u32 on_off);
-abehal_status abe_enable_gain(u32 id, u32 p);
-abehal_status abe_disable_gain(u32 id, u32 p);
-abehal_status abe_mute_gain(u32 id, u32 p);
-abehal_status abe_unmute_gain(u32 id, u32 p);
+int abe_write_gain(u32 id, s32 f_g, u32 ramp, u32 p);
+
+int abe_use_compensated_gain(u32 on_off);
+
+int abe_enable_gain(u32 id, u32 p);
+
+int abe_disable_gain(u32 id, u32 p);
+
+int abe_mute_gain(u32 id, u32 p);
+
+int abe_unmute_gain(u32 id, u32 p);
+
 /**
  * abe_write_mixer
  * @id: name of the mixer
@@ -423,7 +496,8 @@
  * gain in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_write_mixer(u32 id, s32 f_g, u32 f_ramp, u32 p);
+int abe_write_mixer(u32 id, s32 f_g, u32 f_ramp, u32 p);
+
 /**
  * abe_read_gain
  * @id: name of the mixer
@@ -431,7 +505,8 @@
  * @p: list of port corresponding to the above gains
  *
  */
-abehal_status abe_read_gain(u32 id, u32 *f_g, u32 p);
+int abe_read_gain(u32 id, u32 *f_g, u32 p);
+
 /**
  * abe_read_mixer
  * @id: name of the mixer
@@ -444,7 +519,8 @@
  * gain in mute state". A mixer is disabled with a network reconfiguration
  * corresponding to an OPP value.
  */
-abehal_status abe_read_mixer(u32 id, u32 *f_g, u32 p);
+int abe_read_mixer(u32 id, u32 *f_g, u32 p);
+
 /**
  * abe_set_router_configuration
  * @Id: name of the router
@@ -457,29 +533,32 @@
  * route the samples to three directions : REC1 mixer, 2 EANC DMIC source of
  * filtering and MM recording audio path.
  */
-abehal_status abe_set_router_configuration(u32 id, u32 k, u32 *param);
+int abe_set_router_configuration(u32 id, u32 k, u32 *param);
+
 /**
  * abe_select_data_source
  * @@@
  */
-abehal_status abe_select_data_source(u32 port_id, u32 smem_source);
+int abe_select_data_source(u32 port_id, u32 smem_source);
+
 /**
  * ABE_READ_DEBUG_TRACE
  *
- * Parameter :
- *	data destination pointer
- *	max number of data read
+ * Parameters :
+ * @data: data destination pointer
+ * @n	: max number of read data
  *
  * Operations :
- *	reads the AE circular data pointer holding pairs of debug data+
- * 	timestamps, and store the pairs in linear addressing to the parameter
- * 	pointer. Stops the copy when the max parameter is reached or when the
- * 	FIFO is empty.
+ * Reads the AE circular data pointer that holds pairs of debug data +
+ * timestamps, and stores the pairs, via linear addressing, to the parameter
+ * pointer.
+ * Stops the copy when the max parameter is reached or when the FIFO is empty.
  *
  * Return value :
- *	None.
+ *	status
  */
-abehal_status abe_read_debug_trace(u32 *data, u32 *n);
+int abe_read_debug_trace(u32 *data, u32 *n);
+
 /**
  * abe_connect_debug_trace
  * @dma2:pointer to the DMEM trace buffer
@@ -487,30 +566,48 @@
  * returns the address and size of the real-time debug trace buffer,
  * the content of which will vary from one firmware release to an other
  */
-abehal_status abe_connect_debug_trace(abe_dma_t *dma2);
+int abe_connect_debug_trace(abe_dma_t *dma2);
+
 /**
  * abe_set_debug_trace
  * @debug: debug ID from a list to be defined
  *
  * load a mask which filters the debug trace to dedicated types of data
  */
-abehal_status abe_set_debug_trace(abe_dbg_t debug);
+int abe_set_debug_trace(abe_dbg_t debug);
+
 /**
  * abe_remote_debugger_interface
  *
  * interpretation of the UART stream from the remote debugger commands.
  * The commands consist in setting break points, loading parameter
  */
-abehal_status abe_remote_debugger_interface(u32 n, u8 *p);
+int abe_remote_debugger_interface(u32 n, u8 *p);
+
 /**
  * abe_enable_test_pattern
  *
  */
-abehal_status abe_enable_test_pattern(u32 smem_id, u32 on_off);
+int abe_enable_test_pattern(u32 smem_id, u32 on_off);
+
 /**
  * abe_init_mem - Allocate Kernel space memory map for ABE
  *
  * Memory map of ABE memory space for PMEM/DMEM/SMEM/DMEM
  */
-void abe_init_mem(void __iomem *_io_base);
+int abe_init_mem(void __iomem *_io_base);
+
+/*
+ * abe_add_subroutine - Add a subroutine to be called upon interrupt
+ */
+void abe_add_subroutine(u32 *id, abe_subroutine2 f, u32 nparam, u32 *params);
+
+/*
+ * abe_read_next_ping_pong_buffer - Read next address in ping-pong buffer
+ * processing
+ */
+int abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n);
+
+extern u32 abe_irq_pingpong_player_id;
+
 #endif/* _ABE_API_H_ */
Index: kernel/sound/soc/omap/abe/abe_cm_addr.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_cm_addr.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_cm_addr.h	2011-03-28 15:57:05.788354240 +0900
@@ -21,264 +21,264 @@
 #ifndef _ABE_CM_ADDR_H_
 #define _ABE_CM_ADDR_H_
 #define init_CM_ADDR                                        0
-#define init_CM_ADDR_END                                    309
-#define init_CM_sizeof                                      310
-#define C_Data_LSB_2_ADDR                                   310
-#define C_Data_LSB_2_ADDR_END                               310
+#define init_CM_ADDR_END                                    310
+#define init_CM_sizeof                                      311
+#define C_Data_LSB_2_ADDR                                   311
+#define C_Data_LSB_2_ADDR_END                               311
 #define C_Data_LSB_2_sizeof                                 1
-#define C_1_Alpha_ADDR                                      311
-#define C_1_Alpha_ADDR_END                                  328
+#define C_1_Alpha_ADDR                                      312
+#define C_1_Alpha_ADDR_END                                  329
 #define C_1_Alpha_sizeof                                    18
-#define C_Alpha_ADDR                                        329
-#define C_Alpha_ADDR_END                                    346
+#define C_Alpha_ADDR                                        330
+#define C_Alpha_ADDR_END                                    347
 #define C_Alpha_sizeof                                      18
-#define C_GainsWRamp_ADDR                                   347
-#define C_GainsWRamp_ADDR_END                               360
+#define C_GainsWRamp_ADDR                                   348
+#define C_GainsWRamp_ADDR_END                               361
 #define C_GainsWRamp_sizeof                                 14
-#define C_Gains_DL1M_ADDR                                   361
-#define C_Gains_DL1M_ADDR_END                               364
+#define C_Gains_DL1M_ADDR                                   362
+#define C_Gains_DL1M_ADDR_END                               365
 #define C_Gains_DL1M_sizeof                                 4
-#define C_Gains_DL2M_ADDR                                   365
-#define C_Gains_DL2M_ADDR_END                               368
+#define C_Gains_DL2M_ADDR                                   366
+#define C_Gains_DL2M_ADDR_END                               369
 #define C_Gains_DL2M_sizeof                                 4
-#define C_Gains_EchoM_ADDR                                  369
-#define C_Gains_EchoM_ADDR_END                              370
+#define C_Gains_EchoM_ADDR                                  370
+#define C_Gains_EchoM_ADDR_END                              371
 #define C_Gains_EchoM_sizeof                                2
-#define C_Gains_SDTM_ADDR                                   371
-#define C_Gains_SDTM_ADDR_END                               372
+#define C_Gains_SDTM_ADDR                                   372
+#define C_Gains_SDTM_ADDR_END                               373
 #define C_Gains_SDTM_sizeof                                 2
-#define C_Gains_VxRecM_ADDR                                 373
-#define C_Gains_VxRecM_ADDR_END                             376
+#define C_Gains_VxRecM_ADDR                                 374
+#define C_Gains_VxRecM_ADDR_END                             377
 #define C_Gains_VxRecM_sizeof                               4
-#define C_Gains_ULM_ADDR                                    377
-#define C_Gains_ULM_ADDR_END                                380
+#define C_Gains_ULM_ADDR                                    378
+#define C_Gains_ULM_ADDR_END                                381
 #define C_Gains_ULM_sizeof                                  4
-#define C_Gains_unused_ADDR                                 381
-#define C_Gains_unused_ADDR_END                             382
-#define C_Gains_unused_sizeof                               2
-#define C_SDT_Coefs_ADDR                                    383
-#define C_SDT_Coefs_ADDR_END                                391
+#define C_Gains_BTUL_ADDR                                   382
+#define C_Gains_BTUL_ADDR_END                               383
+#define C_Gains_BTUL_sizeof                                 2
+#define C_SDT_Coefs_ADDR                                    384
+#define C_SDT_Coefs_ADDR_END                                392
 #define C_SDT_Coefs_sizeof                                  9
-#define C_CoefASRC1_VX_ADDR                                 392
-#define C_CoefASRC1_VX_ADDR_END                             410
+#define C_CoefASRC1_VX_ADDR                                 393
+#define C_CoefASRC1_VX_ADDR_END                             411
 #define C_CoefASRC1_VX_sizeof                               19
-#define C_CoefASRC2_VX_ADDR                                 411
-#define C_CoefASRC2_VX_ADDR_END                             429
+#define C_CoefASRC2_VX_ADDR                                 412
+#define C_CoefASRC2_VX_ADDR_END                             430
 #define C_CoefASRC2_VX_sizeof                               19
-#define C_CoefASRC3_VX_ADDR                                 430
-#define C_CoefASRC3_VX_ADDR_END                             448
+#define C_CoefASRC3_VX_ADDR                                 431
+#define C_CoefASRC3_VX_ADDR_END                             449
 #define C_CoefASRC3_VX_sizeof                               19
-#define C_CoefASRC4_VX_ADDR                                 449
-#define C_CoefASRC4_VX_ADDR_END                             467
+#define C_CoefASRC4_VX_ADDR                                 450
+#define C_CoefASRC4_VX_ADDR_END                             468
 #define C_CoefASRC4_VX_sizeof                               19
-#define C_CoefASRC5_VX_ADDR                                 468
-#define C_CoefASRC5_VX_ADDR_END                             486
+#define C_CoefASRC5_VX_ADDR                                 469
+#define C_CoefASRC5_VX_ADDR_END                             487
 #define C_CoefASRC5_VX_sizeof                               19
-#define C_CoefASRC6_VX_ADDR                                 487
-#define C_CoefASRC6_VX_ADDR_END                             505
+#define C_CoefASRC6_VX_ADDR                                 488
+#define C_CoefASRC6_VX_ADDR_END                             506
 #define C_CoefASRC6_VX_sizeof                               19
-#define C_CoefASRC7_VX_ADDR                                 506
-#define C_CoefASRC7_VX_ADDR_END                             524
+#define C_CoefASRC7_VX_ADDR                                 507
+#define C_CoefASRC7_VX_ADDR_END                             525
 #define C_CoefASRC7_VX_sizeof                               19
-#define C_CoefASRC8_VX_ADDR                                 525
-#define C_CoefASRC8_VX_ADDR_END                             543
+#define C_CoefASRC8_VX_ADDR                                 526
+#define C_CoefASRC8_VX_ADDR_END                             544
 #define C_CoefASRC8_VX_sizeof                               19
-#define C_CoefASRC9_VX_ADDR                                 544
-#define C_CoefASRC9_VX_ADDR_END                             562
+#define C_CoefASRC9_VX_ADDR                                 545
+#define C_CoefASRC9_VX_ADDR_END                             563
 #define C_CoefASRC9_VX_sizeof                               19
-#define C_CoefASRC10_VX_ADDR                                563
-#define C_CoefASRC10_VX_ADDR_END                            581
+#define C_CoefASRC10_VX_ADDR                                564
+#define C_CoefASRC10_VX_ADDR_END                            582
 #define C_CoefASRC10_VX_sizeof                              19
-#define C_CoefASRC11_VX_ADDR                                582
-#define C_CoefASRC11_VX_ADDR_END                            600
+#define C_CoefASRC11_VX_ADDR                                583
+#define C_CoefASRC11_VX_ADDR_END                            601
 #define C_CoefASRC11_VX_sizeof                              19
-#define C_CoefASRC12_VX_ADDR                                601
-#define C_CoefASRC12_VX_ADDR_END                            619
+#define C_CoefASRC12_VX_ADDR                                602
+#define C_CoefASRC12_VX_ADDR_END                            620
 #define C_CoefASRC12_VX_sizeof                              19
-#define C_CoefASRC13_VX_ADDR                                620
-#define C_CoefASRC13_VX_ADDR_END                            638
+#define C_CoefASRC13_VX_ADDR                                621
+#define C_CoefASRC13_VX_ADDR_END                            639
 #define C_CoefASRC13_VX_sizeof                              19
-#define C_CoefASRC14_VX_ADDR                                639
-#define C_CoefASRC14_VX_ADDR_END                            657
+#define C_CoefASRC14_VX_ADDR                                640
+#define C_CoefASRC14_VX_ADDR_END                            658
 #define C_CoefASRC14_VX_sizeof                              19
-#define C_CoefASRC15_VX_ADDR                                658
-#define C_CoefASRC15_VX_ADDR_END                            676
+#define C_CoefASRC15_VX_ADDR                                659
+#define C_CoefASRC15_VX_ADDR_END                            677
 #define C_CoefASRC15_VX_sizeof                              19
-#define C_CoefASRC16_VX_ADDR                                677
-#define C_CoefASRC16_VX_ADDR_END                            695
+#define C_CoefASRC16_VX_ADDR                                678
+#define C_CoefASRC16_VX_ADDR_END                            696
 #define C_CoefASRC16_VX_sizeof                              19
-#define C_AlphaCurrent_UL_VX_ADDR                           696
-#define C_AlphaCurrent_UL_VX_ADDR_END                       696
+#define C_AlphaCurrent_UL_VX_ADDR                           697
+#define C_AlphaCurrent_UL_VX_ADDR_END                       697
 #define C_AlphaCurrent_UL_VX_sizeof                         1
-#define C_BetaCurrent_UL_VX_ADDR                            697
-#define C_BetaCurrent_UL_VX_ADDR_END                        697
+#define C_BetaCurrent_UL_VX_ADDR                            698
+#define C_BetaCurrent_UL_VX_ADDR_END                        698
 #define C_BetaCurrent_UL_VX_sizeof                          1
-#define C_AlphaCurrent_DL_VX_ADDR                           698
-#define C_AlphaCurrent_DL_VX_ADDR_END                       698
+#define C_AlphaCurrent_DL_VX_ADDR                           699
+#define C_AlphaCurrent_DL_VX_ADDR_END                       699
 #define C_AlphaCurrent_DL_VX_sizeof                         1
-#define C_BetaCurrent_DL_VX_ADDR                            699
-#define C_BetaCurrent_DL_VX_ADDR_END                        699
+#define C_BetaCurrent_DL_VX_ADDR                            700
+#define C_BetaCurrent_DL_VX_ADDR_END                        700
 #define C_BetaCurrent_DL_VX_sizeof                          1
-#define C_CoefASRC1_MM_ADDR                                 700
-#define C_CoefASRC1_MM_ADDR_END                             717
+#define C_CoefASRC1_MM_ADDR                                 701
+#define C_CoefASRC1_MM_ADDR_END                             718
 #define C_CoefASRC1_MM_sizeof                               18
-#define C_CoefASRC2_MM_ADDR                                 718
-#define C_CoefASRC2_MM_ADDR_END                             735
+#define C_CoefASRC2_MM_ADDR                                 719
+#define C_CoefASRC2_MM_ADDR_END                             736
 #define C_CoefASRC2_MM_sizeof                               18
-#define C_CoefASRC3_MM_ADDR                                 736
-#define C_CoefASRC3_MM_ADDR_END                             753
+#define C_CoefASRC3_MM_ADDR                                 737
+#define C_CoefASRC3_MM_ADDR_END                             754
 #define C_CoefASRC3_MM_sizeof                               18
-#define C_CoefASRC4_MM_ADDR                                 754
-#define C_CoefASRC4_MM_ADDR_END                             771
+#define C_CoefASRC4_MM_ADDR                                 755
+#define C_CoefASRC4_MM_ADDR_END                             772
 #define C_CoefASRC4_MM_sizeof                               18
-#define C_CoefASRC5_MM_ADDR                                 772
-#define C_CoefASRC5_MM_ADDR_END                             789
+#define C_CoefASRC5_MM_ADDR                                 773
+#define C_CoefASRC5_MM_ADDR_END                             790
 #define C_CoefASRC5_MM_sizeof                               18
-#define C_CoefASRC6_MM_ADDR                                 790
-#define C_CoefASRC6_MM_ADDR_END                             807
+#define C_CoefASRC6_MM_ADDR                                 791
+#define C_CoefASRC6_MM_ADDR_END                             808
 #define C_CoefASRC6_MM_sizeof                               18
-#define C_CoefASRC7_MM_ADDR                                 808
-#define C_CoefASRC7_MM_ADDR_END                             825
+#define C_CoefASRC7_MM_ADDR                                 809
+#define C_CoefASRC7_MM_ADDR_END                             826
 #define C_CoefASRC7_MM_sizeof                               18
-#define C_CoefASRC8_MM_ADDR                                 826
-#define C_CoefASRC8_MM_ADDR_END                             843
+#define C_CoefASRC8_MM_ADDR                                 827
+#define C_CoefASRC8_MM_ADDR_END                             844
 #define C_CoefASRC8_MM_sizeof                               18
-#define C_CoefASRC9_MM_ADDR                                 844
-#define C_CoefASRC9_MM_ADDR_END                             861
+#define C_CoefASRC9_MM_ADDR                                 845
+#define C_CoefASRC9_MM_ADDR_END                             862
 #define C_CoefASRC9_MM_sizeof                               18
-#define C_CoefASRC10_MM_ADDR                                862
-#define C_CoefASRC10_MM_ADDR_END                            879
+#define C_CoefASRC10_MM_ADDR                                863
+#define C_CoefASRC10_MM_ADDR_END                            880
 #define C_CoefASRC10_MM_sizeof                              18
-#define C_CoefASRC11_MM_ADDR                                880
-#define C_CoefASRC11_MM_ADDR_END                            897
+#define C_CoefASRC11_MM_ADDR                                881
+#define C_CoefASRC11_MM_ADDR_END                            898
 #define C_CoefASRC11_MM_sizeof                              18
-#define C_CoefASRC12_MM_ADDR                                898
-#define C_CoefASRC12_MM_ADDR_END                            915
+#define C_CoefASRC12_MM_ADDR                                899
+#define C_CoefASRC12_MM_ADDR_END                            916
 #define C_CoefASRC12_MM_sizeof                              18
-#define C_CoefASRC13_MM_ADDR                                916
-#define C_CoefASRC13_MM_ADDR_END                            933
+#define C_CoefASRC13_MM_ADDR                                917
+#define C_CoefASRC13_MM_ADDR_END                            934
 #define C_CoefASRC13_MM_sizeof                              18
-#define C_CoefASRC14_MM_ADDR                                934
-#define C_CoefASRC14_MM_ADDR_END                            951
+#define C_CoefASRC14_MM_ADDR                                935
+#define C_CoefASRC14_MM_ADDR_END                            952
 #define C_CoefASRC14_MM_sizeof                              18
-#define C_CoefASRC15_MM_ADDR                                952
-#define C_CoefASRC15_MM_ADDR_END                            969
+#define C_CoefASRC15_MM_ADDR                                953
+#define C_CoefASRC15_MM_ADDR_END                            970
 #define C_CoefASRC15_MM_sizeof                              18
-#define C_CoefASRC16_MM_ADDR                                970
-#define C_CoefASRC16_MM_ADDR_END                            987
+#define C_CoefASRC16_MM_ADDR                                971
+#define C_CoefASRC16_MM_ADDR_END                            988
 #define C_CoefASRC16_MM_sizeof                              18
-#define C_AlphaCurrent_MM_EXT_IN_ADDR                       988
-#define C_AlphaCurrent_MM_EXT_IN_ADDR_END                   988
+#define C_AlphaCurrent_MM_EXT_IN_ADDR                       989
+#define C_AlphaCurrent_MM_EXT_IN_ADDR_END                   989
 #define C_AlphaCurrent_MM_EXT_IN_sizeof                     1
-#define C_BetaCurrent_MM_EXT_IN_ADDR                        989
-#define C_BetaCurrent_MM_EXT_IN_ADDR_END                    989
+#define C_BetaCurrent_MM_EXT_IN_ADDR                        990
+#define C_BetaCurrent_MM_EXT_IN_ADDR_END                    990
 #define C_BetaCurrent_MM_EXT_IN_sizeof                      1
-#define C_DL2_L_Coefs_ADDR                                  990
-#define C_DL2_L_Coefs_ADDR_END                              1014
+#define C_DL2_L_Coefs_ADDR                                  991
+#define C_DL2_L_Coefs_ADDR_END                              1015
 #define C_DL2_L_Coefs_sizeof                                25
-#define C_DL2_R_Coefs_ADDR                                  1015
-#define C_DL2_R_Coefs_ADDR_END                              1039
+#define C_DL2_R_Coefs_ADDR                                  1016
+#define C_DL2_R_Coefs_ADDR_END                              1040
 #define C_DL2_R_Coefs_sizeof                                25
-#define C_DL1_Coefs_ADDR                                    1040
-#define C_DL1_Coefs_ADDR_END                                1064
+#define C_DL1_Coefs_ADDR                                    1041
+#define C_DL1_Coefs_ADDR_END                                1065
 #define C_DL1_Coefs_sizeof                                  25
-#define C_SRC_3_LP_Coefs_ADDR                               1065
-#define C_SRC_3_LP_Coefs_ADDR_END                           1075
+#define C_SRC_3_LP_Coefs_ADDR                               1066
+#define C_SRC_3_LP_Coefs_ADDR_END                           1076
 #define C_SRC_3_LP_Coefs_sizeof                             11
-#define C_SRC_3_LP_GAIN_Coefs_ADDR                          1076
-#define C_SRC_3_LP_GAIN_Coefs_ADDR_END                      1086
+#define C_SRC_3_LP_GAIN_Coefs_ADDR                          1077
+#define C_SRC_3_LP_GAIN_Coefs_ADDR_END                      1087
 #define C_SRC_3_LP_GAIN_Coefs_sizeof                        11
-#define C_SRC_3_HP_Coefs_ADDR                               1087
-#define C_SRC_3_HP_Coefs_ADDR_END                           1091
+#define C_SRC_3_HP_Coefs_ADDR                               1088
+#define C_SRC_3_HP_Coefs_ADDR_END                           1092
 #define C_SRC_3_HP_Coefs_sizeof                             5
-#define C_SRC_6_LP_Coefs_ADDR                               1092
-#define C_SRC_6_LP_Coefs_ADDR_END                           1102
+#define C_SRC_6_LP_Coefs_ADDR                               1093
+#define C_SRC_6_LP_Coefs_ADDR_END                           1103
 #define C_SRC_6_LP_Coefs_sizeof                             11
-#define C_SRC_6_LP_GAIN_Coefs_ADDR                          1103
-#define C_SRC_6_LP_GAIN_Coefs_ADDR_END                      1113
+#define C_SRC_6_LP_GAIN_Coefs_ADDR                          1104
+#define C_SRC_6_LP_GAIN_Coefs_ADDR_END                      1114
 #define C_SRC_6_LP_GAIN_Coefs_sizeof                        11
-#define C_SRC_6_HP_Coefs_ADDR                               1114
-#define C_SRC_6_HP_Coefs_ADDR_END                           1120
+#define C_SRC_6_HP_Coefs_ADDR                               1115
+#define C_SRC_6_HP_Coefs_ADDR_END                           1121
 #define C_SRC_6_HP_Coefs_sizeof                             7
-#define C_APS_DL1_coeffs1_ADDR                              1121
-#define C_APS_DL1_coeffs1_ADDR_END                          1129
+#define C_APS_DL1_coeffs1_ADDR                              1122
+#define C_APS_DL1_coeffs1_ADDR_END                          1130
 #define C_APS_DL1_coeffs1_sizeof                            9
-#define C_APS_DL1_M_coeffs2_ADDR                            1130
-#define C_APS_DL1_M_coeffs2_ADDR_END                        1132
+#define C_APS_DL1_M_coeffs2_ADDR                            1131
+#define C_APS_DL1_M_coeffs2_ADDR_END                        1133
 #define C_APS_DL1_M_coeffs2_sizeof                          3
-#define C_APS_DL1_C_coeffs2_ADDR                            1133
-#define C_APS_DL1_C_coeffs2_ADDR_END                        1135
+#define C_APS_DL1_C_coeffs2_ADDR                            1134
+#define C_APS_DL1_C_coeffs2_ADDR_END                        1136
 #define C_APS_DL1_C_coeffs2_sizeof                          3
-#define C_APS_DL2_L_coeffs1_ADDR                            1136
-#define C_APS_DL2_L_coeffs1_ADDR_END                        1144
+#define C_APS_DL2_L_coeffs1_ADDR                            1137
+#define C_APS_DL2_L_coeffs1_ADDR_END                        1145
 #define C_APS_DL2_L_coeffs1_sizeof                          9
-#define C_APS_DL2_R_coeffs1_ADDR                            1145
-#define C_APS_DL2_R_coeffs1_ADDR_END                        1153
+#define C_APS_DL2_R_coeffs1_ADDR                            1146
+#define C_APS_DL2_R_coeffs1_ADDR_END                        1154
 #define C_APS_DL2_R_coeffs1_sizeof                          9
-#define C_APS_DL2_L_M_coeffs2_ADDR                          1154
-#define C_APS_DL2_L_M_coeffs2_ADDR_END                      1156
+#define C_APS_DL2_L_M_coeffs2_ADDR                          1155
+#define C_APS_DL2_L_M_coeffs2_ADDR_END                      1157
 #define C_APS_DL2_L_M_coeffs2_sizeof                        3
-#define C_APS_DL2_R_M_coeffs2_ADDR                          1157
-#define C_APS_DL2_R_M_coeffs2_ADDR_END                      1159
+#define C_APS_DL2_R_M_coeffs2_ADDR                          1158
+#define C_APS_DL2_R_M_coeffs2_ADDR_END                      1160
 #define C_APS_DL2_R_M_coeffs2_sizeof                        3
-#define C_APS_DL2_L_C_coeffs2_ADDR                          1160
-#define C_APS_DL2_L_C_coeffs2_ADDR_END                      1162
+#define C_APS_DL2_L_C_coeffs2_ADDR                          1161
+#define C_APS_DL2_L_C_coeffs2_ADDR_END                      1163
 #define C_APS_DL2_L_C_coeffs2_sizeof                        3
-#define C_APS_DL2_R_C_coeffs2_ADDR                          1163
-#define C_APS_DL2_R_C_coeffs2_ADDR_END                      1165
+#define C_APS_DL2_R_C_coeffs2_ADDR                          1164
+#define C_APS_DL2_R_C_coeffs2_ADDR_END                      1166
 #define C_APS_DL2_R_C_coeffs2_sizeof                        3
-#define C_AlphaCurrent_ECHO_REF_ADDR                        1166
-#define C_AlphaCurrent_ECHO_REF_ADDR_END                    1166
+#define C_AlphaCurrent_ECHO_REF_ADDR                        1167
+#define C_AlphaCurrent_ECHO_REF_ADDR_END                    1167
 #define C_AlphaCurrent_ECHO_REF_sizeof                      1
-#define C_BetaCurrent_ECHO_REF_ADDR                         1167
-#define C_BetaCurrent_ECHO_REF_ADDR_END                     1167
+#define C_BetaCurrent_ECHO_REF_ADDR                         1168
+#define C_BetaCurrent_ECHO_REF_ADDR_END                     1168
 #define C_BetaCurrent_ECHO_REF_sizeof                       1
-#define C_APS_DL1_EQ_ADDR                                   1168
-#define C_APS_DL1_EQ_ADDR_END                               1176
+#define C_APS_DL1_EQ_ADDR                                   1169
+#define C_APS_DL1_EQ_ADDR_END                               1177
 #define C_APS_DL1_EQ_sizeof                                 9
-#define C_APS_DL2_L_EQ_ADDR                                 1177
-#define C_APS_DL2_L_EQ_ADDR_END                             1185
+#define C_APS_DL2_L_EQ_ADDR                                 1178
+#define C_APS_DL2_L_EQ_ADDR_END                             1186
 #define C_APS_DL2_L_EQ_sizeof                               9
-#define C_APS_DL2_R_EQ_ADDR                                 1186
-#define C_APS_DL2_R_EQ_ADDR_END                             1194
+#define C_APS_DL2_R_EQ_ADDR                                 1187
+#define C_APS_DL2_R_EQ_ADDR_END                             1195
 #define C_APS_DL2_R_EQ_sizeof                               9
-#define C_Vibra2_consts_ADDR                                1195
-#define C_Vibra2_consts_ADDR_END                            1198
+#define C_Vibra2_consts_ADDR                                1196
+#define C_Vibra2_consts_ADDR_END                            1199
 #define C_Vibra2_consts_sizeof                              4
-#define C_Vibra1_coeffs_ADDR                                1199
-#define C_Vibra1_coeffs_ADDR_END                            1209
+#define C_Vibra1_coeffs_ADDR                                1200
+#define C_Vibra1_coeffs_ADDR_END                            1210
 #define C_Vibra1_coeffs_sizeof                              11
-#define C_48_96_LP_Coefs_ADDR                               1210
-#define C_48_96_LP_Coefs_ADDR_END                           1224
+#define C_48_96_LP_Coefs_ADDR                               1211
+#define C_48_96_LP_Coefs_ADDR_END                           1225
 #define C_48_96_LP_Coefs_sizeof                             15
-#define C_96_48_AMIC_Coefs_ADDR                             1225
-#define C_96_48_AMIC_Coefs_ADDR_END                         1243
+#define C_96_48_AMIC_Coefs_ADDR                             1226
+#define C_96_48_AMIC_Coefs_ADDR_END                         1244
 #define C_96_48_AMIC_Coefs_sizeof                           19
-#define C_96_48_DMIC_Coefs_ADDR                             1244
-#define C_96_48_DMIC_Coefs_ADDR_END                         1262
+#define C_96_48_DMIC_Coefs_ADDR                             1245
+#define C_96_48_DMIC_Coefs_ADDR_END                         1263
 #define C_96_48_DMIC_Coefs_sizeof                           19
-#define C_INPUT_SCALE_ADDR                                  1263
-#define C_INPUT_SCALE_ADDR_END                              1263
+#define C_INPUT_SCALE_ADDR                                  1264
+#define C_INPUT_SCALE_ADDR_END                              1264
 #define C_INPUT_SCALE_sizeof                                1
-#define C_OUTPUT_SCALE_ADDR                                 1264
-#define C_OUTPUT_SCALE_ADDR_END                             1264
+#define C_OUTPUT_SCALE_ADDR                                 1265
+#define C_OUTPUT_SCALE_ADDR_END                             1265
 #define C_OUTPUT_SCALE_sizeof                               1
-#define C_MUTE_SCALING_ADDR                                 1265
-#define C_MUTE_SCALING_ADDR_END                             1265
+#define C_MUTE_SCALING_ADDR                                 1266
+#define C_MUTE_SCALING_ADDR_END                             1266
 #define C_MUTE_SCALING_sizeof                               1
-#define C_GAINS_0DB_ADDR                                    1266
-#define C_GAINS_0DB_ADDR_END                                1267
+#define C_GAINS_0DB_ADDR                                    1267
+#define C_GAINS_0DB_ADDR_END                                1268
 #define C_GAINS_0DB_sizeof                                  2
-#define C_AlphaCurrent_BT_UL_ADDR                           1268
-#define C_AlphaCurrent_BT_UL_ADDR_END                       1268
+#define C_AlphaCurrent_BT_UL_ADDR                           1269
+#define C_AlphaCurrent_BT_UL_ADDR_END                       1269
 #define C_AlphaCurrent_BT_UL_sizeof                         1
-#define C_BetaCurrent_BT_UL_ADDR                            1269
-#define C_BetaCurrent_BT_UL_ADDR_END                        1269
+#define C_BetaCurrent_BT_UL_ADDR                            1270
+#define C_BetaCurrent_BT_UL_ADDR_END                        1270
 #define C_BetaCurrent_BT_UL_sizeof                          1
-#define C_AlphaCurrent_BT_DL_ADDR                           1270
-#define C_AlphaCurrent_BT_DL_ADDR_END                       1270
+#define C_AlphaCurrent_BT_DL_ADDR                           1271
+#define C_AlphaCurrent_BT_DL_ADDR_END                       1271
 #define C_AlphaCurrent_BT_DL_sizeof                         1
-#define C_BetaCurrent_BT_DL_ADDR                            1271
-#define C_BetaCurrent_BT_DL_ADDR_END                        1271
+#define C_BetaCurrent_BT_DL_ADDR                            1272
+#define C_BetaCurrent_BT_DL_ADDR_END                        1272
 #define C_BetaCurrent_BT_DL_sizeof                          1
-#endif/* _ABECM_ADDR_H_ */
+#endif /* _ABECM_ADDR_H_ */
Index: kernel/sound/soc/omap/abe/abe_dat.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_dat.c	2011-03-28 12:30:01.058353357 +0900
+++ kernel/sound/soc/omap/abe/abe_dat.c	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,40 +18,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+
 #include "abe_main.h"
-#ifndef abe_dat_c
-#define abe_dat_c
+
 const u32 abe_firmware_array[ABE_FIRMWARE_MAX_SIZE] = {
 #include "abe_firmware.c"
 };
-u32 abe_firmware_version_number;
-/*
- * Kernel base
- */
-void __iomem *io_base;
-/*
- * global variable : saves stack area
- */
-u16 MultiFrame[PROCESSING_SLOTS][TASKS_IN_SLOT];
-ABE_SIODescriptor sio_desc;
-ABE_SPingPongDescriptor desc_pp;
-abe_satcdescriptor_aess atc_desc;
-/*
- * automatic gain control of input mixer's gains
- */
-u32 abe_compensated_mixer_gain;
-u8 abe_muted_gains_indicator[MAX_NBGAIN_CMEM];
-u32 abe_desired_gains_decibel[MAX_NBGAIN_CMEM];
-u32 abe_muted_gains_decibel[MAX_NBGAIN_CMEM];
-u32 abe_desired_gains_linear[MAX_NBGAIN_CMEM];
-u32 abe_desired_ramp_delay_ms[MAX_NBGAIN_CMEM];
-/*
- * HAL/FW ports status / format / sampling / protocol(call_back) / features
- *	/ gain / name
- */
-u32 pdm_dl1_status;
-u32 pdm_dl2_status;
-u32 pdm_vib_status;
+
+struct omap_abe *abe;
+
 /*
  * HAL/FW ports status / format / sampling / protocol(call_back) / features
  *	/ gain / name
@@ -63,7 +38,7 @@
 	   reseted at start Port Name for the debug trace */
 	/* DMIC */ {
 		    OMAP_ABE_PORT_ACTIVITY_IDLE, {96000, SIX_MSB},
-		    NODRIFT, NOCALLBACK, 0, (DMIC_ITER / 6),
+		    NODRIFT, NOCALLBACK, 0, (DMIC_ITER/6),
 		    {
 		     SNK_P, DMIC_PORT_PROT,
 		     {{dmem_dmic, dmem_dmic_size, DMIC_ITER} }
@@ -72,7 +47,7 @@
 		    {EQDMIC, 0}, "DMIC"},
 	/* PDM_UL */ {
 		      OMAP_ABE_PORT_ACTIVITY_IDLE, {96000, STEREO_MSB},
-		      NODRIFT, NOCALLBACK, smem_amic, (MCPDM_UL_ITER / 2),
+		      NODRIFT, NOCALLBACK, smem_amic, (MCPDM_UL_ITER/2),
 		      {
 		       SNK_P, MCPDMUL_PORT_PROT,
 		       {{dmem_amic, dmem_amic_size, MCPDM_UL_ITER} }
@@ -84,11 +59,11 @@
 			NODRIFT, NOCALLBACK, smem_bt_vx_ul_opp50, 1,
 			{
 			 SNK_P, SERIAL_PORT_PROT, {{
-						    (MCBSP1_DMA_TX*ATC_SIZE),
-						    dmem_bt_vx_ul,
-						    dmem_bt_vx_ul_size,
-						    (1*SCHED_LOOP_8kHz)
-						    } }
+						   (MCBSP1_DMA_TX*ATC_SIZE),
+						   dmem_bt_vx_ul,
+						   dmem_bt_vx_ul_size,
+						   (1*SCHED_LOOP_8kHz)
+						   } }
 			 },
 			{0, 0}, {0}, "BT_VX_UL"},
 	/* MM_UL */ {
@@ -96,11 +71,11 @@
 		     NODRIFT, NOCALLBACK, smem_mm_ul, 1,
 		     {
 		      SRC_P, DMAREQ_PORT_PROT, {{
-						 (CBPr_DMA_RTX3*ATC_SIZE),
-						 dmem_mm_ul, dmem_mm_ul_size,
-						 (10*SCHED_LOOP_48kHz),
-						 ABE_DMASTATUS_RAW, (1 << 3)
-						 } }
+						(CBPr_DMA_RTX3*ATC_SIZE),
+						dmem_mm_ul, dmem_mm_ul_size,
+						(10*SCHED_LOOP_48kHz),
+						ABE_DMASTATUS_RAW, (1 << 3)
+						} }
 		      },
 		     {CIRCULAR_BUFFER_PERIPHERAL_R__3, 120},
 		     {UPROUTE, 0}, "MM_UL"},
@@ -109,11 +84,11 @@
 		      NODRIFT, NOCALLBACK, smem_mm_ul2, 1,
 		      {
 		       SRC_P, DMAREQ_PORT_PROT, {{
-						  (CBPr_DMA_RTX4*ATC_SIZE),
-						  dmem_mm_ul2, dmem_mm_ul2_size,
-						  (2*SCHED_LOOP_48kHz),
-						  ABE_DMASTATUS_RAW, (1 << 4)
-						  } }
+						 (CBPr_DMA_RTX4*ATC_SIZE),
+						 dmem_mm_ul2, dmem_mm_ul2_size,
+						 (2*SCHED_LOOP_48kHz),
+						 ABE_DMASTATUS_RAW, (1 << 4)
+						 } }
 		       },
 		      {CIRCULAR_BUFFER_PERIPHERAL_R__4, 24},
 		      {UPROUTE, 0}, "MM_UL2"},
@@ -122,11 +97,11 @@
 		     NODRIFT, NOCALLBACK, smem_vx_ul, 1,
 		     {
 		      SRC_P, DMAREQ_PORT_PROT, {{
-						 (CBPr_DMA_RTX2*ATC_SIZE),
-						 dmem_vx_ul, dmem_vx_ul_size,
-						 (1*SCHED_LOOP_8kHz),
-						 ABE_DMASTATUS_RAW, (1 << 2)
-						 } }
+						(CBPr_DMA_RTX2*ATC_SIZE),
+						dmem_vx_ul, dmem_vx_ul_size,
+						(1*SCHED_LOOP_8kHz),
+						ABE_DMASTATUS_RAW, (1 << 2)
+						} }
 		      }, {
 			  CIRCULAR_BUFFER_PERIPHERAL_R__2, 2},
 		     {ASRC2, 0}, "VX_UL"},
@@ -135,11 +110,11 @@
 		     NODRIFT, NOCALLBACK, smem_mm_dl, 1,
 		     {
 		      SNK_P, PINGPONG_PORT_PROT, {{
-						   (CBPr_DMA_RTX0*ATC_SIZE),
-						   dmem_mm_dl, dmem_mm_dl_size,
-						   (2*SCHED_LOOP_48kHz),
-						   ABE_DMASTATUS_RAW, (1 << 0)
-						   } }
+						  (CBPr_DMA_RTX0*ATC_SIZE),
+						  dmem_mm_dl, dmem_mm_dl_size,
+						  (2*SCHED_LOOP_48kHz),
+						  ABE_DMASTATUS_RAW, (1 << 0)
+						  } }
 		      },
 		     {CIRCULAR_BUFFER_PERIPHERAL_R__0, 24},
 		     {ASRC3, 0}, "MM_DL"},
@@ -148,11 +123,11 @@
 		     NODRIFT, NOCALLBACK, smem_vx_dl, 1,
 		     {
 		      SNK_P, DMAREQ_PORT_PROT, {{
-						 (CBPr_DMA_RTX1*ATC_SIZE),
-						 dmem_vx_dl, dmem_vx_dl_size,
-						 (1*SCHED_LOOP_8kHz),
-						 ABE_DMASTATUS_RAW, (1 << 1)
-						 } }
+						(CBPr_DMA_RTX1*ATC_SIZE),
+						dmem_vx_dl, dmem_vx_dl_size,
+						(1*SCHED_LOOP_8kHz),
+						ABE_DMASTATUS_RAW, (1 << 1)
+						} }
 		      },
 		     {CIRCULAR_BUFFER_PERIPHERAL_R__1, 2},
 		     {ASRC1, 0}, "VX_DL"},
@@ -161,12 +136,12 @@
 			NODRIFT, NOCALLBACK, smem_tones_dl, 1,
 			{
 			 SNK_P, DMAREQ_PORT_PROT, {{
-						    (CBPr_DMA_RTX5*ATC_SIZE),
-						    dmem_tones_dl,
-						    dmem_tones_dl_size,
-						    (2*SCHED_LOOP_48kHz),
-						    ABE_DMASTATUS_RAW, (1 << 5)
-						    } }
+						   (CBPr_DMA_RTX5*ATC_SIZE),
+						   dmem_tones_dl,
+						   dmem_tones_dl_size,
+						   (2*SCHED_LOOP_48kHz),
+						   ABE_DMASTATUS_RAW, (1 << 5)
+						   } }
 			 },
 			{CIRCULAR_BUFFER_PERIPHERAL_R__5, 24},
 			{0}, "TONES_DL"},
@@ -175,11 +150,11 @@
 		      NODRIFT, NOCALLBACK, smem_vib, 1,
 		      {
 		       SNK_P, DMAREQ_PORT_PROT, {{
-						  (CBPr_DMA_RTX6*ATC_SIZE),
-						  dmem_vib_dl, dmem_vib_dl_size,
-						  (2*SCHED_LOOP_24kHz),
-						  ABE_DMASTATUS_RAW, (1 << 6)
-						  } }
+						 (CBPr_DMA_RTX6*ATC_SIZE),
+						 dmem_vib_dl, dmem_vib_dl_size,
+						 (2*SCHED_LOOP_24kHz),
+						 ABE_DMASTATUS_RAW, (1 << 6)
+						 } }
 		       },
 		      {CIRCULAR_BUFFER_PERIPHERAL_R__6, 12},
 		      {0}, "VIB_DL"},
@@ -188,18 +163,18 @@
 			NODRIFT, NOCALLBACK, smem_bt_vx_dl_opp50, 1,
 			{
 			 SRC_P, SERIAL_PORT_PROT, {{
-						    (MCBSP1_DMA_RX*ATC_SIZE),
-						    dmem_bt_vx_dl,
-						    dmem_bt_vx_dl_size,
-						    (1*SCHED_LOOP_8kHz),
-						    } }
+						   (MCBSP1_DMA_RX*ATC_SIZE),
+						   dmem_bt_vx_dl,
+						   dmem_bt_vx_dl_size,
+						   (1*SCHED_LOOP_8kHz),
+						   } }
 			 },
 			{0, 0}, {0}, "BT_VX_DL"},
 	/* PDM_DL */ {
 		      OMAP_ABE_PORT_ACTIVITY_IDLE, {96000, SIX_MSB},
-		      NODRIFT, NOCALLBACK, 0, (MCPDM_DL_ITER / 6),
-		      {SRC_P, MCPDMDL_PORT_PROT,
-		       {{dmem_mcpdm, dmem_mcpdm_size} } },
+		      NODRIFT, NOCALLBACK, 0, (MCPDM_DL_ITER/6),
+		      {SRC_P, MCPDMDL_PORT_PROT, {{dmem_mcpdm,
+						dmem_mcpdm_size} } },
 		      {0, 0},
 		      {MIXDL1, EQ1, APS1, MIXDL2, EQ2L, EQ2R, APS2L, APS2R, 0},
 		      "PDM_DL"},
@@ -209,10 +184,10 @@
 	 NODRIFT, NOCALLBACK, smem_mm_ext_out, 1,
 	 {
 	  SRC_P, SERIAL_PORT_PROT, {{
-				     (MCBSP1_DMA_TX*ATC_SIZE),
-				     dmem_mm_ext_out, dmem_mm_ext_out_size,
-				     (2*SCHED_LOOP_48kHz)
-				     } }
+				    (MCBSP1_DMA_TX*ATC_SIZE),
+				    dmem_mm_ext_out, dmem_mm_ext_out_size,
+				    (2*SCHED_LOOP_48kHz)
+				    } }
 	  }, {0, 0}, {0}, "MM_EXT_OUT"},
 	/* MM_EXT_IN */
 	{
@@ -220,10 +195,10 @@
 	 NODRIFT, NOCALLBACK, smem_mm_ext_in_opp100, 1,
 	 {
 	  SNK_P, SERIAL_PORT_PROT, {{
-				     (MCBSP1_DMA_RX*ATC_SIZE),
-				     dmem_mm_ext_in, dmem_mm_ext_in_size,
-				     (2*SCHED_LOOP_48kHz)
-				     } }
+				    (MCBSP1_DMA_RX*ATC_SIZE),
+				    dmem_mm_ext_in, dmem_mm_ext_in_size,
+				    (2*SCHED_LOOP_48kHz)
+				    } }
 	  },
 	 {0, 0}, {0}, "MM_EXT_IN"},
 	/* PCM3_TX */ {
@@ -231,12 +206,12 @@
 		       NODRIFT, NOCALLBACK, 0, 1,
 		       {
 			SRC_P, TDM_SERIAL_PORT_PROT, {{
-						       (MCBSP3_DMA_TX *
-							ATC_SIZE),
-						       dmem_mm_ext_out,
-						       dmem_mm_ext_out_size,
-						       (2*SCHED_LOOP_48kHz)
-						       } }
+						      (MCBSP3_DMA_TX *
+						       ATC_SIZE),
+						      dmem_mm_ext_out,
+						      dmem_mm_ext_out_size,
+						      (2*SCHED_LOOP_48kHz)
+						      } }
 			},
 		       {0, 0}, {0}, "TDM_OUT"},
 	/* PCM3_RX */ {
@@ -244,12 +219,12 @@
 		       NODRIFT, NOCALLBACK, 0, 1,
 		       {
 			SRC_P, TDM_SERIAL_PORT_PROT, {{
-						       (MCBSP3_DMA_RX *
-							ATC_SIZE),
-						       dmem_mm_ext_in,
-						       dmem_mm_ext_in_size,
-						       (2*SCHED_LOOP_48kHz)
-						       } }
+						      (MCBSP3_DMA_RX *
+						       ATC_SIZE),
+						      dmem_mm_ext_in,
+						      dmem_mm_ext_in_size,
+						      (2*SCHED_LOOP_48kHz)
+						      } }
 			},
 		       {0, 0}, {0}, "TDM_IN"},
 	/* SCHD_DBG_PORT */ {
@@ -257,14 +232,14 @@
 			     NODRIFT, NOCALLBACK, 0, 1,
 			     {
 			      SRC_P, DMAREQ_PORT_PROT, {{
-							 (CBPr_DMA_RTX7 *
-							  ATC_SIZE),
-							 dmem_mm_trace,
-							 dmem_mm_trace_size,
-							 (2*SCHED_LOOP_48kHz),
-							 ABE_DMASTATUS_RAW,
-							 (1 << 4)
-							 } }
+							(CBPr_DMA_RTX7 *
+							 ATC_SIZE),
+							dmem_mm_trace,
+							dmem_mm_trace_size,
+							(2*SCHED_LOOP_48kHz),
+							ABE_DMASTATUS_RAW,
+							(1 << 4)
+							} }
 			      }, {CIRCULAR_BUFFER_PERIPHERAL_R__7, 24},
 			     {FEAT_SEQ, FEAT_CTL, FEAT_GAINS, 0}, "SCHD_DBG"},
 };
@@ -555,7 +530,7 @@
  typedef double (*PtrFun) (double);
 PtrFun pFun;
 pFun = sin;
-       y = (* pFun) (x);
+   y = (* pFun) (x);
 *//* mask, { time id param tag1} */
 const abe_sequence_t seq_null = {
 	NOMASK, {CL_M1, 0, {0, 0, 0, 0}, 0}, {CL_M1, 0, {0, 0, 0, 0}, 0}
@@ -788,25 +763,6 @@
  * ABE_DEBUG DATA
  */
 /*
- * IRQ and trace pointer in DMEM:
- * FW updates a write pointer at "MCU_IRQ_FIFO_ptr_labelID", the read pointer is in HAL
- */
-u32 abe_irq_dbg_read_ptr;
-/*
- * General circular buffer used to trace APIs calls and AE activity.
- */
-u32 abe_dbg_activity_log[D_DEBUG_HAL_TASK_sizeof];
-u32 abe_dbg_activity_log_write_pointer;
-u32 abe_dbg_mask;
-/*
- * Global variable holding parameter errors
- */
-u32 abe_dbg_param;
-/*
- * Output of messages selector
- */
-u32 abe_dbg_output;
-/*
  * last parameters
  */
 #define SIZE_PARAM 10
@@ -836,24 +792,4 @@
 	BT_VX_UL_PORT,
 	VIB_DL_PORT,
 };
-/*
- * ABE CONST AREA FOR DMIC DECIMATION FILTERS
- */
-/* const s32 abe_dmic_40 [C_98_48_LP_Coefs_sizeof] = {
-	-4119413, -192384, -341428, -348088, -151380, 151380, 348088,
-	341428, 192384, 4119415, 1938156, -6935719, 775202, -1801934,
-	2997698, -3692214, 3406822, -2280190, 1042982 };
-const s32 abe_dmic_32 [C_98_48_LP_Coefs_sizeof] = {
-	-4119413, -192384, -341428, -348088, -151380, 151380, 348088,
-	341428, 192384, 4119415, 1938156, -6935719, 775202, -1801934,
-	2997698, -3692214, 3406822, -2280190, 1042982 };
-const s32 abe_dmic_25 [C_98_48_LP_Coefs_sizeof] = {
-	-4119413, -192384, -341428, -348088, -151380, 151380, 348088,
-	341428, 192384, 4119415, 1938156, -6935719, 775202, -1801934,
-	2997698, -3692214, 3406822, -2280190, 1042982 };
-const s32 abe_dmic_16 [C_98_48_LP_Coefs_sizeof] = {
-	-4119413, -192384, -341428, -348088, -151380, 151380, 348088,
-	341428, 192384, 4119415, 1938156, -6935719, 775202, -1801934,
-	2997698, -3692214, 3406822, -2280190, 1042982 };
-*/
-#endif/* abe_dat_c */
+
Index: kernel/sound/soc/omap/abe/abe_dbg.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_dbg.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_dbg.c	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,6 +19,8 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
+#include "abe_ref.h"
+
 /**
  * abe_dbg_log - Log ABE trace inside circular buffer
  * @x: data to be logged
@@ -35,39 +37,41 @@
 void abe_dbg_log(u32 x, u32 y, u32 z, u32 t)
 {
 	u32 time_stamp, data;
-	if (abe_dbg_activity_log_write_pointer >= (D_DEBUG_HAL_TASK_sizeof - 2))
-		abe_dbg_activity_log_write_pointer = 0;
+	if (abe->dbg_activity_log_write_pointer >=
+			(D_DEBUG_HAL_TASK_sizeof - 2))
+		abe->dbg_activity_log_write_pointer = 0;
 	/* copy in DMEM trace buffer and CortexA9 local buffer and a small 7
 	   words circular buffer of the DMA trace ending with 0x55555555
 	   (tag for last word) */
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM, D_loopCounter_ADDR,
 		       (u32 *) &time_stamp, sizeof(time_stamp));
-	abe_dbg_activity_log[abe_dbg_activity_log_write_pointer] = time_stamp;
+	abe->dbg_activity_log[abe->dbg_activity_log_write_pointer] = time_stamp;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_DEBUG_HAL_TASK_ADDR +
-		       (abe_dbg_activity_log_write_pointer << 2),
+		       (abe->dbg_activity_log_write_pointer << 2),
 		       (u32 *) &time_stamp, sizeof(time_stamp));
-	abe_dbg_activity_log_write_pointer++;
+	abe->dbg_activity_log_write_pointer++;
 	data = ((x & MAX_UINT8) << 24) | ((y & MAX_UINT8) << 16) |
 		((z & MAX_UINT8) << 8)
 		| (t & MAX_UINT8);
-	abe_dbg_activity_log[abe_dbg_activity_log_write_pointer] = data;
+	abe->dbg_activity_log[abe->dbg_activity_log_write_pointer] = data;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_DEBUG_HAL_TASK_ADDR +
-		       (abe_dbg_activity_log_write_pointer << 2),
+		       (abe->dbg_activity_log_write_pointer << 2),
 		       (u32 *) &data, sizeof(data));
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       D_DEBUG_FIFO_HAL_ADDR +
-		       ((abe_dbg_activity_log_write_pointer << 2) &
+		       ((abe->dbg_activity_log_write_pointer << 2) &
 			(D_DEBUG_FIFO_HAL_sizeof - 1)), (u32 *) &data,
 		       sizeof(data));
 	data = ABE_DBG_MAGIC_NUMBER;
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_DEBUG_FIFO_HAL_ADDR +
-		       (((abe_dbg_activity_log_write_pointer +
-			  1) << 2) &(D_DEBUG_FIFO_HAL_sizeof - 1)),
+		       (((abe->dbg_activity_log_write_pointer +
+			  1) << 2) & (D_DEBUG_FIFO_HAL_sizeof - 1)),
 		       (u32 *) &data, sizeof(data));
-	abe_dbg_activity_log_write_pointer++;
-	if (abe_dbg_activity_log_write_pointer >= D_DEBUG_HAL_TASK_sizeof)
-		abe_dbg_activity_log_write_pointer = 0;
+	abe->dbg_activity_log_write_pointer++;
+	if (abe->dbg_activity_log_write_pointer >= D_DEBUG_HAL_TASK_sizeof)
+		abe->dbg_activity_log_write_pointer = 0;
 }
+
 /**
  * abe_debug_output_pins
  * @x: d
@@ -77,6 +81,7 @@
 void abe_debug_output_pins(u32 x)
 {
 }
+
 /**
  * abe_dbg_error_log -  Log ABE error
  * @x: error to log
@@ -87,6 +92,7 @@
 {
 	abe_dbg_log(x, MAX_UINT8, MAX_UINT8, MAX_UINT8);
 }
+
 /**
  * abe_debugger
  * @x: error to log
@@ -96,17 +102,23 @@
 void abe_debugger(u32 x)
 {
 }
+
 /**
  * abe_load_embeddded_patterns
  *
  * load test patterns
  *
  *  S = power (2, 31) * 0.25;
- *  N =  4; B = 2; F=[1/N 1/N]; gen_and_save('dbg_8k_2.txt',  B, F, N, S);
- *  N =  8; B = 2; F=[1/N 2/N]; gen_and_save('dbg_16k_2.txt', B, F, N, S);
- *  N = 12; B = 2; F=[1/N 2/N]; gen_and_save('dbg_48k_2.txt', B, F, N, S);
- *  N = 60; B = 2; F=[4/N 8/N]; gen_and_save('dbg_amic.txt', B, F, N, S);
- *  N = 10; B = 6; F=[1/N 2/N 3/N 1/N 2/N 3/N]; gen_and_save('dbg_dmic.txt', B, F, N, S);
+ *  N =  4; B = 2; F=[1/N 1/N];
+ *	gen_and_save('dbg_8k_2.txt',  B, F, N, S);
+ *  N =  8; B = 2; F=[1/N 2/N];
+ *	gen_and_save('dbg_16k_2.txt', B, F, N, S);
+ *  N = 12; B = 2; F=[1/N 2/N];
+ *	gen_and_save('dbg_48k_2.txt', B, F, N, S);
+ *  N = 60; B = 2; F=[4/N 8/N];
+ *	gen_and_save('dbg_amic.txt', B, F, N, S);
+ *  N = 10; B = 6; F=[1/N 2/N 3/N 1/N 2/N 3/N];
+ *	gen_and_save('dbg_dmic.txt', B, F, N, S);
 */
 void abe_load_embeddded_patterns(void)
 {
Index: kernel/sound/soc/omap/abe/abe_dbg.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_dbg.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_dbg.h	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -146,4 +146,5 @@
 /*
  * MACROS
  */
-#define _log(x, y, z, t) {if (x & abe_dbg_mask) abe_dbg_log(x, y, z, t); }
+#define _log(x, y, z, t) { if (x & abe->dbg_mask) abe_dbg_log(x, y, z, t); }
+
Index: kernel/sound/soc/omap/abe/abe_def.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_def.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_def.h	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -81,7 +81,7 @@
 #define CS_M1 0xFFFF
 #define CL_M1 0xFFFFFFFFL
 /*
-	Mixer ID 	 Input port ID	 Comments
+	Mixer ID	 Input port ID		Comments
 	DL1_MIXER	 0 MMDL path
 	 1 MMUL2 path
 	 2 VXDL path
@@ -188,7 +188,7 @@
  * ABE CONST AREA FOR PARAMETERS TRANSLATION
  */
 #define min_mdb (-12000)
-#define max_mdb ( 3000)
+#define max_mdb (3000)
 #define sizeof_db2lin_table (1 + ((max_mdb - min_mdb)/100))
 #define sizeof_alpha_iir_table 61
 #define sizeof_beta_iir_table 61
@@ -263,12 +263,12 @@
 #define c_feat_read_eq3 6
 #define c_write_eq3 7
 /* max number of gain to be controlled by HAL */
-#define MAX_NBGAIN_CMEM 34
+#define MAX_NBGAIN_CMEM 36
 /*
  * MACROS
  */
-#define maximum(a,b) (((a)<(b))?(b):(a))
-#define minimum(a,b) (((a)>(b))?(b):(a))
-#define absolute(a) (((a)>0)?(a):((-1)*(a)))
+#define maximum(a, b) (((a) < (b)) ? (b) : (a))
+#define minimum(a, b) (((a) > (b)) ? (b) : (a))
+#define absolute(a) (((a) > 0) ? (a) : ((-1)*(a)))
 #define HAL_VERSIONS 9
 #endif/* _ABE_DEF_H_ */
Index: kernel/sound/soc/omap/abe/abe_define.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_define.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_define.h	2011-03-28 15:57:05.788354240 +0900
@@ -52,9 +52,9 @@
 #define SAMP_LOOP_48K                                       12
 #define SAMP_LOOP_16K                                       4
 #define SAMP_LOOP_8K                                        2
-#define INPUT_SCALE_SHIFTM2                                 5052
-#define OUTPUT_SCALE_SHIFTM2                                5056
-#define MUTE_SCALING                                        5060
+#define INPUT_SCALE_SHIFTM2                                 5056
+#define OUTPUT_SCALE_SHIFTM2                                5060
+#define MUTE_SCALING                                        5064
 #define ABE_PMEM                                            1
 #define ABE_CMEM                                            2
 #define ABE_SMEM                                            3
@@ -62,4 +62,4 @@
 #define ABE_ATC                                             5
 #define ASRC_BT_UL_FIR_L                                    19
 #define ASRC_BT_DL_FIR_L                                    19
-#endif/* _ABE_DEFINE_H_ */
+#endif /* _ABE_DEFINE_H_ */
Index: kernel/sound/soc/omap/abe/abe_dm_addr.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_dm_addr.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_dm_addr.h	2011-03-28 15:57:05.788354240 +0900
@@ -323,4 +323,4 @@
 #define D_PONG_ADDR                                         40960
 #define D_PONG_ADDR_END                                     65535
 #define D_PONG_sizeof                                       24576
-#endif/* _ABEDM_ADDR_H_ */
+#endif /* _ABEDM_ADDR_H_ */
Index: kernel/sound/soc/omap/abe/abe_ext.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_ext.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_ext.c	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,6 +20,7 @@
  */
 #include "abe_main.h"
 #define ENABLE_DEFAULT_PLAYERS 0
+
 /**
  * abe_default_irq_pingpong_player
  *
@@ -28,11 +29,12 @@
 void abe_default_irq_pingpong_player(void)
 {
 #if ENABLE_DEFAULT_PLAYERS
-#define N_SAMPLES_MAX ((int)(1024))	/* ping-pong access to MM_DL at 48kHz Mono with 20ms packet sizes */
+/* ping-pong access to MM_DL at 48kHz Mono with 20ms packet sizes */
+#define N_SAMPLES_MAX ((int)(1024))
 	static s32 idx;
 	u32 i, dst, n_samples, n_bytes;
 	s32 temp[N_SAMPLES_MAX], audio_sample;
-#define DATA_SIZE 20		/* t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
+#define DATA_SIZE 20	/* t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
 	const s32 audio_pattern[DATA_SIZE] = {
 		0, 5063, 9630, 13254, 15581, 16383, 15581, 13254, 9630,
 		5063, 0, -5063, -9630, -13254, -15581, -16383, -15581,
@@ -72,12 +74,13 @@
 	abe_set_ping_pong_buffer(MM_DL_PORT, n_bytes);
 #endif
 }
+
 /**
  * abe_default_irq_pingpong_player_32bits
  *
  * generates data for the cache-flush buffer  MODE 32 BITS
  * Return value:
- * None.
+ *	none
  */
 void abe_default_irq_pingpong_player_32bits(void)
 {
@@ -86,7 +89,7 @@
 	static s32 idx;
 	u32 i, dst, n_samples, n_bytes;
 	s32 temp[N_SAMPLES_MAX], audio_sample;
-#define DATA_SIZE 20		/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
+#define DATA_SIZE 20	/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
 	const s32 audio_pattern[DATA_SIZE] = {
 		0, 5063, 9630, 13254, 15581, 16383, 15581, 13254,
 		9630, 5063, 0, -5063, -9630, -13254, -15581, -16383,
@@ -114,12 +117,13 @@
 	abe_set_ping_pong_buffer(MM_DL_PORT, n_bytes);
 #endif
 }
+
 /**
  * abe_rshifted16_irq_pingpong_player_32bits
  *
  * generates data for the cache-flush buffer  MODE 32 BITS
  * Return value:
- * None.
+ *	none
  */
 void abe_rshifted16_irq_pingpong_player_32bits(void)
 {
@@ -128,7 +132,7 @@
 	static s32 idx;
 	u32 i, dst, n_samples, n_bytes;
 	s32 temp[N_SAMPLES_MAX], audio_sample;
-#define DATA_SIZE 20		/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
+#define DATA_SIZE 20	/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
 	const s32 audio_pattern[DATA_SIZE] = {
 		0, 5063, 9630, 13254, 15581, 16383, 15581, 13254,
 		9630, 5063, 0, -5063, -9630, -13254, -15581, -16383,
@@ -156,12 +160,13 @@
 	abe_set_ping_pong_buffer(MM_DL_PORT, n_bytes);
 #endif
 }
+
 /**
  * abe_1616_irq_pingpong_player_1616bits
  *
  * generates data for the cache-flush buffer  MODE 16+16 BITS
  * Return value:
- * None.
+ *	none
  */
 void abe_1616_irq_pingpong_player_1616bits(void)
 {
@@ -170,7 +175,7 @@
 	static s32 idx;
 	u32 i, dst, n_samples, n_bytes;
 	s32 temp[N_SAMPLES_MAX], audio_sample;
-#define DATA_SIZE 20		/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
+#define DATA_SIZE 20	/*  t = [0:N-1]/N; x = round(16383*sin(2*pi*t)) */
 	const s32 audio_pattern[DATA_SIZE] = {
 		0, 5063, 9630, 13254, 15581, 16383, 15581, 13254,
 		9630, 5063, 0, -5063, -9630, -13254, -15581, -16383,
@@ -197,6 +202,7 @@
 	abe_set_ping_pong_buffer(MM_DL_PORT, n_bytes);
 #endif
 }
+
 /**
  * abe_default_irq_aps_adaptation
  *
@@ -205,6 +211,7 @@
 void abe_default_irq_aps_adaptation(void)
 {
 }
+
 /**
  * abe_read_sys_clock
  * @time: pointer to the system clock
@@ -217,6 +224,7 @@
 	*time = clock;
 	clock++;
 }
+
 /**
  * abe_aps_tuning
  *
Index: kernel/sound/soc/omap/abe/abe_ext.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_ext.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_ext.h	2011-03-28 15:57:05.788354240 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 	Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,8 +20,6 @@
  */
 #ifndef _ABE_EXT_H_
 #define _ABE_EXT_H_
-/* Tuning is done on PC ? */
-#define PC_SIMULATION 0
 /*
  * OS DEPENDENT MMU CONFIGURATION
  */
@@ -34,23 +32,8 @@
 #define ABE_ATC_BASE_OFFSET_MPU		0xf1000
 /* default base address for io_base */
 #define ABE_DEFAULT_BASE_ADDRESS_L3 0x49000000L
-/* base address used for L3/DMA access */
-#define ABE_ATC_BASE_ADDRESS_L3 0x490F1000L
-/* base address used for L4/MCU access */
-#define ABE_ATC_BASE_ADDRESS_L4 0x401F1000L
-/* 64kB as seen from DMA access */
-#define ABE_DMEM_BASE_ADDRESS_L3 0x49080000L
-/* 64kB as seen from MCU access */
-#define ABE_DMEM_BASE_ADDRESS_L4 0x40180000L
-/* 8kB as seen from MPU access */
-#define ABE_PMEM_BASE_ADDRESS_MPU 0x490E0000L
-/* 8kB */
-#define ABE_CMEM_BASE_ADDRESS_MPU 0x490A0000L
-/* 24kB */
-#define ABE_SMEM_BASE_ADDRESS_MPU 0x490C0000L
-/* 64kB */
-#define ABE_DMEM_BASE_ADDRESS_MPU 0x49080000L
-#define ABE_ATC_BASE_ADDRESS_MPU 0x490F1000L
+#define ABE_DEFAULT_BASE_ADDRESS_L4 0x40100000L
+#define ABE_DEFAULT_BASE_ADDRESS_DEFAULT ABE_DEFAULT_BASE_ADDRESS_L3
 /*
  * HARDWARE AND PERIPHERAL DEFINITIONS
  */
@@ -74,9 +57,9 @@
 #define ABE_DMASTATUS_RAW 0x84
 #define EVENT_GENERATOR_COUNTER 0x68
 /* PLL output/desired sampling rate = (32768 * 6000)/96000 */
-#define EVENT_GENERATOR_COUNTER_DEFAULT 2048
+#define EVENT_GENERATOR_COUNTER_DEFAULT (2048-1)
 /* PLL output/desired sampling rate = (32768 * 6000)/88200 */
-#define EVENT_GENERATOR_COUNTER_44100 2228
+#define EVENT_GENERATOR_COUNTER_44100 (2228-1)
 /* start / stop the EVENT generator */
 #define EVENT_GENERATOR_START 0x6C
 #define EVENT_GENERATOR_ON 1
Index: kernel/sound/soc/omap/abe/abe_firmware.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_firmware.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_firmware.c	2011-03-28 15:57:05.798386525 +0900
@@ -1,8 +1,8 @@
-0x00009060,  /* VERSION NUMBER */
+0x00009110,  /* VERSION NUMBER */
 0x00002000,  /* PMEM LENGTH IN BYTES */
-0x000013E0,  /* CMEM LENGTH IN BYTES */
+0x000013E4,  /* CMEM LENGTH IN BYTES */
 0x00010000,  /* DMEM LENGTH IN BYTES */
-0x000044E8,  /* SMEM LENGTH IN BYTES */
+0x000044F0,  /* SMEM LENGTH IN BYTES */
 0x1600200f,
 0x0a000670,
 0x08200000,
@@ -205,9 +205,9 @@
 0x01400042,
 0x01400043,
 0x08200000,
-0x16000494,
-0x160004a5,
-0x160004b6,
+0x160004a4,
+0x160004b5,
+0x160004c6,
 0x16000007,
 0x9c032040,
 0x9c032950,
@@ -302,9 +302,9 @@
 0x9d0c8108,
 0x98801240,
 0x08200000,
-0x16000494,
-0x160004a5,
-0x160004b6,
+0x160004a4,
+0x160004b5,
+0x160004c6,
 0x160000bd,
 0x9c032340,
 0x9c032c50,
@@ -329,9 +329,9 @@
 0x9d032c50,
 0x9d033560,
 0x08200000,
-0x160004f4,
-0x16000505,
-0x16000516,
+0x16000504,
+0x16000515,
+0x16000526,
 0x9c03a440,
 0x9c03ad50,
 0x9c03b660,
@@ -852,7 +852,8 @@
 0x9d0c8128,
 0x988034a0,
 0x08200000,
-0x010002fe,
+0x048002ff,
+0x013ffefe,
 0x00801605,
 0x16002a63,
 0x12000155,
@@ -868,10 +869,13 @@
 0x12000155,
 0x0200035e,
 0x0b200000,
-0x000002fe,
+0x003ffefe,
+0x048ffeff,
 0x07800000,
 0x08200000,
+0x048004ff,
 0x16000181,
+0x40800a0d,
 0x04000101,
 0x00800b03,
 0x00000212,
@@ -881,41 +885,49 @@
 0xdc180404,
 0x06000003,
 0x9c180480,
-0x0aa03a10,
+0x0aa03ae0,
 0x9c052b20,
 0x9c042820,
 0x9c023970,
-0x07800000,
-0x07800000,
-0x9d01b060,
+0x40800e04,
 0x16000005,
+0x40800503,
+0x0600000d,
+0x9d01b060,
+0x4a803840,
+0x0400033d,
+0x04200427,
+0x04200d77,
+0x05800750,
+0x0ae03840,
+0x16000006,
+0x16000145,
+0x0a003ac0,
 0x160fffd6,
-0x00800e04,
-0x00800503,
 0x05800420,
-0x0ae03900,
+0x0ae039c0,
 0x160fffe6,
 0x04000344,
 0x05800420,
-0x0ae039f0,
+0x0ae03ab0,
 0x160ffff6,
 0x04000344,
 0x05800420,
-0x0ae039f0,
+0x0ae03ab0,
 0x16000006,
 0x04000344,
 0x05800420,
-0x0ae039f0,
+0x0ae03ab0,
 0x16000016,
 0x04000344,
 0x05800420,
-0x0ae039f0,
+0x0ae03ab0,
 0x16000026,
 0x04000344,
 0x05800420,
-0x0ae039f0,
+0x0ae03ab0,
 0x16000036,
-0x010000f6,
+0x013ffcf6,
 0x12000132,
 0x04000233,
 0x9e088300,
@@ -929,9 +941,10 @@
 0x17800523,
 0x04000377,
 0x9e0f0070,
-0x000000f6,
+0x003ffcf6,
+0x00800715,
 0x01000606,
-0x0a003e10,
+0x0a003ef0,
 0x9c042b20,
 0x9c052920,
 0x9c023870,
@@ -943,45 +956,45 @@
 0x160fffb6,
 0x00800503,
 0x05800420,
-0x0ae03d20,
+0x0ae03df0,
 0x160fffc6,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x160fffd6,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x160fffe6,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x160ffff6,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000006,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000016,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000026,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000036,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000046,
 0x04000344,
 0x05800420,
-0x0ae03e00,
+0x0ae03ed0,
 0x16000056,
-0x010000f6,
+0x013ffcf6,
 0x12000232,
 0x04000233,
 0x9e088300,
@@ -994,32 +1007,33 @@
 0x17800523,
 0x04000377,
 0x9e0f0170,
-0x000000f6,
+0x003ffcf6,
 0x01000606,
 0x00800715,
 0x16002a66,
-0x410004fe,
+0x413ffefe,
 0x12000155,
 0x00000202,
 0x00800d04,
 0x0200056e,
-0x16013bc6,
-0x16013c07,
+0x16013c06,
+0x16013c47,
 0x0400042d,
 0x04a001dd,
 0x9e0e0260,
 0x9e0e0370,
 0x0b200000,
 0x00000806,
-0x000004fe,
+0x003ffefe,
 0x0000021d,
 0x9e0e0560,
-0x00800b05,
+0x40800b05,
+0x048ffcff,
 0x408007d7,
 0x06000005,
 0x40800f02,
 0x04c07f77,
-0x4a804040,
+0x4a804120,
 0x04500273,
 0x00800a02,
 0x9e088100,
@@ -1070,8 +1084,8 @@
 0x9d0c810c,
 0x9d0c815c,
 0x9d0c81ac,
-0x98804250,
-0x0aa041d0,
+0x98804330,
+0x0aa042b0,
 0x9e0f0120,
 0x08200000,
 0x4080070d,
@@ -1083,28 +1097,28 @@
 0x413ffefe,
 0x06000004,
 0x9c03a950,
-0x4aa043f0,
+0x4aa044d0,
 0x144000d2,
-0x0a2046b0,
+0x0a204790,
 0x40000e04,
 0x1440002d,
 0x06000004,
-0x0a804530,
+0x0a804610,
 0x05800d40,
-0x0ae04430,
-0x0a204560,
-0x0a0044e0,
+0x0ae04510,
+0x0a204640,
+0x0a0045c0,
 0x042004d2,
 0x1440004d,
-0x0a204560,
-0x0a2046b0,
+0x0a204640,
+0x0a204790,
 0x06000002,
-0x0a8044e0,
+0x0a8045c0,
 0x1440002d,
 0x00000e04,
 0x05800d40,
-0x0ac04530,
-0x0a204560,
+0x0ac04610,
+0x0a204640,
 0x003ffefe,
 0x40800905,
 0x048ffeff,
@@ -1112,8 +1126,8 @@
 0x08200000,
 0x04a0012d,
 0x0a201690,
-0x0a0044e0,
-0x16013bc6,
+0x0a0045c0,
+0x16013c06,
 0x40800605,
 0x048002ff,
 0x413ffefe,
@@ -1139,19 +1153,19 @@
 0x40000403,
 0x04c001d7,
 0x06000007,
-0x4a8047a0,
+0x4a804880,
 0x16000017,
 0x00001604,
 0x06000004,
-0x0a8048c0,
+0x0a8049a0,
 0x40001405,
 0x048001dd,
 0x01000e04,
 0x01000c05,
-0x0a004810,
+0x0a0048f0,
 0x00001204,
 0x06000004,
-0x0a8048c0,
+0x0a8049a0,
 0x40001005,
 0x048001dd,
 0x01000e04,
@@ -1161,11 +1175,11 @@
 0x16000005,
 0x40800a04,
 0x05c00630,
-0x0a8048b0,
+0x0a804990,
 0x12000233,
 0x9e0e0530,
 0x9d140550,
-0x0a0048c0,
+0x0a0049a0,
 0x01800017,
 0x08200000,
 0x048008ff,
@@ -1191,13 +1205,13 @@
 0x01c00127,
 0x01c0012b,
 0x9c018201,
-0x988049c0,
+0x98804aa0,
 0x04800633,
 0x1440001d,
 0x00000034,
 0x04802833,
 0x01c00124,
-0x98804a70,
+0x98804b50,
 0x1602e8ca,
 0x16002102,
 0x408000a4,
@@ -1255,11 +1269,11 @@
 0x16000005,
 0x16000006,
 0x06000008,
-0x0aa04e70,
+0x0aa04f50,
 0x16000015,
 0x000002a8,
 0x06000009,
-0x0aa04eb0,
+0x0aa04f90,
 0x16000016,
 0x000002b9,
 0x1602cf42,
@@ -1271,12 +1285,12 @@
 0x1602c90d,
 0x41800027,
 0x06000004,
-0x0aa04fa0,
+0x0aa05080,
 0x06000005,
-0x0aa05020,
+0x0aa05100,
 0x06000001,
-0x0aa050b0,
-0x0a0051a0,
+0x0aa05190,
+0x0a005280,
 0x160000a8,
 0x400000d6,
 0x12000c88,
@@ -1284,7 +1298,7 @@
 0x07800000,
 0x06000005,
 0x9d180078,
-0x0a805090,
+0x0a805170,
 0x160000c8,
 0x400000d6,
 0x12000c88,
@@ -1293,7 +1307,7 @@
 0x07800000,
 0x9d180078,
 0x06000001,
-0x0a805120,
+0x0a805200,
 0x160000d8,
 0x400000d6,
 0x12000c88,
@@ -1302,7 +1316,7 @@
 0x07800000,
 0x9d180078,
 0x16000903,
-0x16000f99,
+0x16000fa9,
 0x16000016,
 0x9e0e0530,
 0x16000007,
@@ -1310,35 +1324,33 @@
 0x07800000,
 0x9d140570,
 0x1602c988,
+0x40000280,
 0x16000013,
 0x00000084,
-0x00000280,
-0x1602c942,
 0x06000000,
-0x00000049,
+0x40000049,
+0x1602c942,
+0x4a805320,
 0x16000005,
-0x0a805240,
 0x04200959,
-0x160ffff6,
 0x05800590,
-0x01000045,
+0x41000045,
+0x160ffff6,
 0x17000353,
 0x17800363,
 0x04800233,
 0x01000023,
 0x1601fe02,
 0x01004a23,
-0x003ffefb,
-0x003ffcfa,
-0x003ffaf9,
-0x003ff8f8,
-0x048ff8ff,
+0x403ffefb,
 0x16002202,
 0x9e0e0220,
+0x403ffcfa,
 0x16000806,
-0x07800000,
-0x07800000,
+0x003ffaf9,
+0x003ff8f8,
 0x9d140270,
+0x048ff8ff,
 0x08200000,
 0x048008ff,
 0x413ff8f8,
@@ -1348,14 +1360,14 @@
 0x413ffefb,
 0x04803322,
 0x1602e045,
-0x16000ded,
+0x16000dfd,
 0x00000454,
 0x00000856,
 0x9c0768d0,
 0x01c00124,
 0x01c00126,
 0x40000087,
-0x16002b89,
+0x16002b99,
 0x0000028d,
 0x40000c54,
 0x12000299,
@@ -1364,7 +1376,7 @@
 0x0180012d,
 0x9e0e0490,
 0x41400224,
-0x16002b98,
+0x16002ba8,
 0x41400226,
 0x12000288,
 0x9c100480,
@@ -1372,7 +1384,7 @@
 0x9e0e0580,
 0x9e010080,
 0xdc1005c0,
-0x160005fd,
+0x1600060d,
 0x9f03e0b0,
 0x01400229,
 0x9e0080c0,
@@ -1380,13 +1392,13 @@
 0x9c01ead0,
 0x01400225,
 0x41400226,
-0x16000623,
+0x16000633,
 0x9e090200,
 0x04800122,
 0x9c029c30,
 0x128002bb,
 0x01c0012b,
-0x160005ad,
+0x160005bd,
 0x9e088400,
 0x07800000,
 0x9c01ead0,
@@ -1410,14 +1422,14 @@
 0x01c0012b,
 0x04800222,
 0x1602de45,
-0x16000e0d,
+0x16000e1d,
 0x00000454,
 0x00000856,
 0x9c0768d0,
 0x01c00124,
 0x01c00126,
 0x40000087,
-0x16002ba9,
+0x16002bb9,
 0x0000028d,
 0x40000c54,
 0x12000299,
@@ -1426,7 +1438,7 @@
 0x0180012d,
 0x9e0e0490,
 0x41400224,
-0x16002bb8,
+0x16002bc8,
 0x41400226,
 0x12000288,
 0x9c100480,
@@ -1441,7 +1453,7 @@
 0x0140022a,
 0x9c01ead0,
 0x01400225,
-0x16000553,
+0x16000563,
 0x01400226,
 0x9e090200,
 0x9c029c30,
@@ -1470,20 +1482,20 @@
 0x07800000,
 0x06000033,
 0x9e0e8220,
-0x0aa05c10,
+0x0aa05cd0,
 0x9c1d0004,
 0x9c1d0044,
 0x07800000,
 0x9d0c0210,
-0x0a005cc0,
+0x0a005d80,
 0x06000023,
-0x0aa05c70,
+0x0aa05d30,
 0x9c1d0004,
 0x9d040004,
 0x9d100200,
-0x0a005cc0,
+0x0a005d80,
 0x06000043,
-0x0aa05cc0,
+0x0aa05d80,
 0x9c180024,
 0x9d040004,
 0x9d180200,
@@ -1491,19 +1503,7 @@
 0x05c00740,
 0x17800644,
 0x01000004,
-0x0a005b30,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
-0x00000000,
+0x0a005bf0,
 0x00000000,
 0x00000000,
 0x00000000,
@@ -2083,6 +2083,7 @@
 0x00001000,
 0x00001001,
 0x00001001,
+0x00001011,
 0x00001000,
 0x00001000,
 0x00001000,
@@ -2249,7 +2250,7 @@
 0x00001001,
 0x00001051,
 0x00001001,
-0x000000c5,
+0x000000c6,
 0x00001000,
 0x00001001,
 0x00001001,
@@ -3479,19 +3480,19 @@
 0x00000000,
 0x00000000,
 0x00000000,
-0x00009060,
+0x00009110,
 0x03130298,
 0x02DE031E,
 0x004302E8,
 0x0325003A,
 0x032C0344,
-0x042F02C9,
-0x048D0351,
+0x043D02C9,
+0x049B0351,
 0x018100CA,
 0x026C01AD,
 0x00B402AB,
 0x01BE01CC,
-0x053905AF,
+0x054505BB,
 0x000202F3,
 0x00DE00D8,
 0x00EF00E8,
@@ -3501,9 +3502,8 @@
 0x0146012B,
 0x0003015D,
 0x017F017E,
-0x040E0180,
-0x01690364,
-0x00000000,
+0x041C0180,
+0x01690366,
 0x00000000,
 0x00000000,
 0x00000000,
@@ -5657,221 +5657,218 @@
 0x00000000,
 0x00000000,
 0x00000000,
-0x00B80011,
-0x009D009C,
-0x009F009E,
-0x00000000,
-0x002E0011,
-0x00A300A2,
-0x00A500A4,
 0x00000000,
 0x00B90011,
-0x00AB00AA,
-0x00A000AC,
+0x009E009D,
+0x00A0009F,
 0x00000000,
-0x00B90011,
-0x00B100B0,
-0x00B300B2,
+0x002F0011,
+0x00A400A3,
+0x00A600A5,
 0x00000000,
 0x00BA0011,
-0x00AE00AD,
-0x00A100AF,
+0x00AC00AB,
+0x00A100AD,
 0x00000000,
 0x00BA0011,
-0x00B500B4,
-0x00B700B6,
+0x00B200B1,
+0x00B400B3,
 0x00000000,
-0x00550014,
-0x00560003,
-0x00590057,
+0x00BB0011,
+0x00AF00AE,
+0x00A200B0,
+0x00000000,
+0x00BB0011,
+0x00B600B5,
+0x00B800B7,
+0x00000000,
+0x00560014,
+0x00570003,
+0x005A0058,
 0x00000013,
-0x00550014,
-0x00560006,
-0x00600057,
+0x00560014,
+0x00570006,
+0x00610058,
 0x00000013,
-0x00630014,
-0x0064010B,
-0x00670065,
+0x00640014,
+0x0065010C,
+0x00680066,
 0x00000012,
-0x005A0015,
-0x005B0002,
-0x005E005C,
+0x005B0015,
+0x005C0002,
+0x005F005D,
 0x00000013,
-0x005A0015,
-0x005B0005,
-0x0061005C,
+0x005B0015,
+0x005C0005,
+0x0062005D,
 0x00000013,
-0x01030003,
-0x0001008D,
-0x008F0001,
-0x00000000,
 0x01040003,
 0x0001008E,
 0x00900001,
 0x00000000,
 0x01050003,
-0x0001012A,
-0x008F0001,
+0x0001008F,
+0x00910001,
 0x00000000,
-0x01050003,
+0x01060003,
 0x0001012B,
 0x00900001,
 0x00000000,
-0x004C0003,
-0x0001008D,
-0x008F0001,
+0x01060003,
+0x0001012C,
+0x00910001,
 0x00000000,
-0x004C0003,
+0x004D0003,
 0x0001008E,
 0x00900001,
 0x00000000,
-0x0031000A,
-0x0070002F,
-0x004D0071,
-0x00000000,
-0x00B90000,
-0x00A600B9,
-0x009B00A8,
+0x004D0003,
+0x0001008F,
+0x00910001,
+0x00000000,
+0x0032000A,
+0x00710030,
+0x004E0072,
 0x00000000,
 0x00BA0000,
 0x00A700BA,
-0x009B00A9,
+0x009C00A9,
 0x00000000,
-0x002F000A,
-0x00BD002F,
-0x009B00BE,
+0x00BB0000,
+0x00A800BB,
+0x009C00AA,
+0x00000000,
+0x0030000A,
+0x00BE0030,
+0x009C00BF,
 0x00000000,
 0x00010013,
 0x00010001,
-0x010E0001,
+0x010F0001,
 0x00000000,
 0x00010013,
 0x00010001,
-0x010F0001,
+0x01100001,
 0x00000000,
 0x000D0009,
 0x000F000E,
 0x00110010,
 0x00000000,
-0x00270000,
-0x002A0029,
-0x002C002B,
-0x00000000,
-0x00230000,
-0x00780023,
-0x00910073,
+0x00280000,
+0x002B002A,
+0x002D002C,
 0x00000000,
-0x00030000,
-0x00790003,
+0x00240000,
+0x00790024,
 0x00920074,
 0x00000000,
-0x00230000,
-0x007A0023,
-0x00930076,
+0x00030000,
+0x007A0003,
+0x00930075,
 0x00000000,
-0x00060000,
-0x007B0006,
+0x00240000,
+0x007B0024,
 0x00940077,
 0x00000000,
-0x00280000,
-0x007C0103,
-0x00910072,
+0x00060000,
+0x007C0006,
+0x00950078,
 0x00000000,
-0x008D0000,
-0x007D005F,
-0x00920074,
-0x00000000,
-0x00280000,
-0x007E0104,
-0x00930075,
+0x00290000,
+0x007D0104,
+0x00920073,
 0x00000000,
 0x008E0000,
-0x007F0062,
-0x00940077,
+0x007E0060,
+0x00930075,
 0x00000000,
-0x01060000,
-0x00800106,
-0x00910073,
+0x00290000,
+0x007F0105,
+0x00940076,
+0x00000000,
+0x008F0000,
+0x00800063,
+0x00950078,
 0x00000000,
-0x01090000,
-0x00810109,
+0x01070000,
+0x00810107,
 0x00920074,
 0x00000000,
-0x01060000,
-0x00820106,
-0x00930076,
-0x00000000,
 0x010A0000,
-0x0083010A,
-0x00940077,
-0x00000000,
-0x00300000,
-0x00840105,
-0x00910072,
+0x0082010A,
+0x00930075,
 0x00000000,
-0x012A0000,
-0x00850107,
-0x00920074,
+0x01070000,
+0x00830107,
+0x00940077,
 0x00000000,
-0x00300000,
-0x00860105,
-0x00930075,
+0x010B0000,
+0x0084010B,
+0x00950078,
+0x00000000,
+0x00310000,
+0x00850106,
+0x00920073,
 0x00000000,
 0x012B0000,
-0x00870108,
-0x00940077,
+0x00860108,
+0x00930075,
 0x00000000,
-0x00260000,
-0x008A004C,
-0x00910072,
+0x00310000,
+0x00870106,
+0x00940076,
+0x00000000,
+0x012C0000,
+0x00880109,
+0x00950078,
 0x00000000,
-0x008D0000,
-0x008B008C,
-0x00920074,
+0x00270000,
+0x008B004D,
+0x00920073,
 0x00000000,
-0x00260000,
-0x0088004C,
+0x008E0000,
+0x008C008D,
 0x00930075,
 0x00000000,
-0x008E0000,
-0x0089008C,
-0x00940077,
+0x00270000,
+0x0089004D,
+0x00940076,
 0x00000000,
-0x00300000,
-0x006E002E,
-0x004D006F,
-0x00000000,
-0x002E0000,
-0x009900B8,
-0x009B009A,
-0x00000000,
-0x002E0000,
-0x00BB002E,
-0x009B00BC,
+0x008F0000,
+0x008A008D,
+0x00950078,
+0x00000000,
+0x00310000,
+0x006F002F,
+0x004E0070,
+0x00000000,
+0x002F0000,
+0x009A00B9,
+0x009C009B,
+0x00000000,
+0x002F0000,
+0x00BC002F,
+0x009C00BD,
+0x00000000,
+0x00300018,
+0x00980051,
+0x009700D1,
 0x00000000,
 0x002F0018,
-0x00970050,
-0x009600D0,
-0x00000000,
-0x002E0018,
-0x0095004F,
-0x009600D0,
+0x00960050,
+0x009700D1,
 0x00000000,
-0x002D0007,
-0x00010030,
+0x002E0007,
+0x00010031,
 0x00000017,
 0x00000000,
-0x00210007,
-0x00010031,
+0x00220007,
+0x00010032,
 0x00000018,
 0x00000000,
-0x00CE000B,
+0x00CF000B,
 0x00010001,
-0x00CF0001,
-0x00000000,
-0x0001000C,
-0x00010001,
-0x00D90001,
+0x00D00001,
 0x00000000,
 0x0001000C,
 0x00010001,
@@ -5933,129 +5930,129 @@
 0x00010001,
 0x00E80001,
 0x00000000,
-0x00F9000D,
+0x0001000C,
+0x00010001,
+0x00E90001,
+0x00000000,
+0x00FA000D,
 0x00010001,
-0x00FA0001,
+0x00FB0001,
 0x00000000,
-0x002E0005,
-0x001C0026,
-0x0000002F,
+0x002F0005,
+0x001C0027,
+0x00000030,
 0x00000000,
-0x00290005,
-0x001D002D,
-0x00000020,
+0x002A0005,
+0x001D002E,
+0x00000021,
 0x00000000,
 0x00080006,
-0x00250020,
+0x00260021,
 0x0000001A,
 0x00000000,
 0x00080006,
-0x00250021,
+0x00260022,
 0x0000001B,
 0x00000000,
 0x00080006,
-0x00690068,
+0x006A0069,
 0x0000001E,
 0x00000000,
 0x00080006,
-0x00690028,
+0x006A0029,
 0x0000001F,
 0x00000000,
-0x00C00001,
-0x00C80051,
-0x0000011F,
+0x00C10001,
+0x00C90052,
+0x00000120,
 0x00000000,
 0x00030004,
-0x000C0023,
-0x008F0001,
-0x00000000,
-0x00060004,
-0x000C0023,
+0x000C0024,
 0x00900001,
 0x00000000,
-0x01090004,
-0x000C0106,
-0x008F0001,
+0x00060004,
+0x000C0024,
+0x00910001,
 0x00000000,
 0x010A0004,
-0x000C0106,
+0x000C0107,
 0x00900001,
 0x00000000,
-0x002F0004,
-0x00FC0050,
-0x00FB0001,
+0x010B0004,
+0x000C0107,
+0x00910001,
 0x00000000,
-0x002E0004,
-0x00FC004F,
-0x00FB0001,
+0x00300004,
+0x00FD0051,
+0x00FC0001,
+0x00000000,
+0x002F0004,
+0x00FD0050,
+0x00FC0001,
 0x00000000,
-0x00400002,
-0x00420041,
+0x00410002,
+0x00430042,
 0x00000016,
 0x00000000,
-0x00320002,
-0x00340033,
+0x00330002,
+0x00350034,
 0x00000013,
 0x00000000,
-0x00350002,
-0x00370036,
+0x00360002,
+0x00380037,
 0x00000014,
 0x00000000,
-0x00380002,
-0x003A0039,
+0x00390002,
+0x003B003A,
 0x00000015,
 0x00000000,
-0x00680002,
-0x006B006A,
+0x00690002,
+0x006C006B,
 0x00000019,
 0x00000000,
-0x01060002,
-0x003F003E,
-0x00000019,
+0x01070002,
+0x0040003F,
+0x00000020,
 0x00000000,
 0x00080002,
-0x00460045,
+0x00470046,
 0x00000019,
 0x00000000,
-0x002F0002,
-0x00BA00B9,
+0x00300002,
+0x00BB00BA,
 0x00000019,
 0x00000000,
-0x00CD0002,
-0x00C700BF,
+0x00CE0002,
+0x00C800C0,
 0x00000019,
 0x00000000,
-0x010B0002,
-0x010D010C,
+0x010C0002,
+0x010E010D,
 0x00000019,
 0x00000000,
-0x00260002,
-0x00440043,
+0x00270002,
+0x00450044,
 0x00000019,
 0x00000000,
-0x003B0002,
-0x003D003C,
+0x003C0002,
+0x003E003D,
 0x00000019,
 0x00000000,
 0x00010008,
-0x00010027,
-0x00520001,
+0x00010028,
+0x00530001,
 0x00000000,
 0x00010008,
-0x00010022,
-0x00530001,
+0x00010023,
+0x00540001,
 0x00000000,
-0x00BF0010,
-0x00C100C0,
-0x00C600C2,
-0x00000000,
-0x00C7000F,
-0x00C900C8,
-0x00CC00CA,
-0x00000000,
-0x00010013,
-0x00010001,
-0x01100001,
+0x00C00010,
+0x00C200C1,
+0x00C700C3,
+0x00000000,
+0x00C8000F,
+0x00CA00C9,
+0x00CD00CB,
 0x00000000,
 0x00010013,
 0x00010001,
@@ -6085,14 +6082,14 @@
 0x00010001,
 0x01170001,
 0x00000000,
-0x0001000E,
-0x00010001,
-0x00010001,
-0x00000000,
 0x00010013,
 0x00010001,
 0x01180001,
 0x00000000,
+0x0001000E,
+0x00010001,
+0x00010001,
+0x00000000,
 0x00010013,
 0x00010001,
 0x01190001,
@@ -6101,61 +6098,65 @@
 0x00010001,
 0x011A0001,
 0x00000000,
-0x00480012,
-0x00D10040,
-0x00D400D2,
+0x00010013,
+0x00010001,
+0x011B0001,
 0x00000000,
 0x00490012,
-0x00D60032,
+0x00D20041,
 0x00D500D3,
 0x00000000,
 0x004A0012,
-0x00D70035,
-0x00D500D3,
+0x00D70033,
+0x00D600D4,
 0x00000000,
 0x004B0012,
-0x00D80038,
-0x00D500D3,
+0x00D80036,
+0x00D600D4,
+0x00000000,
+0x004C0012,
+0x00D90039,
+0x00D600D4,
 0x00000000,
-0x011C0016,
-0x011D0001,
+0x011D0016,
 0x011E0001,
+0x011F0001,
 0x00000000,
 0x00010017,
 0x00010001,
 0x00000001,
 0x00000000,
-0x01200014,
-0x01220109,
-0x01250123,
+0x01210014,
+0x0123010A,
+0x01260124,
 0x00000013,
-0x01200014,
-0x0122010A,
-0x01260123,
+0x01210014,
+0x0123010B,
+0x01270124,
 0x00000013,
-0x01270015,
-0x012E012C,
-0x0131012F,
+0x01280015,
+0x012F012D,
+0x01320130,
 0x00000013,
-0x01270015,
-0x012E012D,
-0x0132012F,
+0x01280015,
+0x012F012E,
+0x01330130,
 0x00000013,
-0x012A0000,
-0x00850128,
-0x00920074,
-0x00000000,
 0x012B0000,
-0x00870129,
-0x00940077,
+0x00860129,
+0x00930075,
+0x00000000,
+0x012C0000,
+0x0088012A,
+0x00950078,
 0x00000000,
 0x00010013,
 0x00010001,
-0x01330001,
+0x01340001,
 0x00000000,
 0x00010013,
 0x00010001,
-0x01340001,
+0x01350001,
 0x00000000,
 0x00000000,
 0x00000000,
@@ -6276,14 +6277,14 @@
 0x003FFFF0,
 0x00000000,
 0x00400000,
-0x019B0188,
-0x01C101AE,
-0x01E701D4,
-0x020D01FA,
-0x02330220,
-0x02590246,
-0x027F026C,
-0x02A50292,
+0x019C0189,
+0x01C201AF,
+0x01E801D5,
+0x020E01FB,
+0x02340221,
+0x025A0247,
+0x0280026D,
+0x02A60293,
 0x00000004,
 0x00000001,
 0x00000000,
@@ -6292,14 +6293,14 @@
 0x003FFFF0,
 0x00000000,
 0x00400000,
-0x02CE02BC,
-0x02F202E0,
-0x03160304,
-0x033A0328,
-0x035E034C,
-0x03820370,
-0x03A60394,
-0x03CA03B8,
+0x02CF02BD,
+0x02F302E1,
+0x03170305,
+0x033B0329,
+0x035F034D,
+0x03830371,
+0x03A70395,
+0x03CB03B9,
 0x00008363,
 0x00000428,
 0x00000000,
@@ -19712,165 +19713,167 @@
 0x00000000,
 0x00000000,
 0x00000000,
-0x00041503,
+0x00041603,
 0x00000000,
-0x00041802,
+0x00041902,
 0x00000000,
-0x00066903,
+0x00066A03,
 0x00000000,
-0x00046205,
+0x00046305,
 0x00000000,
-0x00046704,
+0x00046804,
 0x00000000,
-0x00066405,
+0x00066505,
 0x00000000,
-0x0001820C,
+0x0001830C,
 0x00000000,
-0x00046B28,
+0x00046C28,
 0x00000000,
-0x0004BB28,
+0x0004BC28,
 0x00000000,
-0x0006F106,
+0x0006F206,
 0x00000000,
-0x00022918,
+0x00022A18,
 0x00000000,
-0x00013912,
+0x00013A12,
 0x00000000,
-0x00014B12,
-0x00013600,
-0x00015B24,
-0x00013712,
-0x00014912,
+0x00014C12,
+0x00013700,
+0x00015C24,
+0x00013812,
+0x00014A12,
 0x00120024,
-0x00057400,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015B0E,
-0x00015E0C,
-0x00016904,
-0x00015E0C,
-0x00016D04,
-0x00000000,
-0x00017102,
-0x00000000,
-0x00017302,
-0x00016A0C,
-0x00017504,
-0x00016A0C,
-0x00017904,
-0x00000000,
-0x00018E0C,
-0x00000000,
-0x00019A0C,
-0x00000000,
-0x0001760C,
-0x00000000,
-0x00016A0C,
-0x00000000,
-0x00015E0C,
-0x00016A0C,
-0x0001760C,
-0x00000000,
-0x0001A60C,
-0x00000000,
-0x0001BE0C,
-0x00000000,
-0x0001CA0C,
-0x00000000,
-0x0001FC0C,
-0x00020809,
-0x00020809,
+0x00057800,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015C0E,
+0x00015F0C,
+0x00016A04,
+0x00015F0C,
+0x00016E04,
+0x00000000,
+0x00017202,
+0x00000000,
+0x00017402,
+0x00016B0C,
+0x00017604,
+0x00016B0C,
+0x00017A04,
+0x00017E02,
+0x00017E02,
+0x00000000,
+0x00018F0C,
+0x00000000,
+0x00019B0C,
+0x00000000,
+0x0001770C,
+0x00000000,
+0x00016B0C,
+0x00000000,
+0x00015F0C,
+0x00016B0C,
+0x0001770C,
+0x00000000,
+0x0001A70C,
+0x00000000,
+0x0001BF0C,
+0x00000000,
+0x0001CB0C,
+0x00000000,
+0x0001FD0C,
+0x00020909,
+0x00020909,
 0x00000000,
-0x00017F09,
+0x00018009,
 0x000B0009,
 0x00000000,
 0x00000000,
-0x0001B20C,
+0x0001B30C,
 0x00000000,
-0x00066C0C,
+0x00066D0C,
 0x00000000,
-0x0006780C,
+0x0006790C,
 0x00000000,
-0x0006840C,
+0x0006850C,
 0x00000000,
-0x0006900C,
-0x00000000,
-0x0002410C,
-0x00022918,
-0x0002710C,
-0x00022918,
-0x00027D0C,
-0x00000000,
-0x00024D0C,
-0x00022900,
-0x0002890C,
-0x00022900,
-0x0002950C,
-0x00000000,
-0x0002590C,
-0x00022918,
-0x0002A10C,
-0x00022918,
-0x0002AD0C,
-0x00000000,
-0x0008220C,
-0x00022918,
-0x00082E0C,
-0x00022918,
-0x00083A0C,
-0x00022918,
-0x0002B90C,
-0x00022918,
-0x0002C50C,
-0x00000000,
-0x0002650C,
-0x00022918,
-0x0002D10C,
-0x00022918,
-0x0002DD0C,
-0x00022918,
-0x0002E90C,
-0x00022918,
-0x0002F50C,
-0x00022918,
-0x0003010C,
-0x00022918,
-0x00030D0C,
-0x00000000,
-0x00031978,
-0x00000000,
-0x00039118,
+0x0006910C,
+0x00000000,
+0x0002420C,
+0x00022A18,
+0x0002720C,
+0x00022A18,
+0x00027E0C,
+0x00000000,
+0x00024E0C,
+0x00022A00,
+0x00028A0C,
+0x00022A00,
+0x0002960C,
+0x00000000,
+0x00025A0C,
+0x00022A18,
+0x0002A20C,
+0x00022A18,
+0x0002AE0C,
+0x00000000,
+0x0008230C,
+0x00022A18,
+0x00082F0C,
+0x00022A18,
+0x00083B0C,
+0x00022A18,
+0x0002BA0C,
+0x00022A18,
+0x0002C60C,
+0x00000000,
+0x0002660C,
+0x00022A18,
+0x0002D20C,
+0x00022A18,
+0x0002DE0C,
+0x00022A18,
+0x0002EA0C,
+0x00022A18,
+0x0002F60C,
+0x00022A18,
+0x0003020C,
+0x00022A18,
+0x00030E0C,
+0x00000000,
+0x00031A78,
+0x00000000,
+0x00039218,
 0x00000000,
-0x0003A918,
+0x0003AA18,
 0x00000000,
-0x0003C118,
+0x0003C218,
 0x00000000,
-0x0003D918,
+0x0003DA18,
 0x00000000,
-0x0004090C,
+0x00040A0C,
 0x000B0019,
 0x00000000,
 0x000B0009,
 0x00000000,
 0x00000000,
-0x00041A18,
+0x00041B18,
 0x00000000,
-0x00043218,
+0x00043318,
 0x00000000,
-0x00044A18,
+0x00044B18,
 0x000B2DD8,
 0x00000000,
 0x000B2DD4,
@@ -19878,121 +19881,121 @@
 0x000B2DC0,
 0x00000000,
 0x00000000,
-0x00046B28,
-0x00029213,
-0x0002A513,
-0x00046B28,
-0x0002BA00,
+0x00046C28,
+0x00029313,
+0x0002A613,
+0x00046C28,
 0x0002BB00,
+0x0002BC00,
 0x000B7900,
-0x00580002,
+0x00590002,
 0x00217800,
 0x00000000,
-0x00049328,
-0x00029213,
-0x0002A513,
-0x00049328,
-0x0002B800,
+0x00049428,
+0x00029313,
+0x0002A613,
+0x00049428,
 0x0002B900,
+0x0002BA00,
 0x000B8100,
-0x005D0002,
+0x005E0002,
 0x00212800,
 0x00000000,
-0x00049328,
-0x00580004,
+0x00049428,
+0x00590004,
 0x00217800,
-0x005D0004,
+0x005E0004,
 0x00212800,
 0x00000000,
-0x00049328,
+0x00049428,
 0x00000000,
-0x0004BB28,
-0x0003B812,
-0x0003CA12,
-0x0004BB28,
-0x0003DC00,
+0x0004BC28,
+0x0003B912,
+0x0003CB12,
+0x0004BC28,
 0x0003DD00,
+0x0003DE00,
 0x000B9100,
-0x0066000C,
+0x0067000C,
 0x00226800,
 0x00000000,
-0x0004E30C,
-0x0001BE0C,
-0x00015E0C,
-0x00000000,
-0x0004EF0C,
-0x00000000,
-0x0004FB0C,
-0x00022918,
-0x0005070C,
-0x00022918,
-0x0005130C,
-0x00053819,
-0x00053819,
-0x00000000,
-0x00041019,
-0x00051F19,
-0x00051F19,
-0x0003F719,
-0x0003DE19,
-0x00000000,
-0x0004440B,
-0x00000000,
-0x00044F0B,
-0x00000000,
-0x00045A07,
-0x00000000,
-0x0004290B,
-0x00000000,
-0x0004340B,
-0x00000000,
-0x00043F05,
-0x0005750B,
-0x0005750B,
-0x00058007,
-0x00058007,
-0x0005870B,
-0x0005870B,
-0x00059205,
-0x00059205,
-0x0005970B,
-0x0005970B,
-0x0005A207,
-0x0005A207,
-0x0005A90B,
-0x0005A90B,
-0x0005B405,
-0x0005B405,
-0x0005BB0B,
-0x0005BB0B,
-0x0005C607,
-0x0005C607,
-0x0005CD0B,
-0x0005CD0B,
-0x0005D805,
-0x0005D805,
-0x0005DD0B,
-0x0005DD0B,
-0x0005E807,
-0x0005E807,
-0x0005EF0B,
-0x0005EF0B,
-0x0005FA05,
-0x0005FA05,
-0x0006110B,
-0x0006110B,
-0x00061C07,
-0x00061C07,
-0x0005FF0B,
-0x0005FF0B,
-0x00060A05,
-0x00060A05,
+0x0004E40C,
+0x0001BF0C,
+0x00015F0C,
+0x00000000,
+0x0004F00C,
+0x00000000,
+0x0004FC0C,
+0x00022A18,
+0x0005080C,
+0x00022A18,
+0x0005140C,
+0x00053919,
+0x00053919,
+0x00000000,
+0x00041119,
+0x00052019,
+0x00052019,
+0x0003F819,
+0x0003DF19,
+0x00000000,
+0x0004450B,
+0x00000000,
+0x0004500B,
+0x00000000,
+0x00045B07,
+0x00000000,
+0x00042A0B,
+0x00000000,
+0x0004350B,
+0x00000000,
+0x00044005,
+0x0005760B,
+0x0005760B,
+0x00058107,
+0x00058107,
+0x0005880B,
+0x0005880B,
+0x00059305,
+0x00059305,
+0x0005980B,
+0x0005980B,
+0x0005A307,
+0x0005A307,
+0x0005AA0B,
+0x0005AA0B,
+0x0005B505,
+0x0005B505,
+0x0005BC0B,
+0x0005BC0B,
+0x0005C707,
+0x0005C707,
+0x0005CE0B,
+0x0005CE0B,
+0x0005D905,
+0x0005D905,
+0x0005DE0B,
+0x0005DE0B,
+0x0005E907,
+0x0005E907,
+0x0005F00B,
+0x0005F00B,
+0x0005FB05,
+0x0005FB05,
+0x0006120B,
+0x0006120B,
+0x00061D07,
+0x00061D07,
+0x0006000B,
+0x0006000B,
+0x00060B05,
+0x00060B05,
 0x00000000,
-0x00063C28,
+0x00063D28,
 0x00000000,
-0x00056F02,
+0x00057002,
 0x00000000,
-0x00057104,
+0x00057204,
 0x00000006,
 0x00000000,
 0x00000003,
@@ -20005,26 +20008,26 @@
 0x00000000,
 0x00030005,
 0x00000000,
-0x0005510F,
-0x0005510F,
+0x0005520F,
+0x0005520F,
 0x000B000F,
-0x0008A400,
-0x0005600F,
-0x0005600F,
+0x0008A800,
+0x0005610F,
+0x0005610F,
 0x00030007,
 0x00000000,
-0x00062109,
-0x00062109,
-0x00046109,
-0x00046109,
+0x00062209,
+0x00062209,
+0x00046209,
+0x00046209,
 0x000B0009,
 0x00000000,
 0x00000000,
-0x00063002,
-0x00062A03,
-0x00062A03,
+0x00063102,
+0x00062B03,
+0x00062B03,
 0x000BA102,
-0x00046A03,
+0x00046B03,
 0x00000003,
 0x002E8C00,
 0x00000003,
@@ -20032,115 +20035,115 @@
 0x00000003,
 0x002EC000,
 0x00000000,
-0x00063202,
-0x00062D03,
-0x00062D03,
+0x00063302,
+0x00062E03,
+0x00062E03,
 0x000BB102,
-0x00046D03,
+0x00046E03,
 0x00000003,
 0x002E8E00,
-0x00069C09,
-0x00069C09,
-0x0006A509,
-0x0006A509,
-0x00000000,
-0x00047009,
-0x00000000,
-0x00047909,
-0x00000000,
-0x00063402,
-0x0006AE03,
-0x0006AE03,
+0x00069D09,
+0x00069D09,
+0x0006A609,
+0x0006A609,
+0x00000000,
+0x00047109,
+0x00000000,
+0x00047A09,
+0x00000000,
+0x00063502,
+0x0006AF03,
+0x0006AF03,
 0x000BB302,
-0x00048203,
+0x00048303,
 0x00000000,
-0x00063802,
-0x0006B103,
-0x0006B103,
+0x00063902,
+0x0006B203,
+0x0006B203,
 0x000BB702,
-0x00048503,
+0x00048603,
 0x00000000,
-0x00063602,
-0x0006B403,
-0x0006B403,
+0x00063702,
+0x0006B503,
+0x0006B503,
 0x000BB502,
-0x00048803,
+0x00048903,
 0x00000003,
 0x002EBE00,
 0x00000000,
-0x00063A02,
-0x0006B703,
-0x0006B703,
+0x00063B02,
+0x0006B803,
+0x0006B803,
 0x000BB902,
-0x00048B03,
+0x00048C03,
 0x00000003,
 0x002EC200,
 0x00000000,
-0x0006BA0C,
-0x00022918,
-0x0006C60C,
-0x00022918,
-0x0006D20C,
-0x0006DE09,
-0x0006DE09,
-0x00000000,
-0x00049009,
-0x0006E709,
-0x0006E709,
-0x0004A209,
-0x00049909,
-0x00000000,
-0x00072906,
-0x00022900,
-0x00074718,
-0x00075F0B,
-0x00075F0B,
-0x00000000,
-0x0004AF0B,
-0x00013600,
-0x00072F18,
-0x00075F0B,
-0x00075F0B,
-0x00074718,
-0x00072906,
-0x00C3000B,
-0x0000C400,
-0x00000000,
-0x0006F706,
-0x00022918,
-0x0006FE18,
-0x0004AB04,
-0x0006FD00,
-0x00013600,
-0x00071600,
+0x0006BB0C,
+0x00022A18,
+0x0006C70C,
+0x00022A18,
+0x0006D30C,
+0x0006DF09,
+0x0006DF09,
+0x00000000,
+0x00049109,
+0x0006E809,
+0x0006E809,
+0x0004A309,
+0x00049A09,
+0x00000000,
+0x00072A06,
+0x00022A00,
+0x00074818,
+0x0007600B,
+0x0007600B,
+0x00000000,
+0x0004B00B,
+0x00013700,
+0x00073018,
+0x0007600B,
+0x0007600B,
+0x00074818,
+0x00072A06,
+0x00C4000B,
+0x0000C500,
+0x00000000,
+0x0006F806,
+0x00022A18,
+0x0006FF18,
+0x0004AC04,
+0x0006FE00,
+0x00013700,
+0x00071700,
 0x000BAE00,
-0x00071712,
-0x00EA00CB,
+0x00071812,
+0x00EA00CC,
 0x000026FF,
 0x00000000,
-0x0006F106,
+0x0006F206,
 0x00000000,
 0x00100020,
 0x00F42CDC,
 0x0000002C,
 0x00000000,
-0x0004BA0F,
-0x00078213,
-0x00078213,
+0x0004BB0F,
+0x00078313,
+0x00078313,
 0x00000000,
-0x0004C913,
+0x0004CA13,
 0x00000000,
-0x0004DC13,
+0x0004DD13,
 0x00170013,
 0x00000000,
 0x00170013,
 0x00000000,
-0x00079513,
-0x00079513,
-0x0007A813,
-0x0007A813,
-0x0007BB13,
-0x0007BB13,
+0x00079613,
+0x00079613,
+0x0007A913,
+0x0007A913,
+0x0007BC13,
+0x0007BC13,
 0x00002060,
 0x00000000,
 0x00002088,
@@ -20207,46 +20210,46 @@
 0x00000000,
 0x00000000,
 0x000B2710,
-0x000F00E9,
+0x000F00EA,
 0x00000000,
 0x00000002,
 0x00000000,
 0x00000000,
-0x00013600,
+0x00013700,
 0x00000000,
-0x0001400C,
+0x0001410C,
 0x00000000,
-0x0007CE02,
+0x0007CF02,
 0x00000000,
-0x0007D004,
+0x0007D104,
 0x00000000,
-0x0007D406,
+0x0007D506,
 0x00000000,
-0x0007DA0C,
+0x0007DB0C,
 0x00000000,
-0x0007E648,
+0x0007E748,
 0x00000000,
-0x0003F10C,
+0x0003F20C,
 0x00000000,
-0x0003FD0C,
+0x0003FE0C,
 0x00000000,
-0x0001D60C,
+0x0001D70C,
 0x00000000,
-0x0001E20C,
+0x0001E30C,
 0x00000000,
-0x0001EE02,
+0x0001EF02,
 0x00000000,
-0x0001F104,
+0x0001F204,
 0x00000000,
-0x0001F602,
+0x0001F702,
 0x00000000,
-0x0001F804,
+0x0001F904,
 0x00000000,
-0x0007FE0C,
-0x00022918,
-0x00080A0C,
-0x00022918,
-0x0008160C,
+0x0007FF0C,
+0x00022A18,
+0x00080B0C,
+0x00022A18,
+0x0008170C,
 0x00002EEC,
 0x00000000,
 0x00002EF4,
@@ -20278,48 +20281,48 @@
 0x00000000,
 0x000E4000,
 0x0008B800,
-0x00013600,
+0x00013700,
 0x00003CC0,
 0x00000000,
-0x0004F200,
-0x0004F201,
+0x0004F300,
+0x0004F301,
 0x00000000,
-0x00084728,
+0x00084828,
 0x00000000,
-0x00084728,
-0x00029213,
-0x0002A513,
-0x00084728,
-0x0004F400,
+0x00084828,
+0x00029313,
+0x0002A613,
+0x00084828,
 0x0004F500,
+0x0004F600,
 0x000F3400,
-0x00240002,
+0x00250002,
 0x0020B001,
-0x00240004,
+0x00250004,
 0x0020B001,
 0x00000000,
-0x00086F28,
+0x00087028,
 0x00000000,
-0x00086F28,
+0x00087028,
 0x00000000,
-0x00086F28,
+0x00087028,
 0x00000000,
-0x00089702,
+0x00089802,
 0x00000000,
-0x00089904,
+0x00089A04,
 0x00000000,
-0x0001EE03,
+0x0001EF03,
 0x00000000,
-0x0001F105,
-0x00029213,
-0x0002A513,
-0x00086F28,
-0x0004F600,
+0x0001F205,
+0x00029313,
+0x0002A613,
+0x00087028,
 0x0004F700,
+0x0004F800,
 0x000F3C00,
-0x00300002,
+0x00310002,
 0x0021F001,
-0x00300004,
+0x00310004,
 0x0021F001,
 0x00003D10,
 0x00000000,
@@ -20367,8 +20370,8 @@
 0x00000000,
 0x00000000,
 0x00000000,
-0x00040000,
-0x00040000,
+0x00000000,
+0x00000000,
 0x00000001,
 0x00000010,
 0x00000001,
Index: kernel/sound/soc/omap/abe/abe_functionsid.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_functionsid.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_functionsid.h	2011-03-28 15:57:05.798386525 +0900
@@ -72,4 +72,4 @@
 #define ROUTE_MM_UL_CFPID                                   18
 #define IO_IP_CFPID                                         19
 #define COPY_UNDERFLOW_CFPID                                20
-#endif/* _ABE_FUNCTIONSID_H_ */
+#endif /* _ABE_FUNCTIONSID_H_ */
Index: kernel/sound/soc/omap/abe/abe_fw.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_fw.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_fw.h	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -32,7 +32,7 @@
 #define FW_SCHED_LOOP_FREQ_DIV1000	(FW_SCHED_LOOP_FREQ/1000)
 #define EVENT_FREQUENCY 96000
 #define SLOTS_IN_SCHED_LOOP (96000/FW_SCHED_LOOP_FREQ)
-#define SCHED_LOOP_8kHz ( 8000/FW_SCHED_LOOP_FREQ)
+#define SCHED_LOOP_8kHz (8000/FW_SCHED_LOOP_FREQ)
 #define SCHED_LOOP_16kHz (16000/FW_SCHED_LOOP_FREQ)
 #define SCHED_LOOP_24kHz (24000/FW_SCHED_LOOP_FREQ)
 #define SCHED_LOOP_48kHz (48000/FW_SCHED_LOOP_FREQ)
@@ -40,7 +40,7 @@
 /*
  * DMEM AREA - SCHEDULER
  */
-#define dmem_mm_trace D_DEBUG_FIFO_ADDR
+#define dmem_mm_trace	D_DEBUG_FIFO_ADDR
 #define dmem_mm_trace_size ((D_DEBUG_FIFO_ADDR_END-D_DEBUG_FIFO_ADDR+1)/4)
 #define ATC_SIZE 8		/* 8 bytes per descriptors */
 typedef struct {
@@ -55,7 +55,7 @@
 	unsigned wrpt:7;
 	unsigned reserved2:1;
 	unsigned badd:12;	/* second 32bits word of the descriptor */
-	unsigned iter:7;	/* iteration field overlaps the 16 bits boundary */
+	unsigned iter:7;	/* iteration field overlaps 16-bit boundary */
 	unsigned srcid:6;
 	unsigned destid:6;
 	unsigned desen:1;
@@ -64,8 +64,8 @@
  * table of scheduler tasks :
  * char scheduler_table[24 x 4] : four bytes used at OPP100%
  */
-#define dmem_scheduler_table	 D_multiFrame_ADDR
-#define dmem_eanc_task_pointer 	D_pFastLoopBack_ADDR
+#define dmem_scheduler_table	D_multiFrame_ADDR
+#define dmem_eanc_task_pointer	D_pFastLoopBack_ADDR
 /*
  * OPP value :
  * pointer increment steps in the scheduler table
@@ -150,8 +150,8 @@
  * DMEM indexes of the router uplink paths
  * uint8 dmem_router_index [8]
  */
-// OC: TBD ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-//#define dmem_router_index
+
+/* #define dmem_router_index */
 /*
  * analog control circular buffer commands to Phoenix
  * structure {
@@ -160,8 +160,8 @@
  * uint32 FIFO_CONTENT [6];
  * } dmem_commands_to_phoenix; 32 bytes
  */
-#define dmem_commands_to_phoenix 	D_Cmd2PhenixFifo_ADDR
-#define dmem_commands_to_phoenix_descriptor 	D_Cmd2PhenixFifoDesc_ADDR
+#define dmem_commands_to_phoenix		D_Cmd2PhenixFifo_ADDR
+#define dmem_commands_to_phoenix_descriptor	D_Cmd2PhenixFifoDesc_ADDR
 /*
  * analog control circular buffer commands from Phoenix (status line)
  * structure {
@@ -170,15 +170,15 @@
  * uint32 FIFO_CONTENT [6];
  * } dmem_commands_to_phoenix; 32 bytes
  */
-#define dmem_commands_from_phoenix	D_StatusFromPhenixFifo_ADDR
-#define dmem_commands_from_phoenix_descriptor 	D_StatusFromPhenixFifoDesc_ADDR
+#define dmem_commands_from_phoenix		D_StatusFromPhenixFifo_ADDR
+#define dmem_commands_from_phoenix_descriptor	D_StatusFromPhenixFifoDesc_ADDR
 /*
  * DEBUG mask
  * uint16 dmem_debug_trace_mask
  * each bit of this word enables a type a trace in the debug circular buffer
  */
-// OC: TBD ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-//#define dmem_debug_trace_mask
+
+/* #define dmem_debug_trace_mask */
 /*
  * DEBUG circular buffer
  * structure {
@@ -268,7 +268,8 @@
  */
 /*
  * PHOENIX OFFSET in SMEM
- * used to subtract a DC offset on the headset path (power consumption optimization)
+ * used to subtract a DC offset on the headset path
+ * (power consumption optimization)
  */
 /* OC: exact usage to be detailled */
 #define smem_phoenix_offset	S_PhoenixOffset_ADDR
@@ -299,8 +300,8 @@
  * 18 = TOTAL
  */
 #if 0
-#define smem_g0	S_GTarget_ADDR	// [9] 2 gains in 1 SM address
-#define smem_g1	S_GCurrent_ADDR	// [9] 2 gains in 1 SM address
+#define smem_g0	S_GTarget_ADDR		/* [9] 2 gains in 1 SM address */
+#define smem_g1	S_GCurrent_ADDR		/* [9] 2 gains in 1 SM address */
 #endif
 /*
  * COEFFICIENTS AREA
@@ -337,7 +338,7 @@
 #define mixer_sdt_offset 24
 #define mixer_vxrec_offset 26
 #define mixer_audul_offset 30
-#define gain_unused_offset 34
+#define btul_gains_offset 34
 /*
  * DMIC SRC 96->48
  * the filter is changed depending on the decimatio ratio used (16/25/32/40)
@@ -376,4 +377,4 @@
  * int24 cmem_dither(x) [4]
  */
 #define cmem_dither
-#endif /* _ABE_FW_H_ */
+#endif/* _ABE_FW_H_ */
Index: kernel/sound/soc/omap/abe/abe_ini.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_ini.c	2011-03-28 12:30:01.097116007 +0900
+++ kernel/sound/soc/omap/abe/abe_ini.c	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,7 +19,9 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
+#include "abe_ref.h"
 #include "abe_dm_addr.h"
+
 /*
  * initialize the default values for call-backs to subroutines
  * - FIFO IRQ call-backs for sequenced tasks
@@ -28,20 +30,7 @@
  * - Error monitoring
  * - Activity Tracing
  */
-/**
- * abe_hw_configuration
- *
- */
-void abe_hw_configuration()
-{
-	u32 atc_reg;
-	/* enables the DMAreq from AESS AESS_DMAENABLE_SET = 255 */
-	atc_reg = 0xFF;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC, 0x60, &atc_reg, 4);
-	/* enables the MCU IRQ from AESS to Cortex A9 */
-	atc_reg = 0x01;
-	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_ATC, 0x3C, &atc_reg, 4);
-}
+
 /**
  * abe_build_scheduler_table
  *
@@ -49,246 +38,116 @@
 void abe_build_scheduler_table()
 {
 	u16 i, n;
-	u8 *ptr;
-	char aUplinkMuxing[16];
+	u16 aUplinkMuxing[NBROUTE_UL];
+
 #define ABE_TASK_ID(ID) (D_tasksList_ADDR + sizeof(ABE_STask)*(ID))
 	/* LOAD OF THE TASKS' MULTIFRAME */
 	/* WARNING ON THE LOCATION OF IO_MM_DL WHICH IS PATCHED
 	   IN "abe_init_io_tasks" */
-	for (ptr = (u8 *) &(MultiFrame[0][0]), i = 0;
-	     i < sizeof(MultiFrame); i++)
-		*ptr++ = 0;
-	/* MultiFrame[0][0] = 0; */
-	/* MultiFrame[0][1] = 0; */
-	MultiFrame[0][2] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VX_DL);
-	/* MultiFrame[0][3] = 0; */
-	/* MultiFrame[0][4] = 0; */
-	/* MultiFrame[0][5] = 0; */
-	/* MultiFrame[0][6] = 0; */
-	/* MultiFrame[0][7] = 0; */
-	/* MultiFrame[1][0] = 0; */
-	/* MultiFrame[1][1] = 0; */
+	memset(abe->MultiFrame, 0, sizeof(abe->MultiFrame));
+
+	abe->MultiFrame[0][2] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VX_DL);
 #define TASK_ASRC_VX_DL_SLT 1
 #define TASK_ASRC_VX_DL_IDX 2
-	MultiFrame[1][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_DL_8);
+	abe->MultiFrame[1][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_DL_8);
 #define TASK_VX_DL_SLT 1
 #define TASK_VX_DL_IDX 3
-	MultiFrame[1][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_8_48);
-	/* MultiFrame[1][4] = 0; */
-	/* MultiFrame[1][5] = 0; */
-	MultiFrame[1][6] = ABE_TASK_ID(C_ABE_FW_TASK_DL2Mixer);
-	MultiFrame[1][7] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VIB_DL);
-	MultiFrame[2][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1Mixer);
-	MultiFrame[2][1] = ABE_TASK_ID(C_ABE_FW_TASK_SDTMixer);
-	/* MultiFrame[2][2] = 0; */
-	/* MultiFrame[2][3] = 0; */
-	/* MultiFrame[2][4] = 0; */
-	MultiFrame[2][5] = ABE_TASK_ID(C_ABE_FW_TASK_IO_DMIC);
-	/* MultiFrame[2][6] = 0; */
-	/* MultiFrame[2][7] = 0; */
-	MultiFrame[3][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1_GAIN);
-	/* MultiFrame[3][1] = 0; */
-	/* MultiFrame[3][2] = 0; */
-	/* MultiFrame[3][3] = 0; */
-	/* MultiFrame[3][4] = 0; */
-	/* MultiFrame[3][5] = 0; */
-	MultiFrame[3][6] = ABE_TASK_ID(C_ABE_FW_TASK_DL2_GAIN);
-	MultiFrame[3][7] = ABE_TASK_ID(C_ABE_FW_TASK_DL2_EQ);
-	MultiFrame[4][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1_EQ);
-	/* MultiFrame[4][1] = 0; */
-	MultiFrame[4][2] = ABE_TASK_ID(C_ABE_FW_TASK_VXRECMixer);
-	MultiFrame[4][3] = ABE_TASK_ID(C_ABE_FW_TASK_VXREC_SPLIT);
-	/* MultiFrame[4][4] = 0; */
-	/* MultiFrame[4][5] = 0; */
-	MultiFrame[4][6] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA1);
-	MultiFrame[4][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA2);
-	MultiFrame[5][0] = 0;
-	MultiFrame[5][1] = ABE_TASK_ID(C_ABE_FW_TASK_EARP_48_96_LP);
-	MultiFrame[5][2] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_UL);
-	/* MultiFrame[5][3] = 0; */
-	/* MultiFrame[5][4] = 0; */
-	/* MultiFrame[5][5] = 0; */
-	/* MultiFrame[5][6] = 0; */
-	MultiFrame[5][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA_SPLIT);
-	MultiFrame[6][0] = ABE_TASK_ID(C_ABE_FW_TASK_EARP_48_96_LP);
-	/* MultiFrame[6][1] = 0; */
-	/* MultiFrame[6][2] = 0; */
-	/* MultiFrame[6][3] = 0; */
-	/* MultiFrame[6][4] = 0; */
-	MultiFrame[6][5] = ABE_TASK_ID(C_ABE_FW_TASK_EchoMixer);
-	/* MultiFrame[6][6] = 0; */
-	/* MultiFrame[6][7] = 0; */
-	MultiFrame[7][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_DL);
-	/* MultiFrame[7][1] = 0; */
-	MultiFrame[7][2] = ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_SPLIT);
-	MultiFrame[7][3] = ABE_TASK_ID(C_ABE_FW_TASK_DBG_SYNC);
-	/* MultiFrame[7][4] = 0; */
-	MultiFrame[7][5] = ABE_TASK_ID(C_ABE_FW_TASK_ECHO_REF_SPLIT);
-	/* MultiFrame[7][6] = 0; */
-	/* MultiFrame[7][7] = 0; */
-	/* MultiFrame[8][0] = 0; */
-	/* MultiFrame[8][1] = 0; */
-	MultiFrame[8][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC1_96_48_LP);
-	/* MultiFrame[8][3] = 0; */
-	MultiFrame[8][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC1_SPLIT);
-	/* MultiFrame[8][5] = 0; */
-	/* MultiFrame[8][6] = 0; */
-	/* MultiFrame[8][7] = 0; */
-	/* MultiFrame[9][0] = 0; */
-	/* MultiFrame[9][1] = 0; */
-	MultiFrame[9][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC2_96_48_LP);
-	/* MultiFrame[9][3] = 0; */
-	MultiFrame[9][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC2_SPLIT);
-	/* MultiFrame[9][5] = 0; */
-	MultiFrame[9][6] = 0;
-	MultiFrame[9][7] = ABE_TASK_ID(C_ABE_FW_TASK_IHF_48_96_LP);
-	/* MultiFrame[10][0] = 0; */
-	/* MultiFrame[10][1] = 0; */
-	MultiFrame[10][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC3_96_48_LP);
-	/* MultiFrame[10][3] = 0; */
-	MultiFrame[10][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC3_SPLIT);
-	/* MultiFrame[10][5] = 0; */
-	/* MultiFrame[10][6] = 0; */
-	MultiFrame[10][7] = ABE_TASK_ID(C_ABE_FW_TASK_IHF_48_96_LP);
-	/* MultiFrame[11][0] = 0; */
-	/* MultiFrame[11][1] = 0; */
-	MultiFrame[11][2] = ABE_TASK_ID(C_ABE_FW_TASK_AMIC_96_48_LP);
-	/* MultiFrame[11][3] = 0; */
-	MultiFrame[11][4] = ABE_TASK_ID(C_ABE_FW_TASK_AMIC_SPLIT);
-	/* MultiFrame[11][5] = 0; */
-	/* MultiFrame[11][6] = 0; */
-	MultiFrame[11][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA_PACK);
-	/* MultiFrame[12][0] = 0; */
-	/* MultiFrame[12][1] = 0; */
-	/* MultiFrame[12][2] = 0; */
-	MultiFrame[12][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_ROUTING);
-	MultiFrame[12][4] = ABE_TASK_ID(C_ABE_FW_TASK_ULMixer);
+	abe->MultiFrame[1][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_8_48);
+	abe->MultiFrame[1][6] = ABE_TASK_ID(C_ABE_FW_TASK_DL2Mixer);
+	abe->MultiFrame[1][7] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VIB_DL);
+	abe->MultiFrame[2][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1Mixer);
+	abe->MultiFrame[2][1] = ABE_TASK_ID(C_ABE_FW_TASK_SDTMixer);
+	abe->MultiFrame[2][5] = ABE_TASK_ID(C_ABE_FW_TASK_IO_DMIC);
+	abe->MultiFrame[3][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1_GAIN);
+	abe->MultiFrame[3][6] = ABE_TASK_ID(C_ABE_FW_TASK_DL2_GAIN);
+	abe->MultiFrame[3][7] = ABE_TASK_ID(C_ABE_FW_TASK_DL2_EQ);
+	abe->MultiFrame[4][0] = ABE_TASK_ID(C_ABE_FW_TASK_DL1_EQ);
+	abe->MultiFrame[4][2] = ABE_TASK_ID(C_ABE_FW_TASK_VXRECMixer);
+	abe->MultiFrame[4][3] = ABE_TASK_ID(C_ABE_FW_TASK_VXREC_SPLIT);
+	abe->MultiFrame[4][6] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA1);
+	abe->MultiFrame[4][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA2);
+	abe->MultiFrame[5][1] = ABE_TASK_ID(C_ABE_FW_TASK_EARP_48_96_LP);
+	abe->MultiFrame[5][2] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_UL);
+	abe->MultiFrame[5][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA_SPLIT);
+	abe->MultiFrame[6][0] = ABE_TASK_ID(C_ABE_FW_TASK_EARP_48_96_LP);
+	abe->MultiFrame[6][5] = ABE_TASK_ID(C_ABE_FW_TASK_EchoMixer);
+	abe->MultiFrame[7][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_DL);
+	abe->MultiFrame[7][2] = ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_SPLIT);
+	abe->MultiFrame[7][3] = ABE_TASK_ID(C_ABE_FW_TASK_DBG_SYNC);
+	abe->MultiFrame[7][5] = ABE_TASK_ID(C_ABE_FW_TASK_ECHO_REF_SPLIT);
+	abe->MultiFrame[8][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC1_96_48_LP);
+	abe->MultiFrame[8][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC1_SPLIT);
+	abe->MultiFrame[9][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC2_96_48_LP);
+	abe->MultiFrame[9][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC2_SPLIT);
+	abe->MultiFrame[9][6] = 0;
+	abe->MultiFrame[9][7] = ABE_TASK_ID(C_ABE_FW_TASK_IHF_48_96_LP);
+	abe->MultiFrame[10][2] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC3_96_48_LP);
+	abe->MultiFrame[10][4] = ABE_TASK_ID(C_ABE_FW_TASK_DMIC3_SPLIT);
+	abe->MultiFrame[10][7] = ABE_TASK_ID(C_ABE_FW_TASK_IHF_48_96_LP);
+	abe->MultiFrame[11][2] = ABE_TASK_ID(C_ABE_FW_TASK_AMIC_96_48_LP);
+	abe->MultiFrame[11][4] = ABE_TASK_ID(C_ABE_FW_TASK_AMIC_SPLIT);
+	abe->MultiFrame[11][7] = ABE_TASK_ID(C_ABE_FW_TASK_VIBRA_PACK);
+	abe->MultiFrame[12][3] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_ROUTING);
+	abe->MultiFrame[12][4] = ABE_TASK_ID(C_ABE_FW_TASK_ULMixer);
 #define TASK_VX_UL_SLT 12
 #define TASK_VX_UL_IDX 5
-	MultiFrame[12][5] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_8);
-	/* MultiFrame[12][6] = 0; */
-	/* MultiFrame[12][7] = 0; */
-	/* MultiFrame[13][0] = 0; */
-	/* MultiFrame[13][1] = 0; */
-	MultiFrame[13][2] = ABE_TASK_ID(C_ABE_FW_TASK_MM_UL2_ROUTING);
-	MultiFrame[13][3] = ABE_TASK_ID(C_ABE_FW_TASK_SideTone);
-	/* MultiFrame[13][4] = 0; */
-	MultiFrame[13][5] = ABE_TASK_ID(C_ABE_FW_TASK_IO_BT_VX_DL);
-	/* MultiFrame[13][6] = 0; */
-	/* MultiFrame[13][7] = 0; */
-	/* MultiFrame[14][0] = 0; */
-	/* MultiFrame[14][1] = 0; */
-	/* MultiFrame[14][2] = 0; */
-	MultiFrame[14][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_DMIC);
+	abe->MultiFrame[12][5] = ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_8);
+	abe->MultiFrame[13][2] = ABE_TASK_ID(C_ABE_FW_TASK_MM_UL2_ROUTING);
+	abe->MultiFrame[13][3] = ABE_TASK_ID(C_ABE_FW_TASK_SideTone);
+	abe->MultiFrame[13][5] = ABE_TASK_ID(C_ABE_FW_TASK_IO_BT_VX_DL);
+	abe->MultiFrame[14][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_DMIC);
 #define TASK_BT_DL_48_8_SLT 14
 #define TASK_BT_DL_48_8_IDX 4
-	MultiFrame[14][4] = ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_8);
-	/* MultiFrame[14][5] = 0; */
-	/* MultiFrame[14][6] = 0; */
-	/* MultiFrame[14][7] = 0; */
+	abe->MultiFrame[14][4] = ABE_TASK_ID(C_ABE_FW_TASK_BT_DL_48_8);
 #define TASK_ASRC_BT_UL_SLT 15
 #define TASK_ASRC_BT_UL_IDX 6
-	MultiFrame[15][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_EXT_OUT);
-	/* MultiFrame[15][1] = 0; */
-	/* MultiFrame[15][2] = 0; */
-	MultiFrame[15][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_BT_VX_UL);
-	/* MultiFrame[15][4] = 0; */
-	/* MultiFrame[15][5] = 0; */
-	MultiFrame[15][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_UL_8);
-	/* MultiFrame[15][7] = 0; */
-	/* MultiFrame[16][0] = 0; */
-	/* MultiFrame[16][1] = 0; */
+	abe->MultiFrame[15][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_EXT_OUT);
+	abe->MultiFrame[15][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_BT_VX_UL);
+	abe->MultiFrame[15][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_UL_8);
 #define TASK_ASRC_VX_UL_SLT 16
 #define TASK_ASRC_VX_UL_IDX 2
-	MultiFrame[16][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_UL_8);
-	MultiFrame[16][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VX_UL);
-	/* MultiFrame[16][4] = 0; */
-	/* MultiFrame[16][5] = 0; */
-	/* MultiFrame[16][6] = 0; */
-	/* MultiFrame[16][7] = 0; */
-	/* MultiFrame[17][0] = 0; */
-	/* MultiFrame[17][1] = 0; */
+	abe->MultiFrame[16][2] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_UL_8);
+	abe->MultiFrame[16][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_VX_UL);
 #define TASK_BT_UL_8_48_SLT 17
 #define TASK_BT_UL_8_48_IDX 2
-	MultiFrame[17][2] = ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_8_48);
-	MultiFrame[17][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_UL2);
-	/* MultiFrame[17][4] = 0; */
-	/* MultiFrame[17][5] = 0; */
-	/* MultiFrame[17][6] = 0; */
-	/* MultiFrame[17][7] = 0; */
+	abe->MultiFrame[17][2] = ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_8_48);
+	abe->MultiFrame[17][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_UL2);
 #define TASK_IO_MM_DL_SLT 18
 #define TASK_IO_MM_DL_IDX 0
-	MultiFrame[18][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_DL);
-	/* MultiFrame[18][1] = 0; */
-	/* MultiFrame[18][2] = 0; */
-	/* MultiFrame[18][3] = 0; */
-	/* MultiFrame[18][4] = 0; */
-	/* MultiFrame[18][5] = 0; */
+	abe->MultiFrame[18][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_DL);
 #define TASK_ASRC_BT_DL_SLT 18
 #define TASK_ASRC_BT_DL_IDX 6
-	MultiFrame[18][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_DL_8);
-	/* MultiFrame[18][7] = 0; */
-	MultiFrame[19][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_DL);
-	/* MultiFrame[19][1] = 0 */
-	/* MultiFrame[19][2] = 0; */
-	/* MultiFrame[19][3] = 0; */
-	/* MultiFrame[19][4] = 0; */
-	/* MultiFrame[19][5] = 0; */
-	/*         MM_UL is moved to OPP 100% */
-	MultiFrame[19][6] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_UL);
-	/* MultiFrame[19][7] = 0; */
-	MultiFrame[20][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_TONES_DL);
-	/* MultiFrame[20][1] = 0; */
-	/* MultiFrame[20][2] = 0; */
-	/* MultiFrame[20][3] = 0; */
-	/* MultiFrame[20][4] = 0; */
-	/* MultiFrame[20][5] = 0; */
-	MultiFrame[20][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_MM_EXT_IN);
-	/* MultiFrame[20][7] = 0; */
-	/* MultiFrame[21][0] = 0; */
-	MultiFrame[21][1] = ABE_TASK_ID(C_ABE_FW_TASK_DEBUGTRACE_VX_ASRCs);
-	/* MultiFrame[21][2] = 0; */
-	MultiFrame[21][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_EXT_IN);
-	/* MultiFrame[21][4] = 0; */
-	/* MultiFrame[21][5] = 0; */
-	/* MultiFrame[21][6] = 0; */
-	/* MultiFrame[21][7] = 0; */
+	abe->MultiFrame[18][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_DL_8);
+	abe->MultiFrame[19][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_PDM_DL);
+	/* MM_UL is moved to OPP 100% */
+	abe->MultiFrame[19][6] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_UL);
+	abe->MultiFrame[20][0] = ABE_TASK_ID(C_ABE_FW_TASK_IO_TONES_DL);
+	abe->MultiFrame[20][6] = ABE_TASK_ID(C_ABE_FW_TASK_ASRC_MM_EXT_IN);
+	abe->MultiFrame[21][1] = ABE_TASK_ID(C_ABE_FW_TASK_DEBUGTRACE_VX_ASRCs);
+	abe->MultiFrame[21][3] = ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_EXT_IN);
 	/* MUST STAY ON SLOT 22 */
-	MultiFrame[22][0] = ABE_TASK_ID(C_ABE_FW_TASK_DEBUG_IRQFIFO);
-	MultiFrame[22][1] = ABE_TASK_ID(C_ABE_FW_TASK_INIT_FW_MEMORY);
-	MultiFrame[22][2] = 0;
-	/* MultiFrame[22][3] = 0; */
-	/* MM_EXT_IN_SPLIT task must be after IO_MM_EXT_IN and before
-	   ASRC_MM_EXT_IN in order to manage OPP50 <-> transitions */
-	MultiFrame[22][4] = ABE_TASK_ID(C_ABE_FW_TASK_MM_EXT_IN_SPLIT);
-	/* MultiFrame[22][5] = 0; */
-	/* MultiFrame[22][6] = 0; */
-	/* MultiFrame[22][7] = 0; */
-	MultiFrame[23][0] = ABE_TASK_ID(C_ABE_FW_TASK_GAIN_UPDATE);
-	/* MultiFrame[23][1] = 0; */
-	/* MultiFrame[23][2] = 0; */
-	/* MultiFrame[23][3] = 0; */
-	/* MultiFrame[23][4] = 0; */
-	/* MultiFrame[23][5] = 0; */
-	/* MultiFrame[23][6] = 0; */
-	/* MultiFrame[23][7] = 0; */
-	/* MultiFrame[24][0] = 0; */
-	/* MultiFrame[24][1] = 0; */
-	/* MultiFrame[24][2] = 0; */
-	/* MultiFrame[24][3] = 0; */
-	/* MultiFrame[24][4] = 0; */
-	/* MultiFrame[24][5] = 0; */
-	/* MultiFrame[24][6] = 0; */
-	/* MultiFrame[24][7] = 0; */
+	abe->MultiFrame[22][0] = ABE_TASK_ID(C_ABE_FW_TASK_DEBUG_IRQFIFO);
+	abe->MultiFrame[22][1] = ABE_TASK_ID(C_ABE_FW_TASK_INIT_FW_MEMORY);
+	abe->MultiFrame[22][2] = 0;
+	/*
+	 * MM_EXT_IN_SPLIT task must be after IO_MM_EXT_IN and before
+	 * ASRC_MM_EXT_IN in order to manage OPP50 <-> transitions
+	 */
+	abe->MultiFrame[22][4] = ABE_TASK_ID(C_ABE_FW_TASK_MM_EXT_IN_SPLIT);
+	abe->MultiFrame[23][0] = ABE_TASK_ID(C_ABE_FW_TASK_GAIN_UPDATE);
+
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_multiFrame_ADDR,
-		       (u32 *) MultiFrame, sizeof(MultiFrame));
+		       (u32 *) abe->MultiFrame, sizeof(abe->MultiFrame));
+
 	/* reset the uplink router */
 	n = (D_aUplinkRouting_sizeof) >> 1;
 	for (i = 0; i < n; i++)
 		aUplinkMuxing[i] = ZERO_labelID;
+
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM, D_aUplinkRouting_ADDR,
 		       (u32 *) aUplinkMuxing, sizeof(aUplinkMuxing));
 }
+
 /**
  * abe_init_atc
  * @id: ABE port ID
@@ -299,13 +158,11 @@
 {
 	u8 iter;
 	s32 datasize;
+	abe_satcdescriptor_aess atc_desc;
+
 #define JITTER_MARGIN 4
 	/* load default values of the descriptor */
-	atc_desc.rdpt = atc_desc.wrpt = atc_desc.irqdest = atc_desc.cberr = 0;
-	atc_desc.desen = atc_desc.nw = 0;
-	atc_desc.reserved0 = atc_desc.reserved1 = atc_desc.reserved2 = 0;
-	atc_desc.srcid = atc_desc.destid = atc_desc.badd = atc_desc.iter =
-		atc_desc.cbsize = 0;
+	memset(&atc_desc, 0, sizeof(atc_desc));
 	datasize = abe_dma_port_iter_factor(&((abe_port[id]).format));
 	iter = (u8) abe_dma_port_iteration(&((abe_port[id]).format));
 	/* if the ATC FIFO is too small there will be two ABE firmware
@@ -321,12 +178,13 @@
 	/* IN from AESS point of view */
 	if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN)
 		if (iter + 2 * datasize > 126)
-			atc_desc.wrpt =
-				(iter >> 1) + ((JITTER_MARGIN - 1) * datasize);
+			atc_desc.wrpt = (iter >> 1) +
+				((JITTER_MARGIN-1) * datasize);
 		else
-			atc_desc.wrpt = iter + ((JITTER_MARGIN - 1) * datasize);
+			atc_desc.wrpt = iter + ((JITTER_MARGIN-1) * datasize);
 	else
-		atc_desc.wrpt = 0 + ((JITTER_MARGIN + 1) * datasize);
+		atc_desc.wrpt = 0 + ((JITTER_MARGIN+1) * datasize);
+
 	switch ((abe_port[id]).protocol.protocol_switch) {
 	case SLIMBUS_PORT_PROT:
 		atc_desc.cbdir = (abe_port[id]).protocol.direction;
@@ -340,8 +198,7 @@
 				      desc_addr1 >> 3];
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       (abe_port[id]).protocol.p.prot_slimbus.
-			       desc_addr1, (u32 *) &atc_desc,
-			       sizeof(atc_desc));
+			       desc_addr1, (u32 *) &atc_desc, sizeof(atc_desc));
 		atc_desc.badd =
 			(abe_port[id]).protocol.p.prot_slimbus.buf_addr2;
 		atc_desc.srcid =
@@ -349,8 +206,7 @@
 				      desc_addr2 >> 3];
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       (abe_port[id]).protocol.p.prot_slimbus.
-			       desc_addr2, (u32 *) &atc_desc,
-			       sizeof(atc_desc));
+			       desc_addr2, (u32 *) &atc_desc, sizeof(atc_desc));
 		break;
 	case SERIAL_PORT_PROT:
 		atc_desc.cbdir = (abe_port[id]).protocol.direction;
@@ -413,7 +269,8 @@
 			(abe_port[id]).protocol.p.prot_dmareq.buf_size;
 		atc_desc.badd =
 			((abe_port[id]).protocol.p.prot_dmareq.buf_addr) >> 4;
-		/* CBPr needs ITER=1. this is the eDMA job to do the iterations */
+		/* CBPr needs ITER=1.
+		It is the job of eDMA to do the iterations */
 		atc_desc.iter = 1;
 		/* input from ABE point of view */
 		if (abe_port[id].protocol.direction == ABE_ATC_DIRECTION_IN) {
@@ -435,6 +292,7 @@
 		break;
 	}
 }
+
 /**
  * abe_init_dma_t
  * @ id: ABE port ID
@@ -446,6 +304,7 @@
 {
 	abe_dma_t_offset dma;
 	u32 idx;
+
 	/* default dma_t points to address 0000... */
 	dma.data = 0;
 	dma.iter = 0;
@@ -484,17 +343,22 @@
 	/* upload the dma type */
 	abe_port[id].dma = dma;
 }
+
 /**
  * abe_disenable_dma_request
  * Parameter:
  * Operations:
  * Return value:
+ *	none
  */
 void abe_disable_enable_dma_request(u32 id, u32 on_off)
 {
 	u8 desc_third_word[4], irq_dmareq_field;
 	u32 sio_desc_address;
 	u32 struct_offset;
+	ABE_SIODescriptor sio_desc;
+	ABE_SPingPongDescriptor desc_pp;
+
 	if (abe_port[id].protocol.protocol_switch == PINGPONG_PORT_PROT) {
 		irq_dmareq_field =
 			(u8) (on_off *
@@ -514,8 +378,8 @@
 			dmem_port_descriptors +
 			(id * sizeof(ABE_SIODescriptor));
 		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       sio_desc_address, (u32 *) &sio_desc,
-			       sizeof(sio_desc));
+			sio_desc_address, (u32 *) &sio_desc,
+			sizeof(sio_desc));
 		if (on_off) {
 			sio_desc.atc_irq_data =
 				(u8) abe_port[id].protocol.p.prot_dmareq.
@@ -526,34 +390,41 @@
 			sio_desc.on_off = 0;
 		}
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-			       sio_desc_address, (u32 *) &sio_desc,
-			       sizeof(sio_desc));
+			sio_desc_address, (u32 *) &sio_desc,
+			sizeof(sio_desc));
 	}
+
 }
+
 void abe_enable_dma_request(u32 id)
 {
 	abe_disable_enable_dma_request(id, 1);
 }
+
 /**
  * abe_disable_dma_request
  *
  * Parameter:
  * Operations:
  * Return value:
- *
+ *	none
  */
 void abe_disable_dma_request(u32 id)
 {
 	abe_disable_enable_dma_request(id, 0);
 }
+
 /**
  * abe_enable_atc
  * Parameter:
  * Operations:
  * Return value:
+ *	none
  */
 void abe_enable_atc(u32 id)
 {
+	abe_satcdescriptor_aess atc_desc;
+
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
 		       (abe_port[id]).protocol.p.prot_dmareq.desc_addr,
 		       (u32 *) &atc_desc, sizeof(atc_desc));
@@ -561,15 +432,20 @@
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       (abe_port[id]).protocol.p.prot_dmareq.desc_addr,
 		       (u32 *) &atc_desc, sizeof(atc_desc));
+
 }
+
 /**
  * abe_disable_atc
  * Parameter:
  * Operations:
  * Return value:
+ *	none
  */
 void abe_disable_atc(u32 id)
 {
+	abe_satcdescriptor_aess atc_desc;
+
 	abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
 		       (abe_port[id]).protocol.p.prot_dmareq.desc_addr,
 		       (u32 *) &atc_desc, sizeof(atc_desc));
@@ -577,7 +453,9 @@
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 		       (abe_port[id]).protocol.p.prot_dmareq.desc_addr,
 		       (u32 *) &atc_desc, sizeof(atc_desc));
+
 }
+
 /**
  * abe_init_io_tasks
  * @prot : protocol being used
@@ -599,11 +477,15 @@
 	u32 sio_desc_address, datasize, iter, nsamp, datasize2, dOppMode32;
 	u32 atc_ptr_saved, atc_ptr_saved2, copy_func_index1;
 	u32 copy_func_index2, atc_desc_address1, atc_desc_address2;
+	ABE_SPingPongDescriptor desc_pp;
+	ABE_SIODescriptor sio_desc;
+
 	if (prot->protocol_switch == PINGPONG_PORT_PROT) {
 		/* ping_pong is only supported on MM_DL */
 		if (MM_DL_PORT != id) {
-			abe_dbg_param |= ERR_API;
+			abe->dbg_param |= ERR_API;
 			abe_dbg_error_log(ABE_PARAMETER_ERROR);
+			return;
 		}
 		smem1 = smem_mm_dl;
 		copy_func_index = (u8) abe_dma_port_copy_subroutine_id(id);
@@ -647,8 +529,11 @@
 		/* next buffer to send is B1, first IRQ fills B0 */
 		desc_pp.counter = 0;
 		/* send a DMA req to fill B0 with N samples
-		   abe_block_copy (COPY_FROM_HOST_TO_ABE, ABE_ATC, ABE_DMASTATUS_RAW,
-		   &(abe_port[id].protocol.p.prot_pingpong.irq_data), 4); */
+		   abe_block_copy (COPY_FROM_HOST_TO_ABE,
+			ABE_ATC,
+			ABE_DMASTATUS_RAW,
+			&(abe_port[id].protocol.p.prot_pingpong.irq_data),
+			4); */
 		sio_desc_address = D_PingPongDesc_ADDR;
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
 			       sio_desc_address, (u32 *) &desc_pp,
@@ -718,13 +603,17 @@
 			io_sub_id = IO_IP_CFPID;
 			break;
 		}
-		/* special situation of the PING_PONG protocol which has its own SIO descriptor format */
+		/* special situation of the PING_PONG protocol which
+		has its own SIO descriptor format */
 		/*
 		   Sequence of operations on ping-pong buffers B0/B1
-		   ----------------------------------------------------------------- time --------------------------------------------->>>>
+		   -------------- time ---------------------------->>>>
 		   Host Application is ready to send data from DDR to B0
 		   SDMA is initialized from "abe_connect_irq_ping_pong_port" to B0
-		   FIRMWARE starts with #12 B1 data, sends IRQ/DMAreq sens #pong B1 data sends IRQ/DMAreq sends #ping B0 v sends B1 samples
+		   FIRMWARE starts with #12 B1 data,
+		   sends IRQ/DMAreq, sends #pong B1 data,
+		   sends IRQ/DMAreq, sends #ping B0,
+		   sends B1 samples
 		   ARM / SDMA | fills B0 | fills B1 ... | fills B0 ...
 		   Counter 0 1 2 3
 		 */
@@ -734,98 +623,91 @@
 		}
 		/* check for 8kHz/16kHz */
 		if (VX_DL_PORT == id) {
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
 			if (abe_port[id].format.f == 8000) {
-				MultiFrame[TASK_ASRC_VX_DL_SLT]
+				abe->MultiFrame[TASK_ASRC_VX_DL_SLT]
 					[TASK_ASRC_VX_DL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_DL_8);
-				MultiFrame[TASK_VX_DL_SLT][TASK_VX_DL_IDX] =
+				abe->MultiFrame[TASK_VX_DL_SLT][TASK_VX_DL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_8_48);
 				/*Voice_8k_DL_labelID */
 				smem1 = IO_VX_DL_ASRC_labelID;
 			} else {
-				MultiFrame[TASK_ASRC_VX_DL_SLT]
+				abe->MultiFrame[TASK_ASRC_VX_DL_SLT]
 					[TASK_ASRC_VX_DL_IDX] =
 					ABE_TASK_ID
 					(C_ABE_FW_TASK_ASRC_VX_DL_16);
-				MultiFrame[TASK_VX_DL_SLT][TASK_VX_DL_IDX] =
+				abe->MultiFrame[TASK_VX_DL_SLT][TASK_VX_DL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_VX_DL_16_48);
 				/* Voice_16k_DL_labelID */
 				smem1 = IO_VX_DL_ASRC_labelID;
 			}
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+				       D_multiFrame_ADDR,
+				       (u32 *) abe->MultiFrame,
+				       sizeof(abe->MultiFrame));
 		}
 		/* check for 8kHz/16kHz */
 		if (VX_UL_PORT == id) {
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
 			if (abe_port[id].format.f == 8000) {
-				MultiFrame[TASK_ASRC_VX_UL_SLT]
+				abe->MultiFrame[TASK_ASRC_VX_UL_SLT]
 					[TASK_ASRC_VX_UL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_ASRC_VX_UL_8);
-				MultiFrame[TASK_VX_UL_SLT][TASK_VX_UL_IDX] =
+				abe->MultiFrame[TASK_VX_UL_SLT][TASK_VX_UL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_8);
 				/* MultiFrame[TASK_ECHO_SLT][TASK_ECHO_IDX] =
 				   ABE_TASK_ID(C_ABE_FW_TASK_ECHO_REF_48_8); */
 				smem1 = Voice_8k_UL_labelID;
 			} else {
-				MultiFrame[TASK_ASRC_VX_UL_SLT]
+				abe->MultiFrame[TASK_ASRC_VX_UL_SLT]
 					[TASK_ASRC_VX_UL_IDX] =
 					ABE_TASK_ID
 					(C_ABE_FW_TASK_ASRC_VX_UL_16);
-				MultiFrame[TASK_VX_UL_SLT][TASK_VX_UL_IDX] =
+				abe->MultiFrame[TASK_VX_UL_SLT][TASK_VX_UL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_VX_UL_48_16);
 				/* MultiFrame[TASK_ECHO_SLT][TASK_ECHO_IDX] =
 				   ABE_TASK_ID(C_ABE_FW_TASK_ECHO_REF_48_16); */
 				smem1 = Voice_16k_UL_labelID;
 			}
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+				       D_multiFrame_ADDR,
+				       (u32 *) abe->MultiFrame,
+				       sizeof(abe->MultiFrame));
 		}
 		/* check for 8kHz/16kHz */
 		if (BT_VX_DL_PORT == id) {
 			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
 				       D_maxTaskBytesInSlot_ADDR, &dOppMode32,
 				       sizeof(u32));
 			if (abe_port[id].format.f == 8000) {
-				MultiFrame[TASK_ASRC_BT_DL_SLT]
+				abe->MultiFrame[TASK_ASRC_BT_DL_SLT]
 					[TASK_ASRC_BT_DL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_DL_8);
 				if (dOppMode32 == DOPPMODE32_OPP100) {
-					MultiFrame[TASK_BT_DL_48_8_SLT]
+					abe->MultiFrame[TASK_BT_DL_48_8_SLT]
 						[TASK_BT_DL_48_8_IDX] =
 						ABE_TASK_ID
 						(C_ABE_FW_TASK_BT_DL_48_8_OPP100);
 					smem1 = BT_DL_8k_opp100_labelID;
 				} else {
-					MultiFrame[TASK_BT_DL_48_8_SLT]
+					abe->MultiFrame[TASK_BT_DL_48_8_SLT]
 						[TASK_BT_DL_48_8_IDX] =
 						ABE_TASK_ID
 						(C_ABE_FW_TASK_BT_DL_48_8);
 					smem1 = BT_DL_8k_labelID;
 				}
 			} else {
-				MultiFrame[TASK_ASRC_BT_DL_SLT]
+				abe->MultiFrame[TASK_ASRC_BT_DL_SLT]
 					[TASK_ASRC_BT_DL_IDX] =
 					ABE_TASK_ID
 					(C_ABE_FW_TASK_ASRC_BT_DL_16);
 				if (dOppMode32 == DOPPMODE32_OPP100) {
-					MultiFrame[TASK_BT_DL_48_8_SLT]
+					abe->MultiFrame[TASK_BT_DL_48_8_SLT]
 						[TASK_BT_DL_48_8_IDX] =
 						ABE_TASK_ID
 						(C_ABE_FW_TASK_BT_DL_48_16_OPP100);
 					smem1 = BT_DL_16k_opp100_labelID;
 				} else {
-					MultiFrame[TASK_BT_DL_48_8_SLT]
+					abe->MultiFrame[TASK_BT_DL_48_8_SLT]
 						[TASK_BT_DL_48_8_IDX] =
 						ABE_TASK_ID
 						(C_ABE_FW_TASK_BT_DL_48_16);
@@ -833,23 +715,21 @@
 				}
 			}
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+				       D_multiFrame_ADDR,
+				       (u32 *) abe->MultiFrame,
+				       sizeof(abe->MultiFrame));
 		}
 		/* check for 8kHz/16kHz */
 		if (BT_VX_UL_PORT == id) {
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
 			/* set the SMEM buffer -- programming sequence */
 			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
 				       D_maxTaskBytesInSlot_ADDR, &dOppMode32,
 				       sizeof(u32));
 			if (abe_port[id].format.f == 8000) {
-				MultiFrame[TASK_ASRC_BT_UL_SLT]
+				abe->MultiFrame[TASK_ASRC_BT_UL_SLT]
 					[TASK_ASRC_BT_UL_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_ASRC_BT_UL_8);
-				MultiFrame[TASK_BT_UL_8_48_SLT]
+				abe->MultiFrame[TASK_BT_UL_8_48_SLT]
 					[TASK_BT_UL_8_48_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_8_48);
 				if (dOppMode32 == DOPPMODE32_OPP100)
@@ -859,11 +739,11 @@
 					/* at OPP 50 without ASRC */
 					smem1 = BT_UL_8k_labelID;
 			} else {
-				MultiFrame[TASK_ASRC_BT_UL_SLT]
+				abe->MultiFrame[TASK_ASRC_BT_UL_SLT]
 					[TASK_ASRC_BT_UL_IDX] =
 					ABE_TASK_ID
 					(C_ABE_FW_TASK_ASRC_BT_UL_16);
-				MultiFrame[TASK_BT_UL_8_48_SLT]
+				abe->MultiFrame[TASK_BT_UL_8_48_SLT]
 					[TASK_BT_UL_8_48_IDX] =
 					ABE_TASK_ID(C_ABE_FW_TASK_BT_UL_16_48);
 				if (dOppMode32 == DOPPMODE32_OPP100)
@@ -874,19 +754,18 @@
 					smem1 = BT_UL_16k_labelID;
 			}
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+				       D_multiFrame_ADDR,
+				       (u32 *) abe->MultiFrame,
+				       sizeof(abe->MultiFrame));
 		}
 		if (MM_DL_PORT == id) {
 			/* check for CBPr / serial_port / Ping-pong access */
-			abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
-			MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
+			abe->MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
 				ABE_TASK_ID(C_ABE_FW_TASK_IO_MM_DL);
 			abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-				       D_multiFrame_ADDR, (u32 *) MultiFrame,
-				       sizeof(MultiFrame));
+				       D_multiFrame_ADDR,
+				       (u32 *) abe->MultiFrame,
+				       sizeof(abe->MultiFrame));
 			smem1 = smem_mm_dl;
 		}
 		if (MM_EXT_IN_PORT == id) {
@@ -935,13 +814,14 @@
 		sio_desc.data_size2 = (u8) datasize2;
 		sio_desc.copy_f_index2 = (u8) copy_func_index2;
 		sio_desc_address = dmem_port_descriptors + (id *
-							    sizeof
-							    (ABE_SIODescriptor));
+				sizeof(ABE_SIODescriptor));
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-			       sio_desc_address, (u32 *) &sio_desc,
-			       sizeof(sio_desc));
+				sio_desc_address, (u32 *) &sio_desc,
+				sizeof(sio_desc));
 	}
+
 }
+
 /**
  * abe_enable_pp_io_task
  * @id: port_id
@@ -950,23 +830,20 @@
  */
 void abe_enable_pp_io_task(u32 id)
 {
-	/* MM_DL managed in ping-pong */
 	if (MM_DL_PORT == id) {
-		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       D_multiFrame_ADDR, (u32 *) MultiFrame,
-			       sizeof(MultiFrame));
-		MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
+		/* MM_DL managed in ping-pong */
+		abe->MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] =
 			ABE_TASK_ID(C_ABE_FW_TASK_IO_PING_PONG);
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-			       D_multiFrame_ADDR, (u32 *) MultiFrame,
-			       sizeof(MultiFrame));
-	}
-	/* ping_pong is only supported on MM_DL */
-	else {
-		abe_dbg_param |= ERR_API;
+			       D_multiFrame_ADDR, (u32 *) abe->MultiFrame,
+			       sizeof(abe->MultiFrame));
+	} else {
+		/* ping_pong is only supported on MM_DL */
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
 	}
 }
+
 /**
  * abe_disable_pp_io_task
  * @id: port_id
@@ -975,22 +852,19 @@
  */
 void abe_disable_pp_io_task(u32 id)
 {
-	/* MM_DL managed in ping-pong */
 	if (MM_DL_PORT == id) {
-		abe_block_copy(COPY_FROM_ABE_TO_HOST, ABE_DMEM,
-			       D_multiFrame_ADDR, (u32 *) MultiFrame,
-			       sizeof(MultiFrame));
-		MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] = 0;
+		/* MM_DL managed in ping-pong */
+		abe->MultiFrame[TASK_IO_MM_DL_SLT][TASK_IO_MM_DL_IDX] = 0;
 		abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_DMEM,
-			       D_multiFrame_ADDR, (u32 *) MultiFrame,
-			       sizeof(MultiFrame));
-	}
-	/* ping_pong is only supported on MM_DL */
-	else {
-		abe_dbg_param |= ERR_API;
+			       D_multiFrame_ADDR, (u32 *) abe->MultiFrame,
+			       sizeof(abe->MultiFrame));
+	} else {
+		/* ping_pong is only supported on MM_DL */
+		abe->dbg_param |= ERR_API;
 		abe_dbg_error_log(ABE_PARAMETER_ERROR);
 	}
 }
+
 /**
  * abe_init_dmic
  * @x: d
@@ -1000,6 +874,7 @@
 void abe_init_dmic(u32 x)
 {
 }
+
 /**
  * abe_init_mcpdm
  * @x: d
@@ -1008,6 +883,7 @@
 void abe_init_mcpdm(u32 x)
 {
 }
+
 /**
  * abe_reset_feature
  * @x: index of the feature to be initialized
@@ -1020,6 +896,7 @@
 	/* abe_call_subroutine ((all_feature[x]).disable_feature, NOPARAMETER,
 	   NOPARAMETER, NOPARAMETER, NOPARAMETER); */
 }
+
 /**
  * abe_reset_all_feature
  *
@@ -1043,6 +920,7 @@
 	for (i = 0; i < MAXNBFEATURE; i++)
 		abe_reset_one_feature(i);
 }
+
 /**
  * abe_reset_all_ports
  *
@@ -1051,6 +929,7 @@
 void abe_reset_all_ports(void)
 {
 	u16 i;
+
 	for (i = 0; i < LAST_PORT_ID; i++)
 		abe_reset_port(i);
 	/* mixers' configuration */
@@ -1088,7 +967,10 @@
 	abe_write_gain(GAINS_DL1, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
 	abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_100MS, GAIN_LEFT_OFFSET);
 	abe_write_gain(GAINS_DL2, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
+	abe_write_gain(GAINS_BTUL, GAIN_0dB, RAMP_100MS, GAIN_LEFT_OFFSET);
+	abe_write_gain(GAINS_BTUL, GAIN_0dB, RAMP_100MS, GAIN_RIGHT_OFFSET);
 }
+
 /**
  * abe_clean_temporay buffers
  *
@@ -1099,37 +981,33 @@
 	switch (id) {
 	case DMIC_PORT:
 		abe_reset_mem(ABE_DMEM, D_DMIC_UL_FIFO_ADDR,
-			      D_DMIC_UL_FIFO_sizeof);
+			D_DMIC_UL_FIFO_sizeof);
 		abe_reset_mem(ABE_SMEM, S_DMIC0_96_48_data_ADDR << 3,
-			      S_DMIC0_96_48_data_sizeof << 3);
+			S_DMIC0_96_48_data_sizeof << 3);
 		abe_reset_mem(ABE_SMEM, S_DMIC1_96_48_data_ADDR << 3,
-			      S_DMIC1_96_48_data_sizeof << 3);
+			S_DMIC1_96_48_data_sizeof << 3);
 		abe_reset_mem(ABE_SMEM, S_DMIC2_96_48_data_ADDR << 3,
-			      S_DMIC1_96_48_data_sizeof << 3);
-		abe_reset_mem(ABE_CMEM, (C_GainsWRamp_ADDR + dmic1_gains_offset) << 2, 6 << 2);	/* reset current gains */
-		abe_reset_mem(ABE_SMEM,
-			      (S_GCurrent_ADDR + dmic1_gains_offset) << 3,
-			      6 << 3);
-		abe_reset_gain_mixer(GAINS_DMIC1, 0);
-		abe_reset_gain_mixer(GAINS_DMIC2, 0);
-		abe_reset_gain_mixer(GAINS_DMIC3, 0);
+			S_DMIC2_96_48_data_sizeof << 3);
+		/* reset working values of the gain, target gain is preserved */
+		abe_reset_gain_mixer(GAINS_DMIC1, GAIN_LEFT_OFFSET);
+		abe_reset_gain_mixer(GAINS_DMIC1, GAIN_RIGHT_OFFSET);
+		abe_reset_gain_mixer(GAINS_DMIC2, GAIN_LEFT_OFFSET);
+		abe_reset_gain_mixer(GAINS_DMIC2, GAIN_RIGHT_OFFSET);
+		abe_reset_gain_mixer(GAINS_DMIC3, GAIN_LEFT_OFFSET);
+		abe_reset_gain_mixer(GAINS_DMIC3, GAIN_RIGHT_OFFSET);
 		break;
 	case PDM_UL_PORT:
 		abe_reset_mem(ABE_DMEM, D_McPDM_UL_FIFO_ADDR,
-			      D_McPDM_UL_FIFO_sizeof);
-		abe_reset_mem(ABE_SMEM, S_BT_UL_ADDR << 3, S_BT_UL_sizeof << 3);
+			D_McPDM_UL_FIFO_sizeof);
 		abe_reset_mem(ABE_SMEM, S_AMIC_96_48_data_ADDR << 3,
-			      S_AMIC_96_48_data_sizeof << 3);
-		abe_reset_mem(ABE_CMEM, (C_GainsWRamp_ADDR + amic_gains_offset) << 2, 2 << 2);	/* reset current gains */
-		abe_reset_mem(ABE_SMEM,
-			      (S_GCurrent_ADDR + amic_gains_offset) << 3,
-			      6 << 3);
-		abe_reset_gain_mixer(GAINS_AMIC, 0);
+			S_AMIC_96_48_data_sizeof << 3);
+		/* reset working values of the gain, target gain is preserved */
+		abe_reset_gain_mixer(GAINS_AMIC, GAIN_LEFT_OFFSET);
+		abe_reset_gain_mixer(GAINS_AMIC, GAIN_RIGHT_OFFSET);
 		break;
 	case BT_VX_UL_PORT:
 		abe_reset_mem(ABE_DMEM, D_BT_UL_FIFO_ADDR, D_BT_UL_FIFO_sizeof);
 		abe_reset_mem(ABE_SMEM, S_BT_UL_ADDR << 3, S_BT_UL_sizeof << 3);
-		abe_reset_mem(ABE_SMEM, S_BT_UL_ADDR << 3, S_BT_UL_sizeof << 3);
 		abe_reset_mem(ABE_SMEM, S_BT_UL_8_48_HP_data_ADDR << 3,
 			      S_BT_UL_8_48_HP_data_sizeof << 3);
 		abe_reset_mem(ABE_SMEM, S_BT_UL_8_48_LP_data_ADDR << 3,
@@ -1138,12 +1016,13 @@
 			      S_BT_UL_16_48_HP_data_sizeof << 3);
 		abe_reset_mem(ABE_SMEM, S_BT_UL_16_48_LP_data_ADDR << 3,
 			      S_BT_UL_16_48_LP_data_sizeof << 3);
+		/* reset working values of the gain, target gain is preserved */
+		abe_reset_gain_mixer(GAINS_BTUL, GAIN_LEFT_OFFSET);
+		abe_reset_gain_mixer(GAINS_BTUL, GAIN_RIGHT_OFFSET);
 		break;
 	case MM_UL_PORT:
 		abe_reset_mem(ABE_DMEM, D_MM_UL_FIFO_ADDR, D_MM_UL_FIFO_sizeof);
 		abe_reset_mem(ABE_SMEM, S_MM_UL_ADDR << 3, S_MM_UL_sizeof << 3);
-		abe_reset_mem(ABE_SMEM, S_MM_UL2_ADDR << 3,
-			      D_MM_UL2_FIFO_sizeof << 3);
 		break;
 	case MM_UL2_PORT:
 		abe_reset_mem(ABE_DMEM, D_MM_UL2_FIFO_ADDR,
@@ -1244,10 +1123,10 @@
 		break;
 	}
 }
+
 /**
- * abe_clear_current_gain_mixer
+ * abe_reset_gain_mixer
  * @id: name of the mixer
- * @param: list of input gains of the mixer
  * @p: list of port corresponding to the above gains
  *
  * restart the working gain value of the mixers when a port is enabled
@@ -1296,6 +1175,9 @@
 	case MIXAUDUL:
 		mixer_offset = mixer_audul_offset;
 		break;
+	case GAINS_BTUL:
+		mixer_offset = btul_gains_offset;
+		break;
 	}
 	/* SMEM word32 address for the CURRENT gain values */
 	mixer_target = (S_GCurrent_ADDR << 1);
@@ -1308,14 +1190,17 @@
 	abe_block_copy(COPY_FROM_HOST_TO_ABE, ABE_SMEM, mixer_target,
 		       (u32 *) &lin_g, sizeof(lin_g));
 }
+
 /**
  * abe_init_asrc_vx_dl
  *
  * Initialize the following ASRC VX_DL parameters :
  * 1. DriftSign = D_AsrcVars[1] = 1 or -1
  * 2. Subblock = D_AsrcVars[2] = 0
- * 3. DeltaAlpha = D_AsrcVars[3] = (round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
- * 4. MinusDeltaAlpha = D_AsrcVars[4] = (-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 3. DeltaAlpha = D_AsrcVars[3] =
+ *	(round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 4. MinusDeltaAlpha = D_AsrcVars[4] =
+ *	(-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
  * 5. OneMinusEpsilon = D_AsrcVars[5] = 1 - DeltaAlpha/2
  * 6. AlphaCurrent = 0x000020 (CMEM), initial value of Alpha parameter
  * 7. BetaCurrent = 0x3fffe0 (CMEM), initial value of Beta parameter
@@ -1330,13 +1215,16 @@
  * XinASRC_DL_VX = S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/0/1/0/0/0/0
  * 13. SMEM for IO_VX_DL_ASRC pointer
  * 14. CMEM for IO_VX_DL_ASRC pointer
- * IO_VX_DL_ASRC = S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/ASRC_DL_VX_FIR_L+ASRC_margin/1/0/0/0/0
+ * IO_VX_DL_ASRC =
+ *	S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/
+ *	ASRC_DL_VX_FIR_L+ASRC_margin/1/0/0/0/0
  */
 void abe_init_asrc_vx_dl(s32 dppm)
 {
 	s32 el[45];
 	s32 temp0, temp1, adppm, dtemp, mem_tag, mem_addr;
 	u32 i = 0;
+	u32 n_fifo_el = 42;
 	temp0 = 0;
 	temp1 = 1;
 	/* 1. DriftSign = D_AsrcVars[1] = 1 */
@@ -1366,11 +1254,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_DL_VX_ADDR + (3 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = dtemp << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1378,11 +1265,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_DL_VX_ADDR + (4 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = (-dtemp) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1390,11 +1276,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_DL_VX_ADDR + (5 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0x00400000;
-	} else {
+	else
 		el[i + 1] = (0x00100000 - (dtemp / 2)) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1424,8 +1309,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 9. SMEM for ASRC_DL_VX_Coefs pointer */
-	/* ASRC_DL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0
-	   /1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+	/* ASRC_DL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_SMEM;
 	mem_addr = ASRC_DL_VX_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1435,8 +1320,8 @@
 	el[i + 2] = (el[i + 2] << 8) + C_CoefASRC15_VX_sizeof;
 	i = i + 3;
 	/* 10. CMEM for ASRC_DL_VX_Coefs pointer */
-	/* ASRC_DL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/
-	   1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+	/* ASRC_DL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_CMEM;
 	mem_addr = ASRC_DL_VX_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1446,7 +1331,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 11. SMEM for XinASRC_DL_VX pointer */
-	/* XinASRC_DL_VX = S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_DL_VX =
+		S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = XinASRC_DL_VX_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1455,7 +1341,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 12. CMEM for XinASRC_DL_VX pointer */
-	/* XinASRC_DL_VX = S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_DL_VX =
+		S_XinASRC_DL_VX_ADDR/S_XinASRC_DL_VX_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = XinASRC_DL_VX_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1485,16 +1372,20 @@
 		+ (temp0 << 4) + temp0;
 	/* dummy field */
 	el[i + 2] = temp0;
-	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0], 42);
+	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0],
+		       n_fifo_el);
 }
+
 /**
  * abe_init_asrc_vx_ul
  *
  * Initialize the following ASRC VX_UL parameters :
  * 1. DriftSign = D_AsrcVars[1] = 1 or -1
  * 2. Subblock = D_AsrcVars[2] = 0
- * 3. DeltaAlpha = D_AsrcVars[3] = (round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
- * 4. MinusDeltaAlpha = D_AsrcVars[4] = (-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 3. DeltaAlpha = D_AsrcVars[3] =
+ *	(round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 4. MinusDeltaAlpha = D_AsrcVars[4] =
+ *	(-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
  * 5. OneMinusEpsilon = D_AsrcVars[5] = 1 - DeltaAlpha/2
  * 6. AlphaCurrent = 0x000020 (CMEM), initial value of Alpha parameter
  * 7. BetaCurrent = 0x3fffe0 (CMEM), initial value of Beta parameter
@@ -1502,18 +1393,18 @@
  * 8. drift_ASRC = 0 & drift_io = 0
  * 9. SMEM for ASRC_UL_VX_Coefs pointer
  * 10. CMEM for ASRC_UL_VX_Coefs pointer
- *		ASRC_UL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof
- *	/0/1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1
+ * ASRC_UL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+ *	C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1
  * 11. SMEM for XinASRC_UL_VX pointer
  * 12. CMEM for XinASRC_UL_VX pointer
- *		XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/0/0/0/0
+ * XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/0/0/0/0
  * 13. SMEM for UL_48_8_DEC pointer
  * 14. CMEM for UL_48_8_DEC pointer
- *		UL_48_8_DEC = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/
+ * UL_48_8_DEC = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/
  *	ASRC_UL_VX_FIR_L+ASRC_margin/1/0/0/0/0
  * 15. SMEM for UL_48_16_DEC pointer
  * 16. CMEM for UL_48_16_DEC pointer
- *		UL_48_16_DEC = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/
+ * UL_48_16_DEC = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/
  *	ASRC_UL_VX_FIR_L+ASRC_margin/1/0/0/0/0
  */
 void abe_init_asrc_vx_ul(s32 dppm)
@@ -1521,6 +1412,7 @@
 	s32 el[51];
 	s32 temp0, temp1, adppm, dtemp, mem_tag, mem_addr;
 	u32 i = 0;
+	u32 n_fifo_el = 48;
 	temp0 = 0;
 	temp1 = 1;
 	/* 1. DriftSign = D_AsrcVars[1] = 1 */
@@ -1550,11 +1442,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_UL_VX_ADDR + (3 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = dtemp << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1562,11 +1453,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_UL_VX_ADDR + (4 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = (-dtemp) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1574,11 +1464,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_UL_VX_ADDR + (5 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0x00400000;
-	} else {
+	else
 		el[i + 1] = (0x00100000 - (dtemp / 2)) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1609,7 +1498,7 @@
 	i = i + 3;
 	/* 9. SMEM for ASRC_UL_VX_Coefs pointer */
 	/* ASRC_UL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
-	   C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_SMEM;
 	mem_addr = ASRC_UL_VX_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1620,7 +1509,7 @@
 	i = i + 3;
 	/* 10. CMEM for ASRC_UL_VX_Coefs pointer */
 	/* ASRC_UL_VX_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
-	   C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_CMEM;
 	mem_addr = ASRC_UL_VX_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1630,7 +1519,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 11. SMEM for XinASRC_UL_VX pointer */
-	/* XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/
+		0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = XinASRC_UL_VX_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1639,7 +1529,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 12. CMEM for XinASRC_UL_VX pointer */
-	/* XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_UL_VX = S_XinASRC_UL_VX_ADDR/S_XinASRC_UL_VX_sizeof/0/1/
+		0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = XinASRC_UL_VX_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1691,38 +1582,44 @@
 		+ (temp0 << 4) + temp0;
 	/* dummy field */
 	el[i + 2] = temp0;
-	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0], 48);
+	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0],
+		       n_fifo_el);
 }
+
 /**
  * abe_init_asrc_mm_ext_in
  *
- *	Initialize the following ASRC MM_EXT_IN parameters :
+ * Initialize the following ASRC MM_EXT_IN parameters :
  * 1. DriftSign = D_AsrcVars[1] = 1 or -1
  * 2. Subblock = D_AsrcVars[2] = 0
- * 3. DeltaAlpha = D_AsrcVars[3] = (round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
- * 4. MinusDeltaAlpha = D_AsrcVars[4] = (-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 3. DeltaAlpha = D_AsrcVars[3] =
+ *	(round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 4. MinusDeltaAlpha = D_AsrcVars[4] =
+ *	(-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
  * 5. OneMinusEpsilon = D_AsrcVars[5] = 1 - DeltaAlpha/2
  * 6. AlphaCurrent = 0x000020 (CMEM), initial value of Alpha parameter
  * 7. BetaCurrent = 0x3fffe0 (CMEM), initial value of Beta parameter
  * AlphaCurrent + BetaCurrent = 1 (=0x400000 in CMEM = 2^20 << 2)
  * 8. drift_ASRC = 0 & drift_io = 0
- *	9. SMEM for ASRC_MM_EXT_IN_Coefs pointer
- *	10. CMEM for ASRC_MM_EXT_IN_Coefs pointer
- *		ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof/
- *		0/1/C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1
- *	11. SMEM for XinASRC_MM_EXT_IN pointer
- *	12. CMEM for XinASRC_MM_EXT_IN pointer
- *		XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/0/1/0/0/0/0
- *	13. SMEM for IO_MM_EXT_IN_ASRC pointer
- *	14. CMEM for IO_MM_EXT_IN_ASRC pointer
- *		IO_MM_EXT_IN_ASRC = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
- *		ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0
+ * 9. SMEM for ASRC_MM_EXT_IN_Coefs pointer
+ * 10. CMEM for ASRC_MM_EXT_IN_Coefs pointer
+ * ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof/0/1/
+ *	C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1
+ * 11. SMEM for XinASRC_MM_EXT_IN pointer
+ * 12. CMEM for XinASRC_MM_EXT_IN pointer
+ * XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/0/1/
+ *	0/0/0/0
+ * 13. SMEM for IO_MM_EXT_IN_ASRC pointer
+ * 14. CMEM for IO_MM_EXT_IN_ASRC pointer
+ * IO_MM_EXT_IN_ASRC = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
+ *	ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0
  */
 void abe_init_asrc_mm_ext_in(s32 dppm)
 {
 	s32 el[45];
 	s32 temp0, temp1, adppm, dtemp, mem_tag, mem_addr;
 	u32 i = 0;
+	u32 n_fifo_el = 42;
 	temp0 = 0;
 	temp1 = 1;
 	/* 1. DriftSign = D_AsrcVars[1] = 1 */
@@ -1752,11 +1649,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_MM_EXT_IN_ADDR + (3 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = dtemp << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1764,11 +1660,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_MM_EXT_IN_ADDR + (4 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0;
-	} else {
+	else
 		el[i + 1] = (-dtemp) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1776,11 +1671,10 @@
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_MM_EXT_IN_ADDR + (5 * sizeof(s32));
 	el[i] = (mem_tag << 16) + mem_addr;
-	if (dppm == 0) {
+	if (dppm == 0)
 		el[i + 1] = 0x00400000;
-	} else {
+	else
 		el[i + 1] = (0x00100000 - (dtemp / 2)) << 2;
-	}
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
@@ -1810,8 +1704,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 9. SMEM for ASRC_MM_EXT_IN_Coefs pointer */
-	/* ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof
-	   /0/1/C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1 */
+	/* ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof/
+		0/1/C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1 */
 	mem_tag = ABE_SMEM;
 	mem_addr = ASRC_MM_EXT_IN_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1821,8 +1715,8 @@
 	el[i + 2] = (el[i + 2] << 8) + C_CoefASRC15_MM_sizeof;
 	i = i + 3;
 	/*10. CMEM for ASRC_MM_EXT_IN_Coefs pointer */
-	/* ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof
-	   /0/1/C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1 */
+	/* ASRC_MM_EXT_IN_Coefs = C_CoefASRC16_MM_ADDR/C_CoefASRC16_MM_sizeof/
+		0/1/C_CoefASRC15_MM_ADDR/C_CoefASRC15_MM_sizeof/0/1 */
 	mem_tag = ABE_CMEM;
 	mem_addr = ASRC_MM_EXT_IN_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1832,7 +1726,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 11. SMEM for XinASRC_MM_EXT_IN pointer */
-	/* XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/
+		S_XinASRC_MM_EXT_IN_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = XinASRC_MM_EXT_IN_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1841,7 +1736,8 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 12. CMEM for XinASRC_MM_EXT_IN pointer */
-	/* XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_MM_EXT_IN = S_XinASRC_MM_EXT_IN_ADDR/
+		S_XinASRC_MM_EXT_IN_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = XinASRC_MM_EXT_IN_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1851,8 +1747,9 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 13. SMEM for IO_MM_EXT_IN_ASRC pointer */
-	/* IO_MM_EXT_IN_ASRC = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
-	   ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0 */
+	/* IO_MM_EXT_IN_ASRC =
+		S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
+		ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = IO_MM_EXT_IN_ASRC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1861,8 +1758,9 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	/* 14. CMEM for IO_MM_EXT_IN_ASRC pointer */
-	/* IO_MM_EXT_IN_ASRC = S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
-	   ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0 */
+	/* IO_MM_EXT_IN_ASRC =
+		S_XinASRC_MM_EXT_IN_ADDR/S_XinASRC_MM_EXT_IN_sizeof/
+		ASRC_MM_EXT_IN_FIR_L+ASRC_margin+ASRC_N_48k/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = IO_MM_EXT_IN_ASRC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -1871,16 +1769,20 @@
 		(temp1 << 12) + (temp0 << 4) + temp0;
 	/* dummy field */
 	el[i + 2] = temp0;
-	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0], 42);
+	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0],
+		       n_fifo_el);
 }
+
 /**
  * abe_init_asrc_bt_ul
  *
  * Initialize the following ASRC BT_UL parameters :
  * 1. DriftSign = D_AsrcVars[1] = 1 or -1
  * 2. Subblock = D_AsrcVars[2] = 0
- * 3. DeltaAlpha = D_AsrcVars[3] = (round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
- * 4. MinusDeltaAlpha = D_AsrcVars[4] = (-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 3. DeltaAlpha = D_AsrcVars[3] =
+ *	(round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 4. MinusDeltaAlpha = D_AsrcVars[4] =
+ *	(-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
  * 5. OneMinusEpsilon = D_AsrcVars[5] = 1 - DeltaAlpha/2
  * 6. AlphaCurrent = 0x000020 (CMEM), initial value of Alpha parameter
  * 7. BetaCurrent = 0x3fffe0 (CMEM), initial value of Beta parameter
@@ -1895,16 +1797,17 @@
  * XinASRC_BT_UL = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/0/1/0/0/0/0
  * 13. SMEM for IO_BT_UL_ASRC pointer
  * 14. CMEM for IO_BT_UL_ASRC pointer
- * IO_BT_UL_ASRC = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0
+ * IO_BT_UL_ASRC = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/
+ *	ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0
  */
 void abe_init_asrc_bt_ul(s32 dppm)
 {
 	s32 el[45];
 	s32 temp0, temp1, adppm, dtemp, mem_tag, mem_addr;
 	u32 i = 0;
+	u32 n_fifo_el = 42;
 	temp0 = 0;
 	temp1 = 1;
-
 	/* 1. DriftSign = D_AsrcVars[1] = 1 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_UL_ADDR + (1 * sizeof(s32));
@@ -1920,7 +1823,6 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	dtemp = (adppm << 4) + adppm - ((adppm * 3481L) / 15625L);
-
 	/* 2. Subblock = D_AsrcVars[2] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_UL_ADDR + (2 * sizeof(s32));
@@ -1929,7 +1831,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 3. DeltaAlpha = D_AsrcVars[3] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_UL_ADDR + (3 * sizeof(s32));
@@ -1941,7 +1842,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 4. MinusDeltaAlpha = D_AsrcVars[4] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_UL_ADDR + (4 * sizeof(s32));
@@ -1953,7 +1853,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/*5. OneMinusEpsilon = D_AsrcVars[5] = 0x00400000 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_UL_ADDR + (5 * sizeof(s32));
@@ -1965,7 +1864,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 6. AlphaCurrent = 0x000020 (CMEM) */
 	mem_tag = ABE_CMEM;
 	mem_addr = C_AlphaCurrent_BT_UL_ADDR;
@@ -1974,7 +1872,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 7. BetaCurrent = 0x3fffe0 (CMEM) */
 	mem_tag = ABE_CMEM;
 	mem_addr = C_BetaCurrent_BT_UL_ADDR;
@@ -1983,7 +1880,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 8. drift_ASRC = 0 & drift_io = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_IOdescr_ADDR + (BT_VX_UL_PORT * sizeof(ABE_SIODescriptor))
@@ -1993,10 +1889,9 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 9. SMEM for ASRC_BT_UL_Coefs pointer */
-	/* ASRC_BT_UL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0
-	   /1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+	/* ASRC_BT_UL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_SMEM;
 	mem_addr = ASRC_BT_UL_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2005,10 +1900,9 @@
 	el[i + 2] = C_CoefASRC15_VX_ADDR;
 	el[i + 2] = (el[i + 2] << 8) + C_CoefASRC15_VX_sizeof;
 	i = i + 3;
-
 	/* 10. CMEM for ASRC_BT_UL_Coefs pointer */
-	/* ASRC_BT_UL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/
-	   1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+	/* ASRC_BT_UL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_CMEM;
 	mem_addr = ASRC_BT_UL_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2017,9 +1911,9 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 11. SMEM for XinASRC_BT_UL pointer */
-	/* XinASRC_BT_UL = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_BT_UL = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/0/1/
+		0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = XinASRC_BT_UL_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2027,9 +1921,9 @@
 	el[i + 1] = (el[i + 1] << 8) + S_XinASRC_BT_UL_sizeof;
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 12. CMEM for XinASRC_BT_UL pointer */
-	/* XinASRC_BT_UL = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_BT_UL = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/0/1/
+		0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = XinASRC_BT_UL_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2038,10 +1932,9 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 13. SMEM for IO_BT_UL_ASRC pointer */
 	/* IO_BT_UL_ASRC = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/
-	   ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = IO_BT_UL_ASRC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2049,10 +1942,9 @@
 	el[i + 1] = (el[i + 1] << 8) + S_XinASRC_BT_UL_sizeof;
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 14. CMEM for IO_BT_UL_ASRC pointer */
 	/* IO_BT_UL_ASRC = S_XinASRC_BT_UL_ADDR/S_XinASRC_BT_UL_sizeof/
-	   ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_UL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = IO_BT_UL_ASRC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2061,16 +1953,20 @@
 		+ (temp0 << 4) + temp0;
 	/* dummy field */
 	el[i + 2] = temp0;
-	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0], 42);
+	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0],
+		       n_fifo_el);
 }
+
 /**
  * abe_init_asrc_bt_dl
  *
  * Initialize the following ASRC BT_DL parameters :
  * 1. DriftSign = D_AsrcVars[1] = 1 or -1
  * 2. Subblock = D_AsrcVars[2] = 0
- * 3. DeltaAlpha = D_AsrcVars[3] = (round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
- * 4. MinusDeltaAlpha = D_AsrcVars[4] = (-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 3. DeltaAlpha = D_AsrcVars[3] =
+ *	(round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
+ * 4. MinusDeltaAlpha = D_AsrcVars[4] =
+ *	(-round(nb_phases * drift[ppm] * 10^-6 * 2^20)) << 2
  * 5. OneMinusEpsilon = D_AsrcVars[5] = 1 - DeltaAlpha/2
  * 6. AlphaCurrent = 0x000020 (CMEM), initial value of Alpha parameter
  * 7. BetaCurrent = 0x3fffe0 (CMEM), initial value of Beta parameter
@@ -2078,18 +1974,18 @@
  * 8. drift_ASRC = 0 & drift_io = 0
  * 9. SMEM for ASRC_BT_DL_Coefs pointer
  * 10. CMEM for ASRC_BT_DL_Coefs pointer
- *		ASRC_BT_DL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof
- *	/0/1/C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1
+ * ASRC_BT_DL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
+ *	C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1
  * 11. SMEM for XinASRC_BT_DL pointer
  * 12. CMEM for XinASRC_BT_DL pointer
- *		XinASRC_BT_DL = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0
+ * XinASRC_BT_DL = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0
  * 13. SMEM for DL_48_8_DEC pointer
  * 14. CMEM for DL_48_8_DEC pointer
- *		DL_48_8_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
+ * DL_48_8_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
  *	ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0
  * 15. SMEM for DL_48_16_DEC pointer
  * 16. CMEM for DL_48_16_DEC pointer
- *		DL_48_16_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
+ * DL_48_16_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
  *	ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0
  */
 void abe_init_asrc_bt_dl(s32 dppm)
@@ -2097,9 +1993,9 @@
 	s32 el[51];
 	s32 temp0, temp1, adppm, dtemp, mem_tag, mem_addr;
 	u32 i = 0;
+	u32 n_fifo_el = 48;
 	temp0 = 0;
 	temp1 = 1;
-
 	/* 1. DriftSign = D_AsrcVars[1] = 1 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_DL_ADDR + (1 * sizeof(s32));
@@ -2115,7 +2011,6 @@
 	el[i + 2] = temp0;
 	i = i + 3;
 	dtemp = (adppm << 4) + adppm - ((adppm * 3481L) / 15625L);
-
 	/* 2. Subblock = D_AsrcVars[2] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_DL_ADDR + (2 * sizeof(s32));
@@ -2124,7 +2019,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 3. DeltaAlpha = D_AsrcVars[3] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_DL_ADDR + (3 * sizeof(s32));
@@ -2136,7 +2030,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 4. MinusDeltaAlpha = D_AsrcVars[4] = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_DL_ADDR + (4 * sizeof(s32));
@@ -2148,7 +2041,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 5. OneMinusEpsilon = D_AsrcVars[5] = 0x00400000 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_AsrcVars_BT_DL_ADDR + (5 * sizeof(s32));
@@ -2160,7 +2052,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 6. AlphaCurrent = 0x000020 (CMEM) */
 	mem_tag = ABE_CMEM;
 	mem_addr = C_AlphaCurrent_BT_DL_ADDR;
@@ -2169,7 +2060,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 7. BetaCurrent = 0x3fffe0 (CMEM) */
 	mem_tag = ABE_CMEM;
 	mem_addr = C_BetaCurrent_BT_DL_ADDR;
@@ -2178,7 +2068,6 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 8. drift_ASRC = 0 & drift_io = 0 */
 	mem_tag = ABE_DMEM;
 	mem_addr = D_IOdescr_ADDR + (BT_VX_DL_PORT * sizeof(ABE_SIODescriptor))
@@ -2188,20 +2077,20 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 9. SMEM for ASRC_BT_DL_Coefs pointer */
 	/* ASRC_BT_DL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
-	   C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_SMEM;
 	mem_addr = ASRC_BT_DL_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
-	el[i + 1] = (C_CoefASRC16_VX_ADDR << 8) + C_CoefASRC16_VX_sizeof;
-	el[i + 2] = (C_CoefASRC15_VX_ADDR << 8) + C_CoefASRC15_VX_sizeof;
+	el[i + 1] = C_CoefASRC16_VX_ADDR;
+	el[i + 1] = (el[i + 1] << 8) + C_CoefASRC16_VX_sizeof;
+	el[i + 2] = C_CoefASRC15_VX_ADDR;
+	el[i + 2] = (el[i + 2] << 8) + C_CoefASRC15_VX_sizeof;
 	i = i + 3;
-
 	/* 10. CMEM for ASRC_BT_DL_Coefs pointer */
 	/* ASRC_BT_DL_Coefs = C_CoefASRC16_VX_ADDR/C_CoefASRC16_VX_sizeof/0/1/
-	   C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
+		C_CoefASRC15_VX_ADDR/C_CoefASRC15_VX_sizeof/0/1 */
 	mem_tag = ABE_CMEM;
 	mem_addr = ASRC_BT_DL_Coefs_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2210,18 +2099,19 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 11. SMEM for XinASRC_BT_DL pointer */
-	/* XinASRC_BT_DL = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_BT_DL =
+		S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = XinASRC_BT_DL_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
-	el[i + 1] = (S_XinASRC_BT_DL_ADDR << 8) + S_XinASRC_BT_DL_sizeof;
+	el[i + 1] = S_XinASRC_BT_DL_ADDR;
+	el[i + 1] = (el[i + 1] << 8) + S_XinASRC_BT_DL_sizeof;
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 12. CMEM for XinASRC_BT_DL pointer */
-	/* XinASRC_BT_DL = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0 */
+	/* XinASRC_BT_DL =
+		S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/0/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = XinASRC_BT_DL_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2230,20 +2120,19 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 13. SMEM for DL_48_8_DEC pointer */
 	/* DL_48_8_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
-	   ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = DL_48_8_DEC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
-	el[i + 1] = (S_XinASRC_BT_DL_ADDR << 8) + S_XinASRC_BT_DL_sizeof;
+	el[i + 1] = S_XinASRC_BT_DL_ADDR;
+	el[i + 1] = (el[i + 1] << 8) + S_XinASRC_BT_DL_sizeof;
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 14. CMEM for DL_48_8_DEC pointer */
 	/* DL_48_8_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
-	   ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = DL_48_8_DEC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2253,20 +2142,19 @@
 	/* dummy field */
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 15. SMEM for DL_48_16_DEC pointer */
 	/* DL_48_16_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
-	   ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_SMEM;
 	mem_addr = DL_48_16_DEC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
-	el[i + 1] = (S_XinASRC_BT_DL_ADDR << 8) + S_XinASRC_BT_DL_sizeof;
+	el[i + 1] = S_XinASRC_BT_DL_ADDR;
+	el[i + 1] = (el[i + 1] << 8) + S_XinASRC_BT_DL_sizeof;
 	el[i + 2] = temp0;
 	i = i + 3;
-
 	/* 16. CMEM for DL_48_16_DEC pointer */
 	/* DL_48_16_DEC = S_XinASRC_BT_DL_ADDR/S_XinASRC_BT_DL_sizeof/
-	   ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
+		ASRC_BT_DL_FIR_L+ASRC_margin/1/0/0/0/0 */
 	mem_tag = ABE_CMEM;
 	mem_addr = DL_48_16_DEC_labelID;
 	el[i] = (mem_tag << 16) + (mem_addr << 2);
@@ -2275,5 +2163,6 @@
 		+ (temp0 << 4) + temp0;
 	/* dummy field */
 	el[i + 2] = temp0;
-	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0], 48);
+	abe_write_fifo(ABE_DMEM, D_FwMemInitDescr_ADDR, (u32 *) &el[0],
+		       n_fifo_el);
 }
Index: kernel/sound/soc/omap/abe/abe_initxxx_labels.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_initxxx_labels.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_initxxx_labels.h	2011-03-28 15:57:05.798386525 +0900
@@ -52,281 +52,282 @@
 #define SDT_M_G_labelID                                     29
 #define VXREC_M_G_VX_DL_labelID                             30
 #define UL_M_G_VX_DL_labelID                                31
-#define DL1_M_labelID                                       32
-#define DL2_M_labelID                                       33
-#define MM_UL2_labelID                                      34
-#define VX_DL_labelID                                       35
-#define Tones_labelID                                       36
-#define DL_M_MM_UL2_VX_DL_labelID                           37
-#define Echo_M_labelID                                      38
-#define VX_UL_labelID                                       39
-#define VX_UL_M_labelID                                     40
-#define SDT_F_labelID                                       41
-#define SDT_F_data_labelID                                  42
-#define SDT_Coef_labelID                                    43
-#define SDT_Regs_labelID                                    44
-#define SDT_M_labelID                                       45
-#define DL1_EQ_labelID                                      46
-#define DL2_EQ_labelID                                      47
-#define DL1_GAIN_out_labelID                                48
-#define DL2_GAIN_out_labelID                                49
-#define DMIC1_labelID                                       50
-#define DMIC1_L_labelID                                     51
-#define DMIC1_R_labelID                                     52
-#define DMIC2_labelID                                       53
-#define DMIC2_L_labelID                                     54
-#define DMIC2_R_labelID                                     55
-#define DMIC3_labelID                                       56
-#define DMIC3_L_labelID                                     57
-#define DMIC3_R_labelID                                     58
-#define MIC4_labelID                                        59
-#define MIC4_L_labelID                                      60
-#define MIC4_R_labelID                                      61
-#define BT_UL_L_labelID                                     62
-#define BT_UL_R_labelID                                     63
-#define AMIC_labelID                                        64
-#define AMIC_L_labelID                                      65
-#define AMIC_R_labelID                                      66
-#define EchoRef_L_labelID                                   67
-#define EchoRef_R_labelID                                   68
-#define MM_DL_L_labelID                                     69
-#define MM_DL_R_labelID                                     70
-#define MM_UL_labelID                                       71
-#define AMIC_96_labelID                                     72
-#define DMIC0_96_labelID                                    73
-#define DMIC1_96_labelID                                    74
-#define DMIC2_96_labelID                                    75
-#define UL_MIC_48K_labelID                                  76
-#define EQ_DL_48K_labelID                                   77
-#define EQ_48K_labelID                                      78
-#define McPDM_Out1_labelID                                  79
-#define McPDM_Out2_labelID                                  80
-#define McPDM_Out3_labelID                                  81
-#define VX_UL_MUX_labelID                                   82
-#define MM_UL2_MUX_labelID                                  83
-#define MM_UL_MUX_labelID                                   84
-#define XinASRC_DL_VX_labelID                               85
-#define ASRC_DL_VX_Coefs_labelID                            86
-#define ASRC_DL_VX_Alpha_labelID                            87
-#define ASRC_DL_VX_VarsBeta_labelID                         88
-#define ASRC_DL_VX_8k_Regs_labelID                          89
-#define XinASRC_UL_VX_labelID                               90
-#define ASRC_UL_VX_Coefs_labelID                            91
-#define ASRC_UL_VX_Alpha_labelID                            92
-#define ASRC_UL_VX_VarsBeta_labelID                         93
-#define ASRC_UL_VX_8k_Regs_labelID                          94
-#define UL_48_8_DEC_labelID                                 95
-#define ASRC_DL_VX_16k_Regs_labelID                         96
-#define ASRC_UL_VX_16k_Regs_labelID                         97
-#define UL_48_16_DEC_labelID                                98
-#define XinASRC_MM_EXT_IN_labelID                           99
-#define ASRC_MM_EXT_IN_Coefs_labelID                        100
-#define ASRC_MM_EXT_IN_Alpha_labelID                        101
-#define ASRC_MM_EXT_IN_VarsBeta_labelID                     102
-#define ASRC_MM_EXT_IN_Regs_labelID                         103
-#define VX_REC_labelID                                      104
-#define VXREC_UL_M_Tones_VX_UL_labelID                      105
-#define VX_REC_L_labelID                                    106
-#define VX_REC_R_labelID                                    107
-#define DL2_M_L_labelID                                     108
-#define DL2_M_R_labelID                                     109
-#define DL1_M_data_labelID                                  110
-#define DL1_M_Coefs_labelID                                 111
-#define DL2_M_LR_data_labelID                               112
-#define DL2_M_LR_Coefs_labelID                              113
-#define SRC_6_LP_COEFS_labelID                              114
-#define SRC_6_LP_GAIN_COEFS_labelID                         115
-#define SRC_6_HP_COEFS_labelID                              116
-#define SRC_3_LP_COEFS_labelID                              117
-#define SRC_3_LP_GAIN_COEFS_labelID                         118
-#define SRC_3_HP_COEFS_labelID                              119
-#define VX_DL_8_48_LP_DATA_labelID                          120
-#define VX_DL_8_48_HP_DATA_labelID                          121
-#define VX_DL_16_48_LP_DATA_labelID                         122
-#define VX_DL_16_48_HP_DATA_labelID                         123
-#define VX_UL_48_8_LP_DATA_labelID                          124
-#define VX_UL_48_8_HP_DATA_labelID                          125
-#define VX_UL_48_16_LP_DATA_labelID                         126
-#define VX_UL_48_16_HP_DATA_labelID                         127
-#define BT_UL_8_48_LP_DATA_labelID                          128
-#define BT_UL_8_48_HP_DATA_labelID                          129
-#define BT_UL_16_48_LP_DATA_labelID                         130
-#define BT_UL_16_48_HP_DATA_labelID                         131
-#define BT_DL_48_8_LP_DATA_labelID                          132
-#define BT_DL_48_8_HP_DATA_labelID                          133
-#define BT_DL_48_16_LP_DATA_labelID                         134
-#define BT_DL_48_16_HP_DATA_labelID                         135
-#define ECHO_REF_48_16_LP_DATA_labelID                      136
-#define ECHO_REF_48_16_HP_DATA_labelID                      137
-#define ECHO_REF_48_8_LP_DATA_labelID                       138
-#define ECHO_REF_48_8_HP_DATA_labelID                       139
-#define ECHO_REF_DEC_labelID                                140
-#define VX_UL_8_TEMP_labelID                                141
-#define VX_UL_16_TEMP_labelID                               142
-#define UP_DOWN_8_48_labelID                                143
-#define UP_DOWN_16_48_labelID                               144
-#define SRC_6_LP_48k_labelID                                145
-#define SRC_6_HP_labelID                                    146
-#define SRC_3_LP_48k_labelID                                147
-#define SRC_3_HP_labelID                                    148
-#define EARP_48_96_LP_DATA_labelID                          149
-#define SRC_48_96_LP_labelID                                150
-#define IHF_48_96_LP_DATA_labelID                           151
-#define EQ_VX_UL_16K_labelID                                152
-#define pAPS_iir1_p23_labelID                               153
-#define pAPS_iir1_p45_labelID                               154
-#define APS_IIR_Regs_labelID                                155
-#define pAPS_core_DL1_p1_labelID                            156
-#define pAPS_core_DL1_p23_labelID                           157
-#define pAPS_core_DL1_p45_labelID                           158
-#define pAPS_core_DL1_r_labelID                             159
-#define pAPS_DL2L_core_r_labelID                            160
-#define pAPS_DL2R_core_r_labelID                            161
-#define pAPS_COIL_core_DL1_p1_labelID                       162
-#define pAPS_COIL_core_DL1_p23_labelID                      163
-#define pAPS_COIL_core_DL1_p45_labelID                      164
-#define pAPS_COIL_core_DL1_r_labelID                        165
-#define DL2_L_APS_IIR_p23_labelID                           166
-#define DL2_R_APS_IIR_p23_labelID                           167
-#define DL2_L_APS_IIR_p45_labelID                           168
-#define DL2_R_APS_IIR_p45_labelID                           169
-#define DL2_L_APS_CORE_p1_labelID                           170
-#define DL2_L_APS_CORE_p23_labelID                          171
-#define DL2_L_APS_CORE_p45_labelID                          172
-#define DL2_R_APS_CORE_p1_labelID                           173
-#define DL2_R_APS_CORE_p23_labelID                          174
-#define DL2_R_APS_CORE_p45_labelID                          175
-#define DL2_L_APS_COIL_CORE_p1_labelID                      176
-#define DL2_L_APS_COIL_CORE_p23_labelID                     177
-#define DL2_L_APS_COIL_CORE_p45_labelID                     178
-#define pAPS_COIL_DL2L_core_r_labelID                       179
-#define DL2_R_APS_COIL_CORE_p1_labelID                      180
-#define DL2_R_APS_COIL_CORE_p23_labelID                     181
-#define DL2_R_APS_COIL_CORE_p45_labelID                     182
-#define pAPS_COIL_DL2R_core_r_labelID                       183
-#define DL1_APS_labelID                                     184
-#define DL2_L_APS_labelID                                   185
-#define DL2_R_APS_labelID                                   186
-#define DL1_APS_EQ_p23_labelID                              187
-#define DL1_APS_EQ_p45_labelID                              188
-#define DL2_APS_EQ_p23_labelID                              189
-#define DL2_APS_EQ_p45_labelID                              190
-#define pVIBRA1_p0_labelID                                  191
-#define pVIBRA1_p1_labelID                                  192
-#define pVIBRA1_p23_labelID                                 193
-#define pVIBRA1_p45_labelID                                 194
-#define pVibra1_pR1_labelID                                 195
-#define pVibra1_pR2_labelID                                 196
-#define pVibra1_pR3_labelID                                 197
-#define pVIBRA1_r_labelID                                   198
-#define pVIBRA2_p0_labelID                                  199
-#define pVIBRA2_p1_labelID                                  200
-#define pVIBRA2_p23_labelID                                 201
-#define pVIBRA2_p45_labelID                                 202
-#define pCtrl_p67_labelID                                   203
-#define pVIBRA2_r_labelID                                   204
-#define VIBRA_labelID                                       205
-#define PING_labelID                                        206
-#define PING_Regs_labelID                                   207
-#define UP_48_96_LP_COEFS_labelID                           208
-#define AMIC_96_48_data_labelID                             209
-#define DOWN_96_48_AMIC_Coefs_labelID                       210
-#define DOWN_96_48_DMIC_Coefs_labelID                       211
-#define DOWN_96_48_AMIC_Regs_labelID                        212
-#define DOWN_96_48_DMIC_Regs_labelID                        213
-#define DMIC0_96_48_data_labelID                            214
-#define DMIC1_96_48_data_labelID                            215
-#define DMIC2_96_48_data_labelID                            216
-#define SIO_DMIC_labelID                                    217
-#define SIO_PDM_UL_labelID                                  218
-#define SIO_BT_VX_UL_labelID                                219
-#define SIO_MM_UL_labelID                                   220
-#define SIO_MM_UL2_labelID                                  221
-#define SIO_VX_UL_labelID                                   222
-#define SIO_MM_DL_labelID                                   223
-#define SIO_VX_DL_labelID                                   224
-#define SIO_TONES_DL_labelID                                225
-#define SIO_VIB_DL_labelID                                  226
-#define SIO_BT_VX_DL_labelID                                227
-#define SIO_PDM_DL_labelID                                  228
-#define SIO_MM_EXT_OUT_labelID                              229
-#define SIO_MM_EXT_IN_labelID                               230
-#define SIO_TDM_OUT_labelID                                 231
-#define SIO_TDM_IN_labelID                                  232
-#define DMIC_ATC_PTR_labelID                                233
-#define MCPDM_UL_ATC_PTR_labelID                            234
-#define BT_VX_UL_ATC_PTR_labelID                            235
-#define MM_UL_ATC_PTR_labelID                               236
-#define MM_UL2_ATC_PTR_labelID                              237
-#define VX_UL_ATC_PTR_labelID                               238
-#define MM_DL_ATC_PTR_labelID                               239
-#define VX_DL_ATC_PTR_labelID                               240
-#define TONES_DL_ATC_PTR_labelID                            241
-#define VIB_DL_ATC_PTR_labelID                              242
-#define BT_VX_DL_ATC_PTR_labelID                            243
-#define PDM_DL_ATC_PTR_labelID                              244
-#define MM_EXT_OUT_ATC_PTR_labelID                          245
-#define MM_EXT_IN_ATC_PTR_labelID                           246
-#define TDM_OUT_ATC_PTR_labelID                             247
-#define TDM_IN_ATC_PTR_labelID                              248
-#define MCU_IRQ_FIFO_ptr_labelID                            249
-#define DEBUG_IRQ_FIFO_reg_labelID                          250
-#define UP_DOWN_48_96_labelID                               251
-#define OSR96_2_labelID                                     252
-#define DEBUG_GAINS_labelID                                 253
-#define DBG_8K_PATTERN_labelID                              254
-#define DBG_16K_PATTERN_labelID                             255
-#define DBG_24K_PATTERN_labelID                             256
-#define DBG_48K_PATTERN_labelID                             257
-#define DBG_96K_PATTERN_labelID                             258
-#define UL_VX_UL_48_8K_labelID                              259
-#define UL_VX_UL_48_16K_labelID                             260
-#define BT_DL_labelID                                       261
-#define BT_UL_labelID                                       262
-#define BT_DL_8k_labelID                                    263
-#define BT_DL_16k_labelID                                   264
-#define BT_UL_8k_labelID                                    265
-#define BT_UL_16k_labelID                                   266
-#define MM_EXT_IN_labelID                                   267
-#define MM_EXT_IN_L_labelID                                 268
-#define MM_EXT_IN_R_labelID                                 269
-#define ECHO_REF_48_16_WRAP_labelID                         270
-#define ECHO_REF_48_8_WRAP_labelID                          271
-#define BT_UL_16_48_WRAP_labelID                            272
-#define BT_UL_8_48_WRAP_labelID                             273
-#define BT_DL_48_16_WRAP_labelID                            274
-#define BT_DL_48_8_WRAP_labelID                             275
-#define VX_DL_16_48_WRAP_labelID                            276
-#define VX_DL_8_48_WRAP_labelID                             277
-#define VX_UL_48_16_WRAP_labelID                            278
-#define VX_UL_48_8_WRAP_labelID                             279
-#define APS_DL1_IRQs_WRAP_labelID                           280
-#define APS_DL2_L_IRQs_WRAP_labelID                         281
-#define APS_DL2_R_IRQs_WRAP_labelID                         282
-#define ATC_NULL_BUFFER_labelID                             283
-#define MEM_INIT_hal_mem_labelID                            284
-#define MEM_INIT_write_mem_labelID                          285
-#define MEM_INIT_regs_labelID                               286
-#define GAIN_0DB_labelID                                    287
-#define XinASRC_BT_UL_labelID                               288
-#define IO_BT_UL_ASRC_labelID                               289
-#define ASRC_BT_UL_Coefs_labelID                            290
-#define ASRC_BT_UL_Alpha_labelID                            291
-#define ASRC_BT_UL_VarsBeta_labelID                         292
-#define ASRC_BT_UL_8k_Regs_labelID                          293
-#define ASRC_BT_UL_16k_Regs_labelID                         294
-#define XinASRC_BT_DL_labelID                               295
-#define DL_48_8_DEC_labelID                                 296
-#define DL_48_16_DEC_labelID                                297
-#define BT_DL_8k_TEMP_labelID                               298
-#define BT_DL_16k_TEMP_labelID                              299
-#define BT_DL_8k_opp100_labelID                             300
-#define BT_DL_16k_opp100_labelID                            301
-#define ASRC_BT_DL_Coefs_labelID                            302
-#define ASRC_BT_DL_Alpha_labelID                            303
-#define ASRC_BT_DL_VarsBeta_labelID                         304
-#define ASRC_BT_DL_8k_Regs_labelID                          305
-#define ASRC_BT_DL_16k_Regs_labelID                         306
-#define BT_DL_48_8_OPP100_WRAP_labelID                      307
-#define BT_DL_48_16_OPP100_WRAP_labelID                     308
-#endif/* _ABE_INITXXXX_LABELS_H_ */
+#define BTUL_Gain_labelID                                   32
+#define DL1_M_labelID                                       33
+#define DL2_M_labelID                                       34
+#define MM_UL2_labelID                                      35
+#define VX_DL_labelID                                       36
+#define Tones_labelID                                       37
+#define DL_M_MM_UL2_VX_DL_labelID                           38
+#define Echo_M_labelID                                      39
+#define VX_UL_labelID                                       40
+#define VX_UL_M_labelID                                     41
+#define SDT_F_labelID                                       42
+#define SDT_F_data_labelID                                  43
+#define SDT_Coef_labelID                                    44
+#define SDT_Regs_labelID                                    45
+#define SDT_M_labelID                                       46
+#define DL1_EQ_labelID                                      47
+#define DL2_EQ_labelID                                      48
+#define DL1_GAIN_out_labelID                                49
+#define DL2_GAIN_out_labelID                                50
+#define DMIC1_labelID                                       51
+#define DMIC1_L_labelID                                     52
+#define DMIC1_R_labelID                                     53
+#define DMIC2_labelID                                       54
+#define DMIC2_L_labelID                                     55
+#define DMIC2_R_labelID                                     56
+#define DMIC3_labelID                                       57
+#define DMIC3_L_labelID                                     58
+#define DMIC3_R_labelID                                     59
+#define MIC4_labelID                                        60
+#define MIC4_L_labelID                                      61
+#define MIC4_R_labelID                                      62
+#define BT_UL_L_labelID                                     63
+#define BT_UL_R_labelID                                     64
+#define AMIC_labelID                                        65
+#define AMIC_L_labelID                                      66
+#define AMIC_R_labelID                                      67
+#define EchoRef_L_labelID                                   68
+#define EchoRef_R_labelID                                   69
+#define MM_DL_L_labelID                                     70
+#define MM_DL_R_labelID                                     71
+#define MM_UL_labelID                                       72
+#define AMIC_96_labelID                                     73
+#define DMIC0_96_labelID                                    74
+#define DMIC1_96_labelID                                    75
+#define DMIC2_96_labelID                                    76
+#define UL_MIC_48K_labelID                                  77
+#define EQ_DL_48K_labelID                                   78
+#define EQ_48K_labelID                                      79
+#define McPDM_Out1_labelID                                  80
+#define McPDM_Out2_labelID                                  81
+#define McPDM_Out3_labelID                                  82
+#define VX_UL_MUX_labelID                                   83
+#define MM_UL2_MUX_labelID                                  84
+#define MM_UL_MUX_labelID                                   85
+#define XinASRC_DL_VX_labelID                               86
+#define ASRC_DL_VX_Coefs_labelID                            87
+#define ASRC_DL_VX_Alpha_labelID                            88
+#define ASRC_DL_VX_VarsBeta_labelID                         89
+#define ASRC_DL_VX_8k_Regs_labelID                          90
+#define XinASRC_UL_VX_labelID                               91
+#define ASRC_UL_VX_Coefs_labelID                            92
+#define ASRC_UL_VX_Alpha_labelID                            93
+#define ASRC_UL_VX_VarsBeta_labelID                         94
+#define ASRC_UL_VX_8k_Regs_labelID                          95
+#define UL_48_8_DEC_labelID                                 96
+#define ASRC_DL_VX_16k_Regs_labelID                         97
+#define ASRC_UL_VX_16k_Regs_labelID                         98
+#define UL_48_16_DEC_labelID                                99
+#define XinASRC_MM_EXT_IN_labelID                           100
+#define ASRC_MM_EXT_IN_Coefs_labelID                        101
+#define ASRC_MM_EXT_IN_Alpha_labelID                        102
+#define ASRC_MM_EXT_IN_VarsBeta_labelID                     103
+#define ASRC_MM_EXT_IN_Regs_labelID                         104
+#define VX_REC_labelID                                      105
+#define VXREC_UL_M_Tones_VX_UL_labelID                      106
+#define VX_REC_L_labelID                                    107
+#define VX_REC_R_labelID                                    108
+#define DL2_M_L_labelID                                     109
+#define DL2_M_R_labelID                                     110
+#define DL1_M_data_labelID                                  111
+#define DL1_M_Coefs_labelID                                 112
+#define DL2_M_LR_data_labelID                               113
+#define DL2_M_LR_Coefs_labelID                              114
+#define SRC_6_LP_COEFS_labelID                              115
+#define SRC_6_LP_GAIN_COEFS_labelID                         116
+#define SRC_6_HP_COEFS_labelID                              117
+#define SRC_3_LP_COEFS_labelID                              118
+#define SRC_3_LP_GAIN_COEFS_labelID                         119
+#define SRC_3_HP_COEFS_labelID                              120
+#define VX_DL_8_48_LP_DATA_labelID                          121
+#define VX_DL_8_48_HP_DATA_labelID                          122
+#define VX_DL_16_48_LP_DATA_labelID                         123
+#define VX_DL_16_48_HP_DATA_labelID                         124
+#define VX_UL_48_8_LP_DATA_labelID                          125
+#define VX_UL_48_8_HP_DATA_labelID                          126
+#define VX_UL_48_16_LP_DATA_labelID                         127
+#define VX_UL_48_16_HP_DATA_labelID                         128
+#define BT_UL_8_48_LP_DATA_labelID                          129
+#define BT_UL_8_48_HP_DATA_labelID                          130
+#define BT_UL_16_48_LP_DATA_labelID                         131
+#define BT_UL_16_48_HP_DATA_labelID                         132
+#define BT_DL_48_8_LP_DATA_labelID                          133
+#define BT_DL_48_8_HP_DATA_labelID                          134
+#define BT_DL_48_16_LP_DATA_labelID                         135
+#define BT_DL_48_16_HP_DATA_labelID                         136
+#define ECHO_REF_48_16_LP_DATA_labelID                      137
+#define ECHO_REF_48_16_HP_DATA_labelID                      138
+#define ECHO_REF_48_8_LP_DATA_labelID                       139
+#define ECHO_REF_48_8_HP_DATA_labelID                       140
+#define ECHO_REF_DEC_labelID                                141
+#define VX_UL_8_TEMP_labelID                                142
+#define VX_UL_16_TEMP_labelID                               143
+#define UP_DOWN_8_48_labelID                                144
+#define UP_DOWN_16_48_labelID                               145
+#define SRC_6_LP_48k_labelID                                146
+#define SRC_6_HP_labelID                                    147
+#define SRC_3_LP_48k_labelID                                148
+#define SRC_3_HP_labelID                                    149
+#define EARP_48_96_LP_DATA_labelID                          150
+#define SRC_48_96_LP_labelID                                151
+#define IHF_48_96_LP_DATA_labelID                           152
+#define EQ_VX_UL_16K_labelID                                153
+#define pAPS_iir1_p23_labelID                               154
+#define pAPS_iir1_p45_labelID                               155
+#define APS_IIR_Regs_labelID                                156
+#define pAPS_core_DL1_p1_labelID                            157
+#define pAPS_core_DL1_p23_labelID                           158
+#define pAPS_core_DL1_p45_labelID                           159
+#define pAPS_core_DL1_r_labelID                             160
+#define pAPS_DL2L_core_r_labelID                            161
+#define pAPS_DL2R_core_r_labelID                            162
+#define pAPS_COIL_core_DL1_p1_labelID                       163
+#define pAPS_COIL_core_DL1_p23_labelID                      164
+#define pAPS_COIL_core_DL1_p45_labelID                      165
+#define pAPS_COIL_core_DL1_r_labelID                        166
+#define DL2_L_APS_IIR_p23_labelID                           167
+#define DL2_R_APS_IIR_p23_labelID                           168
+#define DL2_L_APS_IIR_p45_labelID                           169
+#define DL2_R_APS_IIR_p45_labelID                           170
+#define DL2_L_APS_CORE_p1_labelID                           171
+#define DL2_L_APS_CORE_p23_labelID                          172
+#define DL2_L_APS_CORE_p45_labelID                          173
+#define DL2_R_APS_CORE_p1_labelID                           174
+#define DL2_R_APS_CORE_p23_labelID                          175
+#define DL2_R_APS_CORE_p45_labelID                          176
+#define DL2_L_APS_COIL_CORE_p1_labelID                      177
+#define DL2_L_APS_COIL_CORE_p23_labelID                     178
+#define DL2_L_APS_COIL_CORE_p45_labelID                     179
+#define pAPS_COIL_DL2L_core_r_labelID                       180
+#define DL2_R_APS_COIL_CORE_p1_labelID                      181
+#define DL2_R_APS_COIL_CORE_p23_labelID                     182
+#define DL2_R_APS_COIL_CORE_p45_labelID                     183
+#define pAPS_COIL_DL2R_core_r_labelID                       184
+#define DL1_APS_labelID                                     185
+#define DL2_L_APS_labelID                                   186
+#define DL2_R_APS_labelID                                   187
+#define DL1_APS_EQ_p23_labelID                              188
+#define DL1_APS_EQ_p45_labelID                              189
+#define DL2_APS_EQ_p23_labelID                              190
+#define DL2_APS_EQ_p45_labelID                              191
+#define pVIBRA1_p0_labelID                                  192
+#define pVIBRA1_p1_labelID                                  193
+#define pVIBRA1_p23_labelID                                 194
+#define pVIBRA1_p45_labelID                                 195
+#define pVibra1_pR1_labelID                                 196
+#define pVibra1_pR2_labelID                                 197
+#define pVibra1_pR3_labelID                                 198
+#define pVIBRA1_r_labelID                                   199
+#define pVIBRA2_p0_labelID                                  200
+#define pVIBRA2_p1_labelID                                  201
+#define pVIBRA2_p23_labelID                                 202
+#define pVIBRA2_p45_labelID                                 203
+#define pCtrl_p67_labelID                                   204
+#define pVIBRA2_r_labelID                                   205
+#define VIBRA_labelID                                       206
+#define PING_labelID                                        207
+#define PING_Regs_labelID                                   208
+#define UP_48_96_LP_COEFS_labelID                           209
+#define AMIC_96_48_data_labelID                             210
+#define DOWN_96_48_AMIC_Coefs_labelID                       211
+#define DOWN_96_48_DMIC_Coefs_labelID                       212
+#define DOWN_96_48_AMIC_Regs_labelID                        213
+#define DOWN_96_48_DMIC_Regs_labelID                        214
+#define DMIC0_96_48_data_labelID                            215
+#define DMIC1_96_48_data_labelID                            216
+#define DMIC2_96_48_data_labelID                            217
+#define SIO_DMIC_labelID                                    218
+#define SIO_PDM_UL_labelID                                  219
+#define SIO_BT_VX_UL_labelID                                220
+#define SIO_MM_UL_labelID                                   221
+#define SIO_MM_UL2_labelID                                  222
+#define SIO_VX_UL_labelID                                   223
+#define SIO_MM_DL_labelID                                   224
+#define SIO_VX_DL_labelID                                   225
+#define SIO_TONES_DL_labelID                                226
+#define SIO_VIB_DL_labelID                                  227
+#define SIO_BT_VX_DL_labelID                                228
+#define SIO_PDM_DL_labelID                                  229
+#define SIO_MM_EXT_OUT_labelID                              230
+#define SIO_MM_EXT_IN_labelID                               231
+#define SIO_TDM_OUT_labelID                                 232
+#define SIO_TDM_IN_labelID                                  233
+#define DMIC_ATC_PTR_labelID                                234
+#define MCPDM_UL_ATC_PTR_labelID                            235
+#define BT_VX_UL_ATC_PTR_labelID                            236
+#define MM_UL_ATC_PTR_labelID                               237
+#define MM_UL2_ATC_PTR_labelID                              238
+#define VX_UL_ATC_PTR_labelID                               239
+#define MM_DL_ATC_PTR_labelID                               240
+#define VX_DL_ATC_PTR_labelID                               241
+#define TONES_DL_ATC_PTR_labelID                            242
+#define VIB_DL_ATC_PTR_labelID                              243
+#define BT_VX_DL_ATC_PTR_labelID                            244
+#define PDM_DL_ATC_PTR_labelID                              245
+#define MM_EXT_OUT_ATC_PTR_labelID                          246
+#define MM_EXT_IN_ATC_PTR_labelID                           247
+#define TDM_OUT_ATC_PTR_labelID                             248
+#define TDM_IN_ATC_PTR_labelID                              249
+#define MCU_IRQ_FIFO_ptr_labelID                            250
+#define DEBUG_IRQ_FIFO_reg_labelID                          251
+#define UP_DOWN_48_96_labelID                               252
+#define OSR96_2_labelID                                     253
+#define DEBUG_GAINS_labelID                                 254
+#define DBG_8K_PATTERN_labelID                              255
+#define DBG_16K_PATTERN_labelID                             256
+#define DBG_24K_PATTERN_labelID                             257
+#define DBG_48K_PATTERN_labelID                             258
+#define DBG_96K_PATTERN_labelID                             259
+#define UL_VX_UL_48_8K_labelID                              260
+#define UL_VX_UL_48_16K_labelID                             261
+#define BT_DL_labelID                                       262
+#define BT_UL_labelID                                       263
+#define BT_DL_8k_labelID                                    264
+#define BT_DL_16k_labelID                                   265
+#define BT_UL_8k_labelID                                    266
+#define BT_UL_16k_labelID                                   267
+#define MM_EXT_IN_labelID                                   268
+#define MM_EXT_IN_L_labelID                                 269
+#define MM_EXT_IN_R_labelID                                 270
+#define ECHO_REF_48_16_WRAP_labelID                         271
+#define ECHO_REF_48_8_WRAP_labelID                          272
+#define BT_UL_16_48_WRAP_labelID                            273
+#define BT_UL_8_48_WRAP_labelID                             274
+#define BT_DL_48_16_WRAP_labelID                            275
+#define BT_DL_48_8_WRAP_labelID                             276
+#define VX_DL_16_48_WRAP_labelID                            277
+#define VX_DL_8_48_WRAP_labelID                             278
+#define VX_UL_48_16_WRAP_labelID                            279
+#define VX_UL_48_8_WRAP_labelID                             280
+#define APS_DL1_IRQs_WRAP_labelID                           281
+#define APS_DL2_L_IRQs_WRAP_labelID                         282
+#define APS_DL2_R_IRQs_WRAP_labelID                         283
+#define ATC_NULL_BUFFER_labelID                             284
+#define MEM_INIT_hal_mem_labelID                            285
+#define MEM_INIT_write_mem_labelID                          286
+#define MEM_INIT_regs_labelID                               287
+#define GAIN_0DB_labelID                                    288
+#define XinASRC_BT_UL_labelID                               289
+#define IO_BT_UL_ASRC_labelID                               290
+#define ASRC_BT_UL_Coefs_labelID                            291
+#define ASRC_BT_UL_Alpha_labelID                            292
+#define ASRC_BT_UL_VarsBeta_labelID                         293
+#define ASRC_BT_UL_8k_Regs_labelID                          294
+#define ASRC_BT_UL_16k_Regs_labelID                         295
+#define XinASRC_BT_DL_labelID                               296
+#define DL_48_8_DEC_labelID                                 297
+#define DL_48_16_DEC_labelID                                298
+#define BT_DL_8k_TEMP_labelID                               299
+#define BT_DL_16k_TEMP_labelID                              300
+#define BT_DL_8k_opp100_labelID                             301
+#define BT_DL_16k_opp100_labelID                            302
+#define ASRC_BT_DL_Coefs_labelID                            303
+#define ASRC_BT_DL_Alpha_labelID                            304
+#define ASRC_BT_DL_VarsBeta_labelID                         305
+#define ASRC_BT_DL_8k_Regs_labelID                          306
+#define ASRC_BT_DL_16k_Regs_labelID                         307
+#define BT_DL_48_8_OPP100_WRAP_labelID                      308
+#define BT_DL_48_16_OPP100_WRAP_labelID                     309
+#endif /* _ABE_INITXXXX_LABELS_H_ */
Index: kernel/sound/soc/omap/abe/abe_irq.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_irq.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_irq.c	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,6 +19,8 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
+#include "abe_ref.h"
+
 /*
  *  initialize the default values for call-backs to subroutines
  *      - FIFO IRQ call-backs for sequenced tasks
@@ -27,19 +29,24 @@
  *      - Error monitoring
  *      - Activity Tracing
  */
+
 /**
  * abe_irq_ping_pong
  *
  * Call the respective subroutine depending on the IRQ FIFO content:
- * APS interrupts : IRQtag_APS to [31:28], APS_IRQs to [27:16], loopCounter to [15:0]
- * SEQ interrupts : IRQtag_COUNT to [31:28], Count_IRQs to [27:16], loopCounter to [15:0]
- * Ping-Pong Interrupts : IRQtag_PP to [31:28], PP_MCU_IRQ to [27:16], loopCounter to [15:0]
+ * APS interrupts : IRQ_FIFO[31:28] = IRQtag_APS,
+ *	IRQ_FIFO[27:16] = APS_IRQs, IRQ_FIFO[15:0] = loopCounter
+ * SEQ interrupts : IRQ_FIFO[31:28] = IRQtag_COUNT,
+ *	IRQ_FIFO[27:16] = Count_IRQs, IRQ_FIFO[15:0] = loopCounter
+ * Ping-Pong Interrupts : IRQ_FIFO[31:28] = IRQtag_PP,
+ *	IRQ_FIFO[27:16] = PP_MCU_IRQ, IRQ_FIFO[15:0] = loopCounter
  */
 void abe_irq_ping_pong(void)
 {
 	abe_call_subroutine(abe_irq_pingpong_player_id, NOPARAMETER,
 			    NOPARAMETER, NOPARAMETER, NOPARAMETER);
 }
+
 /**
  * abe_irq_check_for_sequences
 * @i: sequence ID
@@ -50,10 +57,12 @@
 void abe_irq_check_for_sequences(u32 i)
 {
 }
+
 /**
  * abe_irq_aps
  *
- * call the application subroutines that updates the acoustics protection filters
+ * call the application subroutines that updates
+ * the acoustics protection filters
  */
 void abe_irq_aps(u32 aps_info)
 {
Index: kernel/sound/soc/omap/abe/abe_lib.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_lib.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_lib.c	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 	Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,12 +19,8 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
-/**
-* abe_fprintf
-* @line: character line to be printed
-*
-* Print ABE debug messages.
-*/
+#include "abe_ref.h"
+
 /**
  * abe_read_feature_from_port
  * @x: d
@@ -45,6 +41,7 @@
 void abe_write_feature_to_port(u32 x)
 {
 }
+
 /**
  * abe_read_fifo
  * @x: d
@@ -54,6 +51,7 @@
 void abe_read_fifo(u32 x)
 {
 }
+
 /**
  * abe_write_fifo
  * @mem_bank: currently only ABE_DMEM supported
@@ -62,8 +60,8 @@
  * @data: data to write to FIFO
  * @number: number of 32-bit words to write to DMEM FIFO
  *
- * write DMEM FIFO and update FIFO descriptor, it is assumed that FIFO descriptor
- * is located in DMEM
+ * write DMEM FIFO and update FIFO descriptor,
+ * it is assumed that FIFO descriptor is located in DMEM
  */
 void abe_write_fifo(u32 memory_bank, u32 descr_addr, u32 *data, u32 nb_data32)
 {
@@ -96,10 +94,10 @@
 			       sizeof(u32), &fifo_addr[1], 4);
 		break;
 	default:
-		/* printf("currently only DMEM FIFO write supported ERROR\n"); */
 		break;
 	}
 }
+
 /**
  * abe_monitoring
  *
@@ -107,8 +105,9 @@
  */
 void abe_monitoring(void)
 {
-	abe_dbg_param = 0;
+	abe->dbg_param = 0;
 }
+
 /**
  * abe_format_switch
  * @f: port format
@@ -122,7 +121,7 @@
 void abe_format_switch(abe_data_format_t *f, u32 *iter, u32 *mulfac)
 {
 	u32 n_freq;
-#if FW_SCHED_LOOP_FREQ==4000
+#if FW_SCHED_LOOP_FREQ == 4000
 	switch (f->f) {
 		/* nb of samples processed by scheduling loop */
 	case 8000:
@@ -185,30 +184,33 @@
 	}
 	*iter = (n_freq * (*mulfac));
 }
+
 /**
  * abe_dma_port_iteration
  * @f: port format
  *
  * translates the sampling and data length to ITER number for the DMA
  */
-u32 abe_dma_port_iteration(abe_data_format_t *f)
+int abe_dma_port_iteration(abe_data_format_t *f)
 {
 	u32 iter, mulfac;
 	abe_format_switch(f, &iter, &mulfac);
 	return iter;
 }
+
 /**
  * abe_dma_port_iter_factor
  * @f: port format
  *
  * returns the multiplier factor to apply during data move with DMEM
  */
-u32 abe_dma_port_iter_factor(abe_data_format_t *f)
+int abe_dma_port_iter_factor(abe_data_format_t *f)
 {
 	u32 iter, mulfac;
 	abe_format_switch(f, &iter, &mulfac);
 	return mulfac;
 }
+
 /**
  * abe_dma_port_copy_subroutine_id
  *
@@ -216,7 +218,7 @@
  *
  * returns the index of the function doing the copy in I/O tasks
  */
-u32 abe_dma_port_copy_subroutine_id(u32 port_id)
+int abe_dma_port_copy_subroutine_id(u32 port_id)
 {
 	u32 sub_id;
 	if (abe_port[port_id].protocol.direction == ABE_ATC_DIRECTION_IN) {
@@ -286,6 +288,7 @@
 	}
 	return sub_id;
 }
+
 /**
  * abe_int_2_float
  * returns a mantissa on 16 bits and the exponent
@@ -297,6 +300,7 @@
 void abe_int_2_float16(u32 data, u32 *mantissa, u32 *exp)
 {
 	u32 i;
+
 	*exp = 0;
 	*mantissa = 0;
 	for (i = 0; i < 32; i++) {
@@ -306,6 +310,7 @@
 	*exp = i - 15;
 	*mantissa = (*exp > 0) ? data >> (*exp) : data << (*exp);
 }
+
 /**
  * abe_gain_offset
  * returns the offset to firmware data structures
@@ -354,8 +359,12 @@
 	case MIXAUDUL:
 		*mixer_offset = mixer_audul_offset;
 		break;
+	case GAINS_BTUL:
+		*mixer_offset = btul_gains_offset;
+		break;
 	}
 }
+
 /**
  * abe_decide_main_port - Select stynchronization port for Event generator.
  * @id: audio port name
@@ -365,7 +374,7 @@
  *
  * takes the first port in a list which is slave on the data interface
  */
-u32 abe_valid_port_for_synchro(u32 id)
+int abe_valid_port_for_synchro(u32 id)
 {
 	if ((abe_port[id].protocol.protocol_switch ==
 	     DMAREQ_PORT_PROT) ||
@@ -376,6 +385,7 @@
 	else
 		return 1;
 }
+
 void abe_decide_main_port(void)
 {
 	u32 id, id_not_found;
Index: kernel/sound/soc/omap/abe/abe_lib.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_lib.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_lib.h	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,18 +18,20 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+
 /**
  * abe_fprintf
-	 *
-	 *  Parameter  :
-	 *      character line to be printed
-	 *
-	 *  Operations :
-	 *
-	 *  Return value :
-	 *      None.
-	 */
+ *
+ *  Parameter  :
+ *      character line to be printed
+ *
+ *  Operations :
+ *
+ *  Return value :
+ *	none
+ */
 void abe_fprintf(char *line);
+
 /*
  *  ABE_READ_FEATURE_FROM_PORT
  *
@@ -40,9 +42,10 @@
  *
  *
  *  Return value :
- *
+ *	none
  */
 void abe_read_feature_from_port(u32 x);
+
 /*
  *  ABE_WRITE_FEATURE_TO_PORT
  *
@@ -51,9 +54,8 @@
  *
  *  Operations :
  *
- *
  *  Return value :
- *
+ *	none
  */
 void abe_write_feature_to_port(u32 x);
 /*
@@ -64,29 +66,30 @@
  *
  *  Operations :
  *
- *
  *  Return value :
- *
+ *	none
  */
 void abe_read_fifo(u32 x);
+
 /*
  *  ABE_WRITE_FIFO
  *
  *  Parameter  :
  *      mem_bank : currently only ABE_DMEM supported
  *	addr : FIFO descriptor address ( descriptor fields : READ ptr,
- * 	WRITE ptr, FIFO START_ADDR, FIFO END_ADDR)
+ *	WRITE ptr, FIFO START_ADDR, FIFO END_ADDR)
  *	data to write to FIFO
  *	number of 32-bit words to write to DMEM FIFO
  *
  *  Operations :
- *     write DMEM FIFO and update FIFO descriptor, it is assumed that FIFO
- * 	descriptor is located in DMEM
+ *	write DMEM FIFO and update FIFO descriptor, it is assumed that FIFO
+ *	descriptor is located in DMEM
  *
  *  Return value :
- *      none
+ *	none
  */
 void abe_write_fifo(u32 mem_bank, u32 addr, u32 *data, u32 nb_data32);
+
 /*
  *  ABE_BLOCK_COPY
  *
@@ -101,10 +104,11 @@
  *      block data move
  *
  *  Return value :
- *      none
+ *	none
  */
 void abe_block_copy(u32 direction, u32 memory_bank, u32 address, u32 *data,
 		    u32 nb);
+
 /*
  *  ABE_RESET_MEM
  *
Index: kernel/sound/soc/omap/abe/abe_main.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_main.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_main.h	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,7 +20,9 @@
  */
 #ifndef _ABE_MAIN_H_
 #define _ABE_MAIN_H_
+
 #include <linux/io.h>
+
 #include "abe_dm_addr.h"
 #include "abe_sm_addr.h"
 #include "abe_cm_addr.h"
@@ -31,19 +33,18 @@
 #include "abe_ext.h"
 #include "abe_dbg.h"
 #include "abe_lib.h"
-#include "abe_ref.h"
 #include "abe_api.h"
 #include "abe_typedef.h"
 #include "abe_functionsid.h"
 #include "abe_taskid.h"
 #include "abe_initxxx_labels.h"
 #include "abe_fw.h"
+
 /* pipe connection to the TARGET simulator */
 #define ABE_DEBUG_CHECKERS              0
 /* simulator data extracted from a text-file */
 #define ABE_DEBUG_HWFILE                0
 /* low-level log files */
 #define ABE_DEBUG_LL_LOG                0
-#define ABE_DEBUG (ABE_DEBUG_CHECKERS | ABE_DEBUG_HWFILE | ABE_DEBUG_LL_LOG)
-#endif /* _ABE_MAIN_H_ */
 
+#endif				/* _ABE_MAIN_H_ */
Index: kernel/sound/soc/omap/abe/abe_mem.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_mem.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_mem.c	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 	Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,6 +19,7 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
+#include "abe_ref.h"
 
 /**
  * abe_block_copy
@@ -35,25 +36,26 @@
 {
 	u32 i;
 	u32 base_address = 0, *src_ptr, *dst_ptr, n;
+
 	switch (memory_bank) {
 	case ABE_PMEM:
-		base_address = (u32) io_base + ABE_PMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_PMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_CMEM:
-		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_CMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_SMEM:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_SMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_DMEM:
-		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_DMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_ATC:
-		base_address = (u32) io_base + ABE_ATC_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_ATC_BASE_OFFSET_MPU;
 		break;
 	default:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
-		abe_dbg_param |= ERR_LIB;
+		base_address = (u32) abe->io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		abe->dbg_param |= ERR_LIB;
 		abe_dbg_error_log(ABE_BLOCK_COPY_ERR);
 		break;
 	}
@@ -68,6 +70,7 @@
 	for (i = 0; i < n; i++)
 		*dst_ptr++ = *src_ptr++;
 }
+
 /**
  * abe_reset_mem
  *
@@ -82,15 +85,16 @@
 	u32 i;
 	u32 *dst_ptr, n;
 	u32 base_address = 0;
+
 	switch (memory_bank) {
 	case ABE_SMEM:
-		base_address = (u32) io_base + ABE_SMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_SMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_DMEM:
-		base_address = (u32) io_base + ABE_DMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_DMEM_BASE_OFFSET_MPU;
 		break;
 	case ABE_CMEM:
-		base_address = (u32) io_base + ABE_CMEM_BASE_OFFSET_MPU;
+		base_address = (u32) abe->io_base + ABE_CMEM_BASE_OFFSET_MPU;
 		break;
 	}
 	dst_ptr = (u32 *) (base_address + address);
Index: kernel/sound/soc/omap/abe/abe_mem.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/sound/soc/omap/abe/abe_mem.h	2011-03-28 15:57:05.798386525 +0900
@@ -0,0 +1,62 @@
+/*
+ * ALSA SoC OMAP ABE driver
+*
+ * Author:          Laurent Le Faucheur <l-le-faucheur@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+#ifndef _ABE_MEM_H_
+#define _ABE_MEM_H_
+
+
+#define OMAP_ABE_PMEM_OFFSET	0xe0000
+#define OMAP_ABE_CMEM_OFFSET	0xa0000
+#define OMAP_ABE_SMEM_OFFSET	0xc0000
+#define OMAP_ABE_DMEM_OFFSET	0x80000
+#define OMAP_ABE_AESS_OFFSET	0xf1000
+
+/* Distinction between Read and Write from/to ABE memory
+ * is useful for simulation tool */
+static inline void omap_abe_mem_write(struct omap_abe *abe, u32 offset,
+					u32 *src, size_t bytes)
+{
+	memcpy((abe->io_base + offset), src, bytes);
+}
+
+static inline void omap_abe_mem_read(struct omap_abe *abe, u32 offset,
+					u32 *dest, size_t bytes)
+{
+	memcpy(dest, (abe->io_base + offset), bytes);
+}
+
+static inline u32 omap_abe_reg_readl(struct omap_abe *abe, u32 offset)
+{
+	return __raw_readl(abe->io_base + offset);
+}
+
+static inline void omap_abe_reg_writel(struct omap_abe *abe, u32 offset,
+					u32 val)
+{
+	__raw_writel(val, (abe->io_base + offset));
+}
+
+static inline void *omap_abe_reset_mem(struct omap_abe *abe, u32 offset,
+					size_t bytes)
+{
+	return memset(abe->io_base + offset, 0, bytes);
+}
+
+#endif /*_ABE_MEM_H_*/
Index: kernel/sound/soc/omap/abe/abe_ref.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_ref.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_ref.h	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,6 +20,7 @@
  */
 #ifndef _ABE_REF_H_
 #define _ABE_REF_H_
+
 /*
  * 'ABE_PRO.H' all non-API prototypes for INI, IRQ, SEQ ...
  */
@@ -40,7 +41,7 @@
 void abe_reset_all_ports(void);
 void abe_reset_all_fifo(void);
 void abe_reset_all_sequence(void);
-u32 abe_dma_port_iteration(abe_data_format_t *format);
+int abe_dma_port_iteration(abe_data_format_t *format);
 void abe_read_sys_clock(u32 *time);
 void abe_enable_dma_request(u32 id);
 void abe_disable_dma_request(u32 id);
@@ -48,19 +49,17 @@
 void abe_disable_atc(u32 id);
 void abe_init_atc(u32 id);
 void abe_init_io_tasks(u32 id, abe_data_format_t *format,
-		       abe_port_protocol_t *prot);
+			abe_port_protocol_t *prot);
 void abe_enable_pp_io_task(u32 id);
 void abe_disable_pp_io_task(u32 id);
 void abe_init_dma_t(u32 id, abe_port_protocol_t *prot);
-u32 abe_dma_port_iter_factor(abe_data_format_t *f);
-u32 abe_dma_port_copy_subroutine_id(u32 i);
+int abe_dma_port_iter_factor(abe_data_format_t *f);
+int abe_dma_port_copy_subroutine_id(u32 i);
 void abe_call_subroutine(u32 idx, u32 p1, u32 p2, u32 p3, u32 p4);
 void abe_monitoring(void);
 void abe_lock_execution(void);
 void abe_unlock_execution(void);
 void abe_hw_configuration(void);
-void abe_add_subroutine(u32 *id, abe_subroutine2 f, u32 nparam, u32 *params);
-abehal_status abe_read_next_ping_pong_buffer(u32 port, u32 *p, u32 *n);
 void abe_irq_ping_pong(void);
 void abe_irq_check_for_sequences(u32 seq_info);
 void abe_default_irq_pingpong_player(void);
@@ -77,48 +76,32 @@
 void abe_init_asrc_mm_ext_in(s32 dppm);
 void abe_init_asrc_bt_ul(s32 dppm);
 void abe_init_asrc_bt_dl(s32 dppm);
-//u8 *memmove(u8 *dst, u8 *src, u32 n);
-//u32 __get_unaligned_memmove32(void *p);
-//void __put_unaligned_memmove32(u32 val, void *p);
+
 /*
  * HAL INTERNAL DATA
  */
-extern void __iomem *io_base;
-extern u16 MultiFrame[PROCESSING_SLOTS][TASKS_IN_SLOT];
-extern ABE_SIODescriptor sio_desc;
-extern ABE_SPingPongDescriptor desc_pp;
-extern abe_satcdescriptor_aess atc_desc;
+extern struct omap_abe *abe;
+
 extern const u32 abe_port_priority[LAST_PORT_ID - 1];
-extern u32 abe_compensated_mixer_gain;
-extern u8 abe_muted_gains_indicator[MAX_NBGAIN_CMEM];
-extern u32 abe_desired_gains_decibel[MAX_NBGAIN_CMEM];
-extern u32 abe_muted_gains_decibel[MAX_NBGAIN_CMEM];
-extern u32 abe_desired_gains_linear[MAX_NBGAIN_CMEM];
-extern u32 abe_desired_ramp_delay_ms[MAX_NBGAIN_CMEM];
-extern u32 pdm_dl1_status;
-extern u32 pdm_dl2_status;
-extern u32 pdm_vib_status;
 extern const u32 abe_firmware_array[ABE_FIRMWARE_MAX_SIZE];
-extern u32 abe_firmware_version_number;
 extern const u32 abe_atc_srcid[];
 extern const u32 abe_atc_dstid[];
-extern abe_port_t abe_port[];
-extern abe_feature_t feature[];
 extern const abe_port_t abe_port_init[];
-extern abe_feature_t all_feature[];
 extern const abe_feature_t all_feature_init[];
-extern abe_seq_t all_sequence[];
 extern const abe_seq_t all_sequence_init[];
 extern const abe_router_t abe_router_ul_table_preset
 	[NBROUTE_CONFIG][NBROUTE_UL];
+extern const abe_sequence_t seq_null;
+extern const u32 abe_db2lin_table[];
+extern const u32 abe_alpha_iir[64];
+extern const u32 abe_1_alpha_iir[64];
+
+extern abe_port_t abe_port[];
+extern abe_feature_t feature[];
+extern abe_feature_t all_feature[];
+extern abe_seq_t all_sequence[];
 extern abe_router_t abe_router_ul_table[NBROUTE_CONFIG_MAX][NBROUTE_UL];
-extern u32 abe_dbg_output;
-extern u32 abe_dbg_mask;
-extern u32 abe_dbg_activity_log[D_DEBUG_HAL_TASK_sizeof];
-extern u32 abe_dbg_activity_log_write_pointer;
-extern u32 abe_dbg_param;
 extern u32 abe_current_event_id;
-extern const abe_sequence_t seq_null;
 /* table of new subroutines called in the sequence */
 extern abe_subroutine2 abe_all_subsubroutine[MAXNBSUBROUTINE];
 /* number of parameters per calls */
@@ -138,7 +121,6 @@
 extern abe_seq_t abe_active_sequence[MAXACTIVESEQUENCE][MAXSEQUENCESTEPS];
 /* index of the plugged subroutine doing ping-pong cache-flush
 	DMEM accesses */
-extern u32 abe_irq_pingpong_player_id;
 extern u32 abe_irq_aps_adaptation_id;
 /* base addresses of the ping pong buffers */
 extern u32 abe_base_address_pingpong[MAX_PINGPONG_BUFFERS];
@@ -146,13 +128,6 @@
 extern u32 abe_size_pingpong;
 /* number of ping/pong buffer being used */
 extern u32 abe_nb_pingpong;
-/* circular read pointer to IRQ/DBG DMEM buffer */
-extern u32 abe_irq_dbg_read_ptr;
-/* extern const s32 abe_dmic_40 [C_98_48_LP_Coefs_sizeof];
-extern const s32 abe_dmic_32 [C_98_48_LP_Coefs_sizeof];
-extern const s32 abe_dmic_25 [C_98_48_LP_Coefs_sizeof];
-extern const s32 abe_dmic_16 [C_98_48_LP_Coefs_sizeof]; */
-extern const u32 abe_db2lin_table[];
-extern const u32 abe_alpha_iir[64];
-extern const u32 abe_1_alpha_iir[64];
+
+
 #endif/* _ABE_REF_H_ */
Index: kernel/sound/soc/omap/abe/abe_seq.c
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_seq.c	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_seq.c	2011-03-28 15:57:05.798386525 +0900
@@ -2,7 +2,7 @@
  * ALSA SoC OMAP ABE driver
  *
  * Author:	Laurent Le Faucheur <l-le-faucheur@ti.com>
- * 		Liam Girdwood <lrg@slimlogic.co.uk>
+ *		Liam Girdwood <lrg@slimlogic.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -19,6 +19,8 @@
  * 02110-1301 USA
  */
 #include "abe_main.h"
+#include "abe_ref.h"
+
 /**
  * abe_null_subroutine
  *
@@ -26,12 +28,15 @@
 void abe_null_subroutine_0(void)
 {
 }
+
 void abe_null_subroutine_2(u32 a, u32 b)
 {
 }
+
 void abe_null_subroutine_4(u32 a, u32 b, u32 c, u32 d)
 {
 }
+
 /**
  * abe_init_subroutine_table - initializes the default table of pointers
  * to subroutines
@@ -42,6 +47,7 @@
 void abe_init_subroutine_table(void)
 {
 	u32 id;
+
 	/* reset the table's pointers */
 	abe_subroutine_write_pointer = 0;
 	/* the first index is the NULL task */
@@ -59,6 +65,7 @@
 			   (abe_subroutine2) abe_default_irq_aps_adaptation,
 			   SUB_0_PARAM, (u32 *) 0);
 }
+
 /**
  * abe_add_subroutine
  * @id: ABE port id
@@ -71,8 +78,10 @@
 void abe_add_subroutine(u32 *id, abe_subroutine2 f, u32 nparam, u32 *params)
 {
 	u32 i, i_found;
-	if ((abe_subroutine_write_pointer >= MAXNBSUBROUTINE) || ((u32) f == 0)) {
-		abe_dbg_param |= ERR_SEQ;
+
+	if ((abe_subroutine_write_pointer >= MAXNBSUBROUTINE) ||
+			((u32) f == 0)) {
+		abe->dbg_param |= ERR_SEQ;
 		abe_dbg_error_log(ABE_PARAMETER_OVERFLOW);
 	} else {
 		/* search if this subroutine address was not already
@@ -98,9 +107,11 @@
 		}
 	}
 }
+
 /**
  * abe_add_sequence
- * @id: returned sequence index after pluging a new sequence (index in the tables)
+ * @id: returned sequence index after pluging a new sequence
+ * (index in the tables)
  * @s: sequence to be inserted
  *
  * Load a time-sequenced operations.
@@ -109,10 +120,11 @@
 {
 	abe_seq_t *seq_src, *seq_dst;
 	u32 i, no_end_of_sequence_found;
+
 	seq_src = &(s->seq1);
 	seq_dst = &((abe_all_sequence[abe_sequence_write_pointer]).seq1);
 	if ((abe_sequence_write_pointer >= MAXNBSEQUENCE) || ((u32) s == 0)) {
-		abe_dbg_param |= ERR_SEQ;
+		abe->dbg_param |= ERR_SEQ;
 		abe_dbg_error_log(ABE_PARAMETER_OVERFLOW);
 	} else {
 		*id = abe_subroutine_write_pointer;
@@ -153,6 +165,7 @@
 void abe_reset_all_sequence(void)
 {
 	u32 i;
+
 	abe_init_subroutine_table();
 	/* arrange to have the first sequence index=0 to the NULL operation
 	   sequence */
@@ -177,7 +190,8 @@
 	abe_subroutine3 f3;
 	abe_subroutine4 f4;
 	u32 *params;
-	if (idx >= MAXNBSUBROUTINE)
+
+	if (idx > MAXNBSUBROUTINE)
 		return;
 	switch (idx) {
 		/* call the subroutines defined at compilation time
Index: kernel/sound/soc/omap/abe/abe_sm_addr.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_sm_addr.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_sm_addr.h	2011-03-28 15:57:05.798386525 +0900
@@ -21,483 +21,483 @@
 #ifndef _ABE_SM_ADDR_H_
 #define _ABE_SM_ADDR_H_
 #define init_SM_ADDR                                        0
-#define init_SM_ADDR_END                                    309
-#define init_SM_sizeof                                      310
-#define S_Data0_ADDR                                        310
-#define S_Data0_ADDR_END                                    310
+#define init_SM_ADDR_END                                    310
+#define init_SM_sizeof                                      311
+#define S_Data0_ADDR                                        311
+#define S_Data0_ADDR_END                                    311
 #define S_Data0_sizeof                                      1
-#define S_Temp_ADDR                                         311
-#define S_Temp_ADDR_END                                     311
+#define S_Temp_ADDR                                         312
+#define S_Temp_ADDR_END                                     312
 #define S_Temp_sizeof                                       1
-#define S_PhoenixOffset_ADDR                                312
-#define S_PhoenixOffset_ADDR_END                            312
+#define S_PhoenixOffset_ADDR                                313
+#define S_PhoenixOffset_ADDR_END                            313
 #define S_PhoenixOffset_sizeof                              1
-#define S_GTarget1_ADDR                                     313
-#define S_GTarget1_ADDR_END                                 319
+#define S_GTarget1_ADDR                                     314
+#define S_GTarget1_ADDR_END                                 320
 #define S_GTarget1_sizeof                                   7
-#define S_Gtarget_DL1_ADDR                                  320
-#define S_Gtarget_DL1_ADDR_END                              321
+#define S_Gtarget_DL1_ADDR                                  321
+#define S_Gtarget_DL1_ADDR_END                              322
 #define S_Gtarget_DL1_sizeof                                2
-#define S_Gtarget_DL2_ADDR                                  322
-#define S_Gtarget_DL2_ADDR_END                              323
+#define S_Gtarget_DL2_ADDR                                  323
+#define S_Gtarget_DL2_ADDR_END                              324
 #define S_Gtarget_DL2_sizeof                                2
-#define S_Gtarget_Echo_ADDR                                 324
-#define S_Gtarget_Echo_ADDR_END                             324
+#define S_Gtarget_Echo_ADDR                                 325
+#define S_Gtarget_Echo_ADDR_END                             325
 #define S_Gtarget_Echo_sizeof                               1
-#define S_Gtarget_SDT_ADDR                                  325
-#define S_Gtarget_SDT_ADDR_END                              325
+#define S_Gtarget_SDT_ADDR                                  326
+#define S_Gtarget_SDT_ADDR_END                              326
 #define S_Gtarget_SDT_sizeof                                1
-#define S_Gtarget_VxRec_ADDR                                326
-#define S_Gtarget_VxRec_ADDR_END                            327
+#define S_Gtarget_VxRec_ADDR                                327
+#define S_Gtarget_VxRec_ADDR_END                            328
 #define S_Gtarget_VxRec_sizeof                              2
-#define S_Gtarget_UL_ADDR                                   328
-#define S_Gtarget_UL_ADDR_END                               329
+#define S_Gtarget_UL_ADDR                                   329
+#define S_Gtarget_UL_ADDR_END                               330
 #define S_Gtarget_UL_sizeof                                 2
-#define S_Gtarget_unused_ADDR                               330
-#define S_Gtarget_unused_ADDR_END                           330
-#define S_Gtarget_unused_sizeof                             1
-#define S_GCurrent_ADDR                                     331
-#define S_GCurrent_ADDR_END                                 348
+#define S_Gtarget_BTUL_ADDR                                 331
+#define S_Gtarget_BTUL_ADDR_END                             331
+#define S_Gtarget_BTUL_sizeof                               1
+#define S_GCurrent_ADDR                                     332
+#define S_GCurrent_ADDR_END                                 349
 #define S_GCurrent_sizeof                                   18
-#define S_GAIN_ONE_ADDR                                     349
-#define S_GAIN_ONE_ADDR_END                                 349
+#define S_GAIN_ONE_ADDR                                     350
+#define S_GAIN_ONE_ADDR_END                                 350
 #define S_GAIN_ONE_sizeof                                   1
-#define S_Tones_ADDR                                        350
-#define S_Tones_ADDR_END                                    361
+#define S_Tones_ADDR                                        351
+#define S_Tones_ADDR_END                                    362
 #define S_Tones_sizeof                                      12
-#define S_VX_DL_ADDR                                        362
-#define S_VX_DL_ADDR_END                                    373
+#define S_VX_DL_ADDR                                        363
+#define S_VX_DL_ADDR_END                                    374
 #define S_VX_DL_sizeof                                      12
-#define S_MM_UL2_ADDR                                       374
-#define S_MM_UL2_ADDR_END                                   385
+#define S_MM_UL2_ADDR                                       375
+#define S_MM_UL2_ADDR_END                                   386
 #define S_MM_UL2_sizeof                                     12
-#define S_MM_DL_ADDR                                        386
-#define S_MM_DL_ADDR_END                                    397
+#define S_MM_DL_ADDR                                        387
+#define S_MM_DL_ADDR_END                                    398
 #define S_MM_DL_sizeof                                      12
-#define S_DL1_M_Out_ADDR                                    398
-#define S_DL1_M_Out_ADDR_END                                409
+#define S_DL1_M_Out_ADDR                                    399
+#define S_DL1_M_Out_ADDR_END                                410
 #define S_DL1_M_Out_sizeof                                  12
-#define S_DL2_M_Out_ADDR                                    410
-#define S_DL2_M_Out_ADDR_END                                421
+#define S_DL2_M_Out_ADDR                                    411
+#define S_DL2_M_Out_ADDR_END                                422
 #define S_DL2_M_Out_sizeof                                  12
-#define S_Echo_M_Out_ADDR                                   422
-#define S_Echo_M_Out_ADDR_END                               433
+#define S_Echo_M_Out_ADDR                                   423
+#define S_Echo_M_Out_ADDR_END                               434
 #define S_Echo_M_Out_sizeof                                 12
-#define S_SDT_M_Out_ADDR                                    434
-#define S_SDT_M_Out_ADDR_END                                445
+#define S_SDT_M_Out_ADDR                                    435
+#define S_SDT_M_Out_ADDR_END                                446
 #define S_SDT_M_Out_sizeof                                  12
-#define S_VX_UL_ADDR                                        446
-#define S_VX_UL_ADDR_END                                    457
+#define S_VX_UL_ADDR                                        447
+#define S_VX_UL_ADDR_END                                    458
 #define S_VX_UL_sizeof                                      12
-#define S_VX_UL_M_ADDR                                      458
-#define S_VX_UL_M_ADDR_END                                  469
+#define S_VX_UL_M_ADDR                                      459
+#define S_VX_UL_M_ADDR_END                                  470
 #define S_VX_UL_M_sizeof                                    12
-#define S_BT_DL_ADDR                                        470
-#define S_BT_DL_ADDR_END                                    481
+#define S_BT_DL_ADDR                                        471
+#define S_BT_DL_ADDR_END                                    482
 #define S_BT_DL_sizeof                                      12
-#define S_BT_UL_ADDR                                        482
-#define S_BT_UL_ADDR_END                                    493
+#define S_BT_UL_ADDR                                        483
+#define S_BT_UL_ADDR_END                                    494
 #define S_BT_UL_sizeof                                      12
-#define S_BT_DL_8k_ADDR                                     494
-#define S_BT_DL_8k_ADDR_END                                 496
+#define S_BT_DL_8k_ADDR                                     495
+#define S_BT_DL_8k_ADDR_END                                 497
 #define S_BT_DL_8k_sizeof                                   3
-#define S_BT_DL_16k_ADDR                                    497
-#define S_BT_DL_16k_ADDR_END                                501
+#define S_BT_DL_16k_ADDR                                    498
+#define S_BT_DL_16k_ADDR_END                                502
 #define S_BT_DL_16k_sizeof                                  5
-#define S_BT_UL_8k_ADDR                                     502
-#define S_BT_UL_8k_ADDR_END                                 503
+#define S_BT_UL_8k_ADDR                                     503
+#define S_BT_UL_8k_ADDR_END                                 504
 #define S_BT_UL_8k_sizeof                                   2
-#define S_BT_UL_16k_ADDR                                    504
-#define S_BT_UL_16k_ADDR_END                                507
+#define S_BT_UL_16k_ADDR                                    505
+#define S_BT_UL_16k_ADDR_END                                508
 #define S_BT_UL_16k_sizeof                                  4
-#define S_SDT_F_ADDR                                        508
-#define S_SDT_F_ADDR_END                                    519
+#define S_SDT_F_ADDR                                        509
+#define S_SDT_F_ADDR_END                                    520
 #define S_SDT_F_sizeof                                      12
-#define S_SDT_F_data_ADDR                                   520
-#define S_SDT_F_data_ADDR_END                               528
+#define S_SDT_F_data_ADDR                                   521
+#define S_SDT_F_data_ADDR_END                               529
 #define S_SDT_F_data_sizeof                                 9
-#define S_MM_DL_OSR_ADDR                                    529
-#define S_MM_DL_OSR_ADDR_END                                552
+#define S_MM_DL_OSR_ADDR                                    530
+#define S_MM_DL_OSR_ADDR_END                                553
 #define S_MM_DL_OSR_sizeof                                  24
-#define S_24_zeros_ADDR                                     553
-#define S_24_zeros_ADDR_END                                 576
+#define S_24_zeros_ADDR                                     554
+#define S_24_zeros_ADDR_END                                 577
 #define S_24_zeros_sizeof                                   24
-#define S_DMIC1_ADDR                                        577
-#define S_DMIC1_ADDR_END                                    588
+#define S_DMIC1_ADDR                                        578
+#define S_DMIC1_ADDR_END                                    589
 #define S_DMIC1_sizeof                                      12
-#define S_DMIC2_ADDR                                        589
-#define S_DMIC2_ADDR_END                                    600
+#define S_DMIC2_ADDR                                        590
+#define S_DMIC2_ADDR_END                                    601
 #define S_DMIC2_sizeof                                      12
-#define S_DMIC3_ADDR                                        601
-#define S_DMIC3_ADDR_END                                    612
+#define S_DMIC3_ADDR                                        602
+#define S_DMIC3_ADDR_END                                    613
 #define S_DMIC3_sizeof                                      12
-#define S_AMIC_ADDR                                         613
-#define S_AMIC_ADDR_END                                     624
+#define S_AMIC_ADDR                                         614
+#define S_AMIC_ADDR_END                                     625
 #define S_AMIC_sizeof                                       12
-#define S_DMIC1_L_ADDR                                      625
-#define S_DMIC1_L_ADDR_END                                  636
+#define S_DMIC1_L_ADDR                                      626
+#define S_DMIC1_L_ADDR_END                                  637
 #define S_DMIC1_L_sizeof                                    12
-#define S_DMIC1_R_ADDR                                      637
-#define S_DMIC1_R_ADDR_END                                  648
+#define S_DMIC1_R_ADDR                                      638
+#define S_DMIC1_R_ADDR_END                                  649
 #define S_DMIC1_R_sizeof                                    12
-#define S_DMIC2_L_ADDR                                      649
-#define S_DMIC2_L_ADDR_END                                  660
+#define S_DMIC2_L_ADDR                                      650
+#define S_DMIC2_L_ADDR_END                                  661
 #define S_DMIC2_L_sizeof                                    12
-#define S_DMIC2_R_ADDR                                      661
-#define S_DMIC2_R_ADDR_END                                  672
+#define S_DMIC2_R_ADDR                                      662
+#define S_DMIC2_R_ADDR_END                                  673
 #define S_DMIC2_R_sizeof                                    12
-#define S_DMIC3_L_ADDR                                      673
-#define S_DMIC3_L_ADDR_END                                  684
+#define S_DMIC3_L_ADDR                                      674
+#define S_DMIC3_L_ADDR_END                                  685
 #define S_DMIC3_L_sizeof                                    12
-#define S_DMIC3_R_ADDR                                      685
-#define S_DMIC3_R_ADDR_END                                  696
+#define S_DMIC3_R_ADDR                                      686
+#define S_DMIC3_R_ADDR_END                                  697
 #define S_DMIC3_R_sizeof                                    12
-#define S_BT_UL_L_ADDR                                      697
-#define S_BT_UL_L_ADDR_END                                  708
+#define S_BT_UL_L_ADDR                                      698
+#define S_BT_UL_L_ADDR_END                                  709
 #define S_BT_UL_L_sizeof                                    12
-#define S_BT_UL_R_ADDR                                      709
-#define S_BT_UL_R_ADDR_END                                  720
+#define S_BT_UL_R_ADDR                                      710
+#define S_BT_UL_R_ADDR_END                                  721
 #define S_BT_UL_R_sizeof                                    12
-#define S_AMIC_L_ADDR                                       721
-#define S_AMIC_L_ADDR_END                                   732
+#define S_AMIC_L_ADDR                                       722
+#define S_AMIC_L_ADDR_END                                   733
 #define S_AMIC_L_sizeof                                     12
-#define S_AMIC_R_ADDR                                       733
-#define S_AMIC_R_ADDR_END                                   744
+#define S_AMIC_R_ADDR                                       734
+#define S_AMIC_R_ADDR_END                                   745
 #define S_AMIC_R_sizeof                                     12
-#define S_EchoRef_L_ADDR                                    745
-#define S_EchoRef_L_ADDR_END                                756
+#define S_EchoRef_L_ADDR                                    746
+#define S_EchoRef_L_ADDR_END                                757
 #define S_EchoRef_L_sizeof                                  12
-#define S_EchoRef_R_ADDR                                    757
-#define S_EchoRef_R_ADDR_END                                768
+#define S_EchoRef_R_ADDR                                    758
+#define S_EchoRef_R_ADDR_END                                769
 #define S_EchoRef_R_sizeof                                  12
-#define S_MM_DL_L_ADDR                                      769
-#define S_MM_DL_L_ADDR_END                                  780
+#define S_MM_DL_L_ADDR                                      770
+#define S_MM_DL_L_ADDR_END                                  781
 #define S_MM_DL_L_sizeof                                    12
-#define S_MM_DL_R_ADDR                                      781
-#define S_MM_DL_R_ADDR_END                                  792
+#define S_MM_DL_R_ADDR                                      782
+#define S_MM_DL_R_ADDR_END                                  793
 #define S_MM_DL_R_sizeof                                    12
-#define S_MM_UL_ADDR                                        793
-#define S_MM_UL_ADDR_END                                    912
+#define S_MM_UL_ADDR                                        794
+#define S_MM_UL_ADDR_END                                    913
 #define S_MM_UL_sizeof                                      120
-#define S_AMIC_96k_ADDR                                     913
-#define S_AMIC_96k_ADDR_END                                 936
+#define S_AMIC_96k_ADDR                                     914
+#define S_AMIC_96k_ADDR_END                                 937
 #define S_AMIC_96k_sizeof                                   24
-#define S_DMIC0_96k_ADDR                                    937
-#define S_DMIC0_96k_ADDR_END                                960
+#define S_DMIC0_96k_ADDR                                    938
+#define S_DMIC0_96k_ADDR_END                                961
 #define S_DMIC0_96k_sizeof                                  24
-#define S_DMIC1_96k_ADDR                                    961
-#define S_DMIC1_96k_ADDR_END                                984
+#define S_DMIC1_96k_ADDR                                    962
+#define S_DMIC1_96k_ADDR_END                                985
 #define S_DMIC1_96k_sizeof                                  24
-#define S_DMIC2_96k_ADDR                                    985
-#define S_DMIC2_96k_ADDR_END                                1008
+#define S_DMIC2_96k_ADDR                                    986
+#define S_DMIC2_96k_ADDR_END                                1009
 #define S_DMIC2_96k_sizeof                                  24
-#define S_UL_VX_UL_48_8K_ADDR                               1009
-#define S_UL_VX_UL_48_8K_ADDR_END                           1020
+#define S_UL_VX_UL_48_8K_ADDR                               1010
+#define S_UL_VX_UL_48_8K_ADDR_END                           1021
 #define S_UL_VX_UL_48_8K_sizeof                             12
-#define S_UL_VX_UL_48_16K_ADDR                              1021
-#define S_UL_VX_UL_48_16K_ADDR_END                          1032
+#define S_UL_VX_UL_48_16K_ADDR                              1022
+#define S_UL_VX_UL_48_16K_ADDR_END                          1033
 #define S_UL_VX_UL_48_16K_sizeof                            12
-#define S_UL_MIC_48K_ADDR                                   1033
-#define S_UL_MIC_48K_ADDR_END                               1044
+#define S_UL_MIC_48K_ADDR                                   1034
+#define S_UL_MIC_48K_ADDR_END                               1045
 #define S_UL_MIC_48K_sizeof                                 12
-#define S_Voice_8k_UL_ADDR                                  1045
-#define S_Voice_8k_UL_ADDR_END                              1047
+#define S_Voice_8k_UL_ADDR                                  1046
+#define S_Voice_8k_UL_ADDR_END                              1048
 #define S_Voice_8k_UL_sizeof                                3
-#define S_Voice_8k_DL_ADDR                                  1048
-#define S_Voice_8k_DL_ADDR_END                              1049
+#define S_Voice_8k_DL_ADDR                                  1049
+#define S_Voice_8k_DL_ADDR_END                              1050
 #define S_Voice_8k_DL_sizeof                                2
-#define S_McPDM_Out1_ADDR                                   1050
-#define S_McPDM_Out1_ADDR_END                               1073
+#define S_McPDM_Out1_ADDR                                   1051
+#define S_McPDM_Out1_ADDR_END                               1074
 #define S_McPDM_Out1_sizeof                                 24
-#define S_McPDM_Out2_ADDR                                   1074
-#define S_McPDM_Out2_ADDR_END                               1097
+#define S_McPDM_Out2_ADDR                                   1075
+#define S_McPDM_Out2_ADDR_END                               1098
 #define S_McPDM_Out2_sizeof                                 24
-#define S_McPDM_Out3_ADDR                                   1098
-#define S_McPDM_Out3_ADDR_END                               1121
+#define S_McPDM_Out3_ADDR                                   1099
+#define S_McPDM_Out3_ADDR_END                               1122
 #define S_McPDM_Out3_sizeof                                 24
-#define S_Voice_16k_UL_ADDR                                 1122
-#define S_Voice_16k_UL_ADDR_END                             1126
+#define S_Voice_16k_UL_ADDR                                 1123
+#define S_Voice_16k_UL_ADDR_END                             1127
 #define S_Voice_16k_UL_sizeof                               5
-#define S_Voice_16k_DL_ADDR                                 1127
-#define S_Voice_16k_DL_ADDR_END                             1130
+#define S_Voice_16k_DL_ADDR                                 1128
+#define S_Voice_16k_DL_ADDR_END                             1131
 #define S_Voice_16k_DL_sizeof                               4
-#define S_XinASRC_DL_VX_ADDR                                1131
-#define S_XinASRC_DL_VX_ADDR_END                            1170
+#define S_XinASRC_DL_VX_ADDR                                1132
+#define S_XinASRC_DL_VX_ADDR_END                            1171
 #define S_XinASRC_DL_VX_sizeof                              40
-#define S_XinASRC_UL_VX_ADDR                                1171
-#define S_XinASRC_UL_VX_ADDR_END                            1210
+#define S_XinASRC_UL_VX_ADDR                                1172
+#define S_XinASRC_UL_VX_ADDR_END                            1211
 #define S_XinASRC_UL_VX_sizeof                              40
-#define S_XinASRC_MM_EXT_IN_ADDR                            1211
-#define S_XinASRC_MM_EXT_IN_ADDR_END                        1250
+#define S_XinASRC_MM_EXT_IN_ADDR                            1212
+#define S_XinASRC_MM_EXT_IN_ADDR_END                        1251
 #define S_XinASRC_MM_EXT_IN_sizeof                          40
-#define S_VX_REC_ADDR                                       1251
-#define S_VX_REC_ADDR_END                                   1262
+#define S_VX_REC_ADDR                                       1252
+#define S_VX_REC_ADDR_END                                   1263
 #define S_VX_REC_sizeof                                     12
-#define S_VX_REC_L_ADDR                                     1263
-#define S_VX_REC_L_ADDR_END                                 1274
+#define S_VX_REC_L_ADDR                                     1264
+#define S_VX_REC_L_ADDR_END                                 1275
 #define S_VX_REC_L_sizeof                                   12
-#define S_VX_REC_R_ADDR                                     1275
-#define S_VX_REC_R_ADDR_END                                 1286
+#define S_VX_REC_R_ADDR                                     1276
+#define S_VX_REC_R_ADDR_END                                 1287
 #define S_VX_REC_R_sizeof                                   12
-#define S_DL2_M_L_ADDR                                      1287
-#define S_DL2_M_L_ADDR_END                                  1298
+#define S_DL2_M_L_ADDR                                      1288
+#define S_DL2_M_L_ADDR_END                                  1299
 #define S_DL2_M_L_sizeof                                    12
-#define S_DL2_M_R_ADDR                                      1299
-#define S_DL2_M_R_ADDR_END                                  1310
+#define S_DL2_M_R_ADDR                                      1300
+#define S_DL2_M_R_ADDR_END                                  1311
 #define S_DL2_M_R_sizeof                                    12
-#define S_DL2_M_LR_EQ_data_ADDR                             1311
-#define S_DL2_M_LR_EQ_data_ADDR_END                         1335
+#define S_DL2_M_LR_EQ_data_ADDR                             1312
+#define S_DL2_M_LR_EQ_data_ADDR_END                         1336
 #define S_DL2_M_LR_EQ_data_sizeof                           25
-#define S_DL1_M_EQ_data_ADDR                                1336
-#define S_DL1_M_EQ_data_ADDR_END                            1360
+#define S_DL1_M_EQ_data_ADDR                                1337
+#define S_DL1_M_EQ_data_ADDR_END                            1361
 #define S_DL1_M_EQ_data_sizeof                              25
-#define S_EARP_48_96_LP_data_ADDR                           1361
-#define S_EARP_48_96_LP_data_ADDR_END                       1375
+#define S_EARP_48_96_LP_data_ADDR                           1362
+#define S_EARP_48_96_LP_data_ADDR_END                       1376
 #define S_EARP_48_96_LP_data_sizeof                         15
-#define S_IHF_48_96_LP_data_ADDR                            1376
-#define S_IHF_48_96_LP_data_ADDR_END                        1390
+#define S_IHF_48_96_LP_data_ADDR                            1377
+#define S_IHF_48_96_LP_data_ADDR_END                        1391
 #define S_IHF_48_96_LP_data_sizeof                          15
-#define S_VX_UL_8_TEMP_ADDR                                 1391
-#define S_VX_UL_8_TEMP_ADDR_END                             1392
+#define S_VX_UL_8_TEMP_ADDR                                 1392
+#define S_VX_UL_8_TEMP_ADDR_END                             1393
 #define S_VX_UL_8_TEMP_sizeof                               2
-#define S_VX_UL_16_TEMP_ADDR                                1393
-#define S_VX_UL_16_TEMP_ADDR_END                            1396
+#define S_VX_UL_16_TEMP_ADDR                                1394
+#define S_VX_UL_16_TEMP_ADDR_END                            1397
 #define S_VX_UL_16_TEMP_sizeof                              4
-#define S_VX_DL_8_48_LP_data_ADDR                           1397
-#define S_VX_DL_8_48_LP_data_ADDR_END                       1407
+#define S_VX_DL_8_48_LP_data_ADDR                           1398
+#define S_VX_DL_8_48_LP_data_ADDR_END                       1408
 #define S_VX_DL_8_48_LP_data_sizeof                         11
-#define S_VX_DL_8_48_HP_data_ADDR                           1408
-#define S_VX_DL_8_48_HP_data_ADDR_END                       1414
+#define S_VX_DL_8_48_HP_data_ADDR                           1409
+#define S_VX_DL_8_48_HP_data_ADDR_END                       1415
 #define S_VX_DL_8_48_HP_data_sizeof                         7
-#define S_VX_DL_16_48_LP_data_ADDR                          1415
-#define S_VX_DL_16_48_LP_data_ADDR_END                      1425
+#define S_VX_DL_16_48_LP_data_ADDR                          1416
+#define S_VX_DL_16_48_LP_data_ADDR_END                      1426
 #define S_VX_DL_16_48_LP_data_sizeof                        11
-#define S_VX_DL_16_48_HP_data_ADDR                          1426
-#define S_VX_DL_16_48_HP_data_ADDR_END                      1430
+#define S_VX_DL_16_48_HP_data_ADDR                          1427
+#define S_VX_DL_16_48_HP_data_ADDR_END                      1431
 #define S_VX_DL_16_48_HP_data_sizeof                        5
-#define S_VX_UL_48_8_LP_data_ADDR                           1431
-#define S_VX_UL_48_8_LP_data_ADDR_END                       1441
+#define S_VX_UL_48_8_LP_data_ADDR                           1432
+#define S_VX_UL_48_8_LP_data_ADDR_END                       1442
 #define S_VX_UL_48_8_LP_data_sizeof                         11
-#define S_VX_UL_48_8_HP_data_ADDR                           1442
-#define S_VX_UL_48_8_HP_data_ADDR_END                       1448
+#define S_VX_UL_48_8_HP_data_ADDR                           1443
+#define S_VX_UL_48_8_HP_data_ADDR_END                       1449
 #define S_VX_UL_48_8_HP_data_sizeof                         7
-#define S_VX_UL_48_16_LP_data_ADDR                          1449
-#define S_VX_UL_48_16_LP_data_ADDR_END                      1459
+#define S_VX_UL_48_16_LP_data_ADDR                          1450
+#define S_VX_UL_48_16_LP_data_ADDR_END                      1460
 #define S_VX_UL_48_16_LP_data_sizeof                        11
-#define S_VX_UL_48_16_HP_data_ADDR                          1460
-#define S_VX_UL_48_16_HP_data_ADDR_END                      1466
+#define S_VX_UL_48_16_HP_data_ADDR                          1461
+#define S_VX_UL_48_16_HP_data_ADDR_END                      1467
 #define S_VX_UL_48_16_HP_data_sizeof                        7
-#define S_BT_UL_8_48_LP_data_ADDR                           1467
-#define S_BT_UL_8_48_LP_data_ADDR_END                       1477
+#define S_BT_UL_8_48_LP_data_ADDR                           1468
+#define S_BT_UL_8_48_LP_data_ADDR_END                       1478
 #define S_BT_UL_8_48_LP_data_sizeof                         11
-#define S_BT_UL_8_48_HP_data_ADDR                           1478
-#define S_BT_UL_8_48_HP_data_ADDR_END                       1484
+#define S_BT_UL_8_48_HP_data_ADDR                           1479
+#define S_BT_UL_8_48_HP_data_ADDR_END                       1485
 #define S_BT_UL_8_48_HP_data_sizeof                         7
-#define S_BT_UL_16_48_LP_data_ADDR                          1485
-#define S_BT_UL_16_48_LP_data_ADDR_END                      1495
+#define S_BT_UL_16_48_LP_data_ADDR                          1486
+#define S_BT_UL_16_48_LP_data_ADDR_END                      1496
 #define S_BT_UL_16_48_LP_data_sizeof                        11
-#define S_BT_UL_16_48_HP_data_ADDR                          1496
-#define S_BT_UL_16_48_HP_data_ADDR_END                      1500
+#define S_BT_UL_16_48_HP_data_ADDR                          1497
+#define S_BT_UL_16_48_HP_data_ADDR_END                      1501
 #define S_BT_UL_16_48_HP_data_sizeof                        5
-#define S_BT_DL_48_8_LP_data_ADDR                           1501
-#define S_BT_DL_48_8_LP_data_ADDR_END                       1511
+#define S_BT_DL_48_8_LP_data_ADDR                           1502
+#define S_BT_DL_48_8_LP_data_ADDR_END                       1512
 #define S_BT_DL_48_8_LP_data_sizeof                         11
-#define S_BT_DL_48_8_HP_data_ADDR                           1512
-#define S_BT_DL_48_8_HP_data_ADDR_END                       1518
+#define S_BT_DL_48_8_HP_data_ADDR                           1513
+#define S_BT_DL_48_8_HP_data_ADDR_END                       1519
 #define S_BT_DL_48_8_HP_data_sizeof                         7
-#define S_BT_DL_48_16_LP_data_ADDR                          1519
-#define S_BT_DL_48_16_LP_data_ADDR_END                      1529
+#define S_BT_DL_48_16_LP_data_ADDR                          1520
+#define S_BT_DL_48_16_LP_data_ADDR_END                      1530
 #define S_BT_DL_48_16_LP_data_sizeof                        11
-#define S_BT_DL_48_16_HP_data_ADDR                          1530
-#define S_BT_DL_48_16_HP_data_ADDR_END                      1534
+#define S_BT_DL_48_16_HP_data_ADDR                          1531
+#define S_BT_DL_48_16_HP_data_ADDR_END                      1535
 #define S_BT_DL_48_16_HP_data_sizeof                        5
-#define S_ECHO_REF_48_8_LP_data_ADDR                        1535
-#define S_ECHO_REF_48_8_LP_data_ADDR_END                    1545
+#define S_ECHO_REF_48_8_LP_data_ADDR                        1536
+#define S_ECHO_REF_48_8_LP_data_ADDR_END                    1546
 #define S_ECHO_REF_48_8_LP_data_sizeof                      11
-#define S_ECHO_REF_48_8_HP_data_ADDR                        1546
-#define S_ECHO_REF_48_8_HP_data_ADDR_END                    1552
+#define S_ECHO_REF_48_8_HP_data_ADDR                        1547
+#define S_ECHO_REF_48_8_HP_data_ADDR_END                    1553
 #define S_ECHO_REF_48_8_HP_data_sizeof                      7
-#define S_ECHO_REF_48_16_LP_data_ADDR                       1553
-#define S_ECHO_REF_48_16_LP_data_ADDR_END                   1563
+#define S_ECHO_REF_48_16_LP_data_ADDR                       1554
+#define S_ECHO_REF_48_16_LP_data_ADDR_END                   1564
 #define S_ECHO_REF_48_16_LP_data_sizeof                     11
-#define S_ECHO_REF_48_16_HP_data_ADDR                       1564
-#define S_ECHO_REF_48_16_HP_data_ADDR_END                   1568
+#define S_ECHO_REF_48_16_HP_data_ADDR                       1565
+#define S_ECHO_REF_48_16_HP_data_ADDR_END                   1569
 #define S_ECHO_REF_48_16_HP_data_sizeof                     5
-#define S_APS_IIRmem1_ADDR                                  1569
-#define S_APS_IIRmem1_ADDR_END                              1577
+#define S_APS_IIRmem1_ADDR                                  1570
+#define S_APS_IIRmem1_ADDR_END                              1578
 #define S_APS_IIRmem1_sizeof                                9
-#define S_APS_M_IIRmem2_ADDR                                1578
-#define S_APS_M_IIRmem2_ADDR_END                            1580
+#define S_APS_M_IIRmem2_ADDR                                1579
+#define S_APS_M_IIRmem2_ADDR_END                            1581
 #define S_APS_M_IIRmem2_sizeof                              3
-#define S_APS_C_IIRmem2_ADDR                                1581
-#define S_APS_C_IIRmem2_ADDR_END                            1583
+#define S_APS_C_IIRmem2_ADDR                                1582
+#define S_APS_C_IIRmem2_ADDR_END                            1584
 #define S_APS_C_IIRmem2_sizeof                              3
-#define S_APS_DL1_OutSamples_ADDR                           1584
-#define S_APS_DL1_OutSamples_ADDR_END                       1585
+#define S_APS_DL1_OutSamples_ADDR                           1585
+#define S_APS_DL1_OutSamples_ADDR_END                       1586
 #define S_APS_DL1_OutSamples_sizeof                         2
-#define S_APS_DL1_COIL_OutSamples_ADDR                      1586
-#define S_APS_DL1_COIL_OutSamples_ADDR_END                  1587
+#define S_APS_DL1_COIL_OutSamples_ADDR                      1587
+#define S_APS_DL1_COIL_OutSamples_ADDR_END                  1588
 #define S_APS_DL1_COIL_OutSamples_sizeof                    2
-#define S_APS_DL2_L_OutSamples_ADDR                         1588
-#define S_APS_DL2_L_OutSamples_ADDR_END                     1589
+#define S_APS_DL2_L_OutSamples_ADDR                         1589
+#define S_APS_DL2_L_OutSamples_ADDR_END                     1590
 #define S_APS_DL2_L_OutSamples_sizeof                       2
-#define S_APS_DL2_L_COIL_OutSamples_ADDR                    1590
-#define S_APS_DL2_L_COIL_OutSamples_ADDR_END                1591
+#define S_APS_DL2_L_COIL_OutSamples_ADDR                    1591
+#define S_APS_DL2_L_COIL_OutSamples_ADDR_END                1592
 #define S_APS_DL2_L_COIL_OutSamples_sizeof                  2
-#define S_APS_DL2_R_OutSamples_ADDR                         1592
-#define S_APS_DL2_R_OutSamples_ADDR_END                     1593
+#define S_APS_DL2_R_OutSamples_ADDR                         1593
+#define S_APS_DL2_R_OutSamples_ADDR_END                     1594
 #define S_APS_DL2_R_OutSamples_sizeof                       2
-#define S_APS_DL2_R_COIL_OutSamples_ADDR                    1594
-#define S_APS_DL2_R_COIL_OutSamples_ADDR_END                1595
+#define S_APS_DL2_R_COIL_OutSamples_ADDR                    1595
+#define S_APS_DL2_R_COIL_OutSamples_ADDR_END                1596
 #define S_APS_DL2_R_COIL_OutSamples_sizeof                  2
-#define S_XinASRC_ECHO_REF_ADDR                             1596
-#define S_XinASRC_ECHO_REF_ADDR_END                         1635
+#define S_XinASRC_ECHO_REF_ADDR                             1597
+#define S_XinASRC_ECHO_REF_ADDR_END                         1636
 #define S_XinASRC_ECHO_REF_sizeof                           40
-#define S_ECHO_REF_16K_ADDR                                 1636
-#define S_ECHO_REF_16K_ADDR_END                             1640
+#define S_ECHO_REF_16K_ADDR                                 1637
+#define S_ECHO_REF_16K_ADDR_END                             1641
 #define S_ECHO_REF_16K_sizeof                               5
-#define S_ECHO_REF_8K_ADDR                                  1641
-#define S_ECHO_REF_8K_ADDR_END                              1643
+#define S_ECHO_REF_8K_ADDR                                  1642
+#define S_ECHO_REF_8K_ADDR_END                              1644
 #define S_ECHO_REF_8K_sizeof                                3
-#define S_DL1_EQ_ADDR                                       1644
-#define S_DL1_EQ_ADDR_END                                   1655
+#define S_DL1_EQ_ADDR                                       1645
+#define S_DL1_EQ_ADDR_END                                   1656
 #define S_DL1_EQ_sizeof                                     12
-#define S_DL2_EQ_ADDR                                       1656
-#define S_DL2_EQ_ADDR_END                                   1667
+#define S_DL2_EQ_ADDR                                       1657
+#define S_DL2_EQ_ADDR_END                                   1668
 #define S_DL2_EQ_sizeof                                     12
-#define S_DL1_GAIN_out_ADDR                                 1668
-#define S_DL1_GAIN_out_ADDR_END                             1679
+#define S_DL1_GAIN_out_ADDR                                 1669
+#define S_DL1_GAIN_out_ADDR_END                             1680
 #define S_DL1_GAIN_out_sizeof                               12
-#define S_DL2_GAIN_out_ADDR                                 1680
-#define S_DL2_GAIN_out_ADDR_END                             1691
+#define S_DL2_GAIN_out_ADDR                                 1681
+#define S_DL2_GAIN_out_ADDR_END                             1692
 #define S_DL2_GAIN_out_sizeof                               12
-#define S_APS_DL2_L_IIRmem1_ADDR                            1692
-#define S_APS_DL2_L_IIRmem1_ADDR_END                        1700
+#define S_APS_DL2_L_IIRmem1_ADDR                            1693
+#define S_APS_DL2_L_IIRmem1_ADDR_END                        1701
 #define S_APS_DL2_L_IIRmem1_sizeof                          9
-#define S_APS_DL2_R_IIRmem1_ADDR                            1701
-#define S_APS_DL2_R_IIRmem1_ADDR_END                        1709
+#define S_APS_DL2_R_IIRmem1_ADDR                            1702
+#define S_APS_DL2_R_IIRmem1_ADDR_END                        1710
 #define S_APS_DL2_R_IIRmem1_sizeof                          9
-#define S_APS_DL2_L_M_IIRmem2_ADDR                          1710
-#define S_APS_DL2_L_M_IIRmem2_ADDR_END                      1712
+#define S_APS_DL2_L_M_IIRmem2_ADDR                          1711
+#define S_APS_DL2_L_M_IIRmem2_ADDR_END                      1713
 #define S_APS_DL2_L_M_IIRmem2_sizeof                        3
-#define S_APS_DL2_R_M_IIRmem2_ADDR                          1713
-#define S_APS_DL2_R_M_IIRmem2_ADDR_END                      1715
+#define S_APS_DL2_R_M_IIRmem2_ADDR                          1714
+#define S_APS_DL2_R_M_IIRmem2_ADDR_END                      1716
 #define S_APS_DL2_R_M_IIRmem2_sizeof                        3
-#define S_APS_DL2_L_C_IIRmem2_ADDR                          1716
-#define S_APS_DL2_L_C_IIRmem2_ADDR_END                      1718
+#define S_APS_DL2_L_C_IIRmem2_ADDR                          1717
+#define S_APS_DL2_L_C_IIRmem2_ADDR_END                      1719
 #define S_APS_DL2_L_C_IIRmem2_sizeof                        3
-#define S_APS_DL2_R_C_IIRmem2_ADDR                          1719
-#define S_APS_DL2_R_C_IIRmem2_ADDR_END                      1721
+#define S_APS_DL2_R_C_IIRmem2_ADDR                          1720
+#define S_APS_DL2_R_C_IIRmem2_ADDR_END                      1722
 #define S_APS_DL2_R_C_IIRmem2_sizeof                        3
-#define S_DL1_APS_ADDR                                      1722
-#define S_DL1_APS_ADDR_END                                  1733
+#define S_DL1_APS_ADDR                                      1723
+#define S_DL1_APS_ADDR_END                                  1734
 #define S_DL1_APS_sizeof                                    12
-#define S_DL2_L_APS_ADDR                                    1734
-#define S_DL2_L_APS_ADDR_END                                1745
+#define S_DL2_L_APS_ADDR                                    1735
+#define S_DL2_L_APS_ADDR_END                                1746
 #define S_DL2_L_APS_sizeof                                  12
-#define S_DL2_R_APS_ADDR                                    1746
-#define S_DL2_R_APS_ADDR_END                                1757
+#define S_DL2_R_APS_ADDR                                    1747
+#define S_DL2_R_APS_ADDR_END                                1758
 #define S_DL2_R_APS_sizeof                                  12
-#define S_APS_DL1_EQ_data_ADDR                              1758
-#define S_APS_DL1_EQ_data_ADDR_END                          1766
+#define S_APS_DL1_EQ_data_ADDR                              1759
+#define S_APS_DL1_EQ_data_ADDR_END                          1767
 #define S_APS_DL1_EQ_data_sizeof                            9
-#define S_APS_DL2_EQ_data_ADDR                              1767
-#define S_APS_DL2_EQ_data_ADDR_END                          1775
+#define S_APS_DL2_EQ_data_ADDR                              1768
+#define S_APS_DL2_EQ_data_ADDR_END                          1776
 #define S_APS_DL2_EQ_data_sizeof                            9
-#define S_DC_DCvalue_ADDR                                   1776
-#define S_DC_DCvalue_ADDR_END                               1776
+#define S_DC_DCvalue_ADDR                                   1777
+#define S_DC_DCvalue_ADDR_END                               1777
 #define S_DC_DCvalue_sizeof                                 1
-#define S_VIBRA_ADDR                                        1777
-#define S_VIBRA_ADDR_END                                    1782
+#define S_VIBRA_ADDR                                        1778
+#define S_VIBRA_ADDR_END                                    1783
 #define S_VIBRA_sizeof                                      6
-#define S_Vibra2_in_ADDR                                    1783
-#define S_Vibra2_in_ADDR_END                                1788
+#define S_Vibra2_in_ADDR                                    1784
+#define S_Vibra2_in_ADDR_END                                1789
 #define S_Vibra2_in_sizeof                                  6
-#define S_Vibra2_addr_ADDR                                  1789
-#define S_Vibra2_addr_ADDR_END                              1789
+#define S_Vibra2_addr_ADDR                                  1790
+#define S_Vibra2_addr_ADDR_END                              1790
 #define S_Vibra2_addr_sizeof                                1
-#define S_VibraCtrl_forRightSM_ADDR                         1790
-#define S_VibraCtrl_forRightSM_ADDR_END                     1813
+#define S_VibraCtrl_forRightSM_ADDR                         1791
+#define S_VibraCtrl_forRightSM_ADDR_END                     1814
 #define S_VibraCtrl_forRightSM_sizeof                       24
-#define S_Rnoise_mem_ADDR                                   1814
-#define S_Rnoise_mem_ADDR_END                               1814
+#define S_Rnoise_mem_ADDR                                   1815
+#define S_Rnoise_mem_ADDR_END                               1815
 #define S_Rnoise_mem_sizeof                                 1
-#define S_Ctrl_ADDR                                         1815
-#define S_Ctrl_ADDR_END                                     1832
+#define S_Ctrl_ADDR                                         1816
+#define S_Ctrl_ADDR_END                                     1833
 #define S_Ctrl_sizeof                                       18
-#define S_Vibra1_in_ADDR                                    1833
-#define S_Vibra1_in_ADDR_END                                1838
+#define S_Vibra1_in_ADDR                                    1834
+#define S_Vibra1_in_ADDR_END                                1839
 #define S_Vibra1_in_sizeof                                  6
-#define S_Vibra1_temp_ADDR                                  1839
-#define S_Vibra1_temp_ADDR_END                              1862
+#define S_Vibra1_temp_ADDR                                  1840
+#define S_Vibra1_temp_ADDR_END                              1863
 #define S_Vibra1_temp_sizeof                                24
-#define S_VibraCtrl_forLeftSM_ADDR                          1863
-#define S_VibraCtrl_forLeftSM_ADDR_END                      1886
+#define S_VibraCtrl_forLeftSM_ADDR                          1864
+#define S_VibraCtrl_forLeftSM_ADDR_END                      1887
 #define S_VibraCtrl_forLeftSM_sizeof                        24
-#define S_Vibra1_mem_ADDR                                   1887
-#define S_Vibra1_mem_ADDR_END                               1897
+#define S_Vibra1_mem_ADDR                                   1888
+#define S_Vibra1_mem_ADDR_END                               1898
 #define S_Vibra1_mem_sizeof                                 11
-#define S_VibraCtrl_Stereo_ADDR                             1898
-#define S_VibraCtrl_Stereo_ADDR_END                         1921
+#define S_VibraCtrl_Stereo_ADDR                             1899
+#define S_VibraCtrl_Stereo_ADDR_END                         1922
 #define S_VibraCtrl_Stereo_sizeof                           24
-#define S_AMIC_96_48_data_ADDR                              1922
-#define S_AMIC_96_48_data_ADDR_END                          1940
+#define S_AMIC_96_48_data_ADDR                              1923
+#define S_AMIC_96_48_data_ADDR_END                          1941
 #define S_AMIC_96_48_data_sizeof                            19
-#define S_DMIC0_96_48_data_ADDR                             1941
-#define S_DMIC0_96_48_data_ADDR_END                         1959
+#define S_DMIC0_96_48_data_ADDR                             1942
+#define S_DMIC0_96_48_data_ADDR_END                         1960
 #define S_DMIC0_96_48_data_sizeof                           19
-#define S_DMIC1_96_48_data_ADDR                             1960
-#define S_DMIC1_96_48_data_ADDR_END                         1978
+#define S_DMIC1_96_48_data_ADDR                             1961
+#define S_DMIC1_96_48_data_ADDR_END                         1979
 #define S_DMIC1_96_48_data_sizeof                           19
-#define S_DMIC2_96_48_data_ADDR                             1979
-#define S_DMIC2_96_48_data_ADDR_END                         1997
+#define S_DMIC2_96_48_data_ADDR                             1980
+#define S_DMIC2_96_48_data_ADDR_END                         1998
 #define S_DMIC2_96_48_data_sizeof                           19
-#define S_DBG_8K_PATTERN_ADDR                               1998
-#define S_DBG_8K_PATTERN_ADDR_END                           1999
+#define S_DBG_8K_PATTERN_ADDR                               1999
+#define S_DBG_8K_PATTERN_ADDR_END                           2000
 #define S_DBG_8K_PATTERN_sizeof                             2
-#define S_DBG_16K_PATTERN_ADDR                              2000
-#define S_DBG_16K_PATTERN_ADDR_END                          2003
+#define S_DBG_16K_PATTERN_ADDR                              2001
+#define S_DBG_16K_PATTERN_ADDR_END                          2004
 #define S_DBG_16K_PATTERN_sizeof                            4
-#define S_DBG_24K_PATTERN_ADDR                              2004
-#define S_DBG_24K_PATTERN_ADDR_END                          2009
+#define S_DBG_24K_PATTERN_ADDR                              2005
+#define S_DBG_24K_PATTERN_ADDR_END                          2010
 #define S_DBG_24K_PATTERN_sizeof                            6
-#define S_DBG_48K_PATTERN_ADDR                              2010
-#define S_DBG_48K_PATTERN_ADDR_END                          2021
+#define S_DBG_48K_PATTERN_ADDR                              2011
+#define S_DBG_48K_PATTERN_ADDR_END                          2022
 #define S_DBG_48K_PATTERN_sizeof                            12
-#define S_DBG_96K_PATTERN_ADDR                              2022
-#define S_DBG_96K_PATTERN_ADDR_END                          2045
+#define S_DBG_96K_PATTERN_ADDR                              2023
+#define S_DBG_96K_PATTERN_ADDR_END                          2046
 #define S_DBG_96K_PATTERN_sizeof                            24
-#define S_MM_EXT_IN_ADDR                                    2046
-#define S_MM_EXT_IN_ADDR_END                                2057
+#define S_MM_EXT_IN_ADDR                                    2047
+#define S_MM_EXT_IN_ADDR_END                                2058
 #define S_MM_EXT_IN_sizeof                                  12
-#define S_MM_EXT_IN_L_ADDR                                  2058
-#define S_MM_EXT_IN_L_ADDR_END                              2069
+#define S_MM_EXT_IN_L_ADDR                                  2059
+#define S_MM_EXT_IN_L_ADDR_END                              2070
 #define S_MM_EXT_IN_L_sizeof                                12
-#define S_MM_EXT_IN_R_ADDR                                  2070
-#define S_MM_EXT_IN_R_ADDR_END                              2081
+#define S_MM_EXT_IN_R_ADDR                                  2071
+#define S_MM_EXT_IN_R_ADDR_END                              2082
 #define S_MM_EXT_IN_R_sizeof                                12
-#define S_MIC4_ADDR                                         2082
-#define S_MIC4_ADDR_END                                     2093
+#define S_MIC4_ADDR                                         2083
+#define S_MIC4_ADDR_END                                     2094
 #define S_MIC4_sizeof                                       12
-#define S_MIC4_L_ADDR                                       2094
-#define S_MIC4_L_ADDR_END                                   2105
+#define S_MIC4_L_ADDR                                       2095
+#define S_MIC4_L_ADDR_END                                   2106
 #define S_MIC4_L_sizeof                                     12
-#define S_MIC4_R_ADDR                                       2106
-#define S_MIC4_R_ADDR_END                                   2117
+#define S_MIC4_R_ADDR                                       2107
+#define S_MIC4_R_ADDR_END                                   2118
 #define S_MIC4_R_sizeof                                     12
-#define S_HW_TEST_ADDR                                      2118
-#define S_HW_TEST_ADDR_END                                  2118
+#define S_HW_TEST_ADDR                                      2119
+#define S_HW_TEST_ADDR_END                                  2119
 #define S_HW_TEST_sizeof                                    1
-#define S_XinASRC_BT_UL_ADDR                                2119
-#define S_XinASRC_BT_UL_ADDR_END                            2158
+#define S_XinASRC_BT_UL_ADDR                                2120
+#define S_XinASRC_BT_UL_ADDR_END                            2159
 #define S_XinASRC_BT_UL_sizeof                              40
-#define S_XinASRC_BT_DL_ADDR                                2159
-#define S_XinASRC_BT_DL_ADDR_END                            2198
+#define S_XinASRC_BT_DL_ADDR                                2160
+#define S_XinASRC_BT_DL_ADDR_END                            2199
 #define S_XinASRC_BT_DL_sizeof                              40
-#define S_BT_DL_8k_TEMP_ADDR                                2199
-#define S_BT_DL_8k_TEMP_ADDR_END                            2200
+#define S_BT_DL_8k_TEMP_ADDR                                2200
+#define S_BT_DL_8k_TEMP_ADDR_END                            2201
 #define S_BT_DL_8k_TEMP_sizeof                              2
-#define S_BT_DL_16k_TEMP_ADDR                               2201
-#define S_BT_DL_16k_TEMP_ADDR_END                           2204
+#define S_BT_DL_16k_TEMP_ADDR                               2202
+#define S_BT_DL_16k_TEMP_ADDR_END                           2205
 #define S_BT_DL_16k_TEMP_sizeof                             4
-#endif/* _ABESM_ADDR_H_ */
+#endif /* _ABESM_ADDR_H_ */
Index: kernel/sound/soc/omap/abe/abe_taskid.h
===================================================================
--- kernel.orig/sound/soc/omap/abe/abe_taskid.h	2011-03-28 12:30:01.000000000 +0900
+++ kernel/sound/soc/omap/abe/abe_taskid.h	2011-03-28 15:57:05.798386525 +0900
@@ -145,4 +145,4 @@
 #define C_ABE_FW_TASK_BT_DL_48_16_HP_OPP100                 122
 #define C_ABE_FW_TASK_BT_DL_48_8_OPP100                     123
 #define C_ABE_FW_TASK_BT_DL_48_16_OPP100                    124
-#endif/* _ABE_TASKID_H_ */
+#endif /* _ABE_TASKID_H_ */
